<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    
    <!-- 强制刷新缓存，防止用户加载旧版本 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
<!-- ▼▼▼ 用这整块代码替换掉你旧的meta和icon链接 ▼▼▼ -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">


<!-- 1. (核心) 为苹果设备设置主屏幕图标 -->
<link rel="apple-touch-icon" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="152x152" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="180x180" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="167x167" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">

<!-- 2. (核心) 链接到manifest文件 -->
<link rel="manifest" href="manifest.json">

<!-- 3. (核心) 告诉苹果设备，这是一个Web应用，可以全屏显示 -->
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- 4. (核心) 设置苹果设备全屏模式下的状态栏样式 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- 5. (可选) 设置应用在主屏幕上显示的标题 -->
<meta name="apple-mobile-web-app-title" content="EPhone（兔k机版）">

<!-- 6. (兼容) 为部分安卓浏览器提供支持 -->
<meta name="mobile-web-app-capable" content="yes">

<!-- 7. (备用) 标准浏览器页签图标 -->
<link rel="icon" type="image/png" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


    <title>EPhone（兔k机版）</title>

    <link rel="stylesheet" href="style.css">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
    <script src="main-app.js" defer></script>
    <script src="game-hall.js" defer></script>
    <script src="forum.js" defer></script>
    <script src="lovers-space.js" defer></script>
    <script src="taobao.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/darkreader@4.9.84/darkreader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>



    <style>
    .navbar {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
}

        /* 页面动态效果 - 下雪效果 */
        .snowflake {
            position: fixed;
            top: -10px;
            z-index: 9999;
            user-select: none;
            pointer-events: none;
            color: #fff;
            font-size: 1em;
            animation: fall linear infinite;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }
        
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        /* 动态效果容器 */
        #page-effect-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
            overflow: hidden;
        }
        
        /* 雪花颜色预设块样式 */
        .snow-color-preset {
            position: relative;
            overflow: hidden;
        }
        
        .snow-color-preset::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            color: var(--accent-color);
            font-size: 20px;
            font-weight: bold;
            transition: transform 0.2s;
            text-shadow: 0 0 3px white, 0 0 5px white;
        }
        
        .snow-color-preset.selected::after {
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* 八卦六爻历史记录样式 */
        .bagua-history-item {
            position: relative;
            padding: 15px;
            margin-bottom: 10px;
            background: var(--bg-color, #f5f5f5);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .bagua-history-item:hover {
            background: var(--hover-bg-color, #e8e8e8);
            transform: translateX(2px);
        }
        
        .bagua-history-item .question {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-color, #333);
        }
        
        .bagua-history-item .details {
            font-size: 12px;
            color: var(--secondary-text-color, #999);
        }
        
        .bagua-history-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 59, 48, 0.1);
            color: #ff3b30;
            border-radius: 50%;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .bagua-history-delete-btn:hover {
            background: #ff3b30;
            color: white;
        }
    </style>
    <!-- ▼▼▼ 在这里添加下面这行 ▼▼▼ -->
    <style id="custom-theme-style"></style>

</head>
<body>
        <!-- 页面动态效果容器 -->
        <div id="page-effect-container"></div>
        
        <div id="phone-screen">
            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>

<!-- ▼▼▼ 【全新】在这里粘贴悬浮歌词栏的代码 ▼▼▼ -->
<div id="floating-lyrics-bar">
    <span id="floating-lyric-text">♪</span>
    <!-- 【问题4修复】用包含SVG的div替换旧的span -->
    <div id="lyrics-settings-btn" style="cursor: pointer; display: flex; align-items: center; justify-content: center;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>
    <span class="close-btn">×</span>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼ -->
<div id="lock-screen-background-blur" style="display: none;"></div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
            
<!-- ▼▼▼ 用下面这【一整块】修改后的代码，替换掉你旧的 <div id="home-screen"...>...</div> ▼▼▼ -->
<div id="home-screen" class="screen active">
    
    <!-- 我们用一个滑动容器把页面包起来 -->
    <div class="home-screen-slider">
        <!-- 这是你的第一页，我们把原来的内容都放进来 -->
        <div class="home-page">
            <div id="main-content-area">
                <div id="profile-widget">
                    <img id="profile-banner-img" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image">
                    <!-- ▼▼▼ 用下面这整块代码，替换旧的 profile-avatar-container ▼▼▼ -->
<div class="profile-avatar-container">
    <img id="profile-avatar-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
    <!-- ▼▼▼ 我们在这里新增了一个用于显示头像框的img元素 ▼▼▼ -->
    <img id="profile-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

                    <div class="profile-info">
                        <p id="profile-username" class="editable-text">你的昵称</p>
                        <p id="profile-sub-username" class="editable-text">@your_id</p>
                        <p id="profile-bio" class="editable-text">点击这里编辑你的个性签名</p>
                        <p id="profile-location" class="editable-text" data-placeholder="点击编辑地点"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg><span>点击编辑地点</span></p>
                    </div>
                </div>
                <div id="desktop-layout">
                    <div id="desktop-widget-column">
                        <div class="custom-widget-container">
                            <div id="widget-bubble-1" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
                            <div class="widget-circle-uploader">
                                <img id="widget-image-1" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片">
                            </div>
                            <div id="widget-subtext-1" class="widget-subtext editable-text" contenteditable="true">点击编辑文字</div>
                        </div>
                        <div class="custom-widget-container">
                            <div id="widget-bubble-2" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
                            <div class="widget-circle-uploader">
                                <img id="widget-image-2" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image" title="点击更换图片">
                            </div>
                            <div id="widget-subtext-2" class="widget-subtext editable-text" contenteditable="true">点击编辑文字</div>
                        </div>
                    </div>
                    <div id="desktop-app-container">
                        <div class="desktop-app-icon" onclick="showScreen('chat-list-screen')"><div class="icon-bg-desktop"><img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ"></div><span class="label">QQ</span></div>
                        <div class="desktop-app-icon" onclick="showScreen('world-book-screen')"><div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界书"></div><span class="label">世界书</span></div>
                        <div id="check-phone-btn" class="desktop-app-icon">
                            <div class="icon-bg-desktop"><img id="icon-img-check-phone" src="https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg" alt="查手机"></div>
                            <span class="label">查手机</span>
                        </div>
                        <div class="desktop-app-icon" id="weibo-app-icon">
                            <div class="icon-bg-desktop"><img id="icon-img-weibo" src="https://i.postimg.cc/PqBY5wBq/weibo-icon.png" alt="微博"></div>
                            <span class="label">微博</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

<!-- 这是我们新增的第二页，现在是自定义布局 -->
<div class="home-page">
<!-- 这是左半边的头像小组件 -->
<div id="second-page-left-widget" class="custom-widget-container">
    <div class="widget-circle-uploader">
        <img id="widget-image-3" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片">
    </div>
    
    <!-- ▼▼▼ 这是我们新增的可编辑胶囊气泡 ▼▼▼ -->
    <div id="second-page-bubble" class="widget-bubble editable-text" contenteditable="true">
        点击编辑文字
    </div>
    <!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里添加下面这段全新的HTML代码 ▼▼▼ -->
<div id="new-bubbles-container">
    <div id="flat-capsule-bubble" class="widget-bubble editable-text" contenteditable="true">可编辑</div>
    <div id="circular-bubble" class="widget-bubble editable-text" contenteditable="true">文字</div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

</div>
    <!-- 这是右上角的两个并排图标 -->
    <div id="second-page-top-right-apps">
        <div class="desktop-app-icon" onclick="showScreen('forum-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-forum" src="https://i.postimg.cc/pr0T3WfC/douban-icon.png" alt="圈子"></div>
            <span class="label">圈子</span>
        </div>
        <div class="desktop-app-icon" id="lovers-space-app-icon">
            <div class="icon-bg-desktop"><img id="icon-img-lovers-space" src="https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png" alt="情侣空间"></div>
            <span class="label">情侣空间</span>
        </div>

<!-- 这是你现在的代码 -->
<div id="second-page-x-social-app" class="desktop-app-icon" onclick="showScreen('x-social-screen')">
    <div class="icon-bg-desktop"><img id="icon-img-x-social" src="https://i.postimg.cc/8P1H0vQ8/x-logo.png" alt="X社交"></div>
    <span class="label">X社交</span>
</div>



<!-- ▼▼▼ 用下面这整块【修复后】的代码，替换掉你旧的 id="center-avatar-wrapper" 的那个 div ▼▼▼ -->
<div id="center-avatar-wrapper">
    <!-- 这是你原来的头像，我们把它放在了新容器的中心 -->
    <div id="second-page-center-avatar" class="custom-widget-container">
        <div class="widget-circle-uploader">
            <img id="widget-image-4" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片">
        </div>
    </div>
    
    <!-- 这是修复后的、头像下方的可编辑文字框 -->
    <div id="avatar-subtitle" class="editable-text">点击编辑文字</div>

    <!-- 这是修复后的、头像四个角的可编辑气泡 -->
    <div class="corner-bubble editable-text" id="bubble-top-left">左上角</div>
    <div class="corner-bubble editable-text" id="bubble-top-right">右上角</div>
    <div class="corner-bubble editable-text" id="bubble-bottom-left">左下角</div>
    <div class="corner-bubble editable-text" id="bubble-bottom-right">右下角</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
 <!-- ▼▼▼ 在第二个 <div class="home-page"> 的闭合标签前，粘贴下面这段代码 ▼▼▼ -->
<div style="position: absolute; top: 100px; right: 85px;">
    <div class="desktop-app-icon" onclick="showScreen('game-hall-screen')">
        <div class="icon-bg-desktop">
            <img id="icon-img-game-hall" src="https://i.postimg.cc/P5gL5z2g/game-controller-icon.png" alt="游戏大厅">
        </div>
        <span class="label">游戏大厅</span>
    </div>
</div>
<!-- ▲▲▲ 新增图标代码结束 ▲▲▲ -->
    </div>
<!-- ▼▼▼ 【这是修改后的版本】请用这整块代码，完整替换掉旧的 id="new-custom-widget" ▼▼▼ -->
<div id="new-custom-widget">
    <!-- 我们用一个新的容器把月份和头像包起来 -->
    <div id="new-widget-header">
        <div id="widget-month-display"></div>
        <img id="new-widget-avatar" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
    </div>
    <div id="new-widget-text-1" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
    <div class="new-widget-divider"></div>
    <div id="new-widget-text-2" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
    <div class="new-widget-divider"></div>
    <div id="new-widget-text-3" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 把下面这一整块【全新的代码】，粘贴到第二个 <div class="home-page"> 的【内部】最底部 ▼▼▼ -->
<!-- 这是我们新增的“桃宝”App图标 -->
<div style="position: absolute; bottom: 75px; left: 35px;">
    <div class="desktop-app-icon" id="taobao-app-icon">
        <div class="icon-bg-desktop"><img id="icon-img-taobao" src="https://i.postimg.cc/k47tXg1j/taologo.png" alt="桃宝"></div>
        <span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">桃宝</span>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里粘贴下面这块新代码 ▼▼▼ -->
<!-- 这是我们新增的“约会大作战”App图标 -->
<div style="position: absolute; bottom: 75px; left: 120px;">
    <div class="desktop-app-icon" id="date-a-live-app-icon">
        <div class="icon-bg-desktop"><img id="icon-img-date-a-live" src="https://i.postimg.cc/W36mYgP5/DAL-icon.jpg" alt="约会大作战"></div>
        <span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">约会大作战</span>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
</div>

        <!-- 这是第三页，空白页面 -->
        <div class="home-page">
            <!-- 第三页预留空白，后续添加新的APP -->
        </div>
    </div>
    
    <!-- 底部 Dock 栏保持不变 -->
    <div id="desktop-dock">
        <div class="desktop-app-icon" onclick="showScreen('api-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API设置"></div><span class="label">API设置</span></div>
        <div class="desktop-app-icon" onclick="showScreen('font-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字体"></div><span class="label">字体</span></div>
        <div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外观设置"></div>
            <span class="label">外观设置</span>
        </div>
    </div>

    <!-- 这是我们新增的小圆点 -->
    <div class="pagination-dots">
        <span class="dot active"></span>
        <span class="dot"></span>
        <span class="dot"></span>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->

<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 用下面这【一整块功能最全】的代码，完整替换掉你旧的 id="weibo-screen" 的整个 div ▼▼▼ -->
<div id="weibo-screen" class="screen">
    <!-- 这个容器将存放微博的所有页面 -->
    <div id="weibo-page-container">

        <!-- 页面1: 我的主页 (已改造) -->
        <div id="weibo-my-profile-view" class="weibo-view active">
            <!-- 头部 -->
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>我的主页</span>
                <div class="header-actions">
                              <!-- ▼▼▼ 在这里添加新的私信按钮 ▼▼▼ -->
            <span class="action-btn" id="weibo-my-dms-btn" title="我的私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
            </span>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
                    <!-- 【核心修改】我们在这里新增了一个“编辑”按钮 -->
                    <span class="action-btn" id="edit-weibo-profile-btn" title="编辑资料">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                    </span>
                    <span class="action-btn" id="create-weibo-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
                </div>
            </div>
            <!-- 主页内容区 -->
            <div id="weibo-profile-page">
                <div class="weibo-profile-header">
                    <img id="weibo-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
                  <!-- ▼▼▼ 用下面这整块代码，替换旧的 weibo-avatar-container ▼▼▼ -->
<div class="weibo-avatar-container">
    <img id="weibo-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
    <!-- ▼▼▼ 我们在这里新增了一个用于显示头像框的img元素 ▼▼▼ -->
    <img id="weibo-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

                    <div class="weibo-nickname" id="weibo-nickname">你的昵称</div>
                    <!-- 【核心修改】在这里新增一个显示职业的地方 -->
                    <!-- ▼▼▼ 用这行新代码替换掉旧的 ▼▼▼ -->
<div id="weibo-user-profession-display">点击设置职业</div>

                    <div class="weibo-stats">
                        <div id="weibo-following-btn" class="weibo-stat-item">
                            <span id="weibo-following-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">关注</span>
                        </div>
                        <div id="weibo-posts-item" class="weibo-stat-item">
                            <span id="weibo-posts-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">微博</span>
                        </div>
                        <div id="weibo-fans-item" class="weibo-stat-item">
                            <span id="weibo-fans-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">粉丝</span>
                        </div>
                    </div>
                </div>
                <div id="my-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                    <!-- “我的微博”列表将由JS动态生成在这里 -->
                </div>
            </div>
        </div>

        <!-- 页面2: 关注的人 (保持不变) -->
        <div id="weibo-following-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>关注的人</span>
                <span class="action-btn" id="clear-following-feed-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            </div>
            <div id="weibo-following-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- 关注的人的微博列表将由JS动态生成在这里 -->
            </div>
        </div>
        
        <!-- 页面3: 热搜 (保持不变) -->
        <div id="weibo-hot-search-view" class="weibo-view">
             <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>热搜</span>
                <div class="header-actions">
                    <span class="action-btn" id="generate-hot-search-btn" title="生成热搜">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-hot-search-list" style="flex-grow: 1; overflow-y: auto;">
                <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角放大镜生成热搜</p>
            </div>
        </div>

        <!-- 页面4: 广场 (保持不变) -->
        <div id="weibo-plaza-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>广场</span>
                <div class="header-actions">
                    <span class="action-btn" id="generate-plaza-feed-btn" title="生成广场动态">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-plaza-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                 <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角放大镜生成广场动态</p>
            </div>
        </div>

        <!-- 页面5: 热搜详情页 (保持不变) -->
        <div id="weibo-hottopic-feed-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" id="back-from-hottopic-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span id="weibo-hottopic-title">热搜话题</span>
                <div class="header-actions">
                     <span class="action-btn" id="refresh-hottopic-feed-btn" title="换一批">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-hottopic-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                <!-- 热搜微博列表将由JS动态生成 -->
            </div>
        </div>
    </div>

    <!-- 底部导航栏 -->
    <div id="weibo-bottom-nav">
        <div class="weibo-nav-item" data-view="weibo-hot-search-view">热搜</div>
        <div class="weibo-nav-item" data-view="weibo-plaza-view">广场</div>
        <div class="weibo-nav-item" data-view="weibo-following-view">关注的人</div>
        <div class="weibo-nav-item active" data-view="weibo-my-profile-view">我的微博</div>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->
   
<!-- ▼▼▼ 请用这整块【最终版】代码，完整替换掉你旧的 id="world-book-screen" 的 div ▼▼▼ -->
<div id="world-book-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>世界书</span>
        <div class="header-actions">
            
            <!-- ★★★ 核心修改就在这里 ★★★ -->
            <!-- 我们把 "导入" 两个字，换成了一段SVG代码，并加上了 title 提示 -->
            <span class="action-btn" id="import-world-book-btn" title="导入世界书">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
            </span>
            <!-- ▲▲▲ 修改结束 ▲▲▲ -->

            <span class="action-btn" id="manage-world-book-categories-btn">管理分类</span>
            <span class="action-btn" id="add-world-book-btn">+</span>
        </div>
    </div>
    <div id="world-book-list"></div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">编辑世界书</span>
                    <span class="save-btn" id="save-world-book-btn">保存</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">书名</label>
                        <input type="text" id="world-book-name-input" placeholder="请输入世界书的名称...">
                    </div>

        <!-- ▼▼▼ 【全新】在这里添加分类选择 ▼▼▼ -->
        <div class="form-group">
            <label for="world-book-category-select">分类</label>
            <select id="world-book-category-select">
                <!-- 选项将由JS动态生成 -->
            </select>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->

                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">内容</label>
                        <textarea id="world-book-content-input" placeholder="在此处输入详细的世界观设定..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 设置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p><div class="form-group"><label for="proxy-url">反代地址 (不需要添加/v1噢~)</label><input type="text" id="proxy-url" placeholder="例如: https://api.openai.com"></div><div class="form-group"><label for="api-key">密钥 (直连轮询用英文逗号隔开)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">模型</label><select id="model-select"></select></div>
<!-- ▼▼▼ 请将这段【全新的HTML代码】粘贴到 “模型” 下拉框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label>API 预设</label>
    <div class="bubble-preset-manager"> <!-- 复用现有样式 -->
        <select id="api-preset-select" class="form-group select"></select>
        <button id="manage-api-presets-btn" class="action-btn">管理</button>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
 <!-- ▼▼▼ 请将这段【全新的HTML代码】粘贴到这里 ▼▼▼ -->
<div class="form-group">
    <label for="temperature-slider">模型温度 (Temperature): <span id="temperature-value">0.8</span></label>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px; margin-bottom: 10px;">
        数值越高，回复越随机、有创造性，但可能偏离人设。数值越低，回复越稳定、可预测。推荐值: 0.7 - 1.2
    </p>
    <input type="range" id="temperature-slider" min="0" max="2" step="0.1" value="0.8" style="width: 100%;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
 
<button class="form-button" id="fetch-models-btn">拉取模型</button>

<!-- ▼▼▼ 从这里开始，是全新的后台活动设置区 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">

<!-- 1. 总开关 -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        启用后台角色活动 (总开关)
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：开启后会显著增加API调用和费用！
        </p>
    </label>
    <!-- 【重要】我们把原来的 checkbox 换成了更美观的 iOS 风格开关 -->
    <label class="toggle-switch">
        <input type="checkbox" id="background-activity-switch">
        <span class="slider"></span>
    </label>
</div>

<!-- 2. 后台活动详细设置 (默认隐藏，由总开关控制) -->
<div id="background-activity-details" style="display: none;">
    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <label for="background-interval-input" style="margin-bottom: 0;">
            后台活动检测间隔 (秒)
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                建议值 60-300。值越大，费用越低，但角色反应越慢。
            </p>
        </label>
        <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
    </div>

    <!-- 3. 角色选择与频率设置 -->
    <div class="form-group">
        <label>设置角色活动频率</label>
        <div id="background-activity-char-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="bg-select-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全选</button>
            <button id="bg-deselect-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全不选</button>
        </div>
    </div>

    <div class="form-group">
    <label>为选中角色设置频率</label>
    <div style="display: flex; gap: 10px;">
        <button class="form-button-secondary bg-freq-btn" data-freq="low" style="flex:1; margin:0; border-color: #28a745;">低</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="medium" style="flex:1; margin:0; border-color: #fd7e14;">中</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="high" style="flex:1; margin:0; border-color: #dc3545;">高</button>
        <!-- ▼▼▼ 就是新增了这个“关闭”按钮 ▼▼▼ -->
        <button class="form-button-secondary bg-freq-btn" data-freq="none" style="flex:1; margin:0; border-color: #aaa;">关闭</button>
    </div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px;">
        频率越高，角色主动行为的概率越大，费用也越高。
    </p>
</div>
</div>
<!-- ▲▲▲ 全新的后台活动设置区结束 ▲▲▲ -->


<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑后冷静期 (小时)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超过这个时间后，AI才有几率重新申请好友。
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">以下是 Minimax 语音（TTS）的设置，用于AI发送语音消息。</p>
<div class="form-group">
    <label for="minimax-group-id">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="输入你的 Minimax Group ID">
</div>
<div class="form-group">
    <label for="minimax-api-key">Minimax API Key</label>
    <input type="password" id="minimax-api-key" placeholder="输入你的 Minimax API Key">
</div>


<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group">
    <label for="minimax-speech-model-select">Minimax 语音模型 (TTS Model)</label>
    <select id="minimax-speech-model-select">
        <!-- 选项将由JS填充 -->
    </select>
</div>
<button class="form-button" id="fetch-minimax-speech-models-btn">拉取语音模型</button>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<hr style="margin:20px 0; opacity:.3">
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ NovelAI 图像生成系统配置 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="novelai-switch" style="margin-bottom: 0;">
        启用 NovelAI 图像生成
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            开启后可使用NovelAI官方API生成高质量动漫风格图像（必开🔮）
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            1. 三击下载图片，下面可测试模型或关键词画师串
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            2. 429是novel的访问频繁错误，等待几秒重新即可
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            3. 403是多人共号限制，限制oplus免费出小图但可扣点数
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            4. 403也会因为没开🔮报错，实在不行可更换出图尺寸
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            5. 401是key没权限，检查key是否正确
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            6. 生成失败:Failed to fetch是跨域限制，下方设置里换代理
        </p>
    </label>
    <label class="toggle-switch">
        <input type="checkbox" id="novelai-switch">
        <span class="slider"></span>
    </label>
</div>

<div id="novelai-details" style="display: none;">
    <div class="form-group">
        <label for="novelai-model" style="color: #333;">NovelAI 模型</label>
        <select id="novelai-model" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; border-radius: 4px;">
            <option value="nai-diffusion-4-curated-preview">NAI Diffusion V4.5 Curated (精选版无nsfw)</option>
            <option value="nai-diffusion-4-5-full">NAI Diffusion V4.5 Full（完整版含nsfw）</option>
            <option value="nai-diffusion-3">NAI Diffusion Anime V3（旧版）</option>
            <option value="nai-diffusion-furry-3">NAI Diffusion Furry V3（旧旧版）</option>
        </select>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            💡 必须有oplus订阅的apikey才可以使用！
        </p>
    </div>

    <div class="form-group">
        <label for="novelai-api-key" style="color: #333;">NovelAI API Key</label>
        <div style="position: relative;">
            <input type="password" id="novelai-api-key" placeholder="pst-xxxxxxxxxxxxxxxx" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding-right: 40px;">
            <span id="novelai-key-toggle" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; user-select: none; font-size: 18px;">🧐</span>
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            💡 在 <a href="https://novelai.net" target="_blank" style="color: #007bff;">NovelAI官网</a> 获取API Key
        </p>
    </div>

    <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button type="button" id="novelai-settings-btn" style="flex: 1; background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
             生成设置
        </button>
        <button type="button" id="novelai-test-btn" style="flex: 1; background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
             测试生成
        </button>
    </div>
</div>
<!-- ▲▲▲ NovelAI 图像生成系统配置结束 ▲▲▲ -->
<!-- ▼▼▼ 请将这段【全新的HTML代码】粘贴到 “模型” 下拉框的 form-group 之后 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group">
    <label for="image-quality-slider">发送图片压缩质量 (0.1=高压缩, 1.0=不压缩): <span id="image-quality-value">0.7</span></label>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px; margin-bottom: 10px;">
        数值越低，图片压缩率越高，体积越小，但画质越差。此功能对所有上传的图片生效（如聊天发图、换头像、壁纸等）。推荐值: 0.5 - 0.8。
    </p>
    <input type="range" id="image-quality-slider" min="0.1" max="1.0" step="0.1" value="0.7" style="width: 100%;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 请用这段【新代码】替换掉你旧的“计算图片大小”按钮和文本区域 ▼▼▼ -->
<button class="form-button form-button-secondary" id="compress-all-images-btn" style="margin-top: 10px; background-color:#ffc107; border-color:#ffaf00; color: #333;">一键压缩全部现有图片</button>
<p id="image-data-size-display" style="text-align: center; color: var(--text-secondary); margin-top: 5px;">正在计算图片数据大小...</p>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<button class="form-button" id="save-api-settings-btn">保存设置</button>

<!-- ▼▼▼ 跨设备数据同步区域 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div style="background: var(--card-bg); padding: 15px; border-radius: 10px; margin: 15px 0;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="margin: 0; color: var(--text-primary); font-size: 16px;">🔄 跨设备数据同步</h3>
        <button id="sync-help-btn" style="padding: 6px 12px; border-radius: 5px; border: 1px solid var(--accent-color); background: transparent; color: var(--accent-color); cursor: pointer; font-size: 13px; transition: all 0.3s;">❓ 使用说明</button>
    </div>
    <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 15px;">
        在不同设备间自动同步所有数据，无需手动导入导出。支持云文件和Git仓库两种方式。
    </p>
    
    <!-- 同步方式选择 -->
    <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; color: var(--text-primary); font-size: 14px;">同步方式：</label>
        <select id="sync-method-select" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-primary);">
            <option value="">未启用</option>
            <option value="folder">云同步文件夹 (百度网盘/OneDrive等)</option>
            <option value="github">Git仓库 (GitHub Gist)</option>
        </select>
    </div>

    <!-- 云同步文件夹配置区域 -->
    <div id="folder-config" style="display: none;">
        <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
            <p style="color: var(--text-secondary); font-size: 13px; margin: 0 0 10px 0; line-height: 1.6;">
                📁 <strong>支持的云盘：</strong>百度网盘、OneDrive、Google Drive、Dropbox、坚果云、iCloud Drive 等任何云同步文件夹
            </p>
            <p style="color: var(--text-secondary); font-size: 13px; margin: 0; line-height: 1.6;">
                💡 <strong>使用方法：</strong><br>
                1. 导出数据文件到云盘的同步文件夹（如 D:\百度网盘\兔K同步\）<br>
                2. 等待云盘自动同步到其他设备<br>
                3. 在其他设备上导入该文件即可完成同步
            </p>
        </div>
        
        <!-- 自定义文件名 -->
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">同步文件名：</label>
            <input type="text" id="sync-filename-input" placeholder="gemini_chat_sync" value="gemini_chat_sync" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-primary);">
            <small style="color: var(--text-secondary); font-size: 11px;">💡 自动添加 .json 后缀，建议使用易识别的名称</small>
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <button id="folder-export-btn" class="form-button" style="flex: 1;">💾 导出同步文件</button>
            <button id="folder-import-btn" class="form-button form-button-secondary" style="flex: 1;">📥 导入同步文件</button>
        </div>
        <input type="file" id="folder-import-input" accept=".json" style="display: none;">
        <div style="background: #d1ecf1; color: #0c5460; padding: 10px; border-radius: 5px; font-size: 12px; margin-top: 10px;">
            ℹ️ 提示：使用相同的文件名可以方便在不同设备间同步和识别文件
        </div>
    </div>

    <!-- GitHub Gist 配置区域 -->
    <div id="github-config" style="display: none;">
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">GitHub Personal Access Token：</label>
            <input type="password" id="github-token-input" placeholder="ghp_xxxxxxxxxxxx" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-primary);">
            <small style="color: var(--text-secondary); font-size: 11px;">需要 gist 权限。<a href="https://github.com/settings/tokens/new" target="_blank" style="color: var(--accent-color);">创建Token</a></small>
        </div>
        <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">Gist ID (可选，留空自动创建)：</label>
            <input type="text" id="github-gist-id-input" placeholder="留空将自动创建新的私有Gist" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-primary);">
        </div>
    </div>

    <!-- 自动同步设置 -->
    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 10px;">
            <input type="checkbox" id="auto-sync-checkbox" style="margin-right: 8px;">
            <span style="color: var(--text-primary); font-size: 14px;">启用自动同步</span>
        </label>
        <div id="sync-interval-container" style="display: none; margin-left: 24px;">
            <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">同步间隔（分钟）：</label>
            <input type="number" id="sync-interval-input" min="1" max="60" value="5" style="width: 100px; padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-primary);">
        </div>
    </div>

    <!-- 同步状态显示 -->
    <div id="sync-status-display" style="margin-top: 15px; padding: 10px; border-radius: 5px; background: var(--bg-secondary); font-size: 13px; color: var(--text-secondary);">
        同步状态：未配置
    </div>

    <!-- 操作按钮 -->
    <div style="margin-top: 15px; display: flex; gap: 10px;">
        <button class="form-button" id="save-sync-config-btn" style="flex: 1;">保存同步配置</button>
        <button class="form-button form-button-secondary" id="manual-sync-btn" style="flex: 1;">立即同步</button>
    </div>
</div>
<!-- ▲▲▲ 跨设备数据同步区域结束 ▲▲▲ -->

			<hr style="margin:20px 0; opacity:.3">

<!-- ▼▼▼ 定时导出数据提醒功能 ▼▼▼ -->
<div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label style="font-weight: 500; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
            <span>⏰</span>
            <span>定时导出提醒</span>
        </label>
        <label class="toggle-switch" style="margin: 0;">
            <input type="checkbox" id="export-reminder-toggle">
            <span class="slider"></span>
        </label>
    </div>
    
    <div id="export-reminder-settings" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <label style="font-size: 14px; color: var(--text-secondary);">每天</label>
            <input type="time" id="export-reminder-time" style="padding: 6px 10px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
            <label style="font-size: 14px; color: var(--text-secondary);">提醒导出数据</label>
            <button id="reset-reminder-btn" style="padding: 4px 8px; font-size: 12px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer;" title="清除今天的提醒记录，允许再次测试">🔄 重置</button>
        </div>
        <p style="font-size: 12px; color: var(--text-tertiary); margin: 8px 0 0 0; line-height: 1.4;">
            开启后将在设定的时间弹窗提醒您导出数据，避免数据丢失。修改时间后会自动清除今天的提醒记录。
        </p>
    </div>
</div>
<!-- ▲▲▲ 定时导出数据提醒功能结束 ▲▲▲ -->

<!-- ▼▼▼ 定时自动导出功能 ▼▼▼ -->
<div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label style="font-weight: 500; color: var(--text-primary); display: flex; align-items: center; gap: 8px;">
            <span>🤖</span>
            <span>定时自动导出</span>
        </label>
        <label class="toggle-switch" style="margin: 0;">
            <input type="checkbox" id="auto-export-toggle">
            <span class="slider"></span>
        </label>
    </div>
    
    <div id="auto-export-settings" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 12px;">
            <label style="font-size: 14px; color: var(--text-secondary);">每天</label>
            <input type="time" id="auto-export-time" style="padding: 6px 10px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
            <label style="font-size: 14px; color: var(--text-secondary);">自动导出数据</label>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <label style="font-size: 14px; color: var(--text-secondary);">导出路径：</label>
            <input type="text" id="auto-export-path" placeholder="留空使用默认路径" style="flex: 1; min-width: 200px; padding: 6px 10px; border-radius: 5px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
            <button id="test-auto-export-btn" style="padding: 4px 8px; font-size: 12px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer;" title="测试自动导出功能">🧪 测试</button>
        </div>
        <p style="font-size: 12px; color: var(--text-tertiary); margin: 8px 0 0 0; line-height: 1.4;">
            开启后将在设定的时间自动导出数据。路径留空则使用默认文件名下载到浏览器默认下载文件夹。
        </p>
    </div>
</div>
<!-- ▲▲▲ 定时自动导出功能结束 ▲▲▲ -->

<button class="form-button form-button-secondary" id="clear-orphaned-data-btn" style="margin-top: 10px; border-color: #ff9966; color: #ff9966;">🧹 清理失效数据</button>
			<button class="form-button" id="export-data-btn">导出数据</button>
<!-- ▼▼▼ 在这里粘贴下面的新按钮 ▼▼▼ -->
<button class="form-button form-button-secondary" id="export-data-stream-btn" style="margin-top: 10px;">流式导出 (大数据专用)</button>
<!-- ① 普通按钮，和“导出”一个 class -->
<button class="form-button" id="import-btn">导入备份文件</button>
<button class="form-button" id="advanced-transfer-btn" style="background-color: #6f42c1; margin-top: 10px;">高级导入/导出</button>
<!-- ▼▼▼ 步骤1：将这段全新的HTML代码，粘贴到 id="advanced-transfer-btn" 按钮的下一行 ▼▼▼ -->
<button id="clear-local-data-btn" class="form-button">清除本机数据</button>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ② 真正的文件选择器，完全隐藏 -->
<input id="import-data-input" type="file" accept="application/json" hidden>

</div></div>
<!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- 主头部 (只在消息列表显示) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <!-- ▼▼▼ 这是我们新加的导入按钮 ▼▼▼ -->
<span class="action-btn" id="import-character-card-btn" title="导入角色卡">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
    </svg>
</span>
<!-- ▲▲▲ 导入按钮结束 ▲▲▲ -->
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- 消息列表视图 -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JS会在这里生成聊天列表 -->
        </div>
    </div>

    <!-- 动态界面视图 -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
            <span>好友动态</span>
    <!-- ★★★ 这就是我们新增的清空图标 ★★★ -->
    <div class="header-actions">
        <span class="action-btn" id="clear-qzone-posts-btn" title="清空动态">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
        </span>
    </div>
    <!-- ▲▲▲ 新增结束 ▲▲▲ -->
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                <div class="action-item" id="create-post-btn"><span>动态</span></div>
                <div class="action-item" id="open-album-btn"><span>相册</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- 收藏界面视图 -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>我的收藏</span>
        <!-- 新增的编辑按钮 -->
        <span class="action-btn" id="favorites-edit-btn">编辑</span>
    </div>

        <!-- 【新增】搜索栏容器 -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- 收藏内容将由JS动态生成在这里 -->
        </div>

<!-- 新增：收藏页底部操作栏 -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>我们的回忆</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 回忆卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

   
    <!-- 底部导航栏 -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>消息</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>动态</span>
    </div>
    <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>回忆</span>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>收藏</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. 页面头部，包含返回按钮和标题 -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>我的相册</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- 相册列表将由 JS 动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. 页面头部 -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">相册名称</span>
        <span class="action-btn" id="album-upload-photo-btn">上传</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- 照片列表将由 JS 动态生成在这里 -->
        </div>

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. 关闭按钮 -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. 上一张照片按钮 -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. 图片容器 -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="全屏照片预览">
    </div>
    
    <!-- 4. 下一张照片按钮 -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

<div class="header">
    <!-- 默认控件：包含标题、状态栏和常规按钮 -->
    <div class="default-controls">
        <span class="back-btn" id="back-to-list-btn">‹</span>
        
        <!-- 标题和状态的容器 -->
        <div id="chat-header-title-wrapper">
            <div id="chat-header-main-line">
                <span id="chat-header-title">聊天对象</span>
                    <!-- ▼▼▼ 【全新】群公告按钮 ▼▼▼ -->
    <span id="group-announcement-btn" title="群公告">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="7" y1="15" x2="17" y2="15"></line>
        </svg>
    </span>
    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
            </div>
            <div id="chat-header-status">
                <span class="status-dot"></span>
                <span class="status-text">在线</span>
            </div>
        </div>

        <div class="header-actions">
            <!-- 【正确位置】心声按钮在这里 -->
            <span class="action-btn" id="char-heart-btn" title="心声" style="display: none; cursor: pointer;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ff4d6d" stroke="#ffc3d0" stroke-width="1.5">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            </span>
            <span class="action-btn" id="listen-together-btn" title="一起听"><img src="https://chatbotcos.weixin.qq.com/chatbot/30-openaiassets_63e04c67410237fa43bf6fcce542dbff_469401762321466866.png" alt="一起听"></span>
            <span class="action-btn" id="chat-settings-btn" title="聊天设置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="设置"></span>
        </div>
    </div>

    <!-- 多选模式控件 -->
    <div class="selection-controls">
        <span id="selection-cancel-btn">取消</span>
        <span id="selection-count"></span>
        <div class="header-actions">
           <span id="selection-favorite-btn" class="action-btn">收藏</span>
           <span id="selection-share-btn" class="action-btn">分享</span> 
           <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">删除</span>
        </div>
    </div>
</div>
<!-- ▼▼▼ 在 #chat-interface-screen 内，header 的 div 之后添加 ▼▼▼ -->

<div id="chat-pet-container" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; z-index: 10;">
    <div id="chat-pet" style="display: none; position: absolute; cursor: grab; user-select: none; pointer-events: all; font-size: 80px; line-height: 1; text-align: center;">
        <!-- 宠物会显示在这里 -->
    </div>
</div>

<!-- ▲▲▲ 添加结束 ▲▲▲ -->

    <!-- 聊天消息区域 (保持不变) -->
    <div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>

    <!-- 输入区域 (这是修改后的最终版本) -->
    <div id="chat-input-area">
        <div id="reply-preview-bar">
            <div class="reply-preview-content">
                <div class="sender">回复 xxx:</div>
                <div class="text">被引用的消息内容...</div>
            </div>
            <span id="cancel-reply-btn">×</span>
        </div>
        <div id="chat-input-actions-top">
            <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg></button>
            
            <!-- “重新生成回复”按钮的新家 -->
            <button id="reroll-btn" class="action-button" title="重新生成回复"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg></button>
            
            <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="发送照片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></button>
            <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上传图片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" ><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button id="transfer-btn" class="chat-action-icon-btn action-button" title="转账">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path>
            </svg>
            </button>
            <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg></button>
            <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="发起外卖请求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg></button>
            <button id="video-call-btn" class="chat-action-icon-btn action-button" title="视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
            <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
            <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="发起投票"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg></button>
            <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享链接"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
<!-- ▼▼▼ 请将这段【缺失的】按钮代码，粘贴到下方“分享链接”和“塔罗牌”按钮之间 ▼▼▼ -->
<button id="send-location-btn" class="chat-action-icon-btn action-button" title="发送定位">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
        <circle cx="12" cy="10" r="3"></circle>
    </svg>
</button>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
            <!-- ▼▼▼ 用下面这整块代码，替换你原来的那个 <button id="open-tarot-btn">...</button> ▼▼▼ -->
<button id="open-tarot-btn" class="chat-action-icon-btn action-button" title="塔罗占卜">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 背景左侧卡牌 -->
        <path d="M7 6.5L4 7.5V17.5L7 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round"/>
        <!-- 背景右侧卡牌 -->
        <path d="M17 6.5L20 7.5V17.5L17 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round"/>
        <!-- 前方中心卡牌 -->
        <rect x="7" y="5" width="10" height="15" rx="1.5" stroke="currentColor" stroke-width="2.6"/>
        <!-- 中心卡牌的星星 -->
        <path d="M12 9.5L13.12 11.79L15.61 12.17L13.8 13.92L14.24 16.4L12 15.2L9.76 16.4L10.2 13.92L8.39 12.17L10.88 11.79L12 9.5Z" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 八卦六爻按钮 ▼▼▼ -->
<button id="open-bagua-btn" class="chat-action-icon-btn action-button" title="八卦六爻">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 外圈八卦圆 -->
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
        <!-- 太极阴阳鱼简化版 - 上半圆（阳） -->
        <path d="M12 2 A10 10 0 0 1 12 12 A5 5 0 0 0 12 2" fill="currentColor"/>
        <!-- 太极阴阳鱼简化版 - 下半圆（阴） -->
        <path d="M12 12 A10 10 0 0 1 12 22 A5 5 0 0 1 12 12" fill="currentColor"/>
        <!-- 阳眼 -->
        <circle cx="12" cy="7" r="1.5" fill="none" stroke="currentColor" stroke-width="1.5"/>
        <!-- 阴眼 -->
        <circle cx="12" cy="17" r="1.5" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 八卦六爻按钮结束 ▲▲▲ -->
<!-- ▼▼▼ 【歪头杀·满分可爱猫】请用这块代码替换旧的宠物按钮 <button> ▼▼▼ -->
<button id="pet-action-btn" class="chat-action-icon-btn action-button" title="我的宠物">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 主体轮廓: 耳朵不对称，营造歪头效果 -->
        <path d="M3.5 14.5C3.5 20.5 20.5 20.5 20.5 14.5C20.5 9 17.5 5.5 12.5 8.7C6.5 4.5 3.5 9 3.5 14.5Z" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" stroke-linejoin="round"/>
        <!-- 眼睛 -->
        <circle cx="8.5" cy="15" r="1.5" fill="currentColor"/>
        <circle cx="15.5" cy="15" r="1.5" fill="currentColor"/>
        <!-- 左边两根小胡须 -->
        <path d="M4.5 14.3L2.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <path d="M4.5 15.7L2.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <!-- 右边两根小胡须 -->
        <path d="M19.5 14.3L21.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <path d="M19.5 15.7L21.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
    </svg>
</button>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 我的钱包按钮 ▼▼▼ -->
<button id="wallet-action-btn" class="chat-action-icon-btn action-button" title="我的钱包">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 钱包外框 -->
        <rect x="3" y="6" width="18" height="14" rx="2" stroke="currentColor" stroke-width="2" fill="none"/>
        <!-- 钱包开口 -->
        <path d="M3 9 L21 9" stroke="currentColor" stroke-width="2"/>
        <!-- 钱包卡槽 -->
        <rect x="16" y="11" width="4" height="6" rx="1" fill="currentColor"/>
        <!-- 金钱符号 -->
        <text x="9" y="16" font-size="8" fill="currentColor" font-weight="bold">¥</text>
    </svg>
</button>
<!-- ▲▲▲ 我的钱包按钮结束 ▲▲▲ -->

<!-- ▼▼▼ 记账按钮 ▼▼▼ -->
<button id="accounting-action-btn" class="chat-action-icon-btn action-button" title="记账">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 记账本外框 -->
        <path d="M6 2h12a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z" stroke="currentColor" stroke-width="2" fill="none"/>
        <!-- 装订线 -->
        <path d="M6 2v20" stroke="currentColor" stroke-width="2"/>
        <circle cx="6" cy="6" r="0.8" fill="currentColor"/>
        <circle cx="6" cy="12" r="0.8" fill="currentColor"/>
        <circle cx="6" cy="18" r="0.8" fill="currentColor"/>
        <!-- 记录线条 -->
        <path d="M10 8h7" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
        <path d="M10 12h7" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
        <path d="M10 16h4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
    </svg>
</button>
<!-- ▲▲▲ 记账按钮结束 ▲▲▲ -->

<!-- ▼▼▼ 月经追踪按钮 ▼▼▼ -->
<button id="period-tracker-btn" class="chat-action-icon-btn action-button" title="月经追踪">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 日历外框 -->
        <rect x="3" y="4" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2" fill="none"/>
        <!-- 日历顶部 -->
        <path d="M3 10h18" stroke="currentColor" stroke-width="2"/>
        <!-- 挂钩 -->
        <path d="M8 2v4M16 2v4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <!-- 心形标记（月经标记） -->
        <path d="M12 18c-2-1.5-4-3-4-5 0-1.5 1-2.5 2-2.5 1 0 1.5 0.5 2 1.5 0.5-1 1-1.5 2-1.5 1 0 2 1 2 2.5 0 2-2 3.5-4 5z" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 月经追踪按钮结束 ▲▲▲ -->

<!-- ▼▼▼ 学习按钮 ▼▼▼ -->
<button id="study-btn" class="chat-action-icon-btn action-button" title="学习中心">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 3L1 9L12 15L21 10.09V17H23V9M5 13.18V17.18L12 21L19 17.18V13.18L12 17L5 13.18Z" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 学习按钮结束 ▲▲▲ -->

<!-- ▼▼▼ 消息存放按钮 ▼▼▼ -->
<button id="message-storage-btn" class="chat-action-icon-btn action-button" title="消息存放">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM7 10H17V12H7V10ZM7 13H17V15H7V13ZM7 7H17V9H7V7Z" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 消息存放按钮结束 ▲▲▲ -->


        </div>
        <div id="chat-input-main-row">
            <textarea id="chat-input" rows="1" placeholder="输入消息..."></textarea>
            <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回复"></button>
                <button id="send-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 用这块新代码替换旧的 #sticker-panel ▼▼▼ -->
<div id="sticker-panel">
    <div id="sticker-panel-header">
        <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
        <span class="title">表情包</span>
        <!-- 【核心修改1】在这里新增“编辑”和“完成”按钮 -->
        <div style="display: flex; gap: 10px;">
            <span class="panel-btn" id="edit-user-stickers-btn">编辑</span>
            <span class="panel-btn" id="done-user-stickers-btn" style="display: none;">完成</span>
            <span class="panel-btn" id="add-sticker-btn">添加</span>
            <span class="panel-btn" id="upload-sticker-btn">上传</span>
        </div>
    </div>
    <div id="sticker-grid"></div>
    <!-- 【核心修改2】在底部新增一个用于批量删除的操作栏，默认隐藏 -->
<!-- 在 #sticker-panel 中，找到 id="sticker-panel-footer" -->
<!-- ▼▼▼ 用下面这整块代码，替换掉你旧的 #sticker-panel-footer ▼▼▼ -->
<div id="sticker-category-tabs">
    <!-- 分类胶囊将由JS动态生成在这里 -->
</div>
<!-- ▼▼▼ 用这块新代码替换旧的 #sticker-panel-footer ▼▼▼ -->
<div id="sticker-panel-footer" style="display: none;">
    <!-- 这是移动表情的按钮，保留 -->
    <button id="move-selected-stickers-btn">移动到分类...</button>
    <!-- 这是删除表情的按钮，保留 -->
    <button id="delete-selected-user-stickers-btn">删除已选 (0)</button>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<input type="file" id="sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- 音乐播放器 (保持不变) -->
<div id="music-player-overlay">
<div class="music-player-window">
    <!-- 1. 顶部头像区域 -->
    <div id="music-avatars-container">
        <img id="music-char-avatar" src="" alt="角色头像">
        <svg id="heartbeat-line" viewBox="0 0 80 30">
            <path class="heartbeat-path" d="M 5 15 Q 20 0 30 15 T 55 15 L 75 15"></path>
            <path class="heartbeat-heart" d="M 0 -2 a 2 2 0 0 1 4 0 v 2 a 2 2 0 0 1 -4 0 z"></path>
        </svg>
        <img id="music-user-avatar" src="" alt="用户头像">
    </div>
    
    <!-- ▼▼▼ 【核心修改】我们把这行文字移到了这里 ▼▼▼ -->
    <div id="music-time-counter">已经一起听了0.0小时</div>

    <!-- 2. 顶部操作按钮 -->
    <div class="music-player-top-actions">
        <div class="top-left-cluster">
            <button id="music-return-btn">‹</button>
            <button id="music-exit-btn">×</button>
        </div>
        <span id="music-playlist-btn">☰</span>
    </div>

    <!-- 3. 封面和歌词的切换容器 -->
    <div id="music-display-area">
        <img id="music-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面">
        <div id="music-lyrics-container">
            <div id="music-lyrics-list">
                <div class="lyric-line">♪ 暂无歌词 ♪</div>
            </div>
        </div>
    </div>

    <!-- 4. 歌曲信息 -->
    <div id="music-player-song-title">请添加歌曲</div>
    <div id="music-player-artist">...</div>
    
    <!-- 5. 播放控制区 (保持不变) -->
    <div class="music-player-controls-wrapper">
        <div class="music-progress-bar-container">
            <div id="music-current-time" class="time-display">0:00</div>
            <div class="progress-bar">
                <div id="music-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="music-total-time" class="time-display">0:00</div>
        </div>
        <div class="music-controls">
            <button id="music-prev-btn">◀</button>
            <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="music-next-btn">▶</button>
            <button id="music-mode-btn">顺序</button>
            <button id="toggle-lyrics-bar-btn" title="桌面歌词">悬浮</button>
        </div>
    </div>
</div>

    </div>
</div>
    
<!-- ▼▼▼ 请用这【一整块】全新的代码，替换掉你旧的 id="music-playlist-panel" 及其所有内部内容 ▼▼▼ -->
<div id="music-playlist-panel">
<!-- ▼▼▼ 用这整块代码替换 ▼▼▼ -->
<div class="playlist-header">
    <span class="panel-btn" id="close-playlist-btn">返回</span>
    <span>播放列表</span>
    <div>
        <!-- ▼▼▼ 我们把垃圾桶图标移到了'本地'的左边 ▼▼▼ -->
        <span class="panel-btn" id="delete-expired-songs-btn" title="清理失效的搜索歌曲">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 6H5H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </span>
        <span class="panel-btn" id="add-song-local-btn">本地</span>
        <span class="panel-btn" id="add-song-url-btn">URL</span>
        <span class="panel-btn" id="add-song-search-btn">搜索</span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- 锁屏壁纸设置 (全新) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">锁屏设置</label>
        </div>
        <div id="lockscreen-wallpaper-preview" class="wallpaper-preview">点击下方上传</div>
        <button class="form-button" onclick="document.getElementById('lockscreen-wallpaper-upload-input').click();">上传锁屏壁纸</button>
        <input type="file" id="lockscreen-wallpaper-upload-input" accept="image/*" hidden>
        
        <div class="form-group" style="width: 100%; margin-top: 15px;">
            <label for="password-set-input">锁屏密码 (留空则无密码)</label>
            <input type="text" id="password-set-input" placeholder="设置你的解锁密码">
        </div>
        
        <hr style="width: 80%; opacity: 0.3; margin: 20px 0;">

        <!-- 主屏幕壁纸设置 (原有) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">主屏幕设置</label>
        </div>
        <div id="wallpaper-preview">点击下方上传</div>
<!-- ▼▼▼ 请将这段新代码粘贴到 wallpaper-preview 的 div 之后 ▼▼▼ -->
<div class="form-group">
    <label for="enable-lock-screen-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">启用锁屏界面</span>
        <input type="checkbox" id="enable-lock-screen-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里粘贴新的“显示状态栏”开关代码 ▼▼▼ -->
<div class="form-group">
    <label for="show-status-bar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">显示状态栏</span>
        <input type="checkbox" id="show-status-bar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<div class="form-group">
    <label for="dark-mode-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">夜间模式</span>
        <input type="checkbox" id="dark-mode-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>


        <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
        <input type="file" id="wallpaper-upload-input" accept="image/*">

<!-- ▼▼▼ 将【下面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
<div class="form-group" style="display: none;">
    <label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
    <label class="toggle-switch">
        <input type="checkbox" id="theme-toggle-switch">
        <span class="slider"></span>
    </label>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <!-- === ▼▼▼ 主屏幕页面管理 ▼▼▼ === -->
    <div style="width:100%; text-align: left; margin-bottom: 15px; margin-top: 20px;">
        <label style="font-weight: 500; color: var(--text-secondary);">主屏幕页面管理</label>
    </div>

    <!-- 页面列表 -->
    <div class="form-group">
        <label>当前页面列表</label>
        <div id="home-page-list" style="background: var(--bg-secondary); border-radius: 8px; padding: 10px; max-height: 200px; overflow-y: auto;">
            <!-- 页面项将通过JS动态生成 -->
        </div>
    </div>

    <!-- 页面操作按钮 -->
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="add-home-page-btn" class="form-button-secondary" style="flex:1;">
            ➕ 添加新页面
        </button>
        <button id="delete-selected-pages-btn" class="form-button-secondary" style="flex:1; background-color: #ffdddd; color: #ff3b30;">
            🗑️ 删除选中
        </button>
    </div>

    <div style="font-size: 12px; color: #999; margin-top: 8px; line-height: 1.5;">
        💡 提示：页面1和页面2为默认页面，无法删除。新增的页面为空白页面，可以自由滑动浏览。
    </div>
    <!-- === ▲▲▲ 主屏幕页面管理结束 ▲▲▲ === -->

    <!-- === ▼▼▼ 以下是新增的美化功能UI ▼▼▼ === -->
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">手机美化 (CSS)</label>
    </div>

    <!-- 主题选择和管理 -->
    <div class="form-group">
        <label for="theme-selector">选择已存方案</label>
        <div style="display: flex; gap: 10px;">
            <select id="theme-selector" style="flex-grow: 1;"></select>
            <button id="rename-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px;">重命名</button>
            <button id="delete-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px; background-color: #ffdddd; color: #ff3b30;">删除</button>
        </div>
    </div>

    <!-- CSS 代码编辑区 -->
    <div class="form-group">
        <label for="theme-css-editor">美化代码编辑区</label>
        <textarea id="theme-css-editor" rows="10" style="font-family: monospace; font-size: 12px; resize: vertical;" placeholder="在这里粘贴或编辑美化代码..."></textarea>
    </div>
    
    <!-- 操作按钮 -->
    <button id="apply-theme-btn" class="form-button">应用当前代码</button>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="save-theme-btn" class="form-button-secondary" style="flex:1;">保存</button>
        <button id="save-as-new-theme-btn" class="form-button-secondary" style="flex:1;">另存</button>
    </div>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-theme-btn" class="form-button-secondary" style="flex:1;">导出方案</button>
        <button id="import-theme-btn" class="form-button-secondary" style="flex:1;">导入方案</button>
        <input type="file" id="import-theme-input" accept=".json,.docx" hidden>
    </div>
    <div style="margin-top: 10px;">
        <button id="adapt-mobile-theme-btn" class="form-button-secondary" style="width: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; font-weight: 500;">
            ✨ 一键适配当前设备
        </button>
        <div id="adapt-mobile-theme-tips" style="font-size: 11px; color: #999; margin-top: 5px; text-align: center; display: none;">
            正在智能适配美化代码...
        </div>
    </div>
    <!-- === ▲▲▲ 新增UI结束 ▲▲▲ === -->
<!-- ▼▼▼ 【V3最终美化版】主屏幕美化预设功能UI ▼▼▼ -->
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">主屏幕预设</label>
    </div>
    <div class="form-group">
        <select id="home-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 独占一行的应用按钮 -->
            <button id="apply-home-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>
            
            <!-- 2x2 网格按钮 -->
            <button id="save-home-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <!-- ▼▼▼ 就是在这里新增了“更新”按钮 ▼▼▼ -->
            <button id="update-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-home-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
            <button id="export-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
            <button id="delete-home-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>
            
            <input type="file" id="import-home-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ UI替换结束 ▲▲▲ -->
<!-- ▼▼▼ 步骤2：用这段新代码替换旧的颜色选择器HTML ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">主屏幕图标及小组件字体颜色</label>
</div>
<div class="form-group">
    <label for="home-icon-widget-text-color-picker">自定义字体颜色</label>
    <input type="color" id="home-icon-widget-text-color-picker" value="#FFFFFF" style="width: 100%; height: 40px; padding: 0; border-radius: 8px;">
</div>
<!-- ▲▲▲ 步骤2 HTML代码替换结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group">
    <label for="remove-home-font-shadow-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">去除主屏幕字体阴影</span>
        <input type="checkbox" id="remove-home-font-shadow-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

        <!-- 【核心修改2】新增图标设置区域 -->
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标设置</label>
        </div>
        <div id="icon-settings-grid">
            <!-- 图标设置项将由JS动态生成在这里 -->
        </div>
<!-- ▼▼▼ 把下面这整块全新的代码，粘贴到“App图标设置”的 div 之后 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">主屏幕 App 名称</label>
</div>
<div id="icon-rename-grid" style="width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 15px 20px;">
    <!-- App 名称输入框将由JS动态生成在这里 -->
</div>
<button class="form-button form-button-secondary" id="reset-app-names-btn" style="margin-top: 15px;">恢复默认App名字</button>
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">铃声设置</label>
</div>
<div class="form-group" style="width: 100%;">
    <label for="ringtone-url-input">来电铃声 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="ringtone-url-input" placeholder="输入音频文件的网络链接...">
</div>
<div class="form-group" style="width: 100%; margin-top: 15px;">
    <label for="notification-sound-url-input">消息提示音 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="notification-sound-url-input" placeholder="输入音频文件的网络链接...">
</div>
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">全局聊天背景</label>
</div>
<div id="global-bg-preview" class="wallpaper-preview">点击下方上传</div>
<button class="form-button" onclick="document.getElementById('global-bg-upload-input').click();">上传全局背景</button>
<input type="file" id="global-bg-upload-input" accept="image/*" hidden>
<button class="form-button form-button-secondary" id="remove-global-bg-btn" style="margin-top: 10px;">移除全局背景</button>
<button class="form-button form-button-secondary" id="clear-all-single-bgs-btn" style="margin-top: 10px; border-color: #ff3b30; color: #ff3b30;">一键清空所有单人聊天背景</button>
        
        <!-- 【核心修改3】按钮文字也改一下 -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- 文章内容将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
    <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
    <span>字体预设</span>
    <span style="width: 30px;"></span> <!-- 保留这个占位符，让标题能完美居中 -->
</div>
    <div class="form-container" style="gap: 20px;">
      <p style="font-size: 13px; color: #ff6b6b; background-color: rgba(255, 107, 107, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.2); text-align: center; width: 100%; box-sizing: border-box;">
            字体太大了导入本地字体会闪退！最好用url。
        </p>
        <!-- 字体预设卡槽的容器 -->
        <div id="font-preset-container">
            <!-- 5个卡槽将由JavaScript动态生成在这里 -->
        </div>
<!-- ▼▼▼ 步骤1：用这块新代码替换旧的 id="add-font-preset-actions" 的 div ▼▼▼ -->
<div class="preset-manager-container" style="margin-top: 20px; padding-top: 20px;">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">槽位管理</label>
    </div>
    <div class="preset-manager-controls" style="grid-template-columns: 1fr 1fr;">
        <!-- 这个按钮用于切换编辑模式 -->
        <button id="edit-font-slots-btn" class="preset-btn-capsule preset-btn-secondary">✏️ 编辑槽位</button>
        <!-- 这个按钮保持不变，用于添加新槽位 -->
        <button id="add-new-font-preset-btn" class="preset-btn-capsule" style="background-color: #4cd964; color: white;">+ 添加槽位</button>
    </div>
    <!-- 这个是删除按钮，默认隐藏，只在编辑模式下显示 -->
    <div id="font-slot-selection-actions" style="display: none; margin-top: 10px;">
        <button id="delete-selected-slots-btn" class="preset-btn-capsule preset-btn-delete" style="width: 100%;" disabled>删除已选 (0)</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        <!-- 全局字体预览区 -->
        <div class="form-group" style="width:100%;">
            <label>当前全局字体预览</label>
            <div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                <p style="margin: 0;">这是全局字体预览效果，12345。</p>
            </div>
        </div>

        <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
    </div>
</div>

<!-- 这个是隐藏的文件选择器，用来处理本地上传 -->
<input type="file" id="font-preset-local-upload" accept=".ttf,.otf,.woff,.woff2" style="display: none;">


<!-- ▼▼▼ 【全新】“查角色手机”功能的所有HTML界面 (V3终极版) ▼▼▼ -->

<!-- 1. 角色选择屏幕 (保持不变) -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>选择要查看的手机</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-selection-list" class="list-container"></div>
</div>

<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉你旧的 id="character-phone-container" 及其所有内容 ▼▼▼ -->
<div id="character-phone-container" class="screen">
    <div class="character-phone-frame">
        <div class="character-phone-notch"></div>
        <div class="character-phone-inner-screen">
            
            <!-- 1. 角色手机的主界面 -->
            <div id="character-phone-screen" class="character-phone-page active">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-screen="character-selection-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-phone-owner-name"></span>
                    <div class="header-actions">
                        <span class="action-btn" id="clear-character-data-btn" title="清空全部数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-character-data-btn" title="刷新全部数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14"/></svg>
                        </span>
                    </div>
                </div>
                <!-- ▼▼▼ 在这里粘贴下面这段全新的HTML代码 ▼▼▼ -->
<!-- 这是左上角的小组件 -->
<div id="char-phone-widget-1" class="char-phone-widget">
    <img id="char-phone-widget-img-1" src="">
</div>
<!-- 这是右下角的小组件 -->
<div id="char-phone-widget-2" class="char-phone-widget">
    <img id="char-phone-widget-img-2" src="">
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                <div id="character-app-grid" class="app-grid-standard" style="padding-top: 60px;"></div>
            </div>

            <!-- 2. 角色手机 - 聊天列表 -->
            <div id="character-chat-list-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>消息</span>
                    <div class="header-actions">
                        <!-- ★ 新增：消息页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-npc-chats-btn" title="清空所有NPC聊天">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-chat-message-btn" title="生成新聊天">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-chat-list" class="list-container" style="padding: 0;"></div>
            </div>

            <!-- 3. 角色手机 - 具体聊天记录 -->
            <div id="character-chat-history-screen" class="character-phone-page">
                <div class="header character-phone-header">
                     <span class="back-btn" data-target-page="character-chat-list-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-chat-with-name"></span>
                </div>
                <div id="character-chat-history-messages" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #e5ddd5;"></div>
            </div>

            <!-- 4. 角色手机 - 购物车 -->
            <div id="character-shopping-cart-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                         <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>购物车</span>
                    <div class="header-actions">
                        <!-- ★ 新增：购物车页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-cart-items-btn" title="清空购物车">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-cart-item-btn" title="添加新商品">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                        </span>
                    </div>
                </div>
                <div id="character-shopping-cart-list" class="list-container"></div>
            </div>

            <!-- 5. 角色手机 - 备忘录 -->
            <div id="character-memos-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>备忘录</span>
                    <div class="header-actions">
                        <!-- ★ 新增：备忘录页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-memos-btn" title="清空备忘录">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-memo-btn" title="写新备忘录">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-memos-list" class="list-container"></div>
            </div>

            <!-- 6. 角色手机 - 浏览器 -->
            <div id="character-browser-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>浏览器</span>
                    <div class="header-actions">
                        <!-- ★ 新增：浏览器页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-browser-history-btn" title="清空历史记录">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-browser-history-btn" title="生成新历史">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-browser-list" class="list-container"></div>
            </div>

            <!-- 7. 角色手机 - 浏览器搜索结果详情 -->
            <div id="character-browser-detail-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-browser-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-browser-detail-title">搜索结果</span>
                </div>
                <div id="character-browser-detail-content" class="list-container" style="padding: 15px; line-height: 1.7;"></div>
            </div>

            <!-- 8. 角色手机 - 相册 -->
            <div id="character-album-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>相册</span>
                    <div class="header-actions">
                        <!-- ★ 新增：相册页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-album-photos-btn" title="清空相册">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-album-photo-btn" title="生成新照片">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </span>
                    </div>
                </div>
                <div id="character-album-grid" class="list-container"></div>
            </div>

            <!-- 9. 角色手机 - 银行 -->
            <div id="character-bank-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>钱包</span>
                    <div class="header-actions">
                        <!-- ★ 新增：钱包页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-bank-transactions-btn" title="清空交易记录">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-bank-transaction-btn" title="生成新交易">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-bank-details" class="list-container"></div>
            </div>

            <!-- 10. 角色手机 - 行动轨迹 -->
            <div id="character-trajectory-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>足迹</span>
                    <div class="header-actions">
                        <!-- ★ 新增：足迹页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-trajectory-btn" title="清空足迹">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-trajectory-btn" title="生成新足迹">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                        </span>
                    </div>
                </div>
                <div id="character-trajectory-list" class="list-container"></div>
            </div>

            <!-- 11. 角色手机 - APP使用记录 -->
            <div id="character-app-usage-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>屏幕使用时间</span>
                    <div class="header-actions">
                        <!-- ★ 新增：使用记录页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-app-usage-btn" title="清空记录">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-app-usage-btn" title="生成新记录">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-app-usage-list" class="list-container"></div>
            </div>

            <!-- 12. 角色手机 - 日记 -->
            <div id="character-diary-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>日记</span>
                    <div class="header-actions">
                        <!-- ★ 新增：日记页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-diary-entries-btn" title="清空日记">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-diary-entry-btn" title="写新日记">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-diary-list" class="list-container"></div>
            </div>
            <!-- ▼▼▼ 【全新】这是角色手机外观设置的HTML界面，请粘贴到指定位置 ▼▼▼ -->
<div id="character-phone-appearance-screen" class="character-phone-page">
    <div class="header character-phone-header">
        <span class="back-btn" data-target-page="character-phone-screen">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </span>
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <!-- 复用你已有的.form-container样式，方便滚动和布局 -->
    <div class="form-container" style="padding: 15px; gap: 25px;">
        <!-- 壁纸设置区 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">手机壁纸</label>
            <div id="char-phone-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px;">点击下方上传</div>
            <button id="upload-char-phone-wallpaper-btn" class="form-button">上传壁纸</button>
            <button id="remove-char-phone-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px;">移除壁纸</button>
        </div>
        <!-- ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼ -->
<hr style="width: 100%; opacity: 0.2;">

<div>
    <label style="font-weight: 500; color: var(--text-secondary);">App 内壁纸</label>
    <div id="char-phone-app-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px;">点击下方上传</div>
    <button id="upload-char-phone-app-wallpaper-btn" class="form-button">上传 App 内壁纸</button>
    <button id="remove-char-phone-app-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px;">移除 App 内壁纸</button>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

        <hr style="width: 100%; opacity: 0.2;">

        <!-- App图标设置区 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标</label>
            <div id="char-phone-icon-settings-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 15px; text-align: center;">
                <!-- App图标设置将由JS动态生成在这里 -->
            </div>
        </div>

        <!-- ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼ -->
        <hr style="width: 100%; opacity: 0.2;">
        <!-- 桌面小组件设置区 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">桌面小组件</label>
            <!-- 小组件1: 左上角 -->
            <div class="form-group" style="margin-top: 15px;">
                <label>左上角小组件</label>
                <div class="avatar-upload">
                    <img id="char-phone-widget-preview-1" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0;">
                    <div style="display:flex; flex-direction: column; gap: 8px;">
                        <button class="form-button-secondary" id="upload-widget-1-btn" style="margin-top:0;">上传图片</button>
                        <button class="form-button-secondary" id="remove-widget-1-btn" style="margin-top:0; border-color: #ff3b30; color: #ff3b30;">移除图片</button>
                    </div>
                </div>
            </div>
            <!-- 小组件2: 右下角 -->
            <div class="form-group" style="margin-top: 15px;">
                <label>右下角小组件</label>
                <div class="avatar-upload">
                    <img id="char-phone-widget-preview-2" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0;">
                     <div style="display:flex; flex-direction: column; gap: 8px;">
                        <button class="form-button-secondary" id="upload-widget-2-btn" style="margin-top:0;">上传图片</button>
                        <button class="form-button-secondary" id="remove-widget-2-btn" style="margin-top:0; border-color: #ff3b30; color: #ff3b30;">移除图片</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到角色手机外观设置页面的 .form-container 内部末尾 ▼▼▼ -->
<hr style="width: 100%; opacity: 0.2; margin-top: 25px;">
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">外观预设</label>
    </div>
    <div class="form-group">
        <select id="char-phone-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 独占一行的应用按钮 -->
            <button id="apply-char-phone-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>
            
            <!-- 2x2 网格按钮 -->
            <button id="save-char-phone-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <button id="update-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
            <button id="export-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
            <button id="delete-char-phone-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>
            
            <input type="file" id="import-char-phone-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML代码结束 ▲▲▲ -->

    </div>
</div>
<!-- 隐藏的文件选择器，用于处理上传 -->
<input type="file" id="char-phone-wallpaper-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-icon-upload-input" accept="image/*" hidden>

<!-- ▼▼▼ 在这里粘贴下面这两行新的文件选择器 ▼▼▼ -->
<input type="file" id="char-phone-widget-1-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-widget-2-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-app-wallpaper-upload-input" accept="image/*" hidden>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        </div>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->


<!-- 加载动画遮罩层 (保持不变) -->
<div id="generation-overlay" class="modal" style="background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div style="text-align: center; color: white;">
        <div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <p>正在同步Ta的手机数据...</p>
        <p style="font-size: 12px; opacity: 0.7;">（这可能需要一些时间，并会消耗API额度）</p>
    </div>
</div>

<!-- ▲▲▲ “查角色手机”功能HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
        <span>选择联系人</span>
        <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- 联系人列表将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>群成员管理</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- 现有成员列表会在这里动态生成 -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">从好友列表添加</button>
        <button id="create-new-member-btn">创建群内新成员</button>
        <button id="ai-generate-members-btn">✨ AI 生成成员</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】微博用户人设与职业设置模态框 ▼▼▼ -->
<div id="weibo-user-settings-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>我的微博设定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>预设方案</label>
                <div class="bubble-preset-manager"> <!-- 复用现有样式 -->
                    <select id="weibo-user-preset-select" class="form-group select"></select>
                    <button id="manage-weibo-user-presets-btn" class="action-btn">管理</button>
                </div>
            </div>
            <div class="form-group">
                <label for="weibo-user-profession-modal-input">职业 (显示在昵称下方)</label>
                <input type="text" id="weibo-user-profession-modal-input" placeholder="例如：职业电竞选手、美妆博主">
            </div>
            <div class="form-group">
                <label for="weibo-user-persona-modal-input">隐藏人设 (仅供AI生成评论时参考)</label>
                <textarea id="weibo-user-persona-modal-input" rows="4" placeholder="例如：性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-weibo-user-settings-btn">取消</button>
            <button class="save" id="save-weibo-user-settings-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是微博手动操作的弹窗，粘贴到 </body> 前面 ▼▼▼ -->
<div id="weibo-action-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="weibo-action-modal-title">执行操作</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="weibo-action-actor-select">选择操作者 (Actor)</label>
                <select id="weibo-action-actor-select" class="form-group select"></select>
            </div>
            <div class="form-group">
                <label>选择操作类型</label>
<!-- ▼▼▼ 用这块新代码替换 ▼▼▼ -->
<div id="weibo-action-type-select" style="text-align: left;">
    <label><input type="radio" name="weibo_action_type" value="post" checked> 发布一条新微博</label>
    <label><input type="radio" name="weibo_action_type" value="comment_plaza"> 评论广场最新微博</label>
    <!-- ▼▼▼ 这是我们新增的选项 ▼▼▼ -->
    <label><input type="radio" name="weibo_action_type" value="comment_user"> 评论用户最新微博</label>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
            </div>
             <div class="form-group">
                <label for="weibo-action-prompt-input">关于... (可选, 简要提示)</label>
                <textarea id="weibo-action-prompt-input" rows="2" placeholder="例如：今天比赛赢了很开心 or 回应最近的热搜"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-weibo-action-btn">取消</button>
            <button class="save" id="confirm-weibo-action-btn">执行</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 第2步 第3处修改（新增HTML） ▼▼▼ -->
<!-- ▼▼▼ 用这块新代码替换旧的 #char-sticker-manager-screen ▼▼▼ -->
<div id="char-sticker-manager-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-sticker-manager">‹</span>
        <span id="sticker-manager-title">表情包管理</span>
        <!-- 【核心修改1】在这里添加“编辑/完成”按钮 -->
        <div class="header-actions">
            <span class="action-btn" id="edit-char-stickers-btn">编辑</span>
            <span class="action-btn" id="done-char-stickers-btn" style="display: none;">完成</span>
        </div>
    </div>
    <input type="file" id="char-sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <div class="modal-body" style="padding: 0; display: flex; flex-direction: column; flex-grow: 1;">
        <!-- 页签切换 -->
        <div class="frame-tabs">
            <div id="sticker-tab-exclusive" class="frame-tab active">专属表情</div>
            <div id="sticker-tab-common" class="frame-tab">通用表情</div>
        </div>

        <!-- 专属表情内容区 -->
        <div id="sticker-content-exclusive" class="frame-content active">
            <div class="sticker-panel-header" style="justify-content: flex-end;">
                 <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="add-exclusive-sticker-btn">批量添加</span>
                    <span class="panel-btn" id="upload-exclusive-sticker-btn">本地上传</span>
                </div>
            </div>
            <div id="exclusive-sticker-grid" class="sticker-grid"></div>
        </div>

        <!-- 通用表情内容区 -->
        <div id="sticker-content-common" class="frame-content">
             <div class="sticker-panel-header" style="justify-content: flex-end;">
                 <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="add-common-sticker-btn">批量添加</span>
                    <span class="panel-btn" id="upload-common-sticker-btn">本地上传</span>
                </div>
            </div>
            <div id="common-sticker-grid" class="sticker-grid"></div>
        </div>
    </div>
    <!-- 【核心修改2】在底部新增一个用于批量删除的操作栏 -->
    <div id="char-sticker-footer" style="display: none;">
        <button id="delete-selected-char-stickers-btn">删除已选 (0)</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">邀请你视频通话</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>拒绝</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>接听</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】这是BGM搜索结果的弹窗，请粘贴到body末尾 ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索结果</span>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-music-search-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
<!-- ▼▼▼ 用下面这【一整块】全新的代码，替换掉你文件中旧的 #video-call-screen 及其所有内容 ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 这个 screen 同时为两种模式服务 -->

    <!-- ======================================================= -->
    <!-- 模式一：全新的【可视化】视频通话界面 -->
    <!-- ======================================================= -->
    <div id="visual-call-interface" style="display: none;"> <!-- 默认隐藏 -->
        <!-- 1. 视频背景层 (大图和小图都在这里) -->
        <div class="video-background">
            <!-- 大图容器 -->
            <div id="video-main-view" class="video-container">
                <img src="" alt="主视频画面">
            </div>
            <!-- 小图容器 (画中画) -->
            <div id="video-pip-view" class="video-container pip">
                <img src="" alt="小窗视频画面">
            </div>
        </div>

        <!-- 2. 顶部状态栏 -->
        <div class="video-call-top-bar">
            <span id="visual-call-timer">00:00</span>
        </div>

        <!-- 3. 聊天气泡显示区域 -->
        <div id="video-call-messages-visual" class="video-call-main">
            <!-- 聊天气泡会由JS动态生成在这里 -->
        </div>
<!-- ▼▼▼ 用下面这【一整块】代码，替换掉 id="visual-call-interface" 里面那个旧的 video-call-controls 的 div ▼▼▼ -->
<div class="video-call-controls">
    <!-- 重-roll按钮 -->
    <button id="reroll-call-btn" class="control-btn reroll-btn" title="重新生成"></button>
    <!-- 【核心新增】发言按钮 -->
    <button id="user-speak-btn-visual" class="control-btn speak-btn" title="发言"></button>
    <!-- 切换镜头按钮 -->
    <button id="switch-camera-btn" class="control-btn switch-camera-btn" title="切换镜头"></button>
    <!-- 挂断按钮 -->
    <button id="hang-up-btn-visual" class="control-btn hangup-btn"></button>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    </div>

    <!-- ======================================================= -->
    <!-- 模式二：你原来的【纯文字】语音通话界面 (我们把它保留下来作为默认选项) -->
    <!-- ======================================================= -->
    <div id="text-call-interface" style="display: none;"> <!-- 默认隐藏 -->
        <div class="video-call-top-bar">
            <span id="call-timer">00:00</span>
        </div>
        <div class="video-call-avatar-area">
            <div id="participant-avatars-grid">
                <!-- JS会在这里动态生成头像 -->
            </div>
        </div>
        <div id="video-call-main" class="video-call-main">
            <!-- 对话内容会动态生成在这里 -->
        </div>
        <div class="video-call-controls">
            <!-- 【新增】为旧模式也加上重roll按钮 -->
            <button id="reroll-call-btn-text" class="control-btn reroll-btn" title="重新生成"></button>
            <button id="user-speak-btn" class="control-btn speak-btn"></button>
            <button id="hang-up-btn" class="control-btn hangup-btn"></button>
            <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">正在呼叫...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>取消</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
<div id="call-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="call-history-back-btn">‹</span>
        <span id="call-history-title">通话记录</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 通话记录卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是聊天记录搜索界面，请粘贴到 call-history-screen 的 div 之后 ▼▼▼ -->
<div id="chat-search-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="search-back-btn">‹</span>
        <span>查找聊天记录</span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div class="form-container" style="padding-bottom: 0;">
        <!-- 搜索条件输入区 -->
        <div class="form-group">
            <label for="keyword-search-input">关键词</label>
            <input type="text" id="keyword-search-input" placeholder="输入要查找的关键词...">
        </div>
        <div class="form-group">
            <label for="sender-search-select">人物</label>
            <select id="sender-search-select">
                <!-- 选项将由JS动态生成 -->
            </select>
        </div>
        <div class="form-group">
            <label for="date-search-input">日期</label>
            <input type="date" id="date-search-input">
        </div>
        <div class="form-group">
            <label for="type-search-select">消息类型</label>
            <select id="type-search-select">
                <option value="">全部类型</option>
                <option value="text">普通文本</option>
                <option value="voice_message">语音消息</option>
                <option value="user_photo">用户照片</option>
                <option value="ai_image">AI图片</option>
                <option value="sticker">表情包</option>
                <option value="location">位置</option>
                <option value="transfer">转账</option>
                <option value="red_packet">红包</option>
                <option value="share_link">分享链接</option>
                <option value="share_card">分享卡片</option>
                <option value="waimai_request">外卖请求</option>
                <option value="waimai_gift_from_char">外卖礼物</option>
                <option value="gift_notification">礼物通知</option>
                <option value="borrow_money_request">借钱请求</option>
                <option value="cart_share_request">购物车分享</option>
                <option value="poll">投票</option>
                <option value="tarot_reading">塔罗占卜</option>
                <option value="pat_message">拍一拍</option>
                <option value="lovers_space_invitation">情侣空间邀请</option>
                <option value="lovers_space_notification">情侣空间通知</option>
                <option value="ls_diary_notification">情侣日记</option>
                <option value="dating_summary_card">约会总结</option>
                <option value="repost_forum_post">论坛帖子</option>
            </select>
        </div>
        <button class="form-button" id="perform-search-btn">开始查找</button>
        
        <!-- 搜索结果显示区 -->
        <div id="chat-search-results-list" class="list-container" style="margin-top: 15px; padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->


            <!-- ▼▼▼ 请将下面这整块【全新的HTML代码】粘贴到这里 ▼▼▼ -->
            <div id="lock-screen" class="screen">
                <div id="lock-clock-container">
                    <div id="lock-main-time">12:00</div>
                    <div id="lock-main-date">星期一, 1月1日</div>
                </div>
                <div id="unlock-hint">向上轻扫以解锁</div>
            </div>

            <div id="password-modal-overlay" class="modal">
                <div class="password-modal-content">
                    <p>请输入密码</p>
                    <input type="password" id="password-input-field" maxlength="20">
                    <div class="password-actions">
                        <button id="password-cancel-btn">取消</button>
                        <button id="password-confirm-btn">进入</button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新HTML代码粘贴结束 ▲▲▲ -->

        </div>
    </div>
  <!-- ▼▼▼ 用这整块代码替换 ▼▼▼ -->
<div id="lovers-space-screen" class="screen">
    <!-- 头部 -->
    <div id="ls-header">
        <div class="ls-header-overlay"></div>
        <div class="ls-header-top-bar">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span id="ls-char-name">
                <span id="ls-user-nickname" style="cursor: pointer;" title="点击编辑你的昵称"></span>
                <span> & </span>
                <span id="ls-char-nickname" style="cursor: pointer;" title="点击编辑角色昵称"></span>
            </span>
            <div class="header-actions">
                <span class="action-btn" id="ls-settings-btn" title="空间设置">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </span>
                <span class="action-btn" id="ls-change-bg-btn" title="更换背景">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                </span>
                <span class="action-btn" id="ls-switch-char-btn">切换</span>
            </div>
        </div>
        <div class="ls-avatar-and-counter-wrapper">
            <div class="ls-header-avatars">
                <img id="ls-user-avatar" src="" style="cursor: pointer;" title="点击更换你的头像">
                <span class="heart-icon">❤</span>
                <img id="ls-char-avatar" src="" style="cursor: pointer;" title="点击更换角色头像">
            </div>
            <div id="ls-days-counter"></div>
        </div>
    </div>
<!-- ▼▼▼ 用这整块【SVG图标版】代码，替换你旧的 ls-tab-bar ▼▼▼ -->
<div id="ls-tab-bar">
    <div class="ls-tab-item active" data-view="ls-moments-view" title="说说">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-album-view" title="相册">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-letters-view" title="情书">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-shares-view" title="分享">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-questions-view" title="提问">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-diary-view" title="日记">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-pomodoro-view" title="番茄钟">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
    </div>
<div class="ls-tab-item" data-view="ls-activity-view" title="今日足迹">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
</div>
</div>
<!-- ▲▲▲ HTML替换结束 ▲▲▲ -->
    <!-- 内容显示区域 -->
    <div id="ls-content-area">
        <div id="ls-moments-view" class="ls-view active"><div id="ls-moments-list"></div><button id="ls-add-moment-btn" class="ls-fab-btn">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
    </svg>
</button>
</div>
        <div id="ls-album-view" class="ls-view">
    <div id="ls-album-list"></div>
    <button id="ls-add-album-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <div id="ls-letters-view" class="ls-view">
    <div id="ls-letters-list"></div>
    <button id="ls-add-letter-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <div id="ls-shares-view" class="ls-view"><div id="ls-shares-list"></div></div>
     <div id="ls-questions-view" class="ls-view">
    <div id="ls-questions-list"></div>
    <button id="ls-add-question-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <!-- ▼▼▼ 在 id="ls-questions-view" 的 div 之后，粘贴下面这整块新代码 ▼▼▼ -->
<div id="ls-diary-view" class="ls-view">
    <!-- 日历和心情罐子的内容将由JS动态生成在这里 -->
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
        <!-- ★★★ 这就是我们为番茄钟准备的全新界面 ★★★ -->
        <div id="ls-pomodoro-view" class="ls-view">
            <!-- 番茄钟主页，显示历史记录和开始按钮 -->
            <div id="ls-pomodoro-home">
                <div id="ls-pomodoro-start-btn-container">
                    <div id="ls-pomodoro-start-icon">＋</div>
                    <p>开启新的专注时光</p>
                </div>
                <div id="ls-pomodoro-history-list">
                    <!-- 历史记录会由JS生成在这里 -->
                </div>
            </div>
            <!-- 正在计时的界面，默认隐藏 -->
            <div id="ls-pomodoro-timer-active" style="display: none;">
                <div class="pomodoro-char-avatar-container">
                    <img id="pomodoro-char-avatar" src="">
                    <div id="pomodoro-char-log"></div>
                </div>
                <div class="pomodoro-timer-display">
                    <div id="pomodoro-current-task"></div>
                    <div id="pomodoro-time">25:00</div>
                </div>
                <button id="pomodoro-end-btn">结束专注</button>
            </div>
        </div>
<div id="ls-activity-view" class="ls-view">
    <!-- 今日足迹的内容将由JS动态生成在这里 -->
</div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>聊天设置</span></div><div class="modal-body">
    
    <!-- 角色真名输入框（仅单聊显示） -->
    <div class="form-group" id="real-name-group" style="display: none;">
        <label for="real-name-input">角色真名</label>
        <input type="text" id="real-name-input" placeholder="自动填入创建角色时的名字">
    </div>
    
    <div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input type="text" id="chat-name-input"></div>

    <!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
    <div class="form-group" id="assign-group-section" style="display: none;"> <!-- 默认隐藏，只对单聊显示 -->
        <label for="assign-group-select">好友分组</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- 分组选项将由JS动态生成 -->
            </select>
            <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理分组</button>
        </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>群头像</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>关联世界书 (可多选)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <!-- ▼▼▼ 【全新】记忆互通设置 (持久化链接版) ▼▼▼ -->
<div class="form-group" id="memory-link-group">
    <label>记忆互通 (选择要链接的聊天)</label>
    
    <!-- 复用世界书的多选框样式 -->
    <div class="custom-multiselect" id="memory-link-multiselect">
        <div class="select-box">
            <span class="selected-options-text">-- 点击选择 --</span>
            <span class="arrow-down">▼</span>
        </div>
        <div id="memory-link-checkboxes-container" class="checkboxes-container">
            <!-- 聊天选项将由JS动态生成在这里 -->
        </div>
    </div>
    
    <!-- 新增：记忆条数设置 -->
    <div class="form-group" style="margin-top: 10px;">
        <label for="link-memory-depth-input" style="font-weight: normal; color: var(--text-secondary); font-size: 13px;">互通记忆条数 (AI会看到对方最近的几条消息)</label>
        <input type="number" id="link-memory-depth-input" value="5" min="1" max="20" style="padding: 8px;">
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 <div id="chat-settings-modal"> 的 <div class="modal-body"> 内部，例如“聊天背景”设置的上方 ▼▼▼ -->

<hr style="opacity: 0.2; margin: 20px 0;">

<!-- 1. 线下模式总开关 -->
<div class="form-group" id="offline-mode-section">
    <label for="offline-mode-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            开启线下模式
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                开启后，AI将默认你们在线下见面，并以大段叙事的方式进行回应。
            </p>
        </span>
        <input type="checkbox" id="offline-mode-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>

<!-- 2. 线下模式的详细设置 (默认隐藏) -->
<div id="offline-mode-details" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px;">
    
    <!-- 2.1 预设管理 -->
    <div class="form-group">
        <label>线下模式预设</label>
        <div class="bubble-preset-manager">
            <select id="offline-preset-select" class="form-group select"></select>
            <button id="manage-offline-presets-btn" class="action-btn">管理</button>
        </div>
    </div>
    
    <!-- 2.2 提示词输入 -->
    <div class="form-group">
        <label for="offline-prompt-input">自定义提示词 (Prompt)</label>
        <textarea id="offline-prompt-input" rows="4" placeholder="例如：你正在一家安静的咖啡馆里和用户约会..."></textarea>
    </div>
    
    <!-- 2.3 文风输入 -->
    <div class="form-group">
        <label for="offline-style-input">自定义文风 (Style)</label>
        <textarea id="offline-style-input" rows="3" placeholder="例如：请使用第三人称，详细描写角色的动作、神态和心理活动..."></textarea>
    </div>

    <!-- 2.4 字数设置 -->
    <div class="form-group">
        <label for="offline-word-count-input">期望回复字数</label>
        <input type="number" id="offline-word-count-input" value="300" min="50" step="50">
    </div>

</div>
<!-- ▼▼▼ 【全新】聊天总结设置区域 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">

<div class="form-group">
    <label for="summary-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            开启聊天总结
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                开启后，AI会在对话达到一定长度时自动或手动进行总结，作为长期记忆。
            </p>
        </span>
        <input type="checkbox" id="summary-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>

<div id="summary-details-container" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px;">
    <div class="form-group">
        <label>总结模式</label>
        <div style="display: flex; gap: 20px;">
            <label><input type="radio" name="summary-mode" value="auto" checked> 自动总结</label>
            <label><input type="radio" name="summary-mode" value="manual"> 手动总结</label>
        </div>
    </div>
    <div class="form-group">
        <label for="summary-count-input">触发消息条数</label>
        <input type="number" id="summary-count-input" value="20" min="5">
    </div>
    <div class="form-group">
        <label for="summary-prompt-input">总结提示词 (Prompt)</label>
        <textarea id="summary-prompt-input" rows="4"></textarea>
    </div>
    <button id="view-summaries-btn" class="form-button form-button-secondary" style="margin-top: 10px;">查看和管理总结</button>
        <!-- ▼▼▼ 在这里粘贴下面的新按钮 ▼▼▼ -->
    <button id="manual-summary-btn" class="form-button form-button-secondary" style="margin-top: 10px;">立即手动总结</button>
    <!-- ▲▲▲ 新按钮粘贴结束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在 id="summary-details-container" 的 </div> 之后粘贴 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label style="margin-bottom: 0;">当前总聊天条数</label>
    <span id="total-message-count-display" style="color: var(--text-secondary); font-weight: 500;">--</span>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label style="margin-bottom: 0;">
        上下文Token数
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            (提示词 + 上下文记忆)
        </p>
    </label>
    <span id="context-token-count-display" style="color: var(--text-secondary); font-weight: 500;">--</span>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ TOKEN过大提示设置 ▼▼▼ -->
<div class="form-group" style="margin-top: 10px;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <label style="margin-bottom: 0;">TOKEN过大提示</label>
        <label class="switch-container" style="margin-bottom: 0;">
            <input type="checkbox" id="token-warning-enabled">
            <span class="switch-slider"></span>
        </label>
    </div>
    <div id="token-threshold-group" style="margin-top: 10px; display: none;">
        <label for="token-warning-threshold" style="font-size: 12px; color: #999;">
            提示阈值（留空则默认检测卡顿）
        </label>
        <input type="number" id="token-warning-threshold" placeholder="例如: 4000" min="0" style="margin-top: 5px;">
    </div>
</div>
<!-- ▲▲▲ TOKEN过大提示设置结束 ▲▲▲ -->

<!-- ▼▼▼ 删除指定范围聊天记录功能 ▼▼▼ -->
<div class="form-group" style="margin-top: 10px;">
    <label>删除指定范围的聊天记录</label>
    <div style="margin-top: 8px;">
        <input type="text" id="delete-messages-range" placeholder="例如: 2-10" 
               style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
        <button id="delete-messages-range-btn" class="form-button" 
                style="width: 100%; padding: 12px; margin-top: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer;">
            删除记录
        </button>
    </div>
    <div style="font-size: 12px; color: #999; margin-top: 8px;">
        输入范围格式如 "2-10" 表示删除第2条到第10条消息（包含第2条和第10条）
    </div>
</div>
<!-- ▲▲▲ 删除指定范围聊天记录功能结束 ▲▲▲ -->
<!-- ▲▲▲ 新增HTML代码粘贴结束 ▲▲▲ -->

            <div class="form-group" id="ai-persona-group"><label for="ai-persona">对方人设 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div>
              <!-- ▼▼▼ 第2步 第2处修改（新增HTML） ▼▼▼ -->
            <div class="form-group" id="char-sticker-group">
                <button id="manage-char-stickers-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">
                    管理角色表情包
                </button>
            </div>
            <!-- ▲▲▲ 新增结束 ▲▲▲ -->
            <!-- ▼▼▼ 在这里粘贴新代码 ▼▼▼ -->
<div class="form-group" id="npc-library-group">
    <button id="manage-npcs-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">管理NPC库</button>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" id="minimax-voice-id-group">
    <label for="minimax-voice-id-input">Minimax 语音ID</label>
    <input type="text" id="minimax-voice-id-input" placeholder="例如：male-01">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
 <!-- 【全新】微博人设与职业设置 -->
<div id="weibo-settings-for-user" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group">
        <label>我的微博设定</label>
        <div class="bubble-preset-manager">
            <select id="weibo-persona-preset-select" class="form-group select"></select>
            <button id="manage-weibo-presets-btn" class="action-btn">管理</button>
        </div>
    </div>
    <div class="form-group">
        <label for="weibo-user-profession-input">职业 (显示在昵称下方)</label>
        <input type="text" id="weibo-user-profession-input" placeholder="例如：职业电竞选手、美妆博主">
    </div>
    <div class="form-group">
        <label for="weibo-user-persona-input">隐藏人设 (仅供AI参考)</label>
        <textarea id="weibo-user-persona-input" rows="3" placeholder="例如：性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
    </div>
</div>
<!-- 【全新】微博设置结束 -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" id="weibo-profession-group">
    <label for="weibo-profession-input">微博职业</label>
    <input type="text" id="weibo-profession-input" placeholder="例如：职业电竞选手、美妆博主、演员...">
</div>
<div class="form-group" id="weibo-instruction-group">
    <label for="weibo-instruction-input">微博指令 (AI发微博/评论时将严格遵守)</label>
    <textarea id="weibo-instruction-input" rows="3" placeholder="例如：多发日常训练和比赛的内容，性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
 <!-- ▼▼▼ 把这一整块全新的代码，粘贴到“管理NPC库”按钮的 div 之后 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">
<div class="form-group">
    <label for="time-perception-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">启用实时时间感知</span>
        <input type="checkbox" id="time-perception-toggle" checked>
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<div id="custom-time-container" class="form-group" style="display: none;">
    <label for="custom-time-input">自定义时间</label>
    <input type="datetime-local" id="custom-time-input" style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<div class="form-group" id="ai-avatar-group"><label>对方头像</label>
  <!-- ▼▼▼ 把下面这【一整块】代码，粘贴到 id="ai-avatar-group" 的那个 div 之后 ▼▼▼ -->
<div class="form-group" id="video-call-settings-group">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label>视频通话界面设置</label>
    
    <!-- 1. 功能开关 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <span>启用可视化界面</span>
        <label class="toggle-switch">
            <input type="checkbox" id="visual-video-call-switch">
            <span class="slider"></span>
        </label>
    </div>

    <!-- 2. 图片上传区 (默认隐藏) -->
    <div id="video-call-image-uploads" style="display: none;">
        <div class="form-group">
            <label>对方的视频画面</label>
            <div class="avatar-upload">
                <img id="char-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                <button onclick="document.getElementById('char-video-image-input').click()">上传图片</button>
                <input type="file" id="char-video-image-input" accept="image/*" hidden>
            </div>
        </div>
        <div class="form-group">
            <label>我的视频画面</label>
            <div class="avatar-upload">
                <img id="user-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                <button onclick="document.getElementById('user-video-image-input').click()">上传图片</button>
                <input type="file" id="user-video-image-input" accept="image/*" hidden>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

  <div class="avatar-upload">
    <img id="ai-avatar-preview">
    <button onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button>
    <button class="change-frame-btn" data-type="ai">更换头像框</button>
    <button id="manage-ai-avatar-library-btn">管理头像库</button>
    <input type="file" id="ai-avatar-input" accept="image/*">
</div>
</div>
<!-- ▼▼▼ 用这整块【功能增强版】代码，替换旧的 couple-avatar-group ▼▼▼ -->
<div class="form-group" id="couple-avatar-group">
    <!-- 这是你原来的总开关 -->
    <label for="couple-avatar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">情侣头像开关</span>
        <input type="checkbox" id="couple-avatar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>

    <!-- 这是我们新增的、默认隐藏的详细设置区域 -->
    <div id="couple-avatar-details-container" style="display: none; margin-top: 15px; padding-left: 10px; border-left: 3px solid var(--accent-color);">
        
        <!-- 1. 识图功能开关 -->
        <div class="form-group">
            <label for="couple-avatar-recognition-toggle" class="toggle-switch-label">
                <span class="toggle-switch-text">
                    开启情侣头像识图
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        开启后，AI将“看到”并记住你们的头像内容。
                    </p>
                </span>
                <input type="checkbox" id="couple-avatar-recognition-toggle">
                <span class="toggle-switch-slider"></span>
            </label>
        </div>

        <!-- 2. 头像预览区域 -->
        <div class="form-group">
            <label>当前情侣头像预览</label>
            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px;">
                <div style="text-align: center;">
                    <img id="couple-avatar-preview-my" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover;">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">你的头像</p>
                </div>
                <span style="font-size: 24px; color: #ff8fab;">❤</span>
                <div style="text-align: center;">
                    <img id="couple-avatar-preview-ai" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover;">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">Ta的头像</p>
                </div>
            </div>
        </div>

        <!-- 3. 描述输入框 (保持不变) -->
        <div class="form-group">
             <label for="couple-avatar-description" style="font-size: 13px; color: var(--text-secondary);">情侣头像描述 (可选)</label>
             <input type="text" id="couple-avatar-description" placeholder="例如：一只小猫在看月亮">
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<div class="form-group" id="my-persona-group"><label for="my-persona">我的人设 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div><div class="form-group" id="my-avatar-group"><label>我的头像</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button>
<button class="change-frame-btn" data-type="my">更换头像框</button> <!-- ← 加回这一行 -->        <!-- ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼ -->
        <button id="manage-my-avatar-library-btn">管理头像库</button>
        <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<button id="open-persona-library-btn">预设</button><input type="file" id="my-avatar-input" accept="image/*"></div></div><div class="form-group" id="group-members-group"><label>群成员人设</label><div id="group-members-settings"></div>


    <!-- 【新增】管理成员按钮 -->
    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成员</button></div>
    <!-- ▼▼▼ 【全新】群聊后台活动设置 ▼▼▼ -->
<div class="form-group" id="group-background-activity-group" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label class="toggle-switch-label">
        <span class="toggle-switch-text">
            群聊后台实时活动
            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                警告：开启后会增加API调用和费用！
            </p>
        </span>
        <input type="checkbox" id="group-background-activity-switch">
        <span class="toggle-switch-slider"></span>
    </label>

    <div id="group-background-interval-settings" style="display: none; margin-top: 15px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <label for="group-background-interval-input" style="margin-bottom: 0;">
                活动间隔期 (秒)
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                    建议值 120-600。值越大，费用越低，但群内互动越慢。
                </p>
            </label>
            <input type="number" id="group-background-interval-input" min="60" value="120" style="width: 80px; text-align: center;">
        </div>
    </div>
</div>
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到 id="streak-settings-section" 的 div 上方 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">

<!-- === 攻略模式设置 === -->
<div class="form-group" id="conquest-mode-group">
    <label for="conquest-mode-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            攻略模式开关
            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                开启后，角色将进入攻略系统模式。警告：可能影响正常对话！
            </p>
        </span>
        <input type="checkbox" id="conquest-mode-toggle">
        <span class="toggle-switch-slider"></span>
    </label>

    <!-- 攻略模式详细设置区域 (默认隐藏) -->
    <div id="conquest-mode-details" style="display: none; margin-top: 15px; padding: 15px; border: 2px solid #ff6b6b; border-radius: 8px; background: rgba(255, 107, 107, 0.05);">
        
        <!-- 初始好感度设置 -->
        <div class="form-group" style="margin-bottom: 15px;">
            <label for="conquest-initial-affection">
                初始好感度
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                    设置角色对你的默认好感度（建议 0-100）
                </p>
            </label>
            <input type="number" id="conquest-initial-affection" min="0" max="100" value="50" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
        </div>

        <!-- 攻略成功好感度 -->
        <div class="form-group" style="margin-bottom: 15px;">
            <label for="conquest-success-affection">
                攻略成功目标好感度
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                    达到此好感度即为攻略成功（建议 80-100）
                </p>
            </label>
            <input type="number" id="conquest-success-affection" min="0" max="100" value="90" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
        </div>

        <!-- 实时好感度输入 -->
        <div class="form-group" style="margin-bottom: 15px;">
            <label for="conquest-current-affection">
                实时好感度
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                    当前角色对你的好感度（可随时调整）
                </p>
            </label>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="number" id="conquest-current-affection" min="0" max="100" value="50" style="flex: 0 0 80%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
                <button id="update-affection-btn" class="form-button form-button-secondary" style="flex: 0 0 20%; margin: 0; padding: 8px 4px; white-space: nowrap; font-size: 12px;">更新好感度</button>
            </div>
            <div id="affection-display" style="margin-top: 10px; padding: 10px; border-radius: 8px; background: var(--bg-secondary); text-align: center; font-size: 16px; font-weight: bold;">
                当前好感度: <span id="affection-value">50</span> / <span id="affection-target">90</span>
            </div>
        </div>

        <!-- 好感度变化提示 -->
        <div style="padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; border-radius: 4px; font-size: 13px; color: var(--text-secondary);">
            <strong>提示：</strong>角色会实时看到好感度的增减变化。增加好感度表示你对TA好感上升，减少则表示好感下降。角色会根据好感度变化调整自己的攻略策略。
        </div>
    </div>
</div>

<hr style="opacity: 0.2; margin: 20px 0;">

<!-- === 用户头像形状设置 === -->
<div class="form-group" id="my-avatar-shape-group">
    <label>我的头像形状</label>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
        <label><input type="radio" name="my-avatar-shape" value="default" checked> 默认</label>
        <label><input type="radio" name="my-avatar-shape" value="circle"> 圆形</label>
        <label><input type="radio" name="my-avatar-shape" value="custom"> 自定义</label>
    </div>
    <textarea id="my-avatar-shape-custom" rows="3" style="display: none;" placeholder="在此输入自定义 clip-path 代码..."></textarea>
    <!-- 预设管理 -->
    <div class="bubble-preset-manager" style="margin-top: 10px;">
        <select id="my-avatar-shape-presets-select" class="form-group select"></select>
        <button id="save-my-avatar-shape-preset-btn" class="action-btn">保存</button>
        <button id="delete-my-avatar-shape-preset-btn" class="action-btn">删除</button>
    </div>
</div>

<!-- === 角色头像形状设置 === -->
<div class="form-group" id="ai-avatar-shape-group">
    <label>对方头像形状</label>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
        <label><input type="radio" name="ai-avatar-shape" value="default" checked> 默认</label>
        <label><input type="radio" name="ai-avatar-shape" value="circle"> 圆形</label>
        <label><input type="radio" name="ai-avatar-shape" value="custom"> 自定义</label>
    </div>
    <textarea id="ai-avatar-shape-custom" rows="3" style="display: none;" placeholder="在此输入自定义 clip-path 代码..."></textarea>
    <!-- 预设管理 -->
    <div class="bubble-preset-manager" style="margin-top: 10px;">
        <select id="ai-avatar-shape-presets-select" class="form-group select"></select>
        <button id="save-ai-avatar-shape-preset-btn" class="action-btn">保存</button>
        <button id="delete-ai-avatar-shape-preset-btn" class="action-btn">删除</button>
    </div>
</div>

<!-- 通用操作按钮 -->
<div style="display: flex; gap: 10px;">
    <button id="apply-avatar-shape-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">应用形状</button>
    <button id="reset-avatar-shape-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">重置为默认</button>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 自定义输入框文案设置 ▼▼▼ -->
<div class="form-group" id="custom-placeholder-section">
    <label for="custom-placeholder-input">自定义输入框文案</label>
    <p style="font-size: 12px; color: #999; margin-top: 5px; margin-bottom: 10px;">
        修改聊天输入框的提示文字，留空则使用默认文案
    </p>
    <input type="text" id="custom-placeholder-input" placeholder="输入消息..." style="width: 100%; margin-bottom: 10px; padding: 12px; font-size: 15px;">
    <div style="display: flex; gap: 10px;">
        <button id="apply-placeholder-btn" class="form-button form-button-secondary" style="flex: 1; margin: 0; padding: 8px 16px; font-size: 14px;">应用</button>
        <button id="reset-placeholder-btn" class="form-button form-button-secondary" style="flex: 1; margin: 0; padding: 8px 16px; font-size: 14px;">重置</button>
    </div>
</div>
<!-- ▲▲▲ 自定义输入框文案设置结束 ▲▲▲ -->

<!-- ▼▼▼ 在 index.html 中，用这块代码替换旧的 id="streak-settings-section" 的 div ▼▼▼ -->
<div class="form-group" id="streak-settings-section">
    <!-- 火花总开关 (保持不变) -->
    <label for="streak-enabled-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            开启续火花
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                开启后，每天和Ta互动即可延续火花。
            </p>
        </span>
        <input type="checkbox" id="streak-enabled-toggle">
        <span class="toggle-switch-slider"></span>
    </label>

    <button id="open-intimacy-panel-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 10px; display: none;">
        🏅 
    </button>

    <!-- 火花详细设置 (保持不变) -->
    <div id="streak-details-container" style="display: none; margin-top: 15px; padding-left: 10px; border-left: 3px solid var(--accent-color);">
        <div class="form-group">
            <label for="streak-initial-days-input">初始火花天数</label>
            <input type="number" id="streak-initial-days-input" value="0" min="0">
        </div>
        <div class="form-group">
            <label for="streak-extinguish-threshold-select">火花熄灭规则</label>
            <select id="streak-extinguish-threshold-select">
                <option value="1">1天不联系则熄灭</option>
                <option value="3">3天不联系则熄灭</option>
                <option value="7">7天不联系则熄灭</option>
                <option value="-1">永不熄灭 🔥</option>
            </select>
        </div>
        <div class="form-group">
            <label for="streak-lit-icon-url">点亮的火花图片 URL (可选)</label>
            <input type="text" id="streak-lit-icon-url" placeholder="留空则默认显示🔥">
        </div>
        <div class="form-group">
            <label for="streak-extinguished-icon-url">熄灭的火花图片 URL (可选)</label>
            <input type="text" id="streak-extinguished-icon-url" placeholder="留空则默认显示🧊">
        </div>
        <div class="form-group">
            <label for="streak-font-color-picker">天数字体颜色 (可选)</label>
            <input type="color" id="streak-font-color-picker" value="#ff6f00" style="width: 100%; height: 40px;">
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->



<div class="form-group"><label for="max-memory">上下文记忆条数</label><input type="number" id="max-memory" value="10"></div><div class="form-group"><label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label><div class="theme-selector"><label><input type="radio" name="theme-select" value="default" id="theme-default"> 默认</label><label><input type="radio" name="theme-select" value="pink_blue"> 粉蓝</label><label><input type="radio" name="theme-select" value="blue_white"> 蓝白</label><label><input type="radio" name="theme-select" value="purple_yellow"> 紫黄</label><label><input type="radio" name="theme-select" value="black_white"> 黑白</label><label><input type="radio" name="theme-select" value="yellow_white"> 黄白</label><label><input type="radio" name="theme-select" value="red_black"> 红黑</label><label><input type="radio" name="theme-select" value="blue_yellow"> 蓝黄</label><label><input type="radio" name="theme-select" value="pink_yellow"> 粉黄</label><label><input type="radio" name="theme-select" value="pink_purple"> 粉紫</label><label><input type="radio" name="theme-select" value="gray_white"> 灰白</label><label><input type="radio" name="theme-select" value="blue_green"> 蓝绿</label><label><input type="radio" name="theme-select" value="pink_white"> 粉白</label><label><input type="radio" name="theme-select" value="pink_black"> 粉黑</label><label><input type="radio" name="theme-select" value="pink_green"> 粉绿</label><label><input type="radio" name="theme-select" value="green_black"> 绿黑</label></div></div>

<!-- ▼▼▼ 【全新】自定义气泡颜色选择器 ▼▼▼ -->
<div class="form-group">
    <label style="font-weight: 500; color: var(--text-secondary); margin-bottom: 10px; display: block;">自定义气泡颜色</label>
    
    <!-- USER气泡颜色设置 -->
    <div style="margin-bottom: 15px;">
        <label for="user-bubble-bg-color" style="display: block; margin-bottom: 5px; font-size: 14px;">我的消息气泡背景色</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="color" id="user-bubble-bg-color" value="#ffffff" style="width: 60px; height: 40px; padding: 0; border-radius: 8px; border: 1px solid #ddd; cursor: pointer;">
            <input type="text" id="user-bubble-bg-hex" value="#ffffff" placeholder="#ffffff" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-family: monospace; font-size: 13px;">
            <button type="button" id="reset-user-bubble-color" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; font-size: 12px;">重置</button>
        </div>
    </div>
    
    <div style="margin-bottom: 15px;">
        <label for="user-bubble-text-color" style="display: block; margin-bottom: 5px; font-size: 14px;">我的消息气泡文字颜色</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="color" id="user-bubble-text-color" value="#585858" style="width: 60px; height: 40px; padding: 0; border-radius: 8px; border: 1px solid #ddd; cursor: pointer;">
            <input type="text" id="user-bubble-text-hex" value="#585858" placeholder="#585858" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-family: monospace; font-size: 13px;">
            <button type="button" id="reset-user-text-color" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; font-size: 12px;">重置</button>
        </div>
    </div>
    
    <!-- CHAR气泡颜色设置 -->
    <div style="margin-bottom: 15px;">
        <label for="char-bubble-bg-color" style="display: block; margin-bottom: 5px; font-size: 14px;">角色消息气泡背景色</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="color" id="char-bubble-bg-color" value="#ffffff" style="width: 60px; height: 40px; padding: 0; border-radius: 8px; border: 1px solid #ddd; cursor: pointer;">
            <input type="text" id="char-bubble-bg-hex" value="#ffffff" placeholder="#ffffff" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-family: monospace; font-size: 13px;">
            <button type="button" id="reset-char-bubble-color" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; font-size: 12px;">重置</button>
        </div>
    </div>
    
    <div style="margin-bottom: 15px;">
        <label for="char-bubble-text-color" style="display: block; margin-bottom: 5px; font-size: 14px;">角色消息气泡文字颜色</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="color" id="char-bubble-text-color" value="#585858" style="width: 60px; height: 40px; padding: 0; border-radius: 8px; border: 1px solid #ddd; cursor: pointer;">
            <input type="text" id="char-bubble-text-hex" value="#585858" placeholder="#585858" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-family: monospace; font-size: 13px;">
            <button type="button" id="reset-char-text-color" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; font-size: 12px;">重置</button>
        </div>
    </div>
    
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button type="button" id="apply-custom-bubble-colors" class="form-button" style="flex: 1; margin: 0;">应用颜色</button>
        <button type="button" id="reset-all-bubble-colors" class="form-button-secondary" style="flex: 1; margin: 0;">全部重置</button>
    </div>
    
    <div style="margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 6px; font-size: 12px; color: #666;">
        <strong>提示：</strong>自定义颜色会覆盖预设主题的颜色。如需使用预设主题，请先重置自定义颜色。
    </div>
</div>
<!-- ▲▲▲ 自定义气泡颜色选择器结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新代码粘贴到"聊天气泡主题"的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】气泡样式预设选择器 (已添加导入导出功能) ▼▼▼ -->
<div class="form-group">
    <label>气泡样式预设</label>
    <div class="bubble-preset-manager">
        <select id="bubble-style-preset-select" class="form-group select"></select>
        <button id="manage-bubble-presets-btn" class="action-btn">管理</button>
    </div>
    <!-- ▼▼▼ 这是我们新加的导入和导出按钮 ▼▼▼ -->
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">导出气泡</button>
        <button id="import-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">导入气泡</button>
    </div>
    <input type="file" id="import-bubble-preset-input" accept=".json" style="display: none;">
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->


<!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label for="custom-css-input">
        自定义气泡样式 (CSS)
        <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
    </label>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
    <button id="adapt-css-btn" type="button" style="background: var(--accent-color); color: white; border: none; font-size: 13px; padding: 6px 15px; border-radius: 5px; cursor: pointer; margin-top: 8px; transition: all 0.3s ease;">
        ✨ 一键适配
    </button>
    <div id="adapt-css-tips" style="font-size: 11px; color: #999; margin-top: 5px; display: none;">
        正在智能适配当前设备尺寸...
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 页面动态效果设置区域 ▼▼▼ -->
<div class="form-group" style="border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; background: #fafafa;">
    <label style="font-weight: 600; color: var(--accent-color); font-size: 16px;">页面动态效果</label>
    
    <!-- 预设下雪效果 -->
    <div style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <label style="font-weight: 500; margin: 0;">预设下雪效果</label>
            <label class="toggle-switch" style="margin: 0;">
                <input type="checkbox" id="snow-effect-toggle">
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <div id="snow-effect-settings" style="display: none; margin-top: 10px; padding-left: 10px; border-left: 3px solid var(--accent-color);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                <label style="font-size: 13px; color: #666;">进入页面自动触发</label>
                <label class="toggle-switch" style="margin: 0;">
                    <input type="checkbox" id="snow-auto-trigger-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            
            <div style="margin-top: 10px;">
                <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">循环时长（秒）</label>
                <input type="number" id="snow-duration-input" min="1" max="3600" value="30" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
            </div>
            
            <div style="margin-top: 10px;">
                <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">
                    雪花下落速度（秒）
                    <span style="font-size: 11px; color: #999; margin-left: 5px;">范围: 1-10秒</span>
                </label>
                <input type="number" id="snow-speed-input" min="1" max="10" step="0.5" value="3" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                <div style="font-size: 11px; color: #999; margin-top: 3px;">数值越小，雪花下落越快</div>
            </div>
            
            <!-- 雪花颜色设置 -->
            <div style="margin-top: 15px;">
                <label style="font-size: 13px; color: #666; display: block; margin-bottom: 8px;">雪花颜色</label>
                
                <!-- 颜色选择器 -->
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <input type="color" id="snow-color-picker" value="#ffffff" style="width: 50px; height: 35px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <input type="text" id="snow-color-input" value="#ffffff" placeholder="#ffffff" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                </div>
                
                <!-- 预设颜色 -->
                <div style="margin-top: 10px;">
                    <label style="font-size: 12px; color: #999; display: block; margin-bottom: 6px;">预设颜色</label>
                    <div id="snow-color-presets" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px;">
                        <div class="snow-color-preset" data-color="#ffffff" style="width: 100%; aspect-ratio: 1; background: #ffffff; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="纯白"></div>
                        <div class="snow-color-preset" data-color="#e3f2fd" style="width: 100%; aspect-ratio: 1; background: #e3f2fd; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="冰蓝"></div>
                        <div class="snow-color-preset" data-color="#fce4ec" style="width: 100%; aspect-ratio: 1; background: #fce4ec; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="粉雪"></div>
                        <div class="snow-color-preset" data-color="#fff9c4" style="width: 100%; aspect-ratio: 1; background: #fff9c4; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="金黄"></div>
                        <div class="snow-color-preset" data-color="#e8f5e9" style="width: 100%; aspect-ratio: 1; background: #e8f5e9; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="薄荷"></div>
                        <div class="snow-color-preset" data-color="#f3e5f5" style="width: 100%; aspect-ratio: 1; background: #f3e5f5; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="淡紫"></div>
                        <div class="snow-color-preset" data-color="#b3e5fc" style="width: 100%; aspect-ratio: 1; background: #b3e5fc; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="天蓝"></div>
                        <div class="snow-color-preset" data-color="#ffccbc" style="width: 100%; aspect-ratio: 1; background: #ffccbc; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="桃粉"></div>
                        <div class="snow-color-preset" data-color="#c8e6c9" style="width: 100%; aspect-ratio: 1; background: #c8e6c9; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="嫩绿"></div>
                        <div class="snow-color-preset" data-color="#d1c4e9" style="width: 100%; aspect-ratio: 1; background: #d1c4e9; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="薰衣草"></div>
                        <div class="snow-color-preset" data-color="#ffe0b2" style="width: 100%; aspect-ratio: 1; background: #ffe0b2; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="杏黄"></div>
                        <div class="snow-color-preset" data-color="#f8bbd0" style="width: 100%; aspect-ratio: 1; background: #f8bbd0; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" title="樱花"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 自定义动态效果 -->
    <div style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px;">
        <label style="font-weight: 500; display: block; margin-bottom: 10px;">自定义动态效果</label>
        
        <textarea id="custom-effect-input" placeholder="输入自定义动态效果代码..." style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
        
        <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px;">
            <label style="font-size: 13px; color: #666;">进入页面自动触发</label>
            <label class="toggle-switch" style="margin: 0;">
                <input type="checkbox" id="custom-auto-trigger-toggle">
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <div style="margin-top: 10px;">
            <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">循环时长（秒）</label>
            <input type="number" id="custom-duration-input" min="1" max="3600" value="30" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        
        <div style="margin-top: 10px;">
            <label style="font-size: 13px; color: #666; display: block; margin-bottom: 5px;">
                效果速度（秒）
                <span style="font-size: 11px; color: #999; margin-left: 5px;">范围: 1-10秒</span>
            </label>
            <input type="number" id="custom-speed-input" min="1" max="10" step="0.5" value="3" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
            <div style="font-size: 11px; color: #999; margin-top: 3px;">可在自定义代码中使用 speed 变量</div>
        </div>
    </div>
    
    <!-- 动态预设管理 -->
    <div style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px;">
        <label style="font-weight: 500; display: block; margin-bottom: 10px;">动态预设</label>
        
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
            <select id="effect-preset-select" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">选择预设...</option>
            </select>
            <button type="button" id="save-effect-preset-btn" class="form-button-secondary" style="width: auto; padding: 6px 15px; margin: 0;">保存</button>
            <button type="button" id="delete-effect-preset-btn" class="form-button-secondary" style="width: auto; padding: 6px 15px; margin: 0; background: #ff3b30; color: white; border-color: #ff3b30;">删除</button>
        </div>
        
        <!-- 删除模式 -->
        <div id="delete-preset-mode" style="display: none; padding: 10px; background: #fff3cd; border-radius: 4px; border: 1px solid #ffc107;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                <label style="font-size: 13px; font-weight: 500;">选择要删除的预设</label>
                <label style="font-size: 12px; cursor: pointer; color: var(--accent-color);">
                    <input type="checkbox" id="select-all-presets-checkbox" style="width: auto; margin-right: 5px;">
                    全选
                </label>
            </div>
            <div id="preset-delete-list" style="max-height: 150px; overflow-y: auto; margin-bottom: 8px;">
                <!-- 动态生成复选框列表 -->
            </div>
            <div style="display: flex; gap: 8px;">
                <button type="button" id="confirm-delete-presets-btn" class="form-button-secondary" style="flex: 1; margin: 0; background: #dc3545; color: white; border-color: #dc3545;">确认删除</button>
                <button type="button" id="cancel-delete-presets-btn" class="form-button-secondary" style="flex: 1; margin: 0;">取消</button>
            </div>
        </div>
    </div>
    
    <!-- 操作按钮 -->
    <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button type="button" id="apply-page-effect-btn" class="form-button" style="flex: 1; margin: 0;">应用页面动态效果</button>
        <button type="button" id="reset-page-effect-btn" class="form-button-secondary" style="flex: 1; margin: 0;">重置</button>
        <button type="button" id="preview-page-effect-btn" class="form-button-secondary" style="flex: 1; margin: 0; background: var(--accent-color); color: white; border-color: var(--accent-color);">预览</button>
    </div>
</div>
<!-- ▲▲▲ 页面动态效果设置区域结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label>实时预览</label>
    <div id="settings-preview-area">
        <!-- JS会在这里生成预览内容 -->
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 记忆库功能 ▼▼▼ -->
<div class="form-group">
    <label>记忆库</label>
    <div id="memory-bank-container">
        <div class="memory-bank-header">
            <button class="form-button form-button-secondary" id="save-memory-btn">💾 保存当前状态</button>
            <button class="form-button form-button-secondary" id="delete-memory-btn" style="background-color: #ff3b30; color: white;">🗑️ 删除选中</button>
        </div>
        <div id="memory-bank-list">
            <!-- 记忆卡片会在这里动态生成 -->
            <div class="memory-bank-empty">
                <p>暂无保存的记忆</p>
                <p style="font-size: 12px; color: #999; margin-top: 5px;">点击"保存当前状态"来保存当前对话的所有内容</p>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 记忆库功能结束 ▲▲▲ -->

            <div class="form-group">
                <label>聊天背景</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上传背景图</button>
                    <button type="button" id="remove-bg-btn">移除背景</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到你刚刚删除代码的位置 ▼▼▼ -->

    <!-- NAI出图设置（单聊显示） -->
    <div class="form-group" id="nai-character-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <label style="font-weight: 600; color: var(--accent-color);">NAI出图设置</label>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            为当前角色配置专属的NovelAI出图提示词
        </p>
        
        <div style="margin-top: 15px;">
            <label style="font-weight: 500; color: #333;">提示词来源</label>
            <div style="display: flex; gap: 15px; margin-top: 10px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="nai-prompt-source" value="system" checked style="width: auto; margin-right: 8px;">
                    <span>使用系统设置</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="nai-prompt-source" value="character" style="width: auto; margin-right: 8px;">
                    <span>使用当前角色配置</span>
                </label>
            </div>
        </div>
        
        <button id="character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px;">配置角色专属提示词</button>
    </div>

    <div class="form-group" id="group-nai-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <label style="font-weight: 600; color: var(--accent-color);">NAI出图设置</label>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            为当前角色配置专属的NovelAI出图提示词
        </p>
        
        <div style="margin-top: 15px;">
            <label style="font-weight: 500; color: #333;">提示词来源</label>
            <div style="display: flex; gap: 15px; margin-top: 10px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="group-nai-prompt-source" value="system" checked style="width: auto; margin-right: 8px;">
                    <span>使用系统设置</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="group-nai-prompt-source" value="character" style="width: auto; margin-right: 8px;">
                    <span>使用当前角色配置</span>
                </label>
            </div>
        </div>
        
        <button id="group-character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px;">配置角色专属提示词</button>
    </div>

<!-- 记录管理区 -->
<div class="form-group" style="display: flex; gap: 10px;">
    <button class="form-button form-button-secondary" id="import-chat-history-btn" style="flex: 1; margin: 0;">导入聊天记录</button>
    <button class="form-button form-button-secondary" id="export-chat-history-btn" style="flex: 1; margin: 0;">导出聊天记录</button>
</div>
<input type="file" id="import-chat-history-input" accept="application/json" style="display: none;">
<button class="form-button form-button-secondary" id="chat-memory-stats-btn">我们的聊天记忆</button>
<button class="form-button form-button-secondary" id="search-chat-btn">查找聊天记录</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button>
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑对方</button>

<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

</div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>我的人设库</span><button id="add-persona-preset-btn" class="action-button">添加</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div></div></div>
    
<!-- ▼▼▼ 从这里开始替换 ▼▼▼ -->
<div id="persona-editor-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span id="persona-editor-title">添加人设预设</span>
        </div>
        <div class="modal-body">
            <!-- 【新增】NPC名字输入框 -->
            <div class="form-group" id="npc-editor-name-group">
                <label for="npc-editor-name-input">NPC 名字</label>
                <input type="text" id="npc-editor-name-input">
            </div>
            <div class="form-group">
                <label>头像</label>
                <div class="avatar-upload">
                    <img id="preset-avatar-preview">
                    <button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button>
                    <!-- 【新增】给这个按钮一个ID，方便我们控制它 -->
                    <button id="persona-editor-change-frame-btn" class="change-frame-btn" data-type="member">更换头像框</button>
                    <input type="file" id="preset-avatar-input" accept="image/*">
                </div>
            </div>
            <div class="form-group">
                <label for="preset-persona-input">人设</label>
                <textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-persona-editor-btn">取消</button>
            <button class="save" id="save-persona-preset-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换到这里结束 ▲▲▲ -->



    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>编辑群成员</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
<!-- ▼▼▼ 用下面这整块代码，替换旧的头像上传区域 ▼▼▼ -->
<div class="form-group">
    <label>头像</label>
    <div class="avatar-upload">
        <img id="member-avatar-preview">
        <button onclick="document.getElementById('member-avatar-input').click()">上传头像</button>
        <!-- ★★★ 我们在这里新增了一个更换头像框的按钮 ★★★ -->
        <button id="member-editor-change-frame-btn" class="change-frame-btn">更换头像框</button>
        <input type="file" id="member-avatar-input" accept="image/*" hidden>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>


    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999999999999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

    <audio id="audio-player" style="display:none;"></audio>
<!-- ▼▼▼ 在这里添加下面这行新的音频元素 ▼▼▼ -->
<audio id="tts-audio-player" style="display:none;"></audio>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->
<audio id="ringtone-player" loop></audio>
<audio id="notification-sound-player" preload="auto"></audio>
<!-- ▼▼▼ 用下面这【一整块完整代码】替换掉你旧的 id="create-post-modal" 的整个 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span id="create-post-modal-title">发布动态</span> <!-- 使用ID方便JS修改标题 -->
        </div>
        <div class="modal-body">
            <!-- 公开文字输入区 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="分享新鲜事..."></textarea>
            </div>

            <!-- === 【新增】模式切换开关 === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

            <!-- === 【新增】图片模式区域 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="图片预览">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                        <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <!-- 这个是给AI看的图片描述，在微博模式下我们会用JS隐藏它 -->
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>图片描述 (必填，给AI看)</label>
                    <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                </div>
            </div>

            <!-- === 【新增】文字图模式区域 === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                </div>
            </div>

<!-- ▼▼▼ 在这里粘贴下面这块新代码 ▼▼▼ -->
<div class="form-group" id="post-visibility-group">
    <label>可见范围</label>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
        <label><input type="radio" name="visibility" value="all" checked> 所有人可见</label>
        <label><input type="radio" name="visibility" value="groups"> 仅分组可见</label>
    </div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background-color: #f0f2f5; padding: 10px; border-radius: 8px;">
        <!-- 分组的多选框会由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
            <!-- 这个是动态功能的评论开关，在微博模式下我们会用JS隐藏它 -->
            <div class="form-group" id="post-comments-toggle-group" style="margin-top: 15px;">
                <label for="post-comments-toggle" class="toggle-switch-label">
                    <span class="toggle-switch-text">允许角色看见评论区</span>
                    <input type="checkbox" id="post-comments-toggle" checked>
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">取消</button>
            <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ NovelAI 生成设置弹窗 ▼▼▼ -->
<div id="novelai-settings-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto;">
        <div class="modal-header">
            <span>NovelAI 生成设置</span>
            <span class="close" id="close-novelai-settings" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
        </div>
        <div class="modal-body" style="padding: 20px;">
            <div class="form-group">
                <label style="color: #333;">图像尺寸（oplus可无限出小图）</label>
                <select id="nai-resolution" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <optgroup label="小">
                        <option value="512x768">纵向 (512x768)</option>
                        <option value="768x512">横向 (768x512)</option>
                        <option value="640x640">正方形 (640x640)</option>
                    </optgroup>
                    <optgroup label="正常">
                        <option value="832x1216">竖图 (832x1216)</option>
                        <option value="1216x832">横图 (1216x832)</option>
                        <option value="1024x1024" selected>方图 (1024x1024)</option>
                    </optgroup>
                    <optgroup label="壁纸">
                        <option value="1088x1920">纵向 (1088x1920)</option>
                        <option value="1920x1088">风景 (1920x1088)</option>
                    </optgroup>
                </select>
                <small style="color: #666;">建议使用官方支持的标准尺寸以获得最佳效果</small>
            </div>

            <div class="form-group">
                <label style="color: #333;">采样步数 (Steps)</label>
                <input type="number" id="nai-steps" value="28" min="1" max="50" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                <small style="color: #666;">推荐值: 28 (值越高质量越好但耗时越长)</small>
            </div>

            <div class="form-group">
                <label style="color: #333;">提示词相关性 (CFG Scale)</label>
                <input type="number" id="nai-cfg-scale" value="5" min="1" max="20" step="0.5" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                <small style="color: #666;">推荐值: 5 (控制图像与提示词的相关程度)</small>
            </div>

            <div class="form-group">
                <label style="color: #333;">采样器 (Sampler)</label>
                <select id="nai-sampler" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <option value="k_euler">Euler</option>
                    <option value="k_euler_ancestral" selected>Euler Ancestral</option>
                    <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                    <option value="k_dpmpp_2m">DPM++ 2M</option>
                    <option value="k_dpmpp_sde">DPM++ SDE</option>
                    <option value="ddim">DDIM</option>
                </select>
            </div>

            <div class="form-group">
                <label style="color: #333;">随机种子 (Seed)</label>
                <input type="number" id="nai-seed" value="-1" min="-1" max="9999999999" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                <small style="color: #666;">-1 表示随机，固定种子可复现相同图像</small>
            </div>

            <div class="form-group">
                <label style="color: #333;">负面提示词预设 (UC Preset)</label>
                <select id="nai-uc-preset" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <option value="0">Preset 0 - Heavy</option>
                    <option value="1" selected>Preset 1 - Light</option>
                    <option value="2">Preset 2 - Human Focus</option>
                    <option value="3">Preset 3 - None</option>
                </select>
            </div>

            <div class="form-group">
                <label style="color: #333;">质量标签</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="nai-quality-toggle" checked style="width: auto;">
                    <span style="color: #666; font-size: 14px;">自动添加质量提升标签</span>
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">SMEA (提升细节)</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="nai-smea" checked style="width: auto;">
                    <span style="color: #666; font-size: 14px;">启用SMEA增强</span>
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">SMEA DYN (动态优化)</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="nai-smea-dyn" style="width: auto;">
                    <span style="color: #666; font-size: 14px;">启用动态SMEA</span>
                </div>
            </div>

            <div class="form-group">
                <label style="color: #333;">默认正面提示词</label>
                <textarea id="nai-default-positive" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="masterpiece, best quality, 1girl, beautiful...">masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style</textarea>
                <small style="color: #666;">此提示词将在生成时自动使用（如果测试弹窗中未填写）</small>
            </div>

            <div class="form-group">
                <label style="color: #333;">默认负面提示词</label>
                <textarea id="nai-default-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="lowres, bad anatomy, bad hands, text, error...">lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry</textarea>
            </div>

            <div class="form-group" style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px;">
                <label style="color: #333;">🌐 CORS 代理设置</label>
                <select id="nai-cors-proxy" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <option value="">❌ 直连（无代理）</option>
                    <option value="https://corsproxy.io/?" selected>✅ corsproxy.io（推荐）</option>
                    <option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
                    <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere（需激活）</option>
                    <option value="custom">🔧 自定义代理</option>
                </select>
                <small style="color: #e74c3c; display: block; margin-top: 8px;">
                    ⚠️ 本地运行会遇到CORS跨域问题，需使用代理。推荐使用 corsproxy.io
                </small>
            </div>

            <div id="nai-custom-proxy-group" class="form-group" style="display: none;">
                <label style="color: #333;">自定义代理地址</label>
                <input type="text" id="nai-custom-proxy-url" placeholder="https://your-proxy.com/?" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                <small style="color: #666;">代理URL应以 / 或 ? 结尾，例如：https://proxy.com/?</small>
            </div>
        </div>
        <div class="modal-footer">
            <button id="reset-nai-settings-btn" class="form-button form-button-secondary" style="margin-right: 10px;">恢复默认</button>
            <button id="save-nai-settings-btn" class="form-button form-button-secondary">保存设置</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ NovelAI 生成设置弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ NovelAI 测试生成弹窗 ▼▼▼ -->
<div id="novelai-test-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <span>🖼️ NovelAI 测试生成</span>
            <span class="close" id="close-novelai-test" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
        </div>
        <div class="modal-body" style="padding: 20px;">
            <div class="form-group">
                <label style="color: #333;">正面提示词（此处提示词仅用于该弹窗测试）</label>
                <textarea id="nai-test-prompt" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="1girl, solo, long hair, blue eyes, smile...">1girl, solo, long hair, blue eyes, smile, outdoors, cherry blossoms, spring</textarea>
            </div>

            <div class="form-group">
                <label style="color: #333;">负面提示词（可选，留空使用默认）</label>
                <textarea id="nai-test-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="留空将使用设置中的默认负面提示词"></textarea>
            </div>

            <div style="text-align: center; margin: 20px 0;">
                <button id="nai-generate-btn" style="background-color: #007bff; color: white; border: none; padding: 12px 30px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold;">
                    生成图像
                </button>
            </div>

            <div id="nai-test-status" style="text-align: center; color: #666; margin: 15px 0; display: none;">
                正在生成中，请稍候...
            </div>

            <div id="nai-test-result" style="display: none; margin-top: 20px;">
                <div style="font-weight: bold; color: #333; margin-bottom: 10px;">生成结果：</div>
                <div style="text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                    <img id="nai-result-image" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <button id="nai-download-btn" class="form-button-secondary" style="margin: 0;">下载图像</button>
                </div>
            </div>

            <div id="nai-test-error" style="display: none; margin-top: 15px; padding: 12px; background: #f8d7da; color: #721c24; border-radius: 6px; border: 1px solid #f5c6cb;"></div>
        </div>
        <div class="modal-footer">
            <button id="close-nai-test-btn" class="form-button">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ NovelAI 测试生成弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 角色专属NAI出图设置弹窗 ▼▼▼ -->
<div id="character-nai-prompts-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <span>角色专属NAI提示词配置</span>
            <span class="close" id="close-character-nai-prompts" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
        </div>
        <div class="modal-body">
            <p style="font-size: 13px; color: #666; margin-bottom: 20px; background-color: #f0f8ff; padding: 12px; border-radius: 6px; border-left: 3px solid #007bff;">
                💡 这里配置的提示词仅用于当前角色的NAI出图，不影响其他角色或系统设置
            </p>
            
            <div class="form-group">
                <label for="character-nai-positive" style="color: #333; font-weight: 600;">
                    正面提示词 (Positive Prompt)
                </label>
                <textarea id="character-nai-positive" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px;" placeholder="例如: masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style"></textarea>
                <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
                    描述你希望生成的图像风格，可填入画师串
                </small>
            </div>

            <div class="form-group">
                <label for="character-nai-negative" style="color: #333; font-weight: 600;">
                    负面提示词 (Negative Prompt)
                </label>
                <textarea id="character-nai-negative" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px;" placeholder="例如: lowres, bad anatomy, bad hands, text, error, missing fingers"></textarea>
                <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
                    描述你希望避免的元素
                </small>
            </div>
        </div>
        <div class="modal-footer">
            <button id="reset-character-nai-prompts-btn" class="form-button form-button-secondary" style="margin-right: 10px;">清空配置</button>
            <button id="save-character-nai-prompts-btn" class="form-button form-button-secondary">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 角色专属NAI出图设置弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理好友分组</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分组</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
                    <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分组列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="message-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <!-- 新的操作按钮 -->
            <button id="edit-message-btn">编辑消息</button>
            <button id="copy-message-btn">复制文本</button>
            <button id="recall-message-btn">撤回</button>
<button id="quote-message-btn">引用</button>
            <button id="select-message-btn">进入多选</button>
            <!-- 取消按钮 -->
            <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">编辑动态</button>
            <button id="copy-post-btn">复制内容</button>           
            <button id="cancel-post-action-btn">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 编辑器容器，JS会在这里动态生成文本框 -->
            <div id="message-editor-container"></div>
            <!-- 添加新消息的按钮 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 添加下一条消息
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
            <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品信息</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">代付金额 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">取消</button>
            <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新建约定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">约定标题</label>
                <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">约定日期与时间</label>
                <input type="datetime-local" id="countdown-date-input"style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">取消</button>
            <button class="save" id="confirm-create-countdown-btn">保存约定</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0;">
<!-- 1. 页签切换 -->
<div class="frame-tabs">
    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
</div>

            <!-- 2. 拼手气红包内容区 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>总金额 (元)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>红包个数</label>
                    <input type="number" id="rp-group-count" placeholder="填写红包个数">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
            </div>

            <!-- 3. 专属红包内容区 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>发送给</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>金额 (元)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">的红包</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">元</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 领取详情将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发起投票</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">投票问题</label>
                <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
            </div>
            <div class="form-group">
                <label>投票选项 (至少2项)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 投票选项将由JS动态生成在这里 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加选项</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">取消</button>
            <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】聊天记忆统计模态框 ▼▼▼ -->
<div id="chat-memory-stats-modal" class="modal">
    <div class="modal-content" style="width: 350px; height: auto; max-height: 80vh; overflow-y: auto;">
        <div class="modal-header">
            <span>我们的聊天记忆 💕</span>
        </div>
        <div class="modal-body" style="padding: 20px;">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 20px; color: white; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">
                <div style="text-align: center; font-size: 14px; margin-bottom: 15px; opacity: 0.9;">我们的故事</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 28px; font-weight: bold;" id="stats-message-count">0</div>
                        <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">条消息</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 28px; font-weight: bold;" id="stats-call-count">0</div>
                        <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">次通话</div>
                    </div>
                </div>
            </div>
            
            <div style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: bold; color: #333; margin-bottom: 12px; display: flex; align-items: center;">
                    <span style="font-size: 16px; margin-right: 8px;">💰</span>转账记录
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #666; font-size: 13px;">Ta 转给我：</span>
                    <span style="color: #ff6b6b; font-weight: bold; font-size: 14px;" id="stats-ai-transfer">¥0.00</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #666; font-size: 13px;">我转给 Ta：</span>
                    <span style="color: #51cf66; font-weight: bold; font-size: 14px;" id="stats-user-transfer">¥0.00</span>
                </div>
            </div>
            
            <div style="background: #fff3cd; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: bold; color: #856404; margin-bottom: 10px; display: flex; align-items: center;">
                    <span style="font-size: 16px; margin-right: 8px;">💬</span>Ta 最常说的话
                </div>
                <div id="stats-ai-common-words" style="color: #666; font-size: 13px; line-height: 1.6; font-style: italic;">
                    加载中...
                </div>
            </div>
            
            <div style="background: #d1ecf1; border-radius: 10px; padding: 15px;">
                <div style="font-size: 13px; font-weight: bold; color: #0c5460; margin-bottom: 10px; display: flex; align-items: center;">
                    <span style="font-size: 16px; margin-right: 8px;">💭</span>我最常说的话
                </div>
                <div id="stats-user-common-words" style="color: #666; font-size: 13px; line-height: 1.6; font-style: italic;">
                    加载中...
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-chat-memory-stats-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="ai-avatar-library-title">对方的头像库</span>
            <button id="add-ai-avatar-btn" class="action-button">添加</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 头像库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>分享链接</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">标题</label>
                <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
            </div>
            <div class="form-group">
                <label for="link-description-input">摘要 (可选)</label>
                <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">来源名称 (可选)</label>
                <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
            </div>
            <div class="form-group">
                <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">取消</button>
            <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
<div id="transfer-actions-modal" class="modal">
    <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
            <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
        </div>
        <div class="transfer-actions-footer">
            <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
            <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
<div id="call-transcript-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="transcript-modal-title">通话详情</span>
        </div>
        <div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5;">
            <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">删除记录</button>
            <button class="save" id="close-transcript-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
<div id="share-target-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
<div class="modal-header">
    <span id="share-target-modal-title">分享到...</span>
</div>
        <div class="modal-body" id="share-target-list" style="padding: 0;">
            <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-target-btn">取消</button>
            <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
<div id="shared-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
            <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】世界书分类管理模态框 ▼▼▼ -->
<div id="world-book-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理世界书分类</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分类</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-category-name-input" placeholder="输入分类名..." style="flex-grow: 1;">
                    <button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分类列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】角色专属NPC库管理界面 ▼▼▼ -->
<div id="npc-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-npc-management">‹</span>
        <span id="npc-management-title">NPC 库管理</span>
        <span class="action-btn" id="add-new-npc-btn">+</span>
    </div>
    <div class="list-container" id="npc-management-list">
        <!-- NPC列表将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】在这里粘贴所有论坛相关的HTML代码 ▼▼▼ -->

<!-- 1. 论坛主屏幕 (显示所有小组) -->
<div id="forum-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>圈子</span>
        <div class="header-actions">
                  <!-- ▼▼▼ 在这里添加筛选图标 ▼▼▼ -->
        <span class="action-btn filter-btn" id="forum-filter-btn" title="筛选">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
        </span>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <span class="action-btn" id="create-group-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
    <div id="forum-group-list" class="list-container" style="padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-content: start;">
        <!-- 小组列表将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▼▼▼ 用这整块代码替换旧的 id="group-screen" ▼▼▼ -->
<div id="group-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-to-forum-list">‹</span>
        <span id="group-screen-title">小组名称</span>
        <div class="header-actions">
                  <!-- ▼▼▼ 在这里添加筛选图标 ▼▼▼ -->
        <span class="action-btn filter-btn" id="group-filter-btn" title="筛选">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
        </span>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <!-- 【核心修改】我们在这里新增了一个通用的“生成内容”按钮 -->
            <span class="action-btn" id="generate-group-content-btn" title="生成内容">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            <span class="action-btn" id="create-forum-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
<!-- ▼▼▼ 用这块新代码替换 ▼▼▼ -->
<div id="fanfic-preference-bar" style="display: none; padding: 10px 15px; background-color: #f0f2f5; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
    <div class="form-group" style="margin: 0;">
        <label style="font-size: 14px; margin-bottom: 5px;">选择CP偏好</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="fanfic-char1-select" style="flex: 1;"></select>
            <span>&</span>
            <select id="fanfic-char2-select" style="flex: 1;"></select>
            <button id="trigger-fanfic-generation-btn" class="form-button" style="margin: 0; padding: 10px 15px; width: auto;">生成</button>
        </div>
    </div>
    <!-- 这是我们新加的世界观输入框 -->
    <div class="form-group" style="margin-top: 10px; margin-bottom: 0;">
        <label for="fanfic-worldview-input" style="font-size: 14px; margin-bottom: 5px;">世界观偏好 (可选)</label>
        <input type="text" id="fanfic-worldview-input" placeholder="例如：ABO、哨向、现代大学AU...">
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <div id="group-post-list" class="list-container" style="padding-top: 0;">
        <!-- 帖子列表将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- 3. 单个帖子页面 (显示帖子内容和评论) -->
<div id="post-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-to-group-screen">‹</span>
        <span>帖子详情</span>
        <div class="header-actions">
            <span class="action-btn" id="repost-to-chat-btn">转载</span>
        </div>
    </div>
    <div id="post-detail-content" class="list-container" style="padding: 20px;">
        <!-- 帖子和评论将由JS动态生成在这里 -->
    </div>
    <!-- 帖子页的评论输入框 -->
    <div id="post-comment-input-area" class="chat-input-area" style="visibility: visible;">
         <div class="chat-input-main-row">
            <textarea id="post-comment-input" rows="1" placeholder="发布你的评论..."></textarea>
            <button id="send-post-comment-btn" class="action-button">发送</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】这是为圈子分类筛选新增的弹窗 ▼▼▼ -->
<div id="forum-filter-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 60%;">
        <div class="modal-header">
            <span>按分类筛选</span>
        </div>
        <div class="modal-body">
            <div id="forum-filter-category-list">
                <!-- 分类标签将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button class="cancel" id="reset-forum-filter-btn" style="width: 30%;">重置</button>
            <button class="cancel" id="cancel-forum-filter-btn" style="width: 30%;">取消</button>
            <button class="save" id="apply-forum-filter-btn" style="width: 30%;">应用</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->


<!-- ▲▲▲ 论坛相关HTML代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 步骤1：用这块新代码替换旧的 id="custom-frame-manager-modal" 的 div ▼▼▼ -->
<div id="custom-frame-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理我的头像框</span>
            <div class="header-actions">
                <!-- 这是“编辑/完成”按钮，用于切换模式 -->
                <button id="edit-custom-frames-btn" class="action-btn">编辑</button>
                <!-- 这是您原来就有的“上传”按钮 -->
                <button id="upload-custom-frame-btn" class="action-btn">上传</button>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="custom-frame-grid" class="sticker-grid"> <!-- 复用表情网格的样式 -->
                <!-- 自定义头像框将由JS动态生成在这里 -->
            </div>
        </div>
        <!-- 这是全新的底部操作栏，默认隐藏 -->
        <div id="custom-frame-footer" class="modal-footer" style="display: none; flex-direction: column; gap: 10px;">
            <div style="display: flex; gap: 10px;">
                <button id="frame-select-all-btn" class="form-button-secondary" style="flex: 1; margin: 0;">全选</button>
                <button id="frame-deselect-all-btn" class="form-button-secondary" style="flex: 1; margin: 0;">全不选</button>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="import-custom-frames-btn" class="form-button-secondary" style="flex: 1; margin: 0;">导入</button>
                <button id="export-selected-frames-btn" class="form-button-secondary" style="flex: 1; margin: 0;" disabled>导出已选 (0)</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-frame-manager-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<input type="file" id="custom-frame-upload-input" accept="image/png, image/gif" hidden multiple>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【已修改】头像框选择模态框 ▼▼▼ -->
<div id="avatar-frame-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择头像框</span>
            <!-- 【核心修改】我们在这里加一个“管理”按钮 -->
            <button id="manage-custom-frames-btn" class="action-button">管理</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <!-- 【核心修改】不再需要Tabs，只有一个Grid -->
            <div id="avatar-frame-grid" class="frame-grid">
                <!-- 头像框选项（包括“无”和自定义的）会在这里生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-frame-settings-btn">取消</button>
            <button class="save" id="save-frame-settings-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【全新设计】的代码，替换旧的 id="send-location-modal" ▼▼▼ -->
<div id="send-location-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>发送定位与轨迹</span>
        </div>
        <div class="modal-body" style="padding-bottom: 5px;">
            <!-- 核心信息 -->
            <div class="form-group">
                <label for="user-location-input">我的位置 (起点)</label>
                <input type="text" id="user-location-input" placeholder="例如：市中心的咖啡馆">
            </div>
            <div class="form-group">
                <label for="ai-location-input">Ta的位置 (终点)</label>
                <input type="text" id="ai-location-input" placeholder="例如：海边的灯塔">
            </div>
            <div class="form-group">
                <label for="distance-input">相距</label>
                <input type="text" id="distance-input" placeholder="例如：约5公里 (必填)">
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 【全新】行动轨迹输入区 -->
            <div class="form-group">
                <label>行动轨迹 (可选，按顺序填写)</label>
                <div id="trajectory-points-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- JS会在这里动态添加输入框 -->
                </div>
                <button id="add-trajectory-point-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加途经点</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="location-cancel-btn">取消</button>
            <button class="save" id="location-confirm-btn">发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】粘贴悬浮歌词栏设置模态框 ▼▼▼ -->
<div id="lyrics-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>悬浮歌词设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="lyrics-font-size-slider">字体大小: <span id="lyrics-font-size-value">14px</span></label>
                <input type="range" id="lyrics-font-size-slider" min="12" max="24" value="14" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-bg-opacity-slider">背景不透明度: <span id="lyrics-bg-opacity-value">0%</span></label>
                <input type="range" id="lyrics-bg-opacity-slider" min="0" max="100" value="0" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-font-color-picker">字体颜色</label>
                <input type="color" id="lyrics-font-color-picker" value="#FFFFFF" style="width: 100%; height: 40px;">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="reset-lyrics-settings-btn">恢复默认</button>
            <button class="save" id="close-lyrics-settings-btn">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是“选择搜索源”的弹窗，请粘贴到body末尾 ▼▼▼ -->
<div id="music-source-selector-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>选择搜索源</span>
        </div>
        <div class="modal-body" style="text-align: left; padding: 20px;">
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="all" checked> 全部来源 (网易云 + QQ音乐)
            </label>
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="netease"> 仅网易云音乐
            </label>
            <label style="display: block; cursor: pointer;">
                <input type="radio" name="search-source" value="tencent"> 仅QQ音乐
            </label>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-source-select-btn">取消</button>
            <button class="save" id="confirm-source-select-btn">开始搜索</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是微博关注列表的弹窗，粘贴到 </body> 前面 ▼▼▼ -->
<div id="weibo-following-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>关注列表</span>
        </div>
        <div class="modal-body" style="padding: 0;">
            <!-- 【核心】这个容器将带滚动条 -->
            <div id="weibo-following-list-container">
                <!-- 关注列表将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-following-list-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- 塔罗牌占卜主模态框 -->
<div id="tarot-divination-modal" class="modal">
    <div class="modal-content" style="height: 85%; width: 95%;">
        
        <!-- 1. 占卜设置界面 -->
        <div id="tarot-setup-view">
            <div class="modal-header">
                <span>塔罗牌占卜</span>
                <div>
                    <span id="tarot-history-btn" class="action-btn" style="font-size: 16px;">历史</span>
                    <span id="close-tarot-modal-btn" class="action-btn" style="font-size: 16px;">关闭</span>
                </div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="tarot-question-input">您的问题或关注点</label>
                    <textarea id="tarot-question-input" rows="2" placeholder="例如：我近期的桃花运如何？"></textarea>
                </div>
                <div class="form-group">
                    <label for="tarot-spread-select">选择牌阵</label>
                    <select id="tarot-spread-select">
                        <option value="single">单张牌 - 快速指引</option>
                        <option value="three_past_present_future">三张牌 - 过去/现在/未来</option>
                        <option value="three_situation_challenge_advice">三张牌 - 情境/挑战/建议</option>
                        <option value="celtic_cross">凯尔特十字 - 深度分析 (10张牌)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>牌面方向</label>
                    <div style="display: flex; gap: 20px;">
                        <label><input type="radio" name="tarot-orientation" value="upright" checked> 仅正位</label>
                        <label><input type="radio" name="tarot-orientation" value="reversed"> 包含逆位</label>
                    </div>
                </div>
                <button id="draw-tarot-cards-btn" class="form-button" style="margin-top: 20px;">洗牌并抽牌</button>
            </div>
        </div>

        <!-- 2. 占卜结果界面 (默认隐藏) -->
        <div id="tarot-result-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-tarot-setup-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜结果</span>
            </div>
            <div class="modal-body" id="tarot-result-display">
                <!-- 结果将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button id="send-tarot-result-btn" class="save" style="width: 100%;">发给塔罗师解读</button>
            </div>
        </div>

        <!-- 3. 历史记录界面 (默认隐藏) -->
        <div id="tarot-history-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-tarot-main-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜历史</span>
            </div>
            <div class="modal-body" id="tarot-history-list">
                <!-- 历史记录将由JS动态生成在这里 -->
            </div>
        </div>
    </div>
</div>
<!-- ▼▼▼ 八卦六爻占卜弹窗 ▼▼▼ -->
<div id="bagua-divination-modal" class="modal">
    <div class="modal-content" style="height: 85%; width: 95%;">
        
        <!-- 1. 占卜设置界面 -->
        <div id="bagua-setup-view">
            <div class="modal-header">
                <span>八卦六爻占卜</span>
                <div>
                    <span id="bagua-history-btn" class="action-btn" style="font-size: 16px;">历史</span>
                    <span id="close-bagua-modal-btn" class="action-btn" style="font-size: 16px;">关闭</span>
                </div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="bagua-question-input">您的问题或关注点</label>
                    <textarea id="bagua-question-input" rows="2" placeholder="例如：我近期事业发展如何？"></textarea>
                </div>
                <div class="form-group">
                    <label>起卦方式</label>
                    <select id="bagua-method-select">
                        <option value="coin">铜钱摇卦 - 传统方式</option>
                        <option value="time">时间起卦 - 根据当前时间</option>
                        <option value="number">数字起卦 - 心念数字</option>
                    </select>
                </div>
                <div class="form-group" id="bagua-number-input-group" style="display: none;">
                    <label for="bagua-number-input">请输入一个数字（用于起卦）</label>
                    <input type="number" id="bagua-number-input" placeholder="输入任意正整数">
                </div>
                <button id="start-bagua-btn" class="form-button" style="margin-top: 20px;">开始起卦</button>
            </div>
        </div>

        <!-- 2. 占卜结果界面 (默认隐藏) -->
        <div id="bagua-result-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-bagua-setup-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>卦象结果</span>
            </div>
            <div class="modal-body" id="bagua-result-display" style="overflow-y: auto;">
                <!-- 结果将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button id="send-bagua-result-btn" class="save" style="width: 100%;">发给易经大师解读</button>
            </div>
        </div>

        <!-- 3. 历史记录界面 (默认隐藏) -->
        <div id="bagua-history-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-bagua-main-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜历史</span>
            </div>
            <div class="modal-body" id="bagua-history-list">
                <!-- 历史记录将由JS动态生成在这里 -->
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 八卦六爻占卜弹窗结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这里是整个情侣空间功能的HTML代码 ▼▼▼ -->
<!-- 2. 切换角色的弹窗 -->
<div id="ls-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择空间</span>
        </div>
        <div class="modal-body" id="ls-char-selector-list" style="padding: 0;">
            <!-- 角色列表会由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-switch-char-btn" style="width:100%;">取消</button>
        </div>
    </div>
</div>

<!-- 3. 发布说说的弹窗 -->
<div id="ls-create-moment-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>想对Ta说...</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="ls-moment-content-input" rows="5" placeholder="在这里写下你们的私密话语..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-moment-btn">取消</button>
            <button class="save" id="ls-confirm-moment-btn">发布</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块新代码，替换掉你旧的 ls-create-album-modal ▼▼▼ -->
<!-- 4. 创建相册/上传照片的弹窗 (这是修改后的版本) -->
<div id="ls-create-album-modal" class="modal">
     <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <!-- 标题已修改 -->
            <span id="ls-album-modal-title">上传照片</span>
        </div>
        <div class="modal-body">
            <!-- 新增：模式切换开关 (复用动态的样式) -->
            <div class="post-mode-switcher">
                <button id="ls-switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="ls-switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

            <!-- 模式1: 上传图片 -->
            <div id="ls-image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <label>选择照片 (仅限单张)</label>
                    <div id="ls-photo-preview-container"></div>
                    <button class="form-button form-button-secondary" id="ls-select-photos-btn">选择照片</button>
                    <!-- 关键：这里的 input 移除了 multiple 属性，现在只能单选 -->
                    <input type="file" id="ls-photo-input" accept="image/*" hidden>
                </div>
                 <div class="form-group">
                    <label>图片描述 (必填)</label>
                    <textarea id="ls-photo-desc-input" rows="3" placeholder="为这张照片写下注脚..."></textarea>
                </div>
            </div>

            <!-- 模式2: 使用文字图 -->
            <div id="ls-text-image-mode-content" class="post-mode-content" style="display: none;">
                <div class="form-group">
                    <label>文字图描述 (必填)</label>
                    <textarea id="ls-text-image-desc-input" rows="5" placeholder="在这里写下你的心情或故事..."></textarea>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-album-btn">取消</button>
            <button class="save" id="ls-confirm-album-btn">确认上传</button>
        </div>
    </div>
</div><!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣空间-写情书/回信的弹窗 -->
<div id="ls-create-letter-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="ls-letter-modal-title">给Ta写一封信</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ls-letter-recipient-input">收信人</label>
                <!-- 收信人通常是固定的，所以我们禁用这个输入框 -->
                <input type="text" id="ls-letter-recipient-input" disabled>
            </div>
            <div class="form-group">
                <label for="ls-letter-content-input">情书内容</label>
                <textarea id="ls-letter-content-input" rows="8" placeholder="在这里写下你的心意..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-letter-btn">取消</button>
            <button class="save" id="ls-confirm-letter-btn">寄出</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新美化版】情侣空间-情书查看器 -->
<div id="ls-letter-viewer-modal" class="modal">
    <div class="ls-letter-viewer-content">
        <!-- 头部：收信人信息 -->
        <div class="letter-viewer-header">
            <img id="ls-viewer-recipient-avatar" class="meta-avatar">
            <div class="recipient-info">
                <div class="label">To my dear:</div>
                <div id="ls-viewer-recipient-name" class="name"></div>
            </div>
        </div>
        <!-- 中间：信件正文 -->
        <div id="ls-viewer-body" class="letter-viewer-body">
            <!-- JS会在这里填充信件内容 -->
        </div>
        <!-- 底部：发信人信息和操作按钮 -->
        <div class="letter-viewer-footer">
            <div class="sender-info">
                <div id="ls-viewer-sender-name"></div>
                <div id="ls-viewer-timestamp" class="timestamp"></div>
            </div>
            <div class="letter-actions">
                <button id="ls-close-letter-viewer-btn">关闭</button>
                <button id="ls-reply-letter-btn" class="primary">回信</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】情侣空间设置弹窗 ▼▼▼ -->
<div id="ls-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>情侣空间设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ls-start-date-input">我们在一起的第一天</label>
                <input type="date" id="ls-start-date-input" style="width: 100%; padding: 10px; box-sizing: border-box;">
            </div>
            
            <!-- ▼▼▼ 你新加的代码会出现在这里 ▼▼▼ -->
            <hr style="opacity: 0.2; margin: 20px 0;">
            <div class="form-group">
                <label>危险操作</label>
                <div style="display: flex; gap: 10px;">
                    <button id="ls-cancel-space-btn" class="form-button form-button-secondary" style="background-color: #ffe5e5; color: #ff3b30; border-color: #ffc2d1; flex: 1; margin:0;">取消空间</button>
                    <button id="ls-disconnect-space-btn" class="form-button form-button-secondary" style="background-color: #ff3b30; color: white; border-color: #ff3b30; flex: 1; margin:0;">解除关系</button>
                </div>
                 <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px;">
                    <strong>取消空间</strong>: 将空间变为未启用状态，但保留所有数据。不会通知对方。<br>
                    <strong>解除关系</strong>: 同样会取消空间，但会通知对方关系已解除，对方会对此发表意见。
                </p>
            </div>
            <!-- ▲▲▲ 新代码结束 ▲▲▲ -->

        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-settings-cancel-btn">取消</button>
            <button class="save" id="ls-settings-save-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣空间-提问弹窗 -->
<div id="ls-ask-question-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>发起一个提问</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="ls-question-content-input" rows="5" placeholder="向Ta提个问题吧..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-ask-btn">取消</button>
            <button class="save" id="ls-confirm-ask-btn">向Ta提问</button>
        </div>
    </div>
</div>

<!-- 【全新】情侣空间-回答弹窗 -->
<div id="ls-answer-question-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>回答Ta的问题</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>问题：</label>
                <p id="ls-answer-question-text" style="background-color: #f0f2f5; padding: 10px; border-radius: 8px;"></p>
            </div>
            <div class="form-group">
                <label for="ls-answer-content-input">你的回答：</label>
                <textarea id="ls-answer-content-input" rows="5" placeholder="认真回答哦..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-answer-btn">取消</button>
            <button class="save" id="ls-confirm-answer-btn">确认回答</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是情侣空间专属音乐播放器的HTML代码 ▼▼▼ -->

<!-- 1. 这是播放器专属的音频引擎 -->
<audio id="ls-audio-player" style="display:none;"></audio>

<!-- 2. 这是播放器的主窗口界面 -->
<div id="ls-music-player-overlay" class="modal">
    <div class="music-player-window">
<!-- 【全新】封面和歌词的切换容器 -->
<div id="ls-display-area" style="width: 192px; height: 192px; margin-bottom: 20px; cursor: pointer;">
    <!-- 歌曲封面 -->
    <img id="ls-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面" style="width: 100%; height: 100%; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
    
    <!-- 歌词容器 -->
    <div id="ls-lyrics-container" style="display: none; width: 100%; height: 100%; overflow: hidden; text-align: center; color: #333; font-weight: 500;">
        <div id="ls-lyrics-list" style="transition: transform 0.5s ease;">
             <!-- 歌词会显示在这里 -->
        </div>
    </div>
</div>

        <!-- 歌曲信息 -->
        <div id="ls-song-title" style="font-size: 18px; font-weight: 600;">暂无歌曲</div>
        <div id="ls-artist" style="font-size: 14px; color: #666; margin-bottom: 15px;">...</div>
        
        <!-- 进度条 -->
        <div class="music-progress-bar-container" style="width: 100%;">
            <div id="ls-current-time" class="time-display">0:00</div>
            <div class="progress-bar" id="ls-progress-bar">
                <div id="ls-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="ls-total-time" class="time-display">0:00</div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="music-controls" style="margin-bottom: 15px;">
            <button id="ls-prev-btn">◀</button>
            <button id="ls-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="ls-next-btn">▶</button>
        </div>
        
        <!-- 底部操作按钮 -->
        <div class="music-bottom-actions" style="width: 100%;">
            <button id="ls-playlist-btn" style="background-color: rgba(0, 123, 255, 0.1); color: var(--accent-color); margin-right: 5px;">播放列表</button>
            <button id="ls-close-player-btn" style="background-color: rgba(0,0,0,0.05); color: #333; margin-left: 5px;">关闭</button>
        </div>
    </div>
</div>

<!-- 3. 这是播放列表的侧滑面板 -->
<div id="ls-music-playlist-panel" class="music-playlist-panel">
    <div class="playlist-header">
        <span class="panel-btn" id="ls-close-playlist-btn">返回</span>
        <span>播放列表</span>
        <span class="panel-btn" id="ls-clear-playlist-btn" style="color: #ff3b30;">清空</span>
    </div>
    <div class="playlist-body" id="ls-playlist-body">
        <!-- 播放列表内容会在这里生成 -->
    </div>
</div>

<!-- ▲▲▲ HTML代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣番茄钟-设置弹窗 -->
<div id="ls-pomodoro-setup-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新的专注时光</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="pomodoro-task-input">专注任务</label>
                <input type="text" id="pomodoro-task-input" placeholder="例如：学习JS、完成工作报告">
            </div>
            <div class="form-group">
                <label for="pomodoro-duration-input">专注时长 (分钟)</label>
                <input type="number" id="pomodoro-duration-input" value="25" min="1">
            </div>
<div class="form-group">
    <label>计时模式</label>
    <div style="display: flex; gap: 20px;">
        <label><input type="radio" name="pomodoro-mode" value="countdown" checked> 倒计时</label>
        <label><input type="radio" name="pomodoro-mode" value="countup"> 正计时</label>
    </div>
</div>
            <div class="form-group">
                <label for="pomodoro-talk-interval-input">角色鼓励间隔 (分钟, 0为不自动鼓励)</label>
                <input type="number" id="pomodoro-talk-interval-input" value="5" min="0">
            </div>
<!-- ▼▼▼ 这是修改后的番茄钟背景设置 ▼▼▼ -->
<div class="form-group">
    <label>自定义背景 (可选)</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="text" id="pomodoro-bg-url-input" placeholder="粘贴图片URL" style="flex-grow: 1;">
        <button id="pomodoro-bg-local-upload-btn" class="form-button-secondary" style="margin: 0; padding: 12px; width: auto;">本地上传</button>
    </div>
    <input type="file" id="pomodoro-bg-file-input" accept="image/*" hidden>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="pomodoro-cancel-setup-btn">取消</button>
            <button class="save" id="pomodoro-confirm-setup-btn">开始专注</button>
        </div>
    </div>
</div>

<!-- 【全新】情侣番茄钟-历史详情弹窗 -->
<div id="ls-pomodoro-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="pomodoro-history-viewer-title">专注记录</span>
        </div>
        <div class="modal-body" id="pomodoro-history-viewer-content">
            <!-- 聊天记录会由JS生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="pomodoro-close-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 情侣空间HTML代码结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是为“圈子”功能新增的所有弹窗 ▼▼▼ -->

<!-- 1. 小组编辑器弹窗 (用于修改小组信息和世界观) -->
<div id="forum-group-editor-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>编辑小组信息</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="group-editor-name-input">小组名称</label>
                <input type="text" id="group-editor-name-input">
            </div>
            <div class="form-group">
                <label for="group-editor-desc-input">小组简介</label>
                <input type="text" id="group-editor-desc-input">
            </div>
            <div class="form-group">
                <label for="group-editor-icon-input">小组图标 (Emoji)</label>
                <input type="text" id="group-editor-icon-input" maxlength="2">
            </div>
            <div class="form-group">
                <label for="group-editor-categories-input">小组分类 (用#号分隔, 例如: #科幻 #未来)</label>
                <input type="text" id="group-editor-categories-input" placeholder="例如: #科幻 #未来">
            </div>
            <div class="form-group">
                <label for="group-editor-worldview-input">小组世界观 (供AI生成内容时参考)</label>
                <textarea id="group-editor-worldview-input" rows="5" placeholder="详细描述这个小组独特的背景设定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-group-editor-btn">取消</button>
            <button class="save" id="save-group-editor-btn">保存</button>
        </div>
    </div>
</div>

<!-- 2. 分类管理弹窗 -->
<div id="forum-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理圈子分类</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分类</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-forum-category-name-input" placeholder="输入分类名，无需带'#'..." style="flex-grow: 1;">
                    <button id="add-new-forum-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-forum-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分类列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-forum-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是游戏大厅的主界面，粘贴到所有 modal 的 div 之后、<script> 标签之前 ▼▼▼ -->
<div id="game-hall-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>游戏大厅</span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div class="list-container" style="padding: 20px;">
        <p style="text-align: center; color: var(--text-secondary);">选择一个游戏开始吧！</p>
        <div id="game-hall-grid">
            <!-- 游戏列表将显示在这里 -->
            <div class="game-card" data-game="werewolf">
                <div class="game-icon">🐺</div>
                <div class="game-info">
                    <div class="game-title">狼人杀</div>
                    <div class="game-desc">逻辑与谎言的对决</div>
                </div>
            </div>
            <div class="game-card" data-game="sea-turtle-soup">
                <div class="game-icon">🐢</div>
                <div class="game-info">
                    <div class="game-title">海龟汤</div>
                    <div class="game-desc">揭开情景的真相</div>
                </div>
            </div>
             <div class="game-card" data-game="script-kill">
                <div class="game-icon">📜</div>
                <div class="game-info">
                    <div class="game-title">剧本杀</div>
                    <div class="game-desc">扮演角色，探寻谜案</div>
                </div>
            </div>
            <div class="game-card" data-game="guess-what">
                <div class="game-icon">🗣️</div>
                <div class="game-info">
                    <div class="game-title">你说我猜</div>
                    <div class="game-desc">考验默契的时候到了</div>
                </div>
            </div>
<div class="game-card" data-game="ludo">
    <div class="game-icon">🎲</div>
    <div class="game-info">
        <div class="game-title">心动飞行棋</div>
        <div class="game-desc">和Ta来一场只属于你们的冒险</div>
    </div>
</div>
<!-- ▲▲▲ 新增代码结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴新的游戏卡片 ▼▼▼ -->
<div class="game-card" data-game="undercover">
    <div class="game-icon">🕵️</div>
    <div class="game-info">
        <div class="game-title">谁是卧底</div>
        <div class="game-desc">语言的伪装，逻辑的陷阱</div>
    </div>
</div>
<!-- ▲▲▲ 新增代码结束 ▲▲▲ -->
             <p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); font-size: 14px; margin-top: 20px;">更多游戏正在火速开发中...</p>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是整个狼人杀功能的HTML，粘贴到 game-hall-screen 的 div 之后 ▼▼▼ -->

<!-- 1. 狼人杀游戏设置屏幕 -->
<div id="werewolf-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>狼人杀 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="werewolf-player-count">选择游戏人数</label>
            <select id="werewolf-player-count">
                <option value="6">6人局 (2狼, 2民, 预言家, 守卫)</option>
                <option value="9">9人局 (3狼, 3民, 预言家, 女巫, 猎人)</option>
                <option value="12">12人局 (4狼, 4民, 预言家, 女巫, 猎人, 白痴)</option>
            </select>
        </div>
        <div class="form-group">
            <label>邀请玩家 (你已自动加入)</label>
            <div id="werewolf-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
        <button id="start-werewolf-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. 狼人杀游戏主界面 -->
<div id="werewolf-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-werewolf-game-btn">‹ 退出</span>
        <span id="werewolf-game-title">狼人杀</span>
        <span class="action-btn" id="werewolf-my-role-btn">我的身份</span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="werewolf-game-content">
        <!-- 玩家座位区 -->
        <div id="werewolf-players-grid">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <!-- 游戏日志/信息区 -->
        <div id="werewolf-log-container">
            <div id="werewolf-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <!-- 玩家操作区 -->
        <div id="werewolf-action-area">
            <!-- 玩家的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ 狼人杀功能HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】狼人杀游戏结算卡片 ▼▼▼ -->
<div id="werewolf-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="werewolf-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="repost-summary-btn">发送复盘到聊天</button>
            <button class="save" id="back-to-hall-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】狼人杀复盘发送目标选择器 ▼▼▼ -->
<div id="werewolf-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要发送的玩家</span>
        </div>
        <div class="modal-body" id="werewolf-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="wt-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="wt-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="wt-cancel-btn">取消</button>
            <button class="save" id="wt-confirm-btn">确认发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是整个海龟汤功能的HTML，请粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. 海龟汤游戏主界面 -->
<div id="sea-turtle-soup-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-sts-game-btn">‹ 退出</span>
        <span>海龟汤</span>
        <span class="action-btn" id="reveal-sts-answer-btn">揭晓答案</span>
    </div>
    <div id="sts-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 玩家座位区 -->
        <div id="sts-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; padding: 10px; flex-shrink: 0;">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <!-- 游戏日志/信息区 -->
        <div id="sts-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="sts-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
<!-- ▼▼▼ 用这块新代码替换旧的 id="sts-action-area" ▼▼▼ -->
<div id="sts-action-area" class="chat-input-area" style="visibility: visible;">
     <div class="chat-input-main-row">
        <textarea id="sts-question-input" rows="1" placeholder="输入问题或答案..."></textarea>
        <!-- 【核心修改】新增“猜答案”按钮 -->
        <button id="guess-sts-answer-btn" class="action-button" style="background-color: #ff9800;">猜答案</button>
        <button id="send-sts-question-btn" class="action-button">提问</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    </div>
</div>

<!-- 2. 海龟汤游戏设置模态框 -->
<div id="sea-turtle-soup-setup-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span>海龟汤 - 游戏设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>邀请玩家 (你已自动加入)</label>
                <div id="sts-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
                    <!-- 玩家选择列表将由JS动态生成 -->
                </div>
            </div>
            <div class="form-group">
                <label>谁来出题？</label>
                <select id="sts-riddle-provider-select">
                    <option value="user">我来出题</option>
                    <option value="random_ai">随机一位AI</option>
                </select>
            </div>
            <!-- 用户出题的输入区 (默认隐藏) -->
            <div id="sts-user-riddle-input-area" style="display: none;">
                <div class="form-group">
                    <label for="sts-user-riddle-surface">谜面</label>
                    <textarea id="sts-user-riddle-surface" rows="2" placeholder="例如：一个男人走进酒吧，要了一杯水..."></textarea>
                </div>
                <div class="form-group">
                    <label for="sts-user-riddle-answer">谜底 (完整故事)</label>
                    <textarea id="sts-user-riddle-answer" rows="4" placeholder="例如：男人在打嗝，他想喝水止嗝..."></textarea>
                </div>
            </div>
            <!-- AI出题的输入区 (默认隐藏) -->
            <div id="sts-ai-riddle-input-area" style="display: none;">
                <div class="form-group">
                    <label for="sts-ai-riddle-type">谜题类型 (可选)</label>
                    <input type="text" id="sts-ai-riddle-type" placeholder="例如：恐怖、温情、脑洞、经典">
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sts-setup-btn">取消</button>
            <button class="save" id="start-sts-game-btn">开始游戏</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】请将这两块代码粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. 海龟汤游戏结算卡片 -->
<div id="sts-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="sts-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="share-sts-summary-btn">分享复盘</button>
            <button class="save" id="back-to-hall-from-sts-btn">返回大厅</button>
        </div>
    </div>
</div>

<!-- 2. 海龟汤复盘发送目标选择器 -->
<div id="sts-share-target-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要分享的玩家</span>
        </div>
        <div class="modal-body" id="sts-share-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="sts-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="sts-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sts-cancel-share-btn">取消</button>
            <button class="save" id="sts-confirm-share-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是整个剧本杀功能的HTML，请粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. 剧本杀游戏设置屏幕 -->
<div id="script-kill-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>剧本杀 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>选择剧本</label>
            <div style="display: flex; gap: 10px;">
                <select id="script-kill-script-select" style="flex-grow: 1;"></select>
                <button id="manage-custom-scripts-btn" class="form-button-secondary" style="margin-top: 0; padding: 0 15px;">管理</button>
            </div>
        </div>
        <div class="form-group">
            <label>邀请玩家 (你已自动加入)</label>
            <div id="script-kill-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
        <div class="form-group">
            <label class="toggle-switch-label">
                <span class="toggle-switch-text">自由选择角色 (关闭则随机分配)</span>
                <input type="checkbox" id="script-kill-free-choice-toggle">
                <span class="toggle-switch-slider"></span>
            </label>
        </div>
        <button id="start-script-kill-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. 剧本杀游戏主界面 -->
<div id="script-kill-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-script-kill-game-btn">‹ 退出</span>
        <span id="script-kill-game-title">剧本杀</span>
        <div class="header-actions">
            <span class="action-btn" id="script-kill-my-role-btn">我的角色</span>
            <span class="action-btn" id="script-kill-all-evidence-btn">公共线索</span>
        </div>
    </div>
    <div id="script-kill-game-content">
        <div id="script-kill-players-grid">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <div id="script-kill-log-container">
            <div id="script-kill-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <div id="script-kill-action-area">
            <!-- 玩家的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】剧本杀自定义剧本管理模态框 -->
<div id="script-kill-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
<div class="modal-header">
    <span>管理自定义剧本</span>
    <div class="header-actions">
        <!-- ▼▼▼ 在这里添加一个新按钮 ▼▼▼ -->
        <button id="open-sk-ai-generator-btn" class="action-button" style="font-size: 14px;">AI生成</button>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
        <button id="add-new-script-btn" class="action-button">添加</button>
    </div>
</div>

        <div class="modal-body" id="custom-scripts-list" style="padding: 0;">
            <!-- 自定义剧本列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-script-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 用下面这【一整块】全新的代码，替换掉你旧的 id="script-kill-editor-modal" ▼▼▼ -->

<!-- 1. 剧本编辑器主弹窗 (可视化版) -->
<div id="script-kill-editor-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span id="script-editor-title">剧本编辑器</span>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
            
            <!-- 基础信息 -->
            <div class="form-group">
                <label for="script-name-input">剧本名称</label>
                <input type="text" id="script-name-input">
            </div>
            <div class="form-group">
                <label for="script-background-input">故事背景</label>
                <textarea id="script-background-input" rows="3"></textarea>
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 角色设定区 -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="margin: 0; font-weight: 600;">角色设定</label>
                    <button id="sk-add-role-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px;">+ 添加角色</button>
                </div>
                <div id="sk-roles-container" class="sk-item-container">
                    <!-- 角色卡片将由JS动态生成在这里 -->
                </div>
            </div>

            <!-- 线索卡区 -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="margin: 0; font-weight: 600;">线索卡</label>
                    <button id="sk-add-clue-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px;">+ 添加线索</button>
                </div>
                <div id="sk-clues-container" class="sk-item-container">
                    <!-- 线索卡片将由JS动态生成在这里 -->
                </div>
            </div>

            <!-- 最终真相互动 -->
            <div class="form-group">
                <label for="sk-truth-input">最终真相</label>
                <textarea id="sk-truth-input" rows="3"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-script-editor-btn">取消</button>
            <button class="save" id="save-script-btn">保存剧本</button>
        </div>
    </div>
</div>

<!-- 2. 【全新】用于编辑单个角色/线索的子弹窗 -->
<div id="sk-item-editor-modal" class="modal" style="z-index: 1003;">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span id="sk-item-editor-title"></span>
        </div>
        <div class="modal-body">
            <!-- 角色编辑字段 (默认隐藏) -->
            <div id="sk-role-editor-fields" style="display: none;">
                <div class="form-group">
                    <label for="sk-role-name-input">角色名称</label>
                    <input type="text" id="sk-role-name-input">
                </div>
                <div class="form-group">
                    <label for="sk-role-desc-input">角色介绍</label>
                    <textarea id="sk-role-desc-input" rows="3"></textarea>
                </div>
<div class="form-group">
    <label for="sk-role-storyline-input">故事线 (案发时间段的详细行动轨迹)</label>
    <textarea id="sk-role-storyline-input" rows="5"></textarea>
</div>
                <div class="form-group">
                    <label for="sk-role-tasks-input">秘密任务</label>
                    <textarea id="sk-role-tasks-input" rows="2"></textarea>
                </div>
                <div class="form-group">
                    <label class="toggle-switch-label">
                        <span class="toggle-switch-text">是凶手</span>
                        <input type="checkbox" id="sk-role-killer-toggle">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
            </div>
            <!-- 线索编辑字段 (默认隐藏) -->
            <div id="sk-clue-editor-fields" style="display: none;">
                <div class="form-group">
                    <label for="sk-clue-owner-select">线索归属</label>
                    <select id="sk-clue-owner-select">
                        <!-- 选项将由JS动态生成 -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="sk-clue-desc-input">线索描述</label>
                    <textarea id="sk-clue-desc-input" rows="4"></textarea>
                </div>
                 <div class="form-group">
                    <label class="toggle-switch-label">
                        <span class="toggle-switch-text">是关键线索</span>
                        <input type="checkbox" id="sk-clue-key-toggle">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-item-editor-cancel-btn">取消</button>
            <button class="save" id="sk-item-editor-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- 4. 角色身份卡模态框 -->
<div id="script-kill-role-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="sk-role-name">你的角色</span>
        </div>
        <div class="modal-body" id="sk-role-details" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 角色介绍、任务等将显示在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sk-role-modal-btn" style="width:100%;">我已了解</button>
        </div>
    </div>
</div>

<!-- 5. 个人线索板模态框 -->
<div id="script-kill-evidence-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>我的线索板</span>
        </div>
        <div class="modal-body" id="sk-evidence-list" style="padding: 10px; display: flex; flex-direction: column; gap: 10px;">
            <!-- 搜到的线索卡片会显示在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sk-evidence-modal-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- 6. 投票模态框 -->
<div id="script-kill-vote-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span id="sk-vote-title">最终投票</span>
        </div>
        <div class="modal-body" id="sk-vote-options-list" style="text-align: left; padding: 20px;">
            <!-- 投票选项将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sk-vote-btn">取消</button>
            <button class="save" id="confirm-sk-vote-btn">确认投票</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】剧本杀游戏结算卡片 ▼▼▼ -->
<div id="script-kill-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="script-kill-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="repost-sk-summary-btn">转发复盘到单聊</button>
            <button class="save" id="back-to-hall-from-sk-btn">返回大厅</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】剧本杀复盘发送目标选择器 ▼▼▼ -->
<div id="script-kill-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要转发的玩家</span>
        </div>
        <div class="modal-body" id="script-kill-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="sk-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="sk-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-cancel-share-btn">取消</button>
            <button class="save" id="sk-confirm-share-btn">确认转发</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是AI剧本生成器的弹窗，粘贴到</body>前 ▼▼▼ -->
<div id="sk-ai-generator-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span>AI 剧本生成器</span>
        </div>
<div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
            
    <div class="form-group">
        <label for="sk-ai-elements-input">核心要素 (用逗号分隔)</label>
        <input type="text" id="sk-ai-elements-input" placeholder="例如：现代, 谋杀, 暴风雪山庄, 遗产">
    </div>

    <!-- ▼▼▼ 【这是你要求新增的HTML】请把它粘贴到这里 ▼▼▼ -->
    <div class="form-group">
        <label for="sk-ai-player-count-input">玩家人数 (包含凶手, 建议4-8人)</label>
        <input type="number" id="sk-ai-player-count-input" value="5" min="3" max="12" style="width: 100%; box-sizing: border-box; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color);">
    </div>
    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

    <div class="form-group">
        <label for="sk-ai-summary-input">剧情梗概 (可选)</label>
        <textarea id="sk-ai-summary-input" rows="4" placeholder="可以写一个简单的故事大纲，帮助AI更好地理解你的想法..."></textarea>
    </div>
    <button id="sk-trigger-ai-generation-btn" class="form-button">开始生成</button>
          
            <hr style="opacity: 0.2; margin: 5px 0;">

            <div class="form-group" style="flex-grow: 1; min-height: 0; display: flex; flex-direction: column;">
                <label>AI 生成结果预览</label>
                <div id="sk-ai-result-preview" style="flex-grow: 1; overflow-y: auto; background: #f0f2f5; padding: 10px; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; color: #555;">
                    点击“开始生成”后，结果将显示在这里...
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-ai-generator-cancel-btn">关闭</button>
            <!-- 这个保存按钮初始是禁用的，生成成功后才会激活 -->
            <button class="save" id="sk-ai-generator-save-btn" disabled>保存剧本</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 剧本杀功能HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 海龟汤功能HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是“你说我猜”游戏的所有HTML代码 ▼▼▼ -->

<!-- 1. “你说我猜”游戏设置屏幕 -->
<div id="guess-what-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>你说我猜 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>邀请一位玩伴</label>
            <div id="guess-what-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
        <div class="form-group">
            <label>选择游戏模式</label>
            <div style="display: flex; gap: 20px;">
                <label><input type="radio" name="guess_what_mode" value="ai_guesses" checked> 我出题，AI猜</label>
                <label><input type="radio" name="guess_what_mode" value="user_guesses"> AI出题，我猜</label>
            </div>
        </div>
        <!-- "我出题"模式下的输入框 -->
        <div class="form-group" id="user-word-input-container">
            <label for="guess-what-user-word">请输入你要出的词</label>
            <input type="text" id="guess-what-user-word" placeholder="例如：苹果、流浪地球...">
        </div>
        <button id="start-guess-what-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. “你说我猜”游戏主界面 -->
<div id="guess-what-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-guess-what-game-btn">‹ 退出</span>
        <span id="guess-what-game-title">你说我猜</span>
        <span class="action-btn" id="give-up-guess-what-btn">放弃</span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="guess-what-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 游戏日志/信息区 -->
        <div id="guess-what-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="guess-what-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <!-- 玩家操作区 -->
        <div id="guess-what-action-area" class="chat-input-area" style="visibility: visible;">
             <div class="chat-input-main-row">
                <textarea id="guess-what-user-input" rows="1" placeholder="输入提示或猜测..."></textarea>
                <button id="send-guess-what-input-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ “你说我猜”HTML代码结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】“你说我猜”游戏结算卡片 ▼▼▼ -->
<div id="guess-what-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="guess-what-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="forward-guess-what-summary-btn">转发给Ta</button>
            <button class="save" id="close-guess-what-summary-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是“心动飞行棋”的所有新HTML代码 ▼▼▼ -->

<!-- 1. 飞行棋游戏设置屏幕 -->
<div id="ludo-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>心动飞行棋 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>选择一位玩伴</label>
            <!-- 邀请列表，我们会用JS来填充 -->
            <div id="ludo-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
            </div>
        </div>
        <!-- ▼▼▼ 在 #ludo-setup-screen 的 "form-container" 内，粘贴这段新代码 ▼▼▼ -->
<div class="form-group">
    <label>选择问题库</label>
    <div style="display: flex; align-items: center; gap: 10px;">
        <select id="ludo-question-bank-select" style="flex-grow: 1;"></select>
        <button id="manage-ludo-question-banks-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; width: auto;">管理题库</button>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

        <button id="start-ludo-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. 飞行棋游戏主界面 -->
<div id="ludo-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-ludo-game-btn">‹ 退出</span>
        <span>心动飞行棋</span>
        <!-- 这里可以放一个重置游戏的按钮 -->
        <span class="action-btn" id="restart-ludo-game-btn" title="重新开始">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="ludo-game-content">
        <!-- 棋盘区域 -->
        <div id="ludo-board-container">
            <div id="ludo-board">
                <!-- 棋盘格子将由JS动态生成 -->
            </div>
            <!-- 玩家棋子 -->
            <div id="ludo-user-piece" class="ludo-piece user"></div>
            <div id="ludo-char-piece" class="ludo-piece char"></div>
        </div>

        <!-- 游戏日志区域 -->
        <div id="ludo-log-container">
            <div id="ludo-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        
        <!-- 玩家操作区 -->
        <div id="ludo-action-area">
            <!-- 用户的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ “心动飞行棋”HTML代码结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里找到你的微博私信列表页面 ▼▼▼ -->
<div id="weibo-dm-list-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-dm-list">‹</span>
        <span id="weibo-dm-list-title">粉丝私信</span>
        <!-- 这是你要求的“继续生成”按钮 -->
        <div class="header-actions">
            <span class="action-btn" id="generate-more-dms-btn" title="继续生成私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            
            <!-- ▼▼▼ 在这里粘贴下面这个全新的“清空全部”按钮 ▼▼▼ -->
            <span class="action-btn" id="clear-all-dms-btn" title="清空全部私信">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                </svg>
            </span>
            <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
            
        </div>
    </div>
    <div id="weibo-dm-list" class="list-container" style="padding: 0;">
        <!-- 私信列表将由JS动态生成 -->
    </div>
</div>


<!-- ▼▼▼ 【全新】这是微博私信详情页面，请粘贴到 #phone-screen 的末尾 ▼▼▼ -->
<div id="weibo-dm-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-dm-detail">‹</span>
        <span id="weibo-dm-detail-title"></span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div id="weibo-dm-messages" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5;">
        <!-- 聊天气泡将由JS动态生成 -->
    </div>
</div>
<!-- ▼▼▼ 把下面这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- index.html -->

<!-- ▼▼▼ 用这整块【已集成饿了么】的代码，替换旧的 id="taobao-screen" 的 div ▼▼▼ -->
<div id="taobao-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>桃宝</span>
        <div class="header-actions">
            <span class="action-btn" id="clear-taobao-products-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            <span class="action-btn" id="add-product-btn" title="添加商品">+</span>
        </div>
    </div>

    <!-- 1. 顶部页签导航 (已加入“饿了么”) -->
    <div class="taobao-tabs">
        <button class="taobao-tab active" data-view="products-view">首页</button>
        <!-- ▼▼▼ 这是新增的“饿了么”页签 ▼▼▼ -->
        <button class="taobao-tab" data-view="eleme-view">饿了么</button>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->
        <button class="taobao-tab" data-view="cart-view">
            购物车<span id="cart-item-count-badge" style="display: none;">0</span>
        </button>
        <button class="taobao-tab" data-view="orders-view">我的订单</button>
        <button class="taobao-tab" data-view="my-view">我的</button>
    </div>

    <!-- 2. 页面内容容器 -->
    <div class="taobao-content">
        <!-- “首页”视图 (保持不变) -->
        <div id="products-view" class="taobao-view active">
            <div class="taobao-search-bar">
                <input type="search" id="product-search-input" placeholder="搜一搜，让AI为你创造好物！">
                <button id="product-search-btn">搜索</button>
            </div>
            <div id="product-category-tabs"></div>
            <div id="product-grid" class="product-grid"></div>
        </div>

        <!-- ▼▼▼ 【全新】这是“饿了么”的内容视图 ▼▼▼ -->
        <div id="eleme-view" class="taobao-view">
<!-- ▼▼▼ 请用这整块代码，完整替换掉上面那块旧的 .taobao-search-bar ▼▼▼ -->
<div class="taobao-search-bar">
    <!-- 新增：这是第一行的“搜索”组 -->
    <div class="eleme-search-group">
        <input type="search" id="eleme-search-input" placeholder="想吃点什么？让AI帮你找！">
        <button id="eleme-search-btn">搜索</button>
    </div>

    <!-- 新增：这是第二行的“功能”组 -->
    <div class="eleme-actions-group">
        <button id="eleme-add-manual-btn" class="header-actions" title="手动添加美食">+</button>
        <button id="eleme-generate-ai-btn" class="header-actions" title="AI生成美食">✨</button>
        <button id="eleme-clear-all-btn" class="header-btn">🗑️</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <div id="eleme-grid" class="product-grid">
                <!-- 美食列表将由JS动态生成在这里 -->
            </div>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->

        <!-- “购物车”视图 (保持不变) -->
        <div id="cart-view" class="taobao-view">
            <div id="cart-item-list"></div>
            <div id="cart-checkout-bar" style="display: none;">
                <div class="total-price">
                    合计: <span id="cart-total-price">¥ 0.00</span>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="share-cart-to-char-btn">分享给Ta代付</button>
                    <button id="buy-for-char-btn">为Ta购买</button>
                    <button id="checkout-btn">结算(0)</button>
                </div>
            </div>
        </div>

        <!-- “我的订单”视图 (保持不变) -->
        <div id="orders-view" class="taobao-view">
            <div id="order-list" class="order-list"></div>
        </div>

        <!-- “我的”视图 (保持不变) -->
        <div id="my-view" class="taobao-view">
            <div id="user-balance-container">
                <p>我的余额</p>
                <h2 id="user-balance-display">¥ 0.00</h2>
                <div style="display: flex; gap: 10px;">
                    <button id="top-up-btn" class="form-button" style="flex: 1;">给钱包充点钱</button>
                    <button id="modify-balance-btn" class="form-button" style="flex: 1; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">修改余额</button>
                </div>
            </div>
            <div id="balance-details-list" class="order-list" style="padding: 0 15px;"></div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 用这块【已添加评价区】的代码，替换旧的 id="product-detail-modal" ▼▼▼ -->
<div id="product-detail-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>商品详情</span>
        </div>
        <div class="modal-body" id="product-detail-body">
            <!-- 详情内容将由JS动态生成 -->
        </div>
        <!-- ★★★ 这是我们新增的评价区域 ★★★ -->
        <div id="product-reviews-section">
            <h3>宝贝评价</h3>
            <div id="product-reviews-list">
                <!-- 评价内容会由JS动态生成在这里 -->
            </div>
            <button id="generate-reviews-btn" class="form-button form-button-secondary">✨ AI生成评价</button>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->
        <div class="modal-footer">
            <button class="cancel" id="close-product-detail-btn">关闭</button>
            <button class="save" id="detail-add-to-cart-btn">加入购物车</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- 2. 添加商品的方式选择弹窗 -->
<div id="add-product-choice-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-header">选择添加方式</div>
        <div class="custom-modal-footer">
            <button id="add-product-manual-btn">手动添加</button>
            <button id="add-product-link-btn">识别链接</button>
            <button id="add-product-ai-btn">AI生成</button>
            <button id="cancel-add-choice-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>

<!-- 3. 手动添加/编辑商品弹窗 -->
<div id="product-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="product-editor-title">添加新商品</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="product-name-input">商品名称</label>
                <input type="text" id="product-name-input">
            </div>
            <div class="form-group">
                <label for="product-price-input">价格 (元)</label>
                <input type="number" id="product-price-input">
            </div>
            <div class="form-group">
                <label for="product-image-input">图片 URL</label>
                <input type="text" id="product-image-input">
            </div>
            <div class="form-group">
                <label for="product-category-input">分类 (选填)</label>
                <input type="text" id="product-category-input" placeholder="例如：衣服, 零食...">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-product-editor-btn">取消</button>
            <button class="save" id="save-product-btn">保存</button>
        </div>
    </div>
</div>

<!-- 4. 识别链接弹窗 -->
<div id="add-from-link-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>粘贴分享文案</span>
        </div>
        <div class="modal-body">
            <textarea id="link-paste-area" rows="6" placeholder="请在这里粘贴完整的淘宝或拼多多分享文案..."></textarea>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-link-paste-btn">取消</button>
            <button class="save" id="confirm-link-paste-btn">识别</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】物流详情页面 -->
<div id="logistics-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="logistics-back-btn">‹</span>
        <span>物流详情</span>
        <span style="width: 30px;"></span> <!-- 占位符，让标题居中 -->
    </div>
    <div id="logistics-content-area" class="list-container">
        <!-- 物流信息将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML，粘贴到 </body> 标签的正上方 ▼▼▼ -->
<!-- ▼▼▼ 【全新】这是“谁是卧底”游戏的全部HTML界面，请粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. “谁是卧底”游戏设置屏幕 -->
<div id="undercover-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>谁是卧底 - 游戏设置</span>
    </div>
<div class="form-container">
    <div class="form-group">
        <label>邀请模式</label>
        <div style="display: flex; gap: 20px;">
            <label style="cursor: pointer;"><input type="radio" name="undercover_invite_mode" value="manual" checked> 手动邀请</label>
            <label style="cursor: pointer;"><input type="radio" name="undercover_invite_mode" value="random"> 随机邀请</label>
        </div>
    </div>

    <!-- 随机邀请的选项 -->
    <div id="undercover-random-invite-options" style="display: none;">
        <div class="form-group">
            <label for="undercover-random-player-count">你想邀请几位AI/NPC？ (不含你自己)</label>
            <input type="number" id="undercover-random-player-count" min="2" max="15" value="5" style="width: 100%; box-sizing: border-box; padding: 10px;">
        </div>
    </div>

    <!-- 手动邀请的选项 -->
    <div id="undercover-manual-invite-options">
        <div class="form-group">
            <label>请勾选要邀请的玩家</label>
            <div id="undercover-player-selection" class="list-container" style="height: 350px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
    </div>
    
    <button id="start-undercover-game-btn" class="form-button">开始游戏</button>
    <p style="text-align: center; color: var(--text-secondary); font-size: 13px; margin-top: 15px;">
        游戏最少需要3人。<br>
        3-5人局：1卧底<br>
        6-8人局：1卧底, 1白板<br>
        9人及以上：2卧底, 1白板
    </p>
</div>
</div>

<!-- 2. “谁是卧底”游戏主界面 -->
<div id="undercover-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-undercover-game-btn">‹ 退出</span>
        <span id="undercover-game-title">谁是卧底</span>
        <span class="action-btn" id="undercover-my-word-btn">我的词语</span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="undercover-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 玩家座位区 -->
        <div id="undercover-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 15px; padding: 10px; flex-shrink: 0;">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <!-- 游戏日志/信息区 -->
        <div id="undercover-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="undercover-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <!-- 玩家操作区 -->
        <div id="undercover-action-area" style="flex-shrink: 0; padding: 10px; display: flex; justify-content: center; align-items: center; gap: 15px; min-height: 50px;">
            <!-- 玩家的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【已修改】的代码，替换掉你旧的 undercover-summary-modal ▼▼▼ -->
<div id="undercover-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="undercover-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <!-- ★★★ 核心修改：我们在这里新增了一个“分享复盘”按钮 ★★★ -->
            <button class="cancel" id="repost-undercover-summary-btn">分享复盘到单聊</button>
            <button class="save" id="back-to-hall-from-undercover-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是User自己的私信功能，请粘贴到 <div id="weibo-screen">...</div> 之后 ▼▼▼ -->

<!-- 1. User私信列表页面 -->
<div id="user-dm-list-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-user-dm-list">‹</span>
        <span>我的私信</span>
        <div class="header-actions">
            <!-- 这个按钮用于让AI生成新的粉丝私信 -->
            <span class="action-btn" id="generate-new-user-dms-btn" title="生成新私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            <!-- 这个按钮用于清空所有私信 -->
            <span class="action-btn" id="clear-all-user-dms-btn" title="清空所有私信">
                 <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
            </span>
        </div>
    </div>
    <div id="user-dm-list-container" class="list-container" style="padding: 0;">
        <!-- 私信列表将由JS动态生成在这里 -->
    </div>
</div>

<!-- 2. User私信详情页面 (与粉丝聊天) -->
<div id="user-dm-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-user-dm-detail">‹</span>
        <span id="user-dm-detail-title"></span> <!-- 粉丝名字 -->
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div id="user-dm-messages-container" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5;">
        <!-- 聊天气泡将由JS动态生成在这里 -->
    </div>
    <!-- 聊天输入框 -->
<!-- ▼▼▼ 【V2版】聊天输入框 (已添加新按钮) ▼▼▼ -->
<div id="user-dm-input-area" class="chat-input-area">
    <div class="chat-input-main-row">
        <textarea id="user-dm-input" rows="1" placeholder="和粉丝聊点什么..."></textarea>
        <!-- 我们用一个新的容器把所有操作按钮包起来 -->
        <div id="input-actions-wrapper">
            <!-- 这是新加的“触发AI回应”按钮 -->
            <button id="user-dm-trigger-ai-btn" class="action-button chat-action-icon-btn" title="让对方先说">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
            </button>
            <!-- 这是新加的“重Roll”按钮 -->
            <button id="user-dm-reroll-btn" class="action-button chat-action-icon-btn" title="重新生成回复">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                </svg>
            </button>
            <!-- 这是你原来的发送按钮 -->
            <button id="user-dm-send-btn" class="action-button">发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>

<!-- ▲▲▲ 全新的 User 私信功能 HTML 结构结束 ▲▲▲ -->


<!-- 【全新】角色微博主页屏幕 -->
<div id="weibo-char-profile-screen" class="screen">
    <!-- 头部，包含返回按钮和角色名字 -->
    <div class="header">
        <span class="back-btn" id="back-from-char-profile">‹</span>
        <span id="weibo-char-profile-title">角色主页</span>
        <div class="header-actions">
            <!-- 为角色主页也添加一个编辑按钮 -->
            <span class="action-btn" id="edit-char-weibo-profile-btn" title="编辑角色资料">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 20h9"></path>
                    <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                </svg>
            </span>
        </div>
    </div>
    <!-- 角色主页的内容区 -->
    <div id="weibo-char-profile-page" class="weibo-profile-page"> <!-- 复用个人主页的滚动样式 -->
        <div class="weibo-profile-header">
            <img id="weibo-char-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
            <div class="weibo-avatar-container">
                <img id="weibo-char-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
                <img id="weibo-char-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
            </div>
            <div class="weibo-nickname" id="weibo-char-nickname">角色昵称</div>
            <div id="weibo-char-profession-display">角色职业</div>
<!-- ▼▼▼ 用这整块代码，替换掉 id="weibo-char-profile-page" 里面那个旧的、只有注释的 <div class="weibo-stats"> ▼▼▼ -->
<div class="weibo-stats">
    <div id="weibo-char-following-item" class="weibo-stat-item" style="cursor: pointer;">
        <span id="weibo-char-following-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">关注</span>
    </div>
    <div id="weibo-char-posts-item" class="weibo-stat-item">
        <span id="weibo-char-posts-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">微博</span>
    </div>
    <div id="weibo-char-fans-item" class="weibo-stat-item" style="cursor: pointer;">
        <span id="weibo-char-fans-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">粉丝</span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        </div>
        <div id="char-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
            <!-- 角色的微博列表将由JS动态生成在这里 -->
        </div>
    </div>
</div>

<!-- 【全新】角色微博资料编辑弹窗 -->
<div id="char-weibo-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>编辑角色微博资料</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>微博头像</label>
                <div class="avatar-upload">
                    <img id="char-weibo-editor-avatar-preview">
                    <button onclick="document.getElementById('char-weibo-editor-avatar-input').click()">上传头像</button>
                    <button class="change-frame-btn" data-type="char-weibo">更换头像框</button>
                    <input type="file" id="char-weibo-editor-avatar-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label for="char-weibo-editor-nickname-input">微博昵称</label>
                <input type="text" id="char-weibo-editor-nickname-input">
            </div>
            <div class="form-group">
                <label>微博背景</label>
                <div class="avatar-upload">
                    <img id="char-weibo-editor-bg-preview" style="width: 120px; height: 67.5px; border-radius: 8px;">
                    <button onclick="document.getElementById('char-weibo-editor-bg-input').click()">上传背景</button>
                    <input type="file" id="char-weibo-editor-bg-input" accept="image/*" hidden>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-char-weibo-editor-btn">取消</button>
            <button class="save" id="save-char-weibo-editor-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【已添加新按钮】的代码，替换你旧的 id="date-a-live-screen" ▼▼▼ -->
<div id="date-a-live-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>约会大作战</span>
        <div class="header-actions">

            <!-- ★★★★★ 这就是我们为你新增的“+”号按钮 ★★★★★ -->
            <span class="action-btn" id="create-dating-scene-btn" title="创建新场景">
                 <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </span>
            <!-- ★★★★★ 新增结束 ★★★★★ -->

            <span class="action-btn" id="dating-history-btn" title="历史约会">
                 <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <polyline points="3 3 3 8 8 8"/>
                    <path d="M12 6V12L16 14"/>
                 </svg>
            </span>
            <span class="action-btn" id="refresh-dating-scene-btn" title="刷新场景">
                 <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </span>
        </div>
    </div>
    <div id="dating-scene-content" class="list-container">
        <!-- 约会场景卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->




<!-- ▼▼▼ 【增强版】宠物功能模态框 ▼▼▼ -->
<div id="pet-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span id="pet-modal-title">我的宠物</span>
        </div>
        <div class="modal-body">
            <!-- 宠物信息预览区 -->
            <div id="pet-preview-area" style="text-align: center; margin-bottom: 20px;">
                <div id="pet-preview-display" style="font-size: 60px; line-height: 1; margin-bottom: 10px; cursor: pointer;" title="点击更换图片"></div>
                <strong id="pet-preview-name" style="font-size: 18px;"></strong>
                <p id="pet-preview-type" style="font-size: 14px; color: var(--text-secondary); margin: 5px 0;"></p>
            </div>

            <!-- 宠物数值显示区 -->
            <div id="pet-stats-area" style="display: none;">
                <div id="pet-hunger-bar" class="stat-bar-container">
                    <span class="stat-label">饱食度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
                </div>
                <div id="pet-happiness-bar" class="stat-bar-container">
                    <span class="stat-label">心情值</span>
                    <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
                </div>
                <div id="pet-intimacy-user-bar" class="stat-bar-container">
                    <span class="stat-label">对你的亲密度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
                </div>
                <div id="pet-intimacy-char-bar" class="stat-bar-container">
                    <span class="stat-label">对Ta的亲密度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
                </div>
            </div>

            <!-- 互动按钮区 (已新增“对话”按钮) -->
            <div id="pet-interaction-area" style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);">
                <button class="form-button-secondary" data-action="feed">喂食</button>
                <button class="form-button-secondary" data-action="play">玩耍</button>
                <button class="form-button-secondary" data-action="touch">抚摸</button>
                <button class="form-button-secondary" data-action="chat">对话</button>
            </div>
            
            <!-- 设置区 -->
            <div class="form-group">
                <label for="pet-type-input">种类 (自由填写)</label>
                <input type="text" id="pet-type-input" placeholder="例如: 小猫, 仓鼠, 太阳花...">
            </div>
             <div class="form-group">
                <label for="pet-name-input">昵称</label>
                <input type="text" id="pet-name-input" placeholder="给它起个名字吧">
            </div>
             <div class="form-group">
                <label for="pet-image-input">初始样子 (Emoji 或 图片URL)</label>
                <input type="text" id="pet-image-input" placeholder="输入一个 Emoji 比如 🐈 或图片链接">
            </div>
            <!-- 【全新】人设输入框 -->
            <div class="form-group">
                <label for="pet-persona-input">宠物人设与背景</label>
                <textarea id="pet-persona-input" rows="3" placeholder="描述一下它的性格和故事，AI会根据这个来扮演它。"></textarea>
            </div>
            <div class="form-group">
                <label class="toggle-switch-label">
                    <span>在聊天界面显示</span>
                    <input type="checkbox" id="pet-display-toggle">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div id="pet-position-controls" style="display:none;">
                <div class="form-group">
                    <label for="pet-size-slider">大小: <span id="pet-size-value">100px</span></label>
                    <input type="range" id="pet-size-slider" min="30" max="200" value="100" style="width: 100%;">
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <!-- ▼▼▼ 在这里添加新按钮 ▼▼▼ -->
            <button class="cancel" id="pet-abandon-btn" style="background-color: #ffdde5; color: #ff3b30; border-color: #ffc2d1;">放生宠物</button>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <button class="cancel" id="pet-modal-cancel-btn">取消</button>
            <button class="save" id="pet-modal-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 我的钱包模态框 ▼▼▼ -->
<div id="wallet-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span>我的钱包</span>
        </div>
        <div class="modal-body">
            <!-- 余额显示区 -->
            <div style="text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; margin-bottom: 20px; color: white;">
                <p style="font-size: 14px; margin-bottom: 5px; opacity: 0.9;">我的余额</p>
                <h1 id="wallet-balance-display" style="font-size: 36px; margin: 10px 0; font-weight: bold;">¥ 520.00</h1>
                <p style="font-size: 12px; opacity: 0.8;">与桃宝余额同步</p>
            </div>

            <!-- 功能按钮区 -->
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button id="wallet-modify-balance-btn" class="form-button" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 15px; font-size: 16px;">
                    💰 修改余额
                </button>
                <button id="wallet-family-card-btn" class="form-button-secondary" style="padding: 15px; font-size: 16px;">
                    👨‍👩‍👧 亲属卡
                </button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="wallet-modal-close-btn">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 我的钱包模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 记账模态框 ▼▼▼ -->
<div id="accounting-modal" class="modal">
    <div class="modal-content" style="height: 85%; max-height: 85%;">
        <div class="modal-header">
            <span>记账本</span>
        </div>
        <div class="modal-body" style="padding: 0; display: flex; flex-direction: column; overflow: hidden;">
            <!-- Tab切换 -->
            <div id="accounting-tabs" style="display: flex; border-bottom: 2px solid #f0f0f0; background: white;">
                <div class="accounting-tab active" data-tab="record" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; border-bottom: 3px solid #667eea; color: #667eea;">
                    记一笔
                </div>
                <div class="accounting-tab" data-tab="list" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">
                    账单
                </div>
                <div class="accounting-tab" data-tab="goals" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">
                    财务目标
                </div>
            </div>

            <!-- 记一笔面板 -->
            <div id="accounting-record-panel" class="accounting-panel" style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- 支出/收入切换 -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button id="expense-tab-btn" class="accounting-type-btn active" data-type="expense" style="flex: 1; padding: 12px; border: 2px solid #ff6b6b; background: #ff6b6b; color: white; border-radius: 8px; font-size: 16px; font-weight: 500; cursor: pointer;">
                        支出
                    </button>
                    <button id="income-tab-btn" class="accounting-type-btn" data-type="income" style="flex: 1; padding: 12px; border: 2px solid #51cf66; background: white; color: #51cf66; border-radius: 8px; font-size: 16px; font-weight: 500; cursor: pointer;">
                        收入
                    </button>
                </div>

                <!-- 金额输入 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">金额</label>
                    <div style="position: relative;">
                        <span style="position: absolute; left: 15px; top: 50%; transform: translateY(-50%); font-size: 24px; color: #333;">¥</span>
                        <input type="number" id="accounting-amount" placeholder="0.00" step="0.01" style="width: 100%; padding: 15px 15px 15px 40px; font-size: 24px; border: 2px solid #e0e0e0; border-radius: 8px; text-align: right;">
                    </div>
                </div>

                <!-- 分类选择 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">分类</label>
                    <div id="accounting-categories" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                        <!-- 分类按钮将由JS动态生成 -->
                    </div>
                    <button id="add-category-btn" style="width: 100%; padding: 10px; margin-top: 10px; border: 2px dashed #ddd; background: white; color: #999; border-radius: 8px; cursor: pointer;">
                        + 自定义分类
                    </button>
                </div>

                <!-- 备注 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">备注</label>
                    <textarea id="accounting-note" placeholder="添加备注..." style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; resize: none; font-size: 14px;" rows="3"></textarea>
                </div>

                <!-- 日期选择 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">日期</label>
                    <input type="date" id="accounting-date" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                </div>

                <!-- 是否通知CHAR -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label for="notify-char-toggle" class="toggle-switch-label">
                        <span>通知当前角色</span>
                        <input type="checkbox" id="notify-char-toggle" checked>
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">开启后，角色会看到这笔账并可能回复你。关闭后，角色完全看不到记账内容</p>
                </div>

                <!-- 保存按钮 -->
                <button id="save-accounting-btn" class="form-button" style="width: 100%; padding: 15px; font-size: 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    保存记录
                </button>
            </div>

            <!-- 账单列表面板 -->
            <div id="accounting-list-panel" class="accounting-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none;">
                <!-- 统计卡片 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); padding: 20px; border-radius: 12px; color: white;">
                        <p style="font-size: 12px; opacity: 0.9; margin-bottom: 5px;">总支出</p>
                        <h3 id="total-expense-display" style="font-size: 24px; margin: 0;">¥ 0.00</h3>
                    </div>
                    <div style="background: linear-gradient(135deg, #51cf66 0%, #40c057 100%); padding: 20px; border-radius: 12px; color: white;">
                        <p style="font-size: 12px; opacity: 0.9; margin-bottom: 5px;">总收入</p>
                        <h3 id="total-income-display" style="font-size: 24px; margin: 0;">¥ 0.00</h3>
                    </div>
                </div>

                <!-- 时间筛选 -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; padding: 10px 0;">
                    <button class="time-filter-btn active" data-filter="all" style="padding: 12px 24px; border: 2px solid #667eea; background: #667eea; color: white; border-radius: 25px; white-space: nowrap; cursor: pointer; font-size: 15px; font-weight: 600; min-height: 44px;">全部</button>
                    <button class="time-filter-btn" data-filter="today" style="padding: 12px 24px; border: 2px solid #ddd; background: white; color: #666; border-radius: 25px; white-space: nowrap; cursor: pointer; font-size: 15px; font-weight: 600; min-height: 44px;">今天</button>
                    <button class="time-filter-btn" data-filter="week" style="padding: 12px 24px; border: 2px solid #ddd; background: white; color: #666; border-radius: 25px; white-space: nowrap; cursor: pointer; font-size: 15px; font-weight: 600; min-height: 44px;">本周</button>
                    <button class="time-filter-btn" data-filter="month" style="padding: 12px 24px; border: 2px solid #ddd; background: white; color: #666; border-radius: 25px; white-space: nowrap; cursor: pointer; font-size: 15px; font-weight: 600; min-height: 44px;">本月</button>
                </div>

                <!-- 记录列表 -->
                <div id="accounting-records-list">
                    <!-- 记录将由JS动态生成 -->
                </div>
            </div>

            <!-- 财务目标面板 -->
            <div id="accounting-goals-panel" class="accounting-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none;">
                <h3 style="margin-bottom: 15px; font-size: 18px;">设置财务目标</h3>
                
                <!-- 目标类型选择 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">目标周期</label>
                    <select id="goal-period" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                        <option value="daily">每天</option>
                        <option value="weekly">每周</option>
                        <option value="monthly">每月</option>
                        <option value="custom">自定义时间段</option>
                    </select>
                </div>

                <!-- 自定义时间段 -->
                <div id="custom-period-inputs" style="display: none; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px;">
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #666; margin-bottom: 5px; display: block;">开始日期</label>
                            <input type="date" id="goal-start-date" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #666; margin-bottom: 5px; display: block;">结束日期</label>
                            <input type="date" id="goal-end-date" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                        </div>
                    </div>
                </div>

                <!-- 支出目标 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">支出上限（元）</label>
                    <input type="number" id="goal-expense-limit" placeholder="不限制" step="0.01" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                </div>

                <!-- 收入目标 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">收入目标（元）</label>
                    <input type="number" id="goal-income-target" placeholder="不设置" step="0.01" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                </div>

                <!-- 提醒设置 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label for="goal-reminder-toggle" class="toggle-switch-label">
                        <span>超支提醒</span>
                        <input type="checkbox" id="goal-reminder-toggle" checked>
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">当支出接近或超过目标时提醒</p>
                </div>

                <!-- 保存目标按钮 -->
                <button id="save-goal-btn" class="form-button" style="width: 100%; padding: 15px; font-size: 16px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                    保存目标
                </button>

                <!-- 当前目标显示 -->
                <div id="current-goals-display" style="margin-top: 30px;">
                    <h4 style="margin-bottom: 15px; font-size: 16px; color: #666;">当前目标</h4>
                    <div id="goals-list">
                        <!-- 目标列表将由JS动态生成 -->
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="accounting-modal-close-btn">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 记账模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 月经追踪模态框 ▼▼▼ -->
<div id="period-tracker-modal" class="modal">
    <div class="modal-content" style="height: 85%; max-height: 85%;">
        <div class="modal-header">
            <span>月经追踪</span>
        </div>
        <div class="modal-body" style="padding: 0; display: flex; flex-direction: column; overflow: hidden;">
            <!-- Tab切换 -->
            <div id="period-tabs" style="display: flex; border-bottom: 2px solid #f0f0f0; background: white;">
                <div class="period-tab active" data-tab="calendar" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; border-bottom: 3px solid #ff6b9d; color: #ff6b9d;">
                    日历
                </div>
                <div class="period-tab" data-tab="settings" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">
                    经期设置
                </div>
                <div class="period-tab" data-tab="stats" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">
                    统计
                </div>
            </div>

            <!-- 日历面板 -->
            <div id="period-calendar-panel" class="period-panel" style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- 月份导航 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <button id="prev-month-btn" style="padding: 8px 12px; border: 1px solid #ddd; background: white; border-radius: 8px; cursor: pointer; font-size: 18px;">←</button>
                    <h3 id="current-month-display" style="margin: 0; font-size: 18px; font-weight: 600;">2024年1月</h3>
                    <button id="next-month-btn" style="padding: 8px 12px; border: 1px solid #ddd; background: white; border-radius: 8px; cursor: pointer; font-size: 18px;">→</button>
                </div>

                <!-- 星期标题 -->
                <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-bottom: 10px;">
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">日</div>
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">一</div>
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">二</div>
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">三</div>
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">四</div>
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">五</div>
                    <div style="text-align: center; font-size: 12px; color: #999; padding: 8px;">六</div>
                </div>

                <!-- 日历格子 -->
                <div id="calendar-grid" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px;">
                    <!-- 日期将由JS动态生成 -->
                </div>

                <!-- 标记说明 -->
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">图例说明</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 30px; height: 30px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); border-radius: 6px;"></div>
                            <span style="font-size: 12px; color: #666;">经期日（根据设置自动标记）</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 30px; height: 30px; background: white; border: 2px solid #ff6b9d; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: #ff6b9d;">3</div>
                            <span style="font-size: 12px; color: #666;">手动标记（点击日期标记第几天）</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 30px; height: 30px; background: #e3f2fd; border-radius: 6px;"></div>
                            <span style="font-size: 12px; color: #666;">预测经期（根据周期计算）</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 经期设置面板 -->
            <div id="period-settings-panel" class="period-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none;">
                <h3 style="margin-bottom: 15px; font-size: 18px;">经期基本设置</h3>
                
                <!-- 上次经期开始日期 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">上次经期开始日期</label>
                    <input type="date" id="last-period-start" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">请选择您最近一次经期的开始日期</p>
                </div>

                <!-- 经期持续天数 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">经期持续天数</label>
                    <input type="number" id="period-duration" min="1" max="10" value="7" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">通常为3-7天</p>
                </div>

                <!-- 经期周期 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="font-size: 14px; color: #666; margin-bottom: 8px; display: block;">经期周期（天）</label>
                    <input type="number" id="period-cycle" min="21" max="35" value="28" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">从月经第一天到下次月经第一天的天数，通常为21-35天</p>
                </div>

                <!-- 是否通知CHAR -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label for="notify-char-period-toggle" class="toggle-switch-label">
                        <span>通知角色</span>
                        <input type="checkbox" id="notify-char-period-toggle" checked>
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">开启后，角色会知道您的经期情况并做出关心回复</p>
                </div>

                <!-- 保存按钮 -->
                <button id="save-period-settings-btn" class="form-button" style="width: 100%; padding: 15px; font-size: 16px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%);">
                    保存设置
                </button>

                <!-- 当前设置显示 -->
                <div id="current-period-info" style="margin-top: 30px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">当前设置</h4>
                    <div id="period-info-content" style="font-size: 13px; color: #666; line-height: 1.8;">
                        暂无设置
                    </div>
                </div>
            </div>

            <!-- 统计面板 -->
            <div id="period-stats-panel" class="period-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none;">
                <h3 style="margin-bottom: 15px; font-size: 18px;">经期统计</h3>
                
                <!-- 统计卡片 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); padding: 20px; border-radius: 12px; color: white;">
                        <p style="font-size: 12px; opacity: 0.9; margin-bottom: 5px;">平均周期</p>
                        <h3 id="avg-cycle-display" style="font-size: 24px; margin: 0;">-- 天</h3>
                    </div>
                    <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 20px; border-radius: 12px; color: white;">
                        <p style="font-size: 12px; opacity: 0.9; margin-bottom: 5px;">平均持续</p>
                        <h3 id="avg-duration-display" style="font-size: 24px; margin: 0;">-- 天</h3>
                    </div>
                </div>

                <!-- 下次预测 -->
                <div style="background: white; border: 2px solid #ff6b9d; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 16px; color: #333;">📅 下次经期预测</h4>
                    <p id="next-period-prediction" style="font-size: 14px; color: #666; margin: 0;">
                        请先在"经期设置"中设置您的经期信息
                    </p>
                </div>

                <!-- 历史记录 -->
                <div>
                    <h4 style="margin: 0 0 15px 0; font-size: 16px; color: #333;">📝 手动标记记录</h4>
                    <div id="period-marks-history">
                        <!-- 历史记录将由JS动态生成 -->
                        <p style="font-size: 14px; color: #999; text-align: center; padding: 20px;">暂无标记记录</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="period-modal-close-btn">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 月经追踪模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 学习中心模态框 ▼▼▼ -->
<div id="study-modal" class="modal">
    <div class="modal-content" style="height: 90%; max-height: 90%; width: 95%; max-width: 800px;">
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center;">
            <span>学习中心</span>
            <button id="study-ask-char-btn" style="background: none; border: none; color: #ff6b9d; font-size: 14px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                求助CHAR
            </button>
        </div>
        <div class="modal-body" style="padding: 0; display: flex; flex-direction: column; overflow: hidden; height: 100%;">
            <!-- Tab切换 -->
            <div id="study-tabs" style="display: flex; border-bottom: 2px solid #f0f0f0; background: white; flex-shrink: 0;">
                <div class="study-tab active" data-tab="practice" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; border-bottom: 3px solid #ff6b9d; color: #ff6b9d;">练习</div>
                <div class="study-tab" data-tab="exam" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">考试</div>
                <div class="study-tab" data-tab="banks" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">题库</div>
                <div class="study-tab" data-tab="goals" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">目标</div>
                <div class="study-tab" data-tab="stats" style="flex: 1; text-align: center; padding: 15px; cursor: pointer; font-weight: 500; color: #666;">统计</div>
            </div>

            <!-- 练习面板 -->
            <div id="study-practice-panel" class="study-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px;">
                <!-- 练习设置 (开始前) -->
                <div id="practice-setup-view">
                    <h3 style="margin-bottom: 20px;">开始每日练习</h3>
                    <div class="form-group">
                        <label style="display:block; margin-bottom:5px; color:#666;">选择科目</label>
                        <select id="practice-subject-select" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #e0e0e0; background: white; font-size:14px;">
                            <option value="">加载中...</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label style="display:block; margin-bottom:5px; color:#666;">题目数量</label>
                        <select id="practice-count-select" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #e0e0e0; background: white; font-size:14px;">
                            <option value="5">5题</option>
                            <option value="10" selected>10题</option>
                            <option value="20">20题</option>
                            <option value="50">50题</option>
                        </select>
                        <div style="font-size: 12px; color: #999; margin: 10px 0 4px;">或输入自定义题量</div>
                        <input type="number" id="practice-count-custom" min="1" max="999" placeholder="请输入题数" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e0e0e0;">
                    </div>
                    <!-- 是否通知角色 -->
                    <div class="form-group" style="margin-top: 20px; margin-bottom: 20px;">
                        <label for="notify-char-study-toggle" class="toggle-switch-label">
                            <span>通知角色</span>
                            <input type="checkbox" id="notify-char-study-toggle">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <div style="font-size: 12px; color: #999; margin-top: 8px;">关闭后，角色将完全不知道你的学习情况</div>
                    </div>
                    <button id="start-practice-btn" class="form-button" style="width: 100%; padding: 15px; margin-top: 10px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer;">开始练习</button>
                </div>
                <!-- 练习进行中 (隐藏) -->
                <div id="practice-active-view" style="display: none; flex: 1; flex-direction: column; height:100%;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 15px; align-items: center;">
                        <span id="practice-subject-label" style="font-weight: bold; color: #333; font-size: 16px;">高数</span>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span id="practice-timer" style="font-family: monospace; background: #f0f0f0; padding: 4px 8px; border-radius: 4px;">00:00</span>
                            <span id="practice-progress-label" style="color: #666;">1/10</span>
                        </div>
                    </div>
                    <div id="question-container" style="flex: 1; min-height: 200px; max-height: 400px; background: #f8f9fa; border-radius: 12px; padding: 20px; margin-bottom: 20px; overflow-y: auto; border: 1px solid #eee;">
                        <!-- Question Content -->
                        <div id="question-type-badge" style="display: inline-block; padding: 4px 8px; background: #e3f2fd; color: #2196f3; border-radius: 4px; font-size: 12px; margin-bottom: 10px;">单选题</div>
                        <div id="question-text" style="font-size: 18px; line-height: 1.8; color: #333; padding: 10px 0;"></div>
                        
                        <!-- Drawing Area (Canvas) -->
                        <div id="drawing-area" style="display: none; margin-top: 20px;">
                            <canvas id="question-canvas" width="600" height="300" style="border: 1px solid #ccc; background: white; width: 100%; touch-action: none;"></canvas>
                            <div style="margin-top: 10px; display: flex; gap: 10px;">
                                <button id="clear-canvas-btn" style="padding: 5px 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">清除</button>
                                <input type="color" id="canvas-color" value="#000000">
                            </div>
                        </div>
                    </div>
                    
                    <div id="options-area" style="margin-bottom: 20px;">
                        <!-- Options generated by JS -->
                    </div>

                    <div id="answer-feedback" style="display: none; padding: 15px; background: #e8f5e9; border-radius: 8px; margin-bottom: 15px; color: #2e7d32;">
                        <!-- Feedback -->
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button id="submit-answer-btn" class="form-button" style="flex: 1; padding: 12px; background: #4caf50; color: white; border: none; border-radius: 8px; font-size: 15px;">提交答案</button>
                        <button id="next-question-btn" class="form-button" style="flex: 1; padding: 12px; display: none; background: #2196f3; color: white; border: none; border-radius: 8px; font-size: 15px;">下一题</button>
                        <button id="quit-practice-btn" style="padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 8px; color: #666;">退出</button>
                    </div>
                </div>
            </div>

            <!-- 考试面板 -->
            <div id="study-exam-panel" class="study-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none; flex-direction: column; gap: 20px;">
                <div id="exam-setup-view">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <div style="width: 80px; height: 80px; background: #e3f2fd; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
                            <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#2196f3" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                        </div>
                        <h3 style="margin-bottom: 10px;">模拟考试</h3>
                        <p style="color: #666;">考试模式下将记录分数，请认真作答。<br>考试期间无法查看答案。</p>
                    </div>
                    
                    <div class="form-group">
                        <label style="display:block; margin-bottom:5px; color:#666;">选择考试科目</label>
                        <select id="exam-subject-select" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #e0e0e0; background: white; font-size:14px;"></select>
                    </div>
                     <div class="form-group" style="margin-top: 15px;">
                        <label style="display:block; margin-bottom:5px; color:#666;">题目数量</label>
                        <select id="exam-count-select" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #e0e0e0; background: white; font-size:14px;">
                            <option value="10">10题</option>
                            <option value="20" selected>20题</option>
                            <option value="50">50题</option>
                            <option value="100">100题</option>
                        </select>
                        <div style="font-size: 12px; color: #999; margin: 10px 0 4px;">或输入自定义题量</div>
                        <input type="number" id="exam-count-custom" min="1" max="999" placeholder="请输入题数" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e0e0e0;">
                    </div>
                    <!-- 是否通知角色 -->
                    <div class="form-group" style="margin-top: 20px; margin-bottom: 20px;">
                        <label for="notify-char-exam-toggle" class="toggle-switch-label">
                            <span>通知角色</span>
                            <input type="checkbox" id="notify-char-exam-toggle">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <div style="font-size: 12px; color: #999; margin-top: 8px;">关闭后，角色将完全不知道你的学习情况</div>
                    </div>
                    
                    <button id="start-exam-btn" class="form-button" style="width: 100%; padding: 15px; margin-top: 10px; background: linear-gradient(135deg, #2196f3 0%, #21cbf3 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer;">开始考试</button>
                </div>
                
                <div id="exam-active-view" style="display: none; flex: 1; flex-direction: column; height: 100%;">
                    <!-- Reuse similar structure to practice but without immediate feedback -->
                    <div style="display: flex; justify-content: space-between; margin-bottom: 15px; align-items: center;">
                        <span id="exam-subject-label" style="font-weight: bold; color: #333; font-size: 16px;">高数 - 考试中</span>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <span id="exam-timer" style="font-family: monospace; background: #ffebee; color: #c62828; padding: 4px 8px; border-radius: 4px;">00:00</span>
                            <span id="exam-progress-label" style="color: #666;">1/20</span>
                        </div>
                    </div>
                    <div id="exam-question-container" style="flex: 1; min-height: 200px; max-height: 400px; background: #f8f9fa; border-radius: 12px; padding: 20px; margin-bottom: 20px; overflow-y: auto; border: 1px solid #eee;">
                         <div id="exam-question-text" style="font-size: 18px; line-height: 1.8; color: #333; padding: 10px 0;"></div>
                         <div id="exam-drawing-area" style="display: none; margin-top: 20px;">
                            <canvas id="exam-question-canvas" width="600" height="300" style="border: 1px solid #ccc; background: white; width: 100%; touch-action: none;"></canvas>
                            <div style="margin-top: 10px; display: flex; gap: 10px;">
                                <button id="exam-clear-canvas-btn" style="padding: 5px 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">清除</button>
                                <input type="color" id="exam-canvas-color" value="#000000">
                            </div>
                        </div>
                    </div>
                    <div id="exam-options-area" style="margin-bottom: 20px;"></div>
                    
                    <div style="display: flex; gap: 10px;">
                         <button id="exam-prev-btn" class="form-button" style="flex: 1; padding: 12px; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 8px; font-size: 15px; display: none;">上一题</button>
                         <button id="exam-next-btn" class="form-button" style="flex: 1; padding: 12px; background: #2196f3; color: white; border: none; border-radius: 8px; font-size: 15px;">下一题</button>
                         <button id="exam-submit-paper-btn" class="form-button" style="flex: 1; padding: 12px; background: #ff9800; color: white; border: none; border-radius: 8px; font-size: 15px; display: none;">交卷</button>
                    </div>
                </div>

                <!-- 考试结果 -->
                <div id="exam-result-view" style="display: none; text-align: center; padding: 20px;">
                     <div style="width: 100px; height: 100px; background: #e8f5e9; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
                        <span id="exam-score-display" style="font-size: 36px; font-weight: bold; color: #2e7d32;">90</span>
                     </div>
                     <h3 style="margin-bottom: 10px;">考试结束</h3>
                     <p id="exam-result-detail" style="color: #666; margin-bottom: 30px;">共 20 题，答对 18 题</p>
                     <button id="exam-back-btn" class="form-button" style="padding: 12px 30px; background: #2196f3; color: white; border: none; border-radius: 8px;">返回</button>
                </div>
            </div>

            <!-- 题库面板 -->
            <div id="study-banks-panel" class="study-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none; flex-direction: column; gap: 20px;">
                <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 13px; color: #e65100;">
                    ⚠️ 重要提示：首次使用或题目数量不足时，请先点击下方"刷新题库"按钮，等待题库加载完成后再开始练习或考试！
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; gap: 10px;">
                    <h3 style="margin: 0;">我的题库</h3>
                    <div style="display: flex; gap: 10px;">
                        <button id="refresh-question-banks-btn" style="padding: 8px 15px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); color: white; border: none; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 5px; font-weight: bold;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>
                            刷新题库
                        </button>
                        <button id="import-bank-btn" style="padding: 8px 15px; background: #e3f2fd; color: #2196f3; border: none; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                            <span>+</span> 导入题库
                        </button>
                    </div>
                    <input type="file" id="bank-file-input" accept=".json,.txt" style="display: none;">
                </div>
                
                <div id="banks-list" style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- Banks generated by JS -->
                </div>
            </div>

            <!-- 目标面板 -->
            <div id="study-goals-panel" class="study-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none; flex-direction: column; gap: 20px;">
                 <div class="card" style="background: white; border: 1px solid #eee; border-radius: 12px; padding: 24px;">
                     <div style="margin-bottom: 20px;">
                        <h3 style="margin: 0 0 6px 0;">学习目标设置</h3>
                        <p style="margin: 0; color: #888; font-size: 13px;">先设定你的计划，再去挑战它。</p>
                     </div>
                     <div class="form-group" style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 500;">每日刷题目标</label>
                        <input type="number" id="goal-daily-input" class="form-input" placeholder="例如：10" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                     </div>
                     <div class="form-group" style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 500;">每周刷题目标</label>
                        <input type="number" id="goal-weekly-input" class="form-input" placeholder="例如：50" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                     </div>
                     <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 500;">每月刷题目标</label>
                        <input type="number" id="goal-monthly-input" class="form-input" placeholder="例如：200" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                     </div>
                     <button id="save-goals-btn" class="form-button" style="width: 100%; padding: 12px; background: #4caf50; color: white; border: none; border-radius: 8px;">保存目标</button>
                 </div>
                 
                 <div class="card" style="background: white; border: 1px solid #eee; border-radius: 12px; padding: 24px;">
                     <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">当前进度</h3>
                        <span id="goals-progress-summary" style="font-size: 13px; color: #999;">今日 0 / -</span>
                     </div>
                     <div id="goals-progress-container">
                         <!-- Goals Progress generated by JS -->
                     </div>
                 </div>
            </div>

            <!-- 统计面板 -->
            <div id="study-stats-panel" class="study-panel" style="flex: 1; overflow-y: auto; padding: 20px; display: none; flex-direction: column; gap: 20px;">
                <h3>学习记录</h3>
                <div id="study-stats-summary" style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; margin-top: 15px;">
                    <div style="background: #e3f2fd; padding: 20px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 13px; color: #1976d2; margin-bottom: 5px;">总刷题数</div>
                        <div id="stat-total-questions" style="font-size: 28px; font-weight: bold; color: #1565c0;">0</div>
                    </div>
                    <div style="background: #e8f5e9; padding: 20px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 13px; color: #2e7d32; margin-bottom: 5px;">平均正确率</div>
                        <div id="stat-accuracy" style="font-size: 28px; font-weight: bold; color: #2e7d32;">0%</div>
                    </div>
                </div>
                
                <h4 style="margin-top: 30px; margin-bottom: 15px;">最近练习/考试</h4>
                <div id="study-history-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- History generated by JS -->
                     <div style="text-align: center; color: #999; padding: 20px;">暂无记录</div>
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="study-modal-close-btn">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 学习中心模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 消息存放模态框 ▼▼▼ -->
<div id="message-storage-modal" class="modal">
    <div class="modal-content" style="max-width: 800px; width: 90%; max-height: 85vh;">
        <div class="modal-header">
            <span>消息存放</span>
        </div>
        <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 150px);">
            <div style="margin-bottom: 20px;">
                <button id="add-storage-slot-btn" style="width: 100%; padding: 15px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    新增存储位
                </button>
            </div>
            
            <div id="storage-slots-container" style="display: flex; flex-direction: column; gap: 15px;">
                <!-- 存储位列表将在这里动态生成 -->
                <div style="text-align: center; color: #999; padding: 40px 20px;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" style="margin: 0 auto 15px;">
                        <path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM7 10H17V12H7V10ZM7 13H17V15H7V13ZM7 7H17V9H7V7Z"/>
                    </svg>
                    <p>暂无存储位</p>
                    <p style="font-size: 12px; color: #ccc;">点击上方按钮创建新的消息存储位</p>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="message-storage-close-btn">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 消息存放模态框结束 ▲▲▲ -->

<!-- ▼▼▼ 编辑存储位模态框 ▼▼▼ -->
<div id="edit-storage-slot-modal" class="modal">
    <div class="modal-content" style="max-width: 700px; width: 90%; max-height: 90vh;">
        <div class="modal-header">
            <span id="edit-storage-slot-title">编辑存储位</span>
        </div>
        <div class="modal-body" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 180px);">
            <div class="form-group" style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #333;">存储位名称</label>
                <input type="text" id="storage-slot-name-input" placeholder="给这个存储位起个名字..." style="width: 100%; padding: 12px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
            </div>
            
            <div class="form-group" style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #333;">消息列表</label>
                <div id="messages-list-container" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px;">
                    <!-- 消息列表将在这里动态生成 -->
                </div>
                <button id="add-message-btn" style="width: 100%; padding: 10px; background: #f5f5f5; color: #666; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    添加消息
                </button>
            </div>
            
            <div style="margin-top: 20px; padding: 12px; background: #f0f7ff; border-radius: 8px; font-size: 13px; color: #1976d2;">
                <strong>💡 使用提示：</strong><br>
                • 每个存储位可以存放多条消息<br>
                • 点击存储位后会按顺序自动发送所有消息<br>
                • 每条消息之间会有短暂间隔
            </div>
        </div>
        <div class="modal-footer" style="display: flex; gap: 10px;">
            <button class="cancel" id="cancel-edit-storage-btn" style="flex: 1;">取消</button>
            <button id="save-storage-slot-btn" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer;">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 编辑存储位模态框结束 ▲▲▲ -->

<input type="file" id="pet-custom-image-input" accept="image/*" style="display: none;">
<!-- ▼▼▼ 【全新】宠物聊天模态框 ▼▼▼ -->
<div id="pet-chat-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="pet-chat-title">和宠物的对话</span>
        </div>
        <div id="pet-chat-messages" class="modal-body" style="background-color: #f0f2f5; display: flex; flex-direction: column; gap: 15px;">
            <!-- 宠物聊天记录将显示在这里 -->
        </div>
        <!-- 复用主聊天输入框的样式 -->
        <div id="pet-chat-input-area" class="chat-input-area" style="border-top: 1px solid var(--border-color);">
            <div class="chat-input-main-row">
                <textarea id="pet-chat-input" rows="1" placeholder="和它说点什么..."></textarea>
                <button id="send-to-pet-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 宠物功能模态框结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是微博专用的、支持多选和滚动的角色选择弹窗 ▼▼▼ -->
<div id="weibo-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择生成内容的主角</span>
        </div>
        <!-- ▼▼▼ 角色互识开关 ▼▼▼ -->
        <div style="padding: 15px; border-bottom: 1px solid #eee;">
            <label for="char-mutual-recognition-toggle" class="toggle-switch-label" style="margin: 0;">
                <span class="toggle-switch-text" style="font-size: 14px;">
                    角色互识开关
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 3px;">
                        开启：角色间默认相互认识；关闭：仅在NPC库/描述/世界书中提及时认识
                    </p>
                </span>
                <input type="checkbox" id="char-mutual-recognition-toggle" checked>
                <span class="toggle-switch-slider"></span>
            </label>
        </div>
        <!-- ▲▲▲ 角色互识开关结束 ▲▲▲ -->
        <div class="modal-body" id="weibo-char-selector-list" style="padding: 0; overflow-y: auto;">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="weibo-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="weibo-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="weibo-cancel-char-select-btn">取消</button>
            <button class="save" id="weibo-confirm-char-select-btn">确认</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣空间-情绪日记编辑弹窗 -->
<div id="ls-diary-editor-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="ls-diary-editor-title">记录今天的心情</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>选择一个表情代表今天的心情</label>
                <div id="ls-emoji-selector" style="display: flex; flex-wrap: wrap; gap: 10px; font-size: 24px; cursor: pointer; justify-content: center; padding: 10px 0;">
                    <!-- Emoji将由JS生成 -->
                </div>
            </div>
            <div class="form-group">
                <label for="ls-diary-content-input">写下你的日记</label>
                <textarea id="ls-diary-content-input" rows="6" placeholder="今天发生了什么特别的事吗..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-diary-btn">取消</button>
            <button class="save" id="ls-save-diary-btn">保存日记</button>
        </div>
    </div>
</div>

<!-- 【全新】情侣空间-日记查看弹窗 -->
<div id="ls-diary-viewer-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="ls-diary-viewer-title">查看日记</span>
        </div>
        <div id="ls-diary-viewer-body" class="modal-body" style="display: flex; flex-direction: column; gap: 20px;">
            <!-- 日记内容将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="ls-close-diary-viewer-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】情侣空间 - 每日足迹日历弹窗 (修正版) ▼▼▼ -->
<div id="ls-activity-calendar-modal" class="modal">
    <div class="modal-content" style="max-width: 380px;">
        <div class="modal-header">
            <span id="ls-activity-calendar-title">💕 足迹日历 💕</span>
        </div>
        <div class="modal-body" id="ls-activity-calendar-body">
            <!-- 日历内容会由JavaScript动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 每日足迹日历弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 用这整块代码替换旧的 summary-viewer-modal ▼▼▼ -->
<div id="summary-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="summary-viewer-title">聊天总结</span>
        </div>
        <div class="modal-body" id="summary-list" style="padding: 15px;">
            <!-- 总结列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer" style="display: flex; gap: 10px;">
            <!-- 【核心修改】我们在这里新增了“全部精简”按钮 -->
            <button class="form-button-secondary" id="concise-all-summaries-btn" style="flex: 1; margin: 0;">全部精简</button>
            <button class="save" id="close-summary-viewer-btn" style="flex: 1; margin: 0;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】AI生成商品结果/选择弹窗 -->
<div id="ai-generated-products-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="ai-products-modal-title">AI为你生成了以下宝贝</span>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-product-results-grid" class="product-grid">
                <!-- AI生成的商品会显示在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-products-modal-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 标签的正上方，粘贴下面这一整块新代码 ▼▼▼ -->

<!-- 【全新】飞行棋问题库管理模态框 (已修改) -->
<div id="ludo-qbank-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理问题库</span>
            <!-- ▼▼▼ 核心修改在这里 ▼▼▼ -->
            <div class="header-actions">
                <span class="action-btn" id="import-ludo-qbank-btn" title="导入题库">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </span>
                <span class="action-btn" id="add-ludo-qbank-btn" style="font-size: 16px;">新建</span>
            </div>
            <!-- ▲▲▲ 修改结束 ▲▲▲ -->
        </div>
        <div class="modal-body" id="ludo-qbank-list" style="padding: 0;">
            <!-- 问题库列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-qbank-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>


<!-- 【全新】飞行棋问题编辑器模态框 -->
<div id="ludo-question-editor-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span class="back-btn" id="back-to-qbank-manager-btn">‹</span>
            <span id="ludo-question-editor-title">编辑问题</span>
            <span class="action-btn" id="add-ludo-question-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
        <div class="modal-body" id="ludo-question-list" style="padding: 10px;">
            <!-- 问题列表将由JS动态生成在这里 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 标签的正上方，粘贴下面这一整块新代码 ▼▼▼ -->
<!-- 【全新】飞行棋单个问题编辑器模态框 -->
<div id="ludo-single-question-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="ludo-single-question-title">编辑问题</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ludo-question-text-input">问题内容</label>
                <textarea id="ludo-question-text-input" rows="4"></textarea>
            </div>
            <div class="form-group">
                <label>问题类型</label>
                <div style="display: flex; gap: 20px;">
                    <label><input type="radio" name="ludo_question_type" value="both_answer" checked> 共同回答</label>
                    <label><input type="radio" name="ludo_question_type" value="single_answer"> 一人回答,一人评价</label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-single-question-btn">取消</button>
            <button class="save" id="save-single-question-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是飞行棋游戏结算卡片，请粘贴到 </body> 标签前 ▼▼▼ -->
<div id="ludo-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="ludo-summary-content" style="text-align: left; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="share-ludo-summary-btn">分享给Ta</button>
            <button class="save" id="back-to-hall-from-ludo-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】“谁是卧底”游戏结算卡片 ▼▼▼ -->
<div id="undercover-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="undercover-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <!-- 这是我们新增的“分享复盘”按钮 -->
            <button class="cancel" id="repost-undercover-summary-btn">分享复盘到单聊</button>
            <button class="save" id="back-to-hall-from-undercover-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 在 </body> 标签前，粘贴下面这整块【全新的】HTML代码 ▼▼▼ -->
<!-- “谁是卧底”复盘发送目标选择器 -->
<div id="undercover-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要发送的玩家</span>
        </div>
        <div class="modal-body" id="undercover-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="uc-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="uc-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="uc-cancel-share-btn">取消</button>
            <button class="save" id="uc-confirm-share-btn">确认发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】群公告模态框 ▼▼▼ -->
<div id="group-announcement-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>群公告</span>
        </div>
        <div class="modal-body" id="announcement-content-area">
            <!-- 公告内容将显示在这里 -->
        </div>
        <div class="modal-footer" id="announcement-footer">
            <!-- 按钮将由JS动态生成 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是心声面板的样式编辑器弹窗 ▼▼▼ -->
<div id="inner-voice-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>编辑心声面板样式</span>
        </div>
        <div class="modal-body">
            <!-- 卡片背景颜色 -->
            <div class="form-group">
                <label for="iv-card-bg-color">卡片背景颜色</label>
                <input type="color" id="iv-card-bg-color" value="#FFFFFF" style="width: 100%; height: 40px;">
            </div>
            <!-- 卡片透明度 -->
            <div class="form-group">
                <label for="iv-opacity-slider">卡片背景透明度: <span id="iv-opacity-value">70%</span></label>
                <input type="range" id="iv-opacity-slider" min="0" max="1" step="0.05" value="0.7" style="width: 100%;">
            </div>
            <hr style="opacity: 0.2;">
            <!-- 四个标签的背景色 -->
            <div class="form-group">
                <label for="iv-color-clothing">“服装”标签背景色</label>
                <input type="color" id="iv-color-clothing" value="#f0a1a8" style="width: 100%; height: 40px;">
            </div>
            <div class="form-group">
                <label for="iv-color-behavior">“行为”标签背景色</label>
                <input type="color" id="iv-color-behavior" value="#81c784" style="width: 100%; height: 40px;">
            </div>
            <div class="form-group">
                <label for="iv-color-thoughts">“心声”标签背景色</label>
                <input type="color" id="iv-color-thoughts" value="#64b5f6" style="width: 100%; height: 40px;">
            </div>
            <div class="form-group">
                <label for="iv-color-naughty">“坏心思”标签背景色</label>
                <input type="color" id="iv-color-naughty" value="#ba68c8" style="width: 100%; height: 40px;">
            </div>
            <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">
<div class="form-group">
    <label for="iv-icon-color">图标颜色</label>
    <input type="color" id="iv-icon-color" value="#ff8a80" style="width: 100%; height: 40px;">
</div>
<!-- ▲▲▲ 新增代码粘贴结束 ▲▲▲ -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="iv-editor-cancel-btn">取消</button>
            <button class="save" id="iv-editor-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】AI生成群成员模态框 -->
<div id="ai-generate-members-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>AI 生成群成员</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ai-member-count-input">生成人数 (1-20)</label>
                <input type="number" id="ai-member-count-input" value="3" min="1" max="20">
            </div>
            <div class="form-group">
                <label for="ai-member-prompt-input">要求 (可选，AI会参考)</label>
                <textarea id="ai-member-prompt-input" rows="4" placeholder="例如：一群喜欢户外探险的大学生，性格各异..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-ai-generate-members-btn">取消</button>
            <button class="save" id="confirm-ai-generate-members-btn">开始生成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】约会邀请与支付模态框 ▼▼▼ -->
<div id="dating-payment-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span id="dating-modal-title">发起约会邀请</span>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p>你选择的约会是：</p>
            <h3 id="dating-modal-scene-name" style="color: var(--accent-color); margin: 10px 0;"></h3>
            <p id="dating-modal-scene-cost" style="font-weight: bold;"></p>
            <hr style="opacity: 0.2; margin: 20px 0;">
            <p>由谁来买单呢？</p>
            <div id="dating-payment-options" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 支付选项按钮将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="dating-cancel-btn" style="width:100%;">下次再说</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】约会角色选择弹窗 ▼▼▼ -->
<div id="dating-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择约会对象</span>
        </div>
        <div class="modal-body" id="dating-char-selector-list" style="padding: 0;">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="dating-cancel-char-select-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这整块【最终修复版】的代码，替换你旧的 id="dating-game-screen" 的 div ▼▼▼ -->
<div id="dating-game-screen" class="screen">
    <!-- 1. 动态背景图 (最底层) -->
    <div id="dating-game-background"></div>

    <!-- 2. 角色立绘容器 (中间层) -->
    <div id="dating-game-sprite-container">
        <img id="dating-game-sprite" src="">
    </div>

    <!-- 3. UI覆盖层 (最顶层, 包含头部/文本框/选项) -->
    <div class="dating-game-ui-overlay">
<!-- ▼▼▼ 请用这块【已添加心形UI】的代码，完整替换掉你旧的 id="dating-game-screen" 里的那个 .header ▼▼▼ -->
<div class="header">
    <span class="back-btn" id="end-date-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>

    <span id="dating-game-char-name"></span>
    <div class="header-actions">

        <!-- ★★★★★ 这就是我们新加的心形数值条 ★★★★★ -->
        <div id="dating-values-container">
            <div id="romance-value" class="value-display">
                <!-- 我们会用JS在这里生成5个粉色心形 -->
            </div>
            <div id="lust-value" class="value-display">
                <!-- 我们会用JS在这里生成5个黄色心形 -->
            </div>
        </div>
        <!-- ★★★★★ 新增HTML结束 ★★★★★ -->

        <span class="action-btn" id="dating-game-settings-btn" title="场景设置">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </span>
        <span class="action-btn" id="dating-game-reroll-btn" title="重Roll回应">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


        <!-- 3b. 底部文本框 -->
        <div class="dating-game-textbox">
            <p id="dating-game-text-content">约会即将开始...</p>
        </div>
<div id="dating-completion-bar-container">
    <div id="dating-completion-bar-fill"></div>
    <span id="dating-completion-text">0%</span>
</div>
        <!-- 3c. 玩家操作区 -->
        <div id="dating-game-choices" class="dating-game-choices">
            <!-- 选项按钮将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->



<!-- ▼▼▼ 【全新】借钱对象选择弹窗（带滚动和头像）▼▼▼ -->
<div id="borrow-money-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>向谁借钱？</span>
        </div>
        <div class="modal-body" id="borrow-money-char-list" style="padding: 0; overflow-y: auto;">
            <!-- 借钱对象列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="borrow-money-cancel-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这块【立绘功能增强版】代码，完整替换旧的 id="dating-game-settings-modal" ▼▼▼ -->
<div id="dating-game-settings-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>约会场景设置</span>
        </div>
        <div class="modal-body">
            <!-- 预设管理 (保持不变) -->
            <div class="form-group">
                <label>预设方案</label>
                <div class="bubble-preset-manager">
                    <select id="dating-preset-select" class="form-group select"></select>
                    <button id="manage-dating-presets-btn" class="action-btn">管理</button>
                </div>
            </div>

            <hr style="opacity: 0.2;">
            
            <!-- ★★★ 核心新增：立绘组选择器 ★★★ -->
            <div class="form-group">
                <label>选择角色立绘组</label>
                <div class="bubble-preset-manager">
                    <select id="dating-sprite-group-select" class="form-group select">
                        <option value="">-- 不使用立绘 --</option>
                        <!-- 立绘组将由JS动态填充 -->
                    </select>
                    <button id="manage-sprite-groups-btn" class="action-btn">管理立绘组</button>
                </div>
            </div>
            <!-- ★★★ 新增结束 ★★★ -->

            <hr style="opacity: 0.2;">

            <!-- 核心设置 (保持不变) -->
            <div class="form-group">
                <label for="dating-prompt-input">场景/角色提示词 (Prompt)</label>
                <textarea id="dating-prompt-input" rows="4" placeholder="例如：你是一个傲娇但内心温柔的少女，在海边对用户的表白感到不知所措..."></textarea>
            </div>
            <div class="form-group">
                <label for="dating-style-input">文风 (Style)</label>
                <textarea id="dating-style-input" rows="3" placeholder="例如：请使用细腻的心理描写和优美的风景描写..."></textarea>
            </div>
            <div class="form-group">
                <label>约会背景图</label>
                <div class="bg-upload-container">
                    <button class="form-button-secondary" onclick="document.getElementById('dating-bg-upload-input').click()" style="margin-top:0;">上传图片</button>
                    <input type="text" id="dating-bg-url-input" placeholder="或粘贴网络图片URL" style="flex-grow:1;">
                </div>
                 <input type="file" id="dating-bg-upload-input" accept="image/*" hidden>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-dating-settings-btn">取消</button>
            <button class="save" id="save-dating-settings-btn">应用并保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 前，粘贴下面这两块全新的弹窗HTML ▼▼▼ -->

<!-- 1. 【全新】立绘组管理弹窗 -->
<div id="sprite-group-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理立绘组</span>
            <span class="action-btn" id="create-new-sprite-group-btn" style="font-size: 16px;">新建</span>
        </div>
        <div class="modal-body" id="sprite-group-list-container" style="padding: 0;">
            <!-- 立绘组列表将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sprite-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- 2. 【全新】立绘组编辑器弹窗 -->
<div id="sprite-editor-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span id="sprite-editor-title">编辑立绘组</span>
        </div>
        <div class="modal-body" id="sprite-editor-body">
            <div class="form-group">
                <label for="sprite-group-name-input">立绘组名称</label>
                <input type="text" id="sprite-group-name-input" placeholder="例如：日常、战斗、害羞...">
            </div>
            <hr style="opacity: 0.2;">
            <label>立绘列表</label>
            <div id="sprite-list-editor" style="display: flex; flex-direction: column; gap: 15px; margin-top: 10px;">
                <!-- 单个立绘的编辑卡片将由JS动态生成 -->
            </div>
            <button id="add-new-sprite-btn" class="form-button form-button-secondary" style="margin-top: 20px;">+ 添加一个新立绘</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sprite-editor-btn">取消</button>
            <button class="save" id="save-sprite-editor-btn">保存立绘组</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 约会结算卡片 ▼▼▼ -->
<div id="dating-summary-overlay" class="modal">
    <div class="dating-summary-card">
        <div class="dating-summary-card-inner">
            <!-- 卡片正面 -->
            <div class="card-front">
                <img id="summary-card-avatar" src="" alt="角色头像">
                <h2 id="summary-card-rating"></h2>
                <p class="summary-card-tip">点击卡片查看完整约会记录</p>
                <div class="summary-card-actions">
                    <button id="summary-share-btn">分享给Ta</button>
                    <button id="summary-close-btn">关闭</button>
                </div>
            </div>
            <!-- 卡片背面 -->
            <div class="card-back">
                <div class="card-back-header">
                    <span>完整约会记录</span>
                    <button id="summary-flip-back-btn">返回</button>
                </div>
                <div id="summary-card-history" class="card-back-content">
                    <!-- 约会历史记录将由JS动态生成在这里 -->
                </div>
            </div>
        </div>
    </div>
</div>


<!-- ▼▼▼ 【全新】这是为约会结算卡片分享功能新增的HTML ▼▼▼ -->
<input type="file" id="dating-summary-image-upload" accept="image/*" hidden>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】约会历史记录界面 -->
<div id="dating-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="dating-history-back-btn">‹</span>
        <span>历史约会</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="dating-history-list" class="list-container">
        <!-- 历史约会卡片将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▲▲▲ 新增HTML代码结束 ▲▲▲ -->
<!-- ▼▼▼ 用这块【已优化提示】的代码，替换旧的创建场景弹窗 ▼▼▼ -->
<div id="create-dating-scene-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>创建约会场景</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="scene-name-input">场景名称</label>
                <input type="text" id="scene-name-input" placeholder="例如：月光下的海滩漫步">
            </div>
            <div class="form-group">
                <label for="scene-image-url-input">图片 URL (可选)</label>
                <!-- ★★★ 核心修改：更新了 placeholder 提示文字 ★★★ -->
                <input type="text" id="scene-image-url-input" placeholder="留空则由AI根据场景名生成图片...">
            </div>
            <div class="form-group">
                <label for="scene-cost-input">花费 (金币)</label>
                <input type="number" id="scene-cost-input" placeholder="例如：520">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-scene-btn">取消</button>
            <button class="save" id="save-custom-scene-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】在 </body> 前粘贴这个新的表情分类管理模态框 ▼▼▼ -->
<div id="sticker-category-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span>移动表情到分类</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>选择一个现有分类</label>
                <div id="sticker-category-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 5px;">
                    <!-- 分类列表将由JS动态生成 -->
                </div>
            </div>
            <p style="text-align: center; color: var(--text-secondary); margin: 10px 0;">或</p>
            <div class="form-group">
                <label for="new-sticker-category-input">创建一个新分类</label>
                <input type="text" id="new-sticker-category-input" placeholder="输入新分类的名称...">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sticker-category-btn">取消</button>
            <button class="save" id="confirm-sticker-category-btn">确认移动</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这块【已添加新按钮】的代码替换旧的 advanced-transfer-modal ▼▼▼ -->
<div id="advanced-transfer-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>高级导入 / 导出</span>
        </div>
        <div class="modal-body">
            <h4>选择要导出的内容</h4>
            
            <!-- App 数据导出区 -->
            <div class="form-group">
                <label>全局App数据 (多选)</label>
                <div id="export-apps-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px;">
                    <!-- App 多选框将由JS动态生成在这里 -->
                </div>
            </div>

            <!-- 角色数据导出区 -->
            <div class="form-group">
                <label style="display: flex; justify-content: space-between; align-items: center;">
                    <span>角色数据 (多选,qq动态什么的)</span>
                    <label style="font-size: 13px; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="select-all-characters-checkbox" style="vertical-align: middle; margin-right: 4px;"> 全选/全不选
                    </label>
                </label>
                <div id="export-characters-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; border-radius: 8px;">
                    <!-- 角色多选框将由JS动态生成在这里 -->
                </div>
            </div>
            <button id="export-selected-data-btn" class="form-button">导出选中项</button>

            <hr style="margin: 20px 0;">
            
            <h4>兼容性操作</h4>
            <p style="font-size: 13px; color: #666;">
                从其他版本导入数据，或将数据导出为兼容格式。
            </p>
            
            <!-- ▼▼▼ 这就是我们新增的导入按钮！▼▼▼ -->
            <button id="import-from-330-btn" class="form-button" style="background-color: #28a745; margin-bottom: 10px;">📥 兼容330格式导入</button>
            
            <button id="export-for-330-btn" class="form-button" style="background-color: #6f42c1;">🚀 兼容330数据导出</button>

            <hr style="margin: 20px 0;">

            <h4>导入补充数据</h4>
            <p style="font-size: 13px; color: #666;">导入将以【补充和覆盖】的方式进行，不会删除您现有的其他数据。这可以用来合并数据或恢复单个角色的备份。</p>
            <button id="import-chunked-data-btn" class="form-button form-button-secondary">选择文件并导入</button>
            <input id="import-chunked-data-input" type="file" accept="application/json" hidden>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="close-advanced-transfer-btn">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】这是为新按钮准备的隐藏文件选择器，请粘贴到上面那个div的后面 ▼▼▼ -->
<input id="import-from-330-input" type="file" accept="application/json" hidden>
<!-- ▲▲▲ HTML修改结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是亲密值面板的HTML，请粘贴到 </body> 标签前 ▼▼▼ -->
<div id="intimacy-panel" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>亲密关系</span>
            <span id="close-intimacy-panel" class="close-btn" style="cursor: pointer;">&times;</span>
        </div>
        <div class="modal-body" id="intimacy-panel-body">
            <div id="intimacy-display">
                <p>当前亲密值</p>
                <h2 id="intimacy-score-display">--</h2>
            </div>
            <div id="intimacy-details">
                <div class="detail-item">
                    <span>🔥 火花天数</span>
                    <span id="intimacy-streak-days">-- 天</span>
                </div>
                <div class="detail-item">
                    <span>💬 今日消息</span>
                    <span id="intimacy-today-msgs">-- 条</span>
                </div>
                <div class="detail-item">
                    <span>📈 累计消息</span>
                    <span id="intimacy-total-msgs">-- 条</span>
                </div>
            </div>
            <div id="intimacy-symbol-unlocks">
                <h3>亲密徽章</h3>
                <div id="symbol-list-container">
                    <!-- JS会在这里生成所有可解锁的徽章 -->
                </div>
            </div>
            <div id="intimacy-records">
                <h3>解锁记录</h3>
                <div id="unlocked-symbols-record">
                    <!-- JS会在这里生成已解锁徽章的记录 -->
                    <p>暂无记录</p>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->



<!-- ▼▼▼ 用这整块代码替换旧的 inner-voice-modal ▼▼▼ -->
<div id="inner-voice-modal" class="modal">
    <!-- 心声主面板 -->
    <div id="inner-voice-main-panel" class="modal-content" style="width: 90%; max-width: 340px; height: auto; max-height: 80%; background-color: #fffafb; border: 1px solid #ffe4e1;">
<!-- ▼▼▼ 用这块新代码替换旧的 <div class="modal-header">...</div> ▼▼▼ -->
<div class="modal-header" style="border-bottom: 1px solid #ffe4e1; padding: 12px 15px; display: flex; justify-content: space-between; align-items: center;">
    <span id="close-inner-voice-modal" style="cursor: pointer; font-size: 24px;">×</span>
    
    <div style="display: flex; align-items: center; gap: 15px;">
        <span id="inner-voice-edit-btn" style="cursor: pointer;" title="编辑心声面板">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 20h9"></path>
                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
            </svg>
        </span>
        <span id="change-inner-voice-bg-btn" style="cursor: pointer;" title="更换背景">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
        </span>
        <span id="inner-voice-history-btn" style="cursor: pointer;">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        </span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->



        <div class="modal-body" style="padding: 15px;">
            <!-- 头像和名字信息现在是独立的、可定位的元素 -->
            <!-- 角色头像 -->
            <div id="inner-voice-avatar-wrapper">
                <img id="inner-voice-avatar" src="">
                <!-- 【全新】这是为头像框预留的位置 -->
                <img id="inner-voice-avatar-frame" src="" style="display: none;">
            </div>

            
            <!-- 角色名字 -->
            <div id="inner-voice-char-info">
                <div id="inner-voice-char-name"></div>
            </div>

            <!-- 【全新】领养人信息（头像+名字）-->
            <div id="inner-voice-adopter-info">
                <img id="inner-voice-adopter-avatar" src="">
                <span id="inner-voice-adopter-name"></span>
            </div>
            
            <!-- 心声内容 -->
            <div id="inner-voice-content-area" style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <strong style="color: #e57373;">服装:</strong>
                    <p id="inner-voice-clothing" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #81c784;">行为:</strong>
                    <p id="inner-voice-behavior" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #64b5f6;">心声:</strong>
                    <p id="inner-voice-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #ba68c8;">坏心思:</strong>
                    <p id="inner-voice-naughty-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- 历史记录面板 (保持不变) -->
    <div id="inner-voice-history-panel" class="modal-content" style="width: 90%; max-width: 340px; height: 80%; background-color: #f5f5f5; display: none; flex-direction: column;">
        <div class="modal-header" style="border-bottom: 1px solid #ddd; justify-content: space-between;">
            <span id="back-from-history-btn" style="cursor: pointer; font-size: 16px; font-weight: 600; color: var(--accent-color);">返回</span>
            <span>历史心声</span>
            <span id="clear-all-history-btn" style="cursor: pointer; font-size: 14px; color: #ff3b30;">全部清空</span>
        </div>
        <div class="modal-body" id="inner-voice-history-list" style="padding: 0;">
            <!-- 历史记录会由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<script>
// ▼▼▼ 把这一整块超长的塔罗牌数据，粘贴到 const GEMINI_API_URL 的正上方 ▼▼▼

const TAROT_DECK = [
    { name: "愚人", upright: "开始, 天真, 自发性, 自由精神", reversed: "天真, 鲁莽, 承担风险" },
    { name: "魔术师", upright: "显化, 足智多谋, 力量, 灵感行动", reversed: "操纵, 计划不周, 未被利用的天赋" },
    { name: "女祭司", upright: "直觉, 神圣女性, 潜意识, 神秘", reversed: "秘密, 脱离直觉, 压抑的感情" },
    { name: "皇后", upright: "生育, 女性气质, 美丽, 自然, 丰富", reversed: "创造力受阻, 依赖他人" },
    { name: "皇帝", upright: "权威, 父亲形象, 结构, 稳固控制", reversed: "控制欲, 僵化, 缺乏纪律" },
    { name: "教皇", upright: "精神智慧, 宗教信仰, 传统, 制度", reversed: "个人信仰, 挑战传统, 墨守成规" },
    { name: "恋人", upright: "爱, 和谐, 关系, 价值观对齐, 选择", reversed: "不和谐, 失衡, 价值观错位" },
    { name: "战车", upright: "控制, 意志力, 胜利, 断言, 决心", reversed: "缺乏控制和方向, 侵略性" },
    { name: "力量", upright: "力量, 勇气, 同情, 专注, 耐心", reversed: "内在力量, 自我怀疑, 精力不足" },
    { name: "隐士", upright: "灵魂探索, 内省, 孤独, 内在引导", reversed: "孤立, 孤独, 退缩" },
    { name: "命运之轮", upright: "好运, 因果报应, 生命周期, 转折点", reversed: "坏运气, 抵抗改变, 打破循环" },
    { name: "正义", upright: "正义, 公平, 真理, 因果, 法律", reversed: "不公平, 缺乏责任感, 不诚实" },
    { name: "倒吊人", upright: "暂停, 限制, 放手, 牺牲, 新视角", reversed: "拖延, 毫无意义的牺牲, 停滞" },
    { name: "死神", upright: "结束, 改变, 转变, 过渡", reversed: "抵抗改变, 无法前进, 停滞" },
    { name: "节制", upright: "平衡, 适度, 耐心, 目标", reversed: "失衡, 过度, 重新调整" },
    { name: "恶魔", upright: "束缚, 成瘾, 消极, 唯物主义", reversed: "挣脱束缚, 释放, 恢复控制" },
    { name: "高塔", upright: "突变, 剧变, 混乱, 启示, 觉醒", reversed: "避免灾难, 害怕改变" },
    { name: "星星", upright: "希望, 信念, 目标, 更新, 灵性", reversed: "缺乏信念, 绝望, 不专注" },
    { name: "月亮", upright: "幻觉, 恐惧, 焦虑, 潜意识, 直觉", reversed: "释放恐惧, 压抑的情感, 内心困惑" },
    { name: "太阳", upright: "积极, 乐趣, 温暖, 成功, 活力", reversed: "内心幼稚, 过于乐观, 沮丧" },
    { name: "审判", upright: "审判, 重生, 内心召唤, 赦免", reversed: "自我怀疑, 无视召唤" },
    { name: "世界", upright: "完成, 整合, 成就, 旅行", reversed: "寻求个人结束, 走捷径, 拖延" },
    { name: "权杖ACE", upright: "灵感, 新机会, 成长, 潜力", reversed: "缺乏动力, 错过机会, 拖延" },
    { name: "权杖二", upright: "未来规划, 进步, 决策, 离开家", reversed: "恐惧未知, 缺乏规划, 害怕改变" },
    { name: "权杖三", upright: "扩张, 成长, 远见, 海外机会", reversed: "计划受挫, 缺乏远见, 延误" },
    { name: "权杖四", upright: "庆祝, 和谐, 婚姻, 回家, 稳定", reversed: "不和谐, 过渡, 缺乏支持" },
    { name: "权杖五", upright: "冲突, 分歧, 竞争, 紧张", reversed: "冲突避免, 尊重差异" },
    { name: "权杖六", upright: "成功, 公众认可, 胜利, 进步", reversed: "自负, 缺乏认可, 惩罚" },
    { name: "权杖七", upright: "挑战, 竞争, 保护, 坚持", reversed: "放弃, 不知所措, 过度保护" },
    { name: "权杖八", upright: "速度, 行动, 空中旅行, 运动, 快速决策", reversed: "延误, 挫折, 抵制改变" },
    { name: "权杖九", upright: "韧性, 勇气, 坚持, 界限", reversed: "内心挣扎, 偏执, 防御性" },
    { name: "权杖十", upright: "负担, 责任, 努力工作, 压力", reversed: "卸下负担, 委派, 释放" },
    { name: "权杖侍从", upright: "灵感, 想法, 发现, 自由精神", reversed: "不切实际的想法, 拖延, 创造力受阻" },
    { name: "权杖骑士", upright: "能量, 激情, 欲望, 行动, 冒险", reversed: "愤怒, 冲动, 鲁莽" },
    { name: "权杖王后", upright: "勇气, 自信, 独立, 社交蝴蝶", reversed: "自我尊重, 自信, 内向" },
    { name: "权杖国王", upright: "天生的领袖, 远见, 企业家, 荣誉", reversed: "冲动, 仓促, 无情的" },
    { name: "圣杯ACE", upright: "爱, 新关系, 同情, 创造力", reversed: "自我爱, 直觉, 压抑的情感" },
    { name: "圣杯二", upright: "统一的爱, 伙伴关系, 相互吸引", reversed: "分手, 不和谐, 不信任" },
    { name: "圣杯三", upright: "庆祝, 友谊, 创造力, 合作", reversed: "独立, 独处, '三人行'" },
    { name: "圣杯四", upright: "沉思, 断开连接, 冷漠, 重新评估", reversed: "退缩, 孤僻, 错过机会" },
    { name: "圣杯五", upright: "遗憾, 失败, 失望, 悲观主义", reversed: "个人挫折, 自我宽恕, 前进" },
    { name: "圣杯六", upright: "重温过去, 童年记忆, 天真, 喜悦", reversed: "活在过去, 不愿原谅, 缺乏玩乐" },
    { name: "圣杯七", upright: "机会, 选择, 幻想, 幻觉", reversed: "一致性, 幻想, 过多选择" },
    { name: "圣杯八", upright: "失望, 放弃, 退缩, 逃避主义", reversed: "尝试新事物, 冷漠, 恐惧改变" },
    { name: "圣杯九", upright: "满足, 满意, 感激, 愿望成真", reversed: "不满足, 唯物主义, 不满" },
    { name: "圣杯十", upright: "神圣的爱, 和谐关系, 家庭, 一致性", reversed: "脱节, 对齐错误, 挣扎的关系" },
    { name: "圣杯侍从", upright: "创意机会, 直觉信息, 好奇心", reversed: "新的想法, 怀疑, 创造力受阻" },
    { name: "圣杯骑士", upright: "创造力, 浪漫, 魅力, 想象力", reversed: "不切实际, 嫉妒, 情绪波动" },
    { name: "圣杯王后", upright: "富有同情心, 关怀, 直觉, 平静", reversed: "内在感受, 自我照顾, 自爱, 共情" },
    { name: "圣杯国王", upright: "情绪平衡, 同情, 外交", reversed: "自我同情, 内在真理, 情绪不稳定" },
    { name: "宝剑ACE", upright: "突破, 新想法, 头脑清晰, 成功", reversed: "内心清晰, 重新思考一个想法, 混乱" },
    { name: "宝剑二", upright: "艰难的选择, 未知的后果, 僵局", reversed: "优柔寡断, 困惑, 信息过载" },
    { name: "宝剑三", upright: "心碎, 悲伤, 拒绝, 分离", reversed: "释放痛苦, 乐观, 宽恕" },
    { name: "宝剑四", upright: "休息, 放松, 沉思, 恢复", reversed: "精疲力尽, 倦怠, 停滞" },
    { name: "宝剑五", upright: "冲突, 分歧, 竞争, 失败", reversed: "和解, 过去的原谅" },
    { name: "宝剑六", upright: "过渡, 改变, 仪式, 放下", reversed: "个人过渡, 抵抗改变, 未完成的事" },
    { name: "宝剑七", upright: "背叛, 欺骗, 走捷径, 鬼祟", reversed: "冒名顶替综合症, 欺骗, 守秘" },
    { name: "宝剑八", upright: "负面想法, 自我强加的限制, 监禁", reversed: "自我限制的信念, 释放, 思想开放" },
    { name: "宝剑九", upright: "焦虑, 担忧, 恐惧, 抑郁, 噩梦", reversed: "内心挣扎, 深度恐惧, 释放忧虑" },
    { name: "宝剑十", upright: "痛苦的结局, 深度创伤, 背叛, 损失", reversed: "恢复, 抵抗结局, 无法放手" },
    { name: "宝剑侍从", upright: "新想法, 好奇心, 追求真理", reversed: "自言自语, 全能选手, 仓促" },
    { name: "宝剑骑士", upright: "雄心勃勃, 行动导向, 追求目标", reversed: "不安, 冲动, 倦怠" },
    { name: "宝剑王后", upright: "独立的, 无偏见的判断, 清晰的界限", reversed: "过于情绪化, 轻易受影响, 刻薄" },
    { name: "宝剑国王", upright: "精神清晰, 智慧, 权威, 真理", reversed: "安静的力量, 内在真理, 滥用权力" },
    { name: "星币ACE", upright: "显化, 新的财务机会, 繁荣", reversed: "机会丧失, 缺乏规划和远见" },
    { name: "星币二", upright: "多任务, 适应性, 时间管理", reversed: "重新调整优先级, 过度投入" },
    { name: "星币三", upright: "团队合作, 合作, 学习, 实施", reversed: "不和谐, 团队内部冲突, 计划不周" },
    { name: "星币四", upright: "节约, 安全, 保守, 稀缺心态", reversed: "过度消费, 贪婪, 自我保护" },
    { name: "星币五", upright: "财务损失, 贫困, 孤立, 忧虑", reversed: "从财务损失中恢复, 精神贫困" },
    { name: "星币六", upright: "给予, 接受, 分享财富, 慷慨", reversed: "自私, 债务, 单方面给予" },
    { name: "星币七", upright: "长期眼光, 可持续的结果, 投资", reversed: "缺乏长期眼光, 成功受限" },
    { name: "星币八", upright: "学徒, 重复, 掌握, 技能发展", reversed: "自我发展, 完美主义, 部署不当" },
    { name: "星币九", upright: "丰富, 奢华, 自给自足, 财务独立", reversed: "自我价值, 过度投资于工作" },
    { name: "星币十", upright: "财富, 财务安全, 家庭, 遗产", reversed: "财务失败, 负担, 遗产丧失" },
    { name: "星币侍从", upright: "显化, 财务机会, 技能发展", reversed: "缺乏进步, 拖延, 学会新技能" },
    { name: "星币骑士", upright: "努力工作, 生产力, 日常, 保守", reversed: "自我纪律, 无聊, 感觉'卡住'" },
    { name: "星币王后", upright: "养育, 务实, 财务安全, 工作与家庭的平衡", reversed: "财务独立, 自我照顾, 工作与家庭的不平衡" },
    { name: "星币国王", upright: "财富, 商业, 领导力, 安全, 纪律", reversed: "财务不称职, 过时, 固执" }
];

// ▲▲▲ 塔罗牌数据粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 const GEMINI_API_URL 的正上方 ▼▼▼

const BUILT_IN_SCRIPTS = [
    {
        id: 'built_in_1',
        name: '办公室疑云',
        storyBackground: '深夜，顶级互联网公司“比特无限”灯火通明。以苛刻闻名的项目总监王强，被发现死在自己的座位上，死因为药物中毒。警方初步锁定了当晚还在公司的五位嫌疑人，每个人似乎都与死者有着千丝万缕的联系。在这座欲望与代码交织的钢铁森林里，谁的秘密被永远埋葬，谁的双手沾染了罪恶？',
        roles: [
            {
                name: '李思',
                description: '公司新晋的天才程序员，技术过硬，但性格内向，不善言辞。',
                storyline: `今天是项目上线的最后期限，我被王总监逼着加班到深夜。\n**晚上8:00**：王总监把我叫进他办公室，因为一个微不足道的bug对我破口大骂，甚至撕掉了我的绩效评估报告，说我“不合格”。我气得浑身发抖，和他大吵了一架，然后摔门而出。\n**晚上8:30**：我回到工位，越想越气，打开电脑写了一封辞职信，但还没发送。\n**晚上9:00**：我起身去茶水间倒水，路过总监办公室时，看到人事主管陈静端着一杯咖啡走了进去。我当时没太在意。\n**晚上9:30**：我有点饿，点了一份外卖。等外卖的时候，我看到设计师孙伟鬼鬼祟祟地从茶水间的方向走出来，手里好像攥着什么东西。\n**晚上10:00**：外卖到了，我吃完外卖继续改bug，直到被发现尸体的惊叫声打断。`,
                tasks: '1. 隐藏你与王强总监发生过激烈争吵，并被他评为“不合格”的事实。\n2. 你的首要目标是自保，找到证据证明你离开后另有其人进入过办公室。\n3. 你怀疑陈静和孙伟，尝试找出他们的可疑之处。',
                isKiller: false
            },
            {
                name: '赵娜',
                description: '公司的市场部经理，能力出众，是典型的职场女强人，野心勃勃。',
                storyline: `今晚本不需要我加班，但我为了准备一个重要的竞标方案，主动留了下来。\n**晚上7:30**：我在自己的办公室整理资料，无意中发现了王强挪用项目公款的证据。我立刻起草了一封匿名举报邮件，准备发给总部。\n**晚上8:10**：我听到隔壁总监办公室传来激烈的争吵声，好像是李思在和王强吵架。\n**晚上8:45**：我需要一些数据，就去找王强签字。进他办公室时，他正在喝咖啡，脸色很差。我把文件给他，他很不耐烦地签了字。我注意到他桌上放着一瓶没贴标签的药瓶。\n**晚上9:15**：我回到自己办公室，思考着举报邮件的事情。我担心这会影响公司声誉，最终还是没有发送。\n**晚上10:15**：我准备下班，路过总监办公室时，发现门虚掩着，里面很安静。我没有进去看，直接离开了公司。`,
                tasks: '1. 你的首要任务是找出真凶，洗清自己的嫌疑，确保公司丑闻不被曝光，以免影响你的职业前途。\n2. 隐藏你发现王强挪用公款并准备举报他的事实。\n3. 你看到他桌上的药瓶，这是一个重要线索，你需要引导大家注意到这一点。',
                isKiller: false
            },
            {
                name: '孙伟',
                description: '公司的资深UI设计师，也是王强的老部下，表面对他毕恭毕敬。',
                storyline: `我恨透了王强！他克扣了我们团队辛辛苦苦做完的项目奖金，自己却拿了大头。\n**晚上9:00**：我借口加班，实际上是想潜入王强的办公室，找到他克扣奖金的证据。我看到陈静端着咖啡进去后不久就出来了。\n**晚上9:20**：我确认王强办公室没人注意，就偷偷溜了进去。我看到他趴在桌上睡着了，旁边是那杯几乎没喝的咖啡。我在他抽屉里翻找，果然找到了一份内部奖金分配表，证实了他中饱私囊。我用手机拍了下来。\n**晚上9:30**：我拿着证据悄悄离开办公室，准备去茶水间处理一下。这时迎面撞上了去倒水的李思，我吓了一跳，赶紧把手机藏进口袋里。\n**晚上10:00后**：我一直在自己的工位上，盘算着怎么利用这个证据让他身败名裂。`,
                tasks: '1. 隐藏你曾潜入总监办公室并偷拍证据的事实。\n2. 王强死了对你有利，你需要引导大家怀疑其他有动机的人，比如与他争吵的李思。\n3. 保护好你手机里的照片证据，这是你的护身符。',
                isKiller: false
            },
            {
                name: '陈静',
                description: '公司的人事主管，外表温柔体贴，善于处理人际关系。',
                storyline: `我曾是王强秘密的情人，他承诺过会和妻子离婚娶我。但最近，我发现他为了攀附一个富家女，准备抛弃我。更让我恐惧的是，他手机里存着我们大量的私密照片和视频，如果曝光，我的职业生涯就全毁了。\n**晚上8:45**：我知道王强有喝咖啡的习惯。我提前准备了强效安眠药，磨成粉末，藏在身上。\n**晚上9:00**：我以关心他为由，为他冲了一杯咖啡，并将安眠药全部倒了进去，然后端进了他的办公室。他当时正在处理文件，没有怀疑，喝了一大口。\n**晚上9:10**：我借口离开，在外面观察。不一会儿，就看到他趴在桌上睡着了。\n**晚上9:20**：我返回办公室，想找到他的手机删除资料。但我怎么也找不到他的手机。此时我发现他已经没了呼吸，我吓坏了，慌乱中，我不小心将他桌上的一条项链（他准备送给那个富家女的）碰掉，掉进了我的手提包里。\n**晚上9:40**：我惊慌失措地逃离了办公室，回到自己的工位假装加班，心乱如麻。`,
                tasks: `【你的核心任务】\n请隐藏你为了销毁证据而失手用安眠药毒杀王强的事实。你是本案的唯一真凶。\n\n【你的行动指南】\n1. 嫁祸他人。你可以利用你看到的、听到的信息，将嫌疑引向李思或孙伟。\n2. 你包里的项链是定时炸弹，想办法合理解释它的来历，或者神不知鬼不觉地处理掉它。\n3. 你的目标是误导所有人，让他们投出错误的凶手。`,
                isKiller: true
            },
            {
                name: '周毅',
                description: '公司大楼的夜班保安，看起来忠厚老实，但观察力敏锐。',
                storyline: `作为保安，我负责大楼夜间的安全巡逻。\n**晚上8:10**：我巡逻到18楼，听到总监办公室里有激烈的争吵声，好像是那个叫李思的程序员，我没敢靠近。\n**晚上9:00**：我看到人事主管陈静端着杯咖啡进了总监办公室，几分钟后就出来了，看起来有点紧张。\n**晚上9:20**：我看到UI设计师孙伟，像做贼一样溜进了总监办公室。\n**晚上9:40**：我又看到陈静从总监办公室出来，这次她脸色惨白，脚步匆忙，好像丢了魂一样。我觉得很奇怪，但没敢多问。\n**晚上10:30**：我进行例行检查，发现总监办公室的门没关，进去一看，发现王总监已经……我立刻报了警。`,
                tasks: '1. 你是本案最重要的目击证人，你的任务是诚实、准确地向大家提供你看到的时间线索。\n2. 你觉得陈静的行为最可疑，你需要重点观察她，并向大家说明你的怀疑。\n3. 找出对公司最有利的真相，避免事件扩大化。',
                isKiller: false
            }
        ],
        clues: [
            { owner: '李思', description: '一张被揉成一团、丢在垃圾桶里的绩效评估报告，上面有王强龙飞凤舞的签名和“不合格，建议辞退”的批注。' },
            { owner: '赵娜', description: '你的电脑里有一封未发送的邮件，收件人是集团总部纪检委，标题是“关于比特无限项目总监王强涉嫌严重职务侵占的实名举报”。' },
            { owner: '孙伟', description: '你的手机相册里有一张照片，内容是一份内部奖金分配表，表格显示项目总奖金的70%都流向了王强的个人账户。' },
            { owner: '陈静', description: '在你的手提包夹层里，发现了一条价值不菲的钻石项链，包装盒还在，但没有贺卡。', isKey: true },
            { owner: '周毅', description: '一份保安巡逻日志，清晰地记录了你在不同时间点看到不同人进出总监办公室的情况。' },
            { owner: '公共', description: '在茶水间垃圾桶里发现一个空的安眠药药瓶，上面的标签被撕掉了。' },
            { owner: '公共', description: '在死者办公桌下发现一部手机，但不是死者常用的那部，手机已经没电了。' }
        ],
        truth: '凶手是人事主管陈静。她与总监王强有私情，但王强近期为了利益想和她分手并娶一位富家女。当晚，陈静在王强的咖啡里下了过量安眠药，想让他睡着后偷走他手机里存有的两人亲密照片。但由于药量过大，王强意外死亡。陈静在慌乱中没找到手机，反而不小心将王强准备送给富家女的项链碰进了自己的包里。'
    },
    // --- 【全新剧本1：深海遗书】 ---
    {
        id: 'built_in_2',
        name: '深海遗书',
        storyBackground: '在与世隔绝的“回响岛”上，著名的海洋学家李博士被发现死在自己反锁的书房中，桌上放着一封打印的遗书，死因为氰化物中毒。一场突如其来的风暴切断了岛上与外界的所有联系，将剩下的四个人困在了这座孤岛上：李博士的得意门生、一位竞争对手、一位沉默寡言的技术员，以及一位不请自来的记者。',
        roles: [
            {
                name: '高远',
                description: '李博士的学生，才华横溢但野心勃勃。',
                storyline: `我一直觉得老师窃取了我的研究成果。今晚，我本想和他摊牌。\n**晚上7:00**：我和老师在实验室大吵一架，他承认参考了我的数据，但拒绝公开承认。我愤怒地离开。\n**晚上8:00**：我回到宿舍，越想越气。我利用权限，远程删除了部分对他有利、对我不利的核心实验数据，想让他无法发布论文。\n**晚上9:00**：我去食堂吃饭，看到技术员陈默在调试监控设备，他看起来心事重重。\n**晚上9:45**：我看到记者张莱在李博士书房门口徘徊，似乎想进去但又不敢。`,
                tasks: '1. 隐藏你和老师的学术纠纷以及你删除数据的行为。\n2. 你认为自己的前途受到了威胁，必须找到真凶来洗清嫌疑。\n3. 引导大家怀疑其他有动机的人。',
                isKiller: false
            },
            {
                name: '林雪',
                description: '另一位海洋学家，与李博士是长期的竞争对手。',
                storyline: `我和李博士在竞争一个重要的国际科研基金。我知道他这次的研究有重大突破。\n**晚上7:30**：我去找李博士，希望他能分享一些数据，被他无情拒绝了。我们不欢而散。\n**晚上8:30**：我在自己的房间里整理资料，听到外面有奇怪的电流声，好像是停电了一瞬间又恢复了。\n**晚上9:10**：我口渴去厨房倒水，看到高远神色慌张地从机房的方向出来。\n**晚上10:00**：我经过书房时，闻到一股淡淡的杏仁味（氰化物的典型气味），但我当时以为是实验室的化学品味道，没有在意。`,
                tasks: '1. 李博士的死对你的基金申请有利，这是你的嫌疑点，你需要撇清关系。\n2. 隐藏你曾私下找他索要数据被拒的事实。\n3. 你闻到的杏仁味是关键线索，需要让大家知道。',
                isKiller: false
            },
            {
                name: '陈默',
                description: '研究站的技术员，性格内向，暗恋着李博士。',
                storyline: `我深爱着李博士，但她似乎对我毫不在意。我掌管着整个研究站的设备和监控。\n**晚上8:30**：我接到高远的请求，他让我“不小心”让监控系统断电一分钟。我虽然觉得奇怪，但因为他答应帮我向李博士说好话，我还是照做了。\n**晚上9:00**：我看到李博士把自己锁在书房里，神情悲伤。我很难过，但不敢打扰。\n**晚上9:20**：我看到记者张莱试图撬书房的门锁，被我发现后他慌忙走开了。\n**晚上10:30**：我越想越不对劲，用备用钥匙打开了书房的门，发现了博士的尸体。`,
                tasks: '1. 隐藏你曾受高远指使，人为制造监控断电的事实。\n2. 你有备用钥匙，这让你有重大嫌疑，你需要找到合理的解释。\n3. 你怀疑记者张莱有不轨行为。',
                isKiller: false
            },
            {
                name: '张莱',
                description: '一位追踪学术丑闻的记者，秘密登岛。',
                storyline: `我收到线报，称李博士的研究涉嫌造假，我是来调查真相的。今晚是最好的机会。\n**晚上9:00**：我绕到李博士书房的窗外，看到她正在电脑前打字，似乎在写着什么重要的东西。我用长焦相机拍下了几张模糊的照片。\n**晚上9:20**：我尝试从正门进入书房，想找她当面对质，但门被反锁了。我试图用铁丝开锁，结果被技术员陈默撞见了，我只好假装路过离开。\n**晚上9:50**：我回到自己的住处，放大相机里的照片，发现她打字的内容似乎是一封遗书，但内容很奇怪，好像在暗示什么。我还拍到她桌上有一个遥控器一样的东西。`,
                tasks: '1. 隐藏你记者的身份和你登岛的真实目的。\n2. 你拍到的照片是关键证据，但直接拿出来会暴露你自己。你需要巧妙地引导大家发现遗书和遥控器的问题。\n3. 你是外来者，嫌疑最大，必须尽快找到凶手。',
                isKiller: true
            }
        ],
        clues: [
            { owner: '高远', description: '你的电脑回收站里有一份未发送的邮件，内容是向竞争对手的公司投递简历，并附言可以提供“比特无限”的核心代码。' },
            { owner: '林雪', description: '在你的抽屉里，发现了一瓶标签被撕掉的化学试剂，经过检验，是无毒的营养液。' },
            { owner: '陈默', description: '一张工作日志，上面写着“20:30-20:31，18楼东区服务器意外重启，原因排查中”。'},
            { owner: '张莱', description: '你的相机里有多张照片，其中一张清晰地拍到死者电脑屏幕上的遗书内容，另一张模糊地拍到了桌上的一个小型遥控装置。', isKey: true },
            { owner: '公共', description: '死者手边的咖啡杯里检测出高浓度的氰化物，但奇怪的是，咖啡基本没喝。' },
            { owner: '公共', description: '书房的通风口内侧，发现一个被改装过的、连接着小型雾化喷嘴的遥控香薰机，里面残留有氰化物液体。' },
            { owner: '公共', description: '死者的电脑浏览器历史显示，她在死前最后一个访问的页面是她已故丈夫的纪念网站。' }
        ],
        truth: '凶手是记者张莱。他并非想杀死李博士，而是想制造混乱以窃取学术造假的证据。他提前在书房的通风口安装了遥控毒气装置，计划在采访时如果李博士不配合，就少量释放让她昏迷。但他没想到，当晚李博士因为思念亡夫而情绪低落，正在写一封真的遗书。张莱在窗外看到遗书，误以为时机已到，便按下了遥控器，导致李博士吸入过量毒气身亡。他之后尝试进入房间取回装置未果。'
    },
    // --- 【全新剧本2：古堡魅影】 ---
    {
        id: 'built_in_3',
        name: '古堡魅影',
        storyBackground: '在浓雾笼罩的偏远古堡里，富有而古怪的伯爵被发现死在反锁的书房中，胸口插着一把古董拆信刀。猛烈的暴风雨切断了城堡与外界的唯一桥梁，所有人都被困于此：伯爵年轻貌美的妻子、与他素有嫌隙的侄子、负债累累的私人医生，以及一位被请来进行降神会的女巫。',
        roles: [
            {
                name: '安娜',
                description: '伯爵的年轻妻子，被外界传言是为了财产才嫁给年迈的伯爵。',
                storyline: `我受够了这段没有爱情的婚姻。我爱上了侄子爱德华，我们计划私奔。\n**晚上8:00**：我和爱德华在花园秘密会面，商量私奔的细节。我告诉他，我找到了一条可以通往书房的密道。\n**晚上9:00**：伯爵把我叫到书房，再次因为我购买奢侈品的事与我争吵，并威胁要修改遗嘱，剥夺我的继承权。我愤怒地离开。\n**晚上9:30**：我回到房间，收拾好我的珠宝准备离开。此时我听到楼下传来一声女人的尖叫，但很快就消失了。\n**晚上10:00**：我从房间的密道入口进入，想去书房偷走遗嘱。当我从书房的壁炉后走出来时，发现伯爵已经倒在血泊里。我吓坏了，立刻原路返回，不敢声张。`,
                tasks: '1. 隐藏你和爱德华的私情以及私奔计划。\n2. 隐藏你曾通过密道进入案发现场的事实。\n3. 你认为凶手是其他人，需要尽快找到证据洗脱嫌疑。',
                isKiller: false
            },
            {
                name: '爱德华',
                description: '伯爵的侄子，放荡不羁，是城堡的法定继承人，但与伯爵关系恶劣。',
                storyline: `我急需用钱，但老家伙一分钱都不肯给我。我今晚准备偷点东西去卖。\n**晚上8:00**：我和安娜在花园见面，她告诉我一条通往书房的密道，这正合我意。\n**晚上8:30**：我看到医生马丁行色匆匆地进了伯爵的书房。\n**晚上9:10**：我准备通过安娜告诉我的密道进入书房，但在密道口听到了里面有奇怪的响动，我害怕被发现，就退了回来。\n**晚上9:40**：我在走廊里遇到了女巫罗兰女士，她警告我今晚城堡会有血光之灾，让我不要乱走动。她的眼神很奇怪，让我不寒而栗。`,
                tasks: '1. 隐藏你计划偷窃以及知道密道的事实。\n2. 伯爵死了，你是最大受益人，你的嫌疑最大。你需要将嫌疑转移到他人身上，比如医生或行为诡异的女巫。\n3. 你需要找到对你有利的证据。',
                isKiller: false
            },
            {
                name: '马丁医生',
                description: '伯爵的私人医生，医术高明，但深陷赌博债务。',
                storyline: `我欠了伯爵一大笔钱，他拿走了我的行医执照作为抵押，并威胁如果我还不上钱，就让我身败名裂。\n**晚上8:30**：我去找伯爵，恳求他再宽限我一段时间。他不仅拒绝了，还羞辱了我一番。我绝望地离开。\n**晚上9:00**：我回到我的房间，准备了一些强效镇定剂，我计划让他睡着，然后偷回我的行医执照。\n**晚上9:20**：我再次来到书房门口，却听到里面安娜和伯爵在激烈争吵。我只好暂时放弃计划，躲在附近观察。\n**晚上9:40后**：我看到安娜气冲冲地离开后，就再也没人进出过书房。我因为害怕一直没敢动手，直到尸体被发现。`,
                tasks: '1. 隐藏你欠下巨额赌债并被伯爵威胁的事实。\n2. 隐藏你准备了镇定剂并计划偷东西的意图。\n3. 你是最后一个见到伯爵的人之一，你需要证明你离开后还有作案时间。',
                isKiller: false
            },
            {
                name: '罗兰女士',
                description: '著名的灵媒、女巫，被伯爵请来进行降神会，与城堡的“幽灵”对话。',
                storyline: `我是个骗子。伯爵发现了我的秘密，并以此敲诈我，让我免费为他“服务”。\n**晚上9:10**：伯爵把我叫到书房，再次威胁我，说如果今晚的降神会不能让他满意，就要揭穿我的一切。我感到前所未有的恐惧。\n**晚上9:30**：我借口准备仪式，独自留在书房。伯爵背对着我，在欣赏一幅画。我看到桌上有一把锋利的拆信刀，一时冲动，拿起刀从背后刺向了他。他当场倒下。我发出一声短促的尖叫，但立刻捂住了嘴。\n**晚上9:35**：我慌乱地将书房门从内反锁，然后从墙角的书架后面启动了密道（这是我之前偷偷发现的），逃离了现场。在密道中，我的一片蕾丝袖口被挂掉了。\n**晚上9:40**：我从密道出来，遇到了爱德华，我故作神秘地警告他有血光之灾，以掩饰我的慌张。`,
                tasks: '1. 你是真凶！你的任务是隐藏一切，将罪行嫁祸给他人。\n2. 利用你“女巫”的身份，编造一些鬼神之说来混淆视听。\n3. 爱德华和安娜都知道密道，这是嫁祸他们的好机会。马丁医生有强烈的动机，也可以加以利用。',
                isKiller: true
            }
        ],
        clues: [
            { owner: '安娜', description: '你的珠宝盒里有一张单程的火车票，目的地是巴黎，时间是明天一早。' },
            { owner: '爱德华', description: '你的口袋里有一张当票，上面是一枚属于伯爵家族的古董怀表。' },
            { owner: '马丁医生', description: '你的药箱里有一瓶几乎满装的强效镇定剂，以及一张伯爵写的、要求你一周内还清10万英镑欠款的字条。' },
            { owner: '罗兰女士', description: '你的长裙袖口处有一块明显的撕裂痕迹，似乎是被什么东西挂坏的。', isKey: true },
            { owner: '公共', description: '在书房壁炉后面发现一个隐蔽的按钮，按下后，旁边的一整面书架会旋转打开，露出一条通往楼上走廊的密道。' },
            { owner: '公共', description: '在密道的地板上，发现了一小片黑色的蕾丝布料。' },
            { owner: '公共', description: '伯爵的书桌上摊开着一本关于“灵媒与欺诈”的书，其中一页用红笔圈出了“罗兰女士”的名字。' }
        ],
        truth: '凶手是女巫罗兰女士。伯爵发现了她是个骗子并以此敲诈她。当晚，伯爵再次威胁她，罗兰在恐惧和愤怒之下，用拆信刀从背后杀害了伯主。她知道城堡的密道，于是反锁房门，通过密道逃离，伪造了密室杀人案。但慌乱中，她的一片蕾f丝袖口挂在了密道里，成为了关键证据。'
    }
];

// ▲▲▲ 剧本库粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

/**
 * 【全新】从一个已领完的红包中找出“手气王”
 * @param {object} packet - 已领完的红包消息对象
 * @returns {object|null} - 返回手气王的信息 { name, amount }，或 null
 */
function findLuckyKing(packet) {
    const claimedBy = packet.claimedBy || {};
    const claimedEntries = Object.entries(claimedBy);
    
    // 如果红包是“拼手气”类型，并且有超过1个人领取
    if (packet.packetType === 'lucky' && claimedEntries.length > 1) {
        let luckyKing = { name: '', amount: -1 };
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
        return luckyKing;
    }
    return null; // 如果不满足条件，则没有手气王
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null, weiboCharRecognition: true };
let datingGameState = {
    isActive: false,
    scene: null,
    characterId: null,
    storyHistory: [],
    romance: 0,
    lust: 0,
    currentStoryText: "",
    currentSentenceIndex: -1,
    sentences: [],
    isSwitchingSentence: false,
    isNsfwMode: false,
    completion: 0
};
// ▼▼▼ 在这里粘贴下面这一行新代码 ▼▼▼
let currentDatingSummary = null; // 用于暂存当前结算卡片的数据
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在变量定义区添加 ▼▼▼
let isFontSlotSelectionMode = false;
let selectedFontSlots = new Set();
// ▲▲▲ 添加结束 ▲▲▲
// ▼▼▼ 在变量定义区添加 ▼▼▼
let isFrameSelectionMode = false;
let selectedFrames = new Set();
// ▲▲▲ 添加结束 ▲▲▲
// ▲▲▲ 新代码粘贴结束 ▲▲▲
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
        // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(',')[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}用户向你发送了一张图片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 尝试解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 验证解析结果是否为数组
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失败，返回原始文本
            }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了状态',
            change_music:'切换了歌曲',
            create_memory:'记录了回忆',
            create_countdown:'创建了约定/倒计时',
            text:'发送了文本',
            sticker:'发送了表情',
            ai_image:'发送了图片',
            voice_message:'发送了语音',
            transfer:'发起了转账',
            waimai_request:'发起了外卖请求',
            waimai_response:{
                paid:'回应了外卖-同意',
                rejected:'回应了外卖-拒绝'
            },
            video_call_request:'发起了视频通话',
            video_call_response:{
                accept:'回应了视频通话-接受',
                reject:'回应了视频通话-拒绝'
            },
            qzone_post:{
                shuoshuo:'发布了说说',
                text_image:'发布了文字图'
            },
            qzone_comment:'评论了动态',
            qzone_like:'点赞了动态',
            pat_user:'拍一拍了用户',
            block_user:'拉黑了用户',
            friend_request_response:'回应了好友申请',
            change_avatar:'更换了头像',
            share_link:'分享了链接',
            accept_transfer:'回应了转账-接受',
            decline_transfer:'回应了转账-拒绝/退款',
            quote_reply:'引用了回复',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含义是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/离开' : '空闲'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 图片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 点赞的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 结果是:${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 头像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的内容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

    // (例如，它是一个数组，或者一个AI返回的、我们不认识的JSON对象)
    if (typeof res !== 'string') {
        // 我们就强制使用最原始、最安全的 item.content 字符串
        res = item.content;
    }

    return [{text: res}];
}

    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision, isGemini, temperature) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增这一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
// ▼▼▼ 【修复后的代码】 ▼▼▼
let includesImages = false;
if (Array.isArray(item.content)) {
    includesImages = item.content.some((sub) => {
        return sub.type === 'image_url' && sub.image_url.url;
    });
}
                        return {
                            role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: parseFloat(temperature) || 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 0. 版本检测和缓存清理（必须在最前面执行）
        // ===================================================================
        (function() {
            const APP_VERSION = '2024.11.21.1'; // 每次更新时修改这个版本号
            const STORED_VERSION = localStorage.getItem('app_version');
            
            // 如果版本不匹配，说明是新版本，需要清理缓存
            if (STORED_VERSION !== APP_VERSION) {
                console.log(`检测到版本更新: ${STORED_VERSION || '未知'} -> ${APP_VERSION}`);
                
                // 清理所有可能的缓存
                if ('caches' in window) {
                    caches.keys().then(function(cacheNames) {
                        return Promise.all(
                            cacheNames.map(function(cacheName) {
                                return caches.delete(cacheName);
                            })
                        );
                    }).then(() => {
                        console.log('Service Worker缓存已清理');
                    });
                }
                
                // 保存新版本号
                localStorage.setItem('app_version', APP_VERSION);
                
                // 如果不是第一次加载（即有旧版本），提示用户
                if (STORED_VERSION) {
                    console.log('应用已更新到最新版本');
                }
            }
            
            // 注销任何已存在的Service Worker（如果有的话）
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(function(registrations) {
                    for (let registration of registrations) {
                        registration.unregister();
                        console.log('Service Worker已注销');
                    }
                });
            }
        })();

        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        // ▼▼▼ 【全新】宠物数值衰减相关的全局变量和常量 ▼▼▼
const PET_DECAY_INTERVAL = 60 * 60 * 1000; // 每60分钟衰减一次
const PET_DECAY_AMOUNT = { // 每次衰减的数值
    hunger: 5,
    happiness: 3
};
let petDecayTimer = null; // 用于管理衰减计时器的全局变量
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是角色手机的App列表，请粘贴到JS顶部 ▼▼▼
const CHAR_PHONE_APPS = [
    { id: 'chat', name: '微信', screen: 'character-chat-list-screen', svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>` },
    { id: 'cart', name: '购物车', screen: 'character-shopping-cart-screen', svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>` },
    { id: 'memos', name: '备忘录', screen: 'character-memos-screen', svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>` },
    { id: 'browser', name: '浏览器', screen: 'character-browser-screen', svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>` },
    { id: 'album', name: '相册', screen: 'character-album-screen', svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>` },
    { id: 'bank', name: '钱包', screen: 'character-bank-screen', svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>` },
    { id: 'trajectory', name: '足迹', screen: 'character-trajectory-screen', svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>` },
    { id: 'app_usage', name: '使用记录', screen: 'character-app-usage-screen', svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>` },
    { id: 'diary', name: '日记', screen: 'character-diary-screen', svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>` },
    // 这就是我们新加的App
    { id: 'appearance', name: '外观设置', screen: 'character-phone-appearance-screen', svg: `<svg viewBox="0 0 24 24" fill="#9C27B0"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.17 14.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34-5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32L11.41 8.5c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34 5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.4-.4-.4-1.04 0-1.41l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.2.2.31.45.31.71 0 .26-.11.51-.31.71l-1.41 1.41z"/></svg>` }
];
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

/* --- 【全新 | AI生成版 V4】约会大作战App核心功能 --- */

// 1. 全局变量，用于存储所有已生成的约会场景
let currentDatingScenes = []; 
let isGeneratingScenes = false;
let currentDatingUISettings = null; 
/* --- 【全新 | V5 - 永久保存修复版】约会大作战App核心功能 --- */

/**
 * 【总入口 V6】打开“约会大作战”App，快速显示已保存数据
 */
async function openDatingApp() {
    showScreen('date-a-live-screen');
    // 从数据库加载所有已保存的场景
    currentDatingScenes = await db.datingScenes.toArray();
    console.log(`从数据库加载了 ${currentDatingScenes.length} 个约会场景。`);
    // 渲染这些场景（只会先显示文字和加载动画）
    renderDatingScenes();
}

/**
 * 【AI核心 V6】调用AI生成【新的一批】约会场景，并【只保存场景数据】
 */
async function refreshDatingScenes() {
    if (isGeneratingScenes) {
        alert("正在加载中，请不要着急哦~");
        return;
    }
    isGeneratingScenes = true;

    const contentEl = document.getElementById('dating-scene-content');
    const loadingIndicator = document.createElement('p');
    loadingIndicator.textContent = "AI正在构思新的约会方案...";
    loadingIndicator.style.textAlign = 'center';
    loadingIndicator.style.color = 'var(--text-secondary)';
    contentEl.innerHTML = ''; // 先清空旧场景
    contentEl.appendChild(loadingIndicator);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        loadingIndicator.textContent = 'API未配置，无法生成场景！';
        loadingIndicator.style.color = 'red';
        isGeneratingScenes = false;
        return;
    }
    
    // Prompt保持不变
    const prompt = `
# 任务
你是一位顶级约会策划师，尤其擅长营造浪漫氛围。请为我策划 3-5 个适合情侣的、日常且极具浪漫情调的约会场景。

# 核心规则
1.  **场景风格**: 场景必须是现实生活中可以实现的，但要富有想象力和浪漫气息。**绝对禁止**任何黑暗、恐怖或令人不适的元素。
2.  **场景多样性**: 请包含多种类型的地点，例如：
    -   **户外**: 公园、海边、路边小吃摊。
    -   **室内**: 温馨的咖啡馆、艺术展、书店。
    -   **住宿**: 普通的温馨酒店、电竞酒店、甚至可以来点新奇的情趣酒店。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以'['开头, 以']'结尾。
4.  **内容要求**: 每个场景对象【必须】包含以下三个字段:
    -   \`"name"\`: (字符串) 一个充满浪漫想象的日常约会场景名称 (例如: "星空下的电竞双排夜", "微醺路边摊的夏日晚风", "私语书店的角落")。
    -   \`"cost"\`: (数字) 一个代表浪漫程度的虚拟花费 (例如: 288, 520, 999)。
    -   \`"imagePrompt"\`: (字符串) 一个用于文生图的、纯英文的、详细的【纯风景或静物】描述，用于生成场景图片。【绝对不能包含人物、情侣或任何人】。图片风格必须是【浪漫唯美的 (romantic, beautiful, aesthetic)】，可以使用 anime style, vibrant colors, soft lighting, masterpiece 等词汇来增强艺术感。

# JSON输出格式示例:
[
  {
    "name": "雨后公园的七彩霓虹",
    "cost": 188,
    "imagePrompt": "a peaceful park after rain, wet cobblestone path reflecting neon city lights, rainbow puddle, glowing lanterns on trees, beautiful, aesthetic, anime style, masterpiece, vibrant colors"
  }
]
`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.1, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newScenes = JSON.parse(cleanedContent);

        if (Array.isArray(newScenes)) {
            // ★★★ 核心修改：只添加uid和空的imageUrl，不再立即生成图片 ★★★
            const scenesWithId = newScenes.map((scene, index) => ({
                ...scene,
                uid: 'scene_' + Date.now() + index,
                imageUrl: '' // 初始化时图片链接为空
            }));

            await db.datingScenes.bulkAdd(scenesWithId);

            // 更新内存数据，并重新渲染（此时图片还是加载中状态）
            currentDatingScenes.push(...scenesWithId); 
            renderDatingScenes(); 
            
        } else {
            throw new Error("AI返回的数据不是有效的数组。");
        }
    } catch (error) {
        console.error("生成约会场景失败:", error);
        contentEl.innerHTML = `<p style="text-align:center; color:red;">生成失败: ${error.message}</p>`;
    } finally {
        isGeneratingScenes = false;
    }
}

/**
 * 【渲染函数 - 已改造】渲染所有约会场景卡片，并【异步】加载图片
 */
function renderDatingScenes() {
    const contentEl = document.getElementById('dating-scene-content');
    contentEl.innerHTML = ''; // 每次都清空再渲染

    if (currentDatingScenes.length === 0) {
        // 如果数据库是空的，显示提示并触发一次生成
        if (!isGeneratingScenes) {
            contentEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 50px 0;">正在为你构思浪漫的约会方案...</p>';
            refreshDatingScenes(); 
        }
        return;
    }
    
    // ★★★ 核心修改：使用 forEach 立即渲染所有卡片 ★★★
    currentDatingScenes.forEach(scene => {
        const card = createDatingSceneCard(scene);
        contentEl.appendChild(card);
        // ★★★ 核心修改：调用新的异步函数去处理图片 ★★★
        loadAndDisplaySceneImage(scene);
    });
}
/**
 * 【全新辅助函数】为单个场景加载或生成图片，并更新其卡片
 * @param {object} scene - 约会场景对象
 */
async function loadAndDisplaySceneImage(scene) {
    const card = document.querySelector(`.dating-scene-card[data-uid="${scene.uid}"]`);
    if (!card) return;
    const imageContainer = card.querySelector('.dating-scene-image-container');

    // 1. 如果数据库里已经有图片URL，直接使用它
    if (scene.imageUrl) {
        imageContainer.innerHTML = `<img src="${scene.imageUrl}" alt="${scene.name}">`;
        return;
    }

    // 2. 如果没有URL，说明需要生成
    try {
        const imageUrl = await generateAndLoadImage(scene.imagePrompt);
        // 生成成功后，更新UI
        if (document.body.contains(imageContainer)) {
             imageContainer.innerHTML = `<img src="${imageUrl}" alt="${scene.name}">`;
        }
       
        // ★★★ 关键：将新生成的URL保存回数据库！★★★
        scene.imageUrl = imageUrl;
        await db.datingScenes.update(scene.uid, { imageUrl: imageUrl });
        console.log(`为场景 "${scene.name}" 生成并保存了新图片。`);

    } catch (error) {
        console.error(`场景 "${scene.name}" 图片渲染失败:`, error);
        if (document.body.contains(imageContainer)) {
            imageContainer.innerHTML = `<span>图片加载失败</span>`;
        }
    }
}

/**
 * 【全新】根据唯一ID删除一个约会场景 (已添加数据库操作)
 * @param {string} sceneUid - 场景的唯一ID
 */
async function deleteDatingScene(sceneUid) {
    const cardToRemove = document.querySelector(`.dating-scene-card[data-uid="${sceneUid}"]`);
    if (cardToRemove) {
        cardToRemove.style.transition = 'transform 0.3s, opacity 0.3s';
        cardToRemove.style.transform = 'scale(0.9)';
        cardToRemove.style.opacity = '0';
        setTimeout(async () => {
            await db.datingScenes.delete(sceneUid);
            currentDatingScenes = currentDatingScenes.filter(scene => scene.uid !== sceneUid);
            cardToRemove.remove();
        }, 300);
    }
}


// (你原来的其他辅助函数 processSceneImages, createDatingSceneCard, generateAndLoadImage 保持不变，我已经帮你整合好了)
async function processSceneImages(newScenes) {
    const contentEl = document.getElementById('dating-scene-content');

    for (const scene of newScenes) {
        const card = createDatingSceneCard(scene);
        contentEl.appendChild(card);
        
        try {
            const imageUrl = await generateAndLoadImage(scene.imagePrompt);
            const imageContainer = card.querySelector('.dating-scene-image-container');
            if (imageContainer) {
                imageContainer.innerHTML = `<img src="${imageUrl}" alt="${scene.name}">`;
            }
        } catch (error) {
            console.error(`场景 "${scene.name}" 图片生成失败:`, error);
            const imageContainer = card.querySelector('.dating-scene-image-container');
            if (imageContainer) {
                imageContainer.innerHTML = `<span>图片生成失败</span>`;
            }
        }
    }
}

function createDatingSceneCard(scene) {
    const card = document.createElement('div');
    card.className = 'dating-scene-card';
    card.dataset.uid = scene.uid;

    card.innerHTML = `
        <button class="dating-scene-delete-btn" title="删除此场景">×</button>
        <div class="dating-scene-image-container">
            <div class="loading-spinner"></div>
        </div>
        <div class="dating-scene-info">
            <div class="name">${scene.name}</div>
            <div class="cost">花费: ${scene.cost}金币</div>
        </div>
    `;
    return card;
}

function generateAndLoadImage(prompt) {
    return new Promise((resolve, reject) => {
        const encodedPrompt = encodeURIComponent(prompt);
        const seed = Math.floor(Math.random() * 100000);
        const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1024&height=640&seed=${seed}`;
        
        const img = new Image();
        img.src = imageUrl;

        img.onload = () => resolve(imageUrl);
        img.onerror = () => {
            console.warn(`主URL加载失败，尝试备用URL for: ${prompt}`);
            const fallbackUrl = `https://pollinations.ai/p/${encodedPrompt}?width=1024&height=640&seed=${seed}`;
            img.src = fallbackUrl;
            img.onload = () => resolve(fallbackUrl);
            img.onerror = () => reject(new Error('主域名和备用域名均加载失败'));
        };
    });
}
/* --- 约会大作战功能结束 --- */

// ▲▲▲ 新增代码结束 ▲▲▲


// ▲▲▲ 新增代码结束 ▲▲▲

// ▲▲▲ 新增代码结束 ▲▲▲

// ▲▲▲ 代码粘贴结束 ▲▲▲
const db = new Dexie('GeminiChatDB');
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// ▲▲▲ 新增代码结束 ▲▲▲

        // ▼▼▼ 把下面这一整块全新的微博功能代码，粘贴到这里 ▼▼▼

/**
 * 【微博】总入口：根据当前激活的视图，渲染对应的微博Feed
 */
async function renderWeiboFeeds(viewId) {
    if (viewId === 'weibo-my-profile-view') {
        await renderMyWeiboFeed();
    } else if (viewId === 'weibo-following-view') {
        await renderFollowingWeiboFeed();
    }
}

// ▼▼▼ 用这【两块新代码】分别替换旧的 renderMyWeiboFeed 和 renderFollowingWeiboFeed 函数 ▼▼▼

/**
 * 【微博】渲染“我的主页”上的微博列表
 */
async function renderMyWeiboFeed() {
    const feedEl = document.getElementById('my-weibo-feed-list');
    const posts = await db.weiboPosts.where('authorId').equals('user').reverse().toArray();
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你还没有发过微博哦，点击右上角“+”试试吧！</p>';
        return;
    }
    posts.forEach(post => {
        // 【核心修改】调用我们新的专属函数！
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

// ▼▼▼ 用这块【已修复】的代码，完整替换掉你旧的 renderFollowingWeiboFeed 函数 ▼▼▼
/**
 * 【微博】渲染“关注的人”的微博Feed (已修复卡顿问题)
 */
async function renderFollowingWeiboFeed() {
    const feedEl = document.getElementById('weibo-following-feed-list');
    
    // 【核心优化】我们不再一次性读取所有帖子，而是直接让数据库帮我们筛选和排序，速度会快很多！
    const posts = await db.weiboPosts
        .where('authorId').notEqual('user') // 1. 直接在数据库层面，找出作者不是'user'的帖子
        .reverse()                          // 2. 让结果按倒序排列
        .sortBy('timestamp');               // 3. 根据时间戳排序

    // 后续的渲染逻辑保持不变
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你关注的人还没有发布任何动态哦。</p>';
        return;
    }
    posts.forEach(post => {
        feedEl.appendChild(createWeiboPostElement(post));
    });
}


// ▼▼▼ 请用这【一整块】全新的代码，完整替换掉你旧的 createWeiboPostElement 函数 ▼▼▼

function createWeiboPostElement(post) {
    const postEl = document.createElement('div');
    postEl.className = 'weibo-post-item'; 

    let contentHtml = '';
    if (post.content) {
        contentHtml += `<div class="weibo-post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
    }
    
    if (post.imageUrl) {
        if (post.postType === 'text_image') {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent || ''}">`;
        } else {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image">`;
        }
    }

    let commentsHtml = '';
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) {
        commentsHtml += '<div class="weibo-comments-container">';
        post.comments.forEach(comment => {
            if (typeof comment !== 'object' || comment === null) return;
            let replyHtml = '';
            
            // ★ 修改1：为被回复者添加专属的 class 和 data 属性，方便我们精确点击
            if (comment.replyToNickname) {
                replyHtml = `<span class="weibo-comment-reply-tag">回复</span><span class="reply-target-name" data-reply-to-name="${comment.replyToNickname}">${comment.replyToNickname}</span>`;
            }

            commentsHtml += `
                <div class="weibo-comment-item" data-comment-id="${comment.commentId}" data-commenter-name="${comment.authorNickname}">
                    <span class="weibo-commenter-name">${comment.authorNickname}</span>
                    ${replyHtml}:
                    <span class="weibo-comment-text">${comment.commentText}</span>
                    <button class="comment-delete-btn" title="删除此条评论">×</button>
                </div>`;
        });
        commentsHtml += '</div>';
    }

    const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
    const isLiked = post.likes && post.likes.includes(myNickname);
    
    let finalAuthorAvatar, finalAuthorNickname, finalAuthorAvatarFrame;
    if (post.authorId === 'user') {
        finalAuthorAvatar = state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar;
        finalAuthorNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
        finalAuthorAvatarFrame = state.qzoneSettings.weiboAvatarFrame || '';
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        finalAuthorNickname = authorChat.settings.weiboNickname || authorChat.name;
        finalAuthorAvatar = authorChat.settings.weiboAvatar || authorChat.settings.aiAvatar || defaultAvatar;
        finalAuthorAvatarFrame = authorChat.settings.weiboAvatarFrame || authorChat.settings.aiAvatarFrame || '';
    } else {
        finalAuthorAvatar = defaultAvatar;
        finalAuthorNickname = post.authorNickname || '未知用户';
        finalAuthorAvatarFrame = '';
    }

    let avatarHtml = '';
    if (finalAuthorAvatarFrame) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${finalAuthorAvatar}" class="avatar-img weibo-post-avatar">
                <img src="${finalAuthorAvatarFrame}" class="avatar-frame">
            </div>`;
    } else {
        avatarHtml = `<img src="${finalAuthorAvatar}" class="weibo-post-avatar">`;
    }
    
    const clickableAvatarWrapper = `
        <div class="weibo-post-avatar-clickable" data-char-id="${post.authorId}">
            ${avatarHtml}
        </div>
    `;

    postEl.innerHTML = `
        <div class="weibo-post-header">
            ${clickableAvatarWrapper} 
            <div class="weibo-post-info">
                <span class="weibo-post-nickname">${finalAuthorNickname}</span>
                <span class="weibo-post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
            </div>
            <div class="post-actions-btn" data-post-id="${post.id}" data-author-id="${post.authorId}">…</div>
        </div>
        ${contentHtml}
        <div class="weibo-post-footer">
            <div class="weibo-post-actions">
                <span class="weibo-action-btn like-btn ${isLiked ? 'liked' : ''}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                    <span>${(post.baseLikesCount || 0) + (post.likes || []).length}</span>
                </span>
                <span class="weibo-action-btn comment-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>           
                    <span>${(post.comments || []).length}</span>
                </span>
                <span class="weibo-action-btn generate-comments-btn" title="AI生成评论">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
                    </svg>
                    <span>生成评论</span>
                </span>
            </div>
            ${commentsHtml}
            <div class="weibo-comment-input-area">
                <input type="text" class="weibo-comment-input" placeholder="留下你的精彩评论吧...">
                <button class="weibo-comment-send-btn">发送</button>
            </div>
        </div>
    `;

    // 绑定发送评论按钮
    const sendBtn = postEl.querySelector('.weibo-comment-send-btn');
    if (sendBtn) {
        sendBtn.addEventListener('click', () => {
            const input = postEl.querySelector('.weibo-comment-input');
            handleWeiboComment(post.id, input);
        });
    }

    // 绑定AI生成评论按钮
    const generateBtn = postEl.querySelector('.generate-comments-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', () => generateWeiboComments(post.id));
    }
    
    // 绑定点赞按钮
    const likeBtn = postEl.querySelector('.like-btn');
    if (likeBtn) {
        likeBtn.addEventListener('click', () => handleWeiboLike(post.id));
    }

    // ★ 修改2：为评论区绑定一个全新的、功能更强大的点击事件监听器
    const commentSection = postEl.querySelector('.weibo-comments-container');
    if (commentSection) {
        commentSection.addEventListener('click', (e) => {
            // 阻止事件冒泡，这是解决点击无效的核心！
            e.stopPropagation();

            const target = e.target;
            const commentItem = target.closest('.weibo-comment-item');
            if (!commentItem) return; // 如果点击的不是评论区，就什么也不做
            
            const input = postEl.querySelector('.weibo-comment-input');

            // 检查点击的是否是删除按钮
            if (target.closest('.comment-delete-btn')) {
                deleteWeiboComment(post.id, commentItem.dataset.commentId);
                return; // 删除后结束
            }
            
            let replyToName = '';
            const replyToId = commentItem.dataset.commentId;

            // ★ 修改3：新增逻辑，判断你点击的是谁
            if (target.classList.contains('reply-target-name')) {
                // 如果点击了“被回复者”的名字
                replyToName = target.dataset.replyToName;
            } else {
                // 否则，默认回复这条评论的作者
                replyToName = commentItem.dataset.commenterName;
            }

            // ★ 修改4：优化回复逻辑
            // 如果正在回复同一个人，则取消回复
            if (input.dataset.replyToId === replyToId && input.placeholder.includes(`@${replyToName}`)) {
                input.placeholder = '留下你的精彩评论吧...';
                delete input.dataset.replyToId;
                delete input.dataset.replyToNickname;
            } else {
                // 否则，设置为新的回复目标
                input.placeholder = `回复 @${replyToName}:`;
                input.dataset.replyToId = replyToId;
                input.dataset.replyToNickname = replyToName;
                input.focus();
            }
        });
    }

    return postEl;
}
// ▲▲▲ 替换结束 ▲▲▲





/**
 * 【微博】打开微博发布/编辑模态框
 */
async function openWeiboPublisher() {
    const modal = document.getElementById('create-post-modal');
    
    modal.dataset.mode = 'weibo'; // 关键！标记为微博模式
    
    document.getElementById('create-post-modal-title').textContent = '发微博';
    document.getElementById('post-public-text').placeholder = '有什么新鲜事想分享给大家？';
    
    // 隐藏动态专属的控件
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-comments-toggle-group').style.display = 'none';
    
    document.getElementById('post-mode-switcher').style.display = 'flex'; // 微博也需要模式切换
    
    resetCreatePostModal();
    modal.classList.add('visible');
}
/**
 * 【全新】智能解析带“万”或“亿”的数字字符串
 * @param {string} str - 包含数字的字符串，例如 "30000", "3万", "1.5万"
 * @returns {number} - 解析后的纯数字
 */
function parseChineseNumber(str) {
    if (!str) return 0; // 安全检查

    str = String(str).trim().toLowerCase(); // 转换为小写字符串并去除空格

    let num = parseFloat(str); // 先尝试直接解析数字部分

    if (str.includes('万') || str.includes('w')) {
        // 如果包含“万”或“w”，则将数字部分乘以10000
        num = parseFloat(str) * 10000;
    } else if (str.includes('亿')) {
        // 如果包含“亿”，则乘以100000000
        num = parseFloat(str) * 100000000;
    }

    // 如果解析失败 (比如输入了纯文字)，返回0
    return isNaN(num) ? 0 : Math.floor(num); // 返回整数，确保结果干净
}

// ▼▼▼ 请用这【一整块功能增强版】的代码，完整替换掉你旧的 handlePublishWeibo 函数 ▼▼▼
/**
 * 【微博 V3 - 粉丝数计算版】处理发布微博的核心函数
 */
async function handlePublishWeibo() {
    const modal = document.getElementById('create-post-modal');
    
// ▼▼▼ 从这里开始，是你要粘贴的新代码 ▼▼▼
const mainContent = document.getElementById('post-public-text').value.trim();
let imageUrl = '', hiddenContent = '', postType = 'text_only', imageDescription = '';

const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

if (isImageModeActive) {
    // 【核心修复】我们现在通过检查预览容器是否可见，来判断用户是否真的上传了图片
    const hasImage = document.getElementById('post-image-preview-container').classList.contains('visible');
    
    if (hasImage) {
        imageUrl = document.getElementById('post-image-preview').src;
        postType = 'image';
        imageDescription = document.getElementById('post-image-description').value.trim();
        // 图片描述的检查逻辑保持不变
        if (!imageDescription) {
            alert("为了让AI能看懂图片，请务必填写图片描述哦！");
            return;
        }
    }
    // 如果 hasImage 是 false (即用户只想发纯文字)，这段代码就会被跳过，imageUrl 保持为空，postType 保持为 text_only
    
} else { // 文字图模式的逻辑保持不变
    hiddenContent = document.getElementById('post-hidden-text').value.trim();
    if (hiddenContent) {
        imageUrl = 'https://i.postimg.cc/KYr2qRCK/1.jpg'; 
        postType = 'text_image';
    }
}
// ▲▲▲ 到这里为止，是你要粘贴的新代码 ▲▲▲

    if (!mainContent && !imageUrl) {
        alert('微博内容不能为空哦！');
        return;
    }

    const fansCount = parseChineseNumber(state.qzoneSettings.weiboFansCount) || 0;
    const baseLikes = Math.floor(fansCount * (Math.random() * 0.1 + 0.1));
    const baseComments = Math.floor(baseLikes * (Math.random() * 0.1 + 0.05));

    const newPost = {
        authorId: 'user',
        authorType: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        authorAvatar: state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar,
        content: mainContent,
        imageUrl: imageUrl,
        // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
        authorAvatarFrame: state.qzoneSettings.weiboAvatarFrame || '',
        // ▲▲▲ 添加结束 ▲▲▲
        // ▼▼▼ 这是新增的核心代码 ▼▼▼
        imageDescription: imageDescription, // 3. 把获取到的描述保存到新字段里！
        // ▲▲▲ 新增结束 ▲▲▲

        hiddenContent: hiddenContent,
        postType: postType,
        timestamp: Date.now(),
        likes: [],
        comments: [],
        baseLikesCount: baseLikes,
        baseCommentsCount: baseComments
    };

    await db.weiboPosts.add(newPost);
    await renderMyWeiboFeed(); 
    await renderWeiboProfile();
    
    modal.classList.remove('visible');
    alert('微博发布成功！');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【微博】处理点赞/取消点赞
 * @param {number} postId - 帖子ID
 */
async function handleWeiboLike(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    const myNickname = state.qzoneSettings.nickname || '我';
    if (!post.likes) post.likes = [];
    
    const likeIndex = post.likes.indexOf(myNickname);
    if (likeIndex > -1) {
        post.likes.splice(likeIndex, 1); // 取消点赞
    } else {
        post.likes.push(myNickname); // 点赞
    }

    await db.weiboPosts.put(post);
    // 重新渲染两个Feed，确保数据同步
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}

/**
 * 【微博】处理发布评论或回复
 * @param {number} postId - 帖子ID
 * @param {HTMLInputElement} inputElement - 评论输入框元素
 */
async function handleWeiboComment(postId, inputElement) {
    const commentText = inputElement.value.trim();
    if (!commentText) {
        alert("评论内容不能为空！");
        return;
    }

    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    if (!post.comments) post.comments = [];

    const newComment = {
        commentId: 'comment_' + Date.now(),
        authorId: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        commentText: commentText,
        timestamp: Date.now()
    };
    
    // 检查是否是回复
    if (inputElement.dataset.replyToId) {
        newComment.replyToId = inputElement.dataset.replyToId;
        newComment.replyToNickname = inputElement.dataset.replyToNickname;
    }

    post.comments.push(newComment);
    await db.weiboPosts.put(post);
    
    // 清空输入框并重置状态
    inputElement.value = '';
    inputElement.placeholder = '留下你的精彩评论吧...';
    delete inputElement.dataset.replyToId;
    delete inputElement.dataset.replyToNickname;
    
    // 重新渲染两个Feed
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}


// ▲▲▲ 全新的微博功能代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里添加您的 API 站点黑名单 ▼▼▼
const BLOCKED_API_SITES = [
    'api.pisces.ink',
    'aiapi.qzz.io'
];
// ▲▲▲ 黑名单定义结束 ▲▲▲
        // --- 已修正 ---

        // --- 修正结束 ---
    let isUserStickerSelectionMode = false;
    let activeStickerCategoryId = 'uncategorized'; 
let userStickerCategories = [];      // 用于缓存用户的所有分类
    // ▼▼▼ 在 isUserStickerSelectionMode 变量后添加 ▼▼▼
let isCharStickerSelectionMode = false;
let selectedCharStickers = new Set();
// ▲▲▲ 添加结束 ▲▲▲
let selectedUserStickers = new Set();
let currentViewingDmsFor = null; // 用于追踪正在查看哪个角色的私信
let currentUserDmFanIndex = null; // 用于追踪正在查看哪个粉丝的私信
        let isLocked = false; // <-- 在这里添加这行新代码
        let newLockscreenWallpaperBase64 = null; // <-- 在这里添加这行新代码
let newGlobalBgBase64 = null; // 用于暂存新的全局聊天背景
let newAppWallpaperBase64 = null;
let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    // 【新增】歌词相关状态
    parsedLyrics: [],      // 当前歌曲解析后的歌词数组
    currentLyricIndex: -1  // 当前高亮的歌词行索引
};

// ▲▲▲ 新增状态管理器结束 ▲▲▲
let lyricsBarSettings = {
    fontSize: 14,
    bgOpacity: 0,
    fontColor: '#FFFFFF',
    showOnClose: true // 【问题4需要】默认开启
};

        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let isInnerVoiceHistoryOpen = false; // 用于跟踪历史面板是否打开

        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;
let activeCharPhonePresetId = null; // 用于追踪角色手机外观预设的选择
let activeCharacterPhoneId = null;
let waimaiTimers = {}; // 用于存储外卖倒计时
let editingSpriteGroupId = null;
let activeMessageTimestamp = null;





let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
let currentSearchKeyword = ''; // 用于在搜索结果中高亮关键词
let activePostId = null; // <-- 新增：用于存储当前操作的动态ID
// ▼▼▼ 【全新】BGM 搜索功能核心代码 ▼▼▼

// 一个简单的网络请求函数
if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

// 检查音频链接是否真的可以播放
function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

// ▼▼▼ 【V9.0 | 终极纯净版 - 移除代理】请用这块代码，完整替换旧的 searchNeteaseMusic 函数 ▼▼▼
/**
 * 移除所有代理，直接请求你找到的 vkeys.cn API
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        // 【核心修改】我们不再需要任何代理，直接把目标API作为最终请求地址！
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("正在尝试直接请求:", apiUrl); // 添加一条日志，方便我们调试
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("vkeys API返回无结果:", result);
            return [];
        }
        
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzP-album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 15);

    } catch (e) {
        // 如果这次还失败，请把浏览器F12控制台里的红色错误信息完整地截图给我
        console.error("【vkeys API 直连】搜索失败:", e);
        await showCustomAlert("网易云接口直连失败", `如果浏览器控制台(F12)提示CORS错误，说明此API禁止直接访问。错误: ${e.message}`);
        return [];
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 从QQ音乐搜索歌曲列表
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'tencent' // 标记来源
        })).slice(0, 5); // 只取前5条结果
    } catch (e) {
        console.error("QQ音乐搜索API失败:", e);
        return [];
    }
}
// ▼▼▼ 【V2.0 | 支持源选择】请用这个全新的函数，完整替换旧的 addSongFromSearch ▼▼▼
/**
 * 【总入口 V2.0】当用户点击“搜索”按钮时触发
 */
async function addSongFromSearch() {
    // 步骤 1: 首先弹出选择框，让用户选择搜索源
    const source = await showSearchSourceSelector();
    // 如果用户点了取消，source会是null，我们直接退出函数
    if (!source) return;

    // 步骤 2: 弹出输入框让用户输入关键词 (这部分逻辑不变)
    const searchTerm = await showCustomPrompt("搜索歌曲", "请输入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("请稍候...", "正在搜索歌曲资源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    // 步骤 3: 【核心修改】根据用户的选择，执行不同的搜索
    let combinedResults = [];

    if (source === 'all') {
        // 如果选择“全部”，则并行搜索两个平台
        const [neteaseResults, tencentResults] = await Promise.all([
            searchNeteaseMusic(musicName, singerName),
            searchTencentMusic(musicName)
        ]);
        combinedResults = [...neteaseResults, ...tencentResults];
    } else if (source === 'netease') {
        // 如果只选“网易云”，就只调用网易云的搜索
        combinedResults = await searchNeteaseMusic(musicName, singerName);
    } else if (source === 'tencent') {
        // 如果只选“QQ音乐”，就只调用QQ音乐的搜索
        combinedResults = await searchTencentMusic(musicName);
    }

    // 步骤 4: 后续的显示逻辑保持不变
    if (combinedResults.length === 0) {
        await showCustomAlert("无结果", "抱歉，在所选来源中未能找到相关歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        item.innerHTML = `
            <div class="title">${song.name}</div>
            <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? '网易云' : 'QQ音乐'}</span></div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心升级】处理用户点击搜索结果，增加备用音源查找和是否永久保存的逻辑
 */
async function handleSearchResultClick(songData) {
    const modal = document.getElementById('music-search-results-modal');
    modal.classList.remove('visible');

    await showCustomAlert("请稍候...", `正在获取《${songData.name}》的播放链接...`);

    let playableResult = null;
    let finalSource = songData.source;

    // 1. 尝试主音源
    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    let primaryResult = await Http_Get(primaryApiUrl);
    if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }

    // 2. 如果主音源失败，尝试备用音源
    if (!playableResult) {
        await showCustomAlert("请稍候...", "主音源获取失败，正在尝试备用音源...");
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
            const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    if (!playableResult) {
        await showCustomAlert("获取失败", "无法获取该歌曲的有效播放链接，主音源和备用音源均已尝试。");
        return;
    }
    
// ▼▼▼ 从这里开始粘贴新代码 ▼▼▼
const confirmed = await showCustomConfirm(
    '温馨提示', // 这是弹窗的标题
    '搜索的歌曲24h后会过期，重要的歌曲记得用url或者本地上传哦🐇', // 这是你指定的提示内容
    { confirmText: '确定' } // 按钮会显示“确定”和“取消”，这里的“取消”就等同于“返回”
);

// 如果用户点击了“取消”（返回），就直接结束，不添加歌曲
if (!confirmed) {
    return;
}
// ▲▲▲ 粘贴结束 ▲▲▲   
    // 获取歌词
    const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";

// ▼▼▼ 用这块新代码替换 ▼▼▼
const newSong = {
    name: songData.name,
    artist: songData.artist,
    src: playableResult.url,
    cover: songData.cover,
    isLocal: false,
    lrcContent: lrcContent,
    isTemporary: true,
    // 核心新增：记录这首歌被添加的精确时间
    addedTimestamp: Date.now() 
};
// ▲▲▲ 替换结束 ▲▲▲



musicState.playlist.push(newSong);

// 注意：我们已经删除了 saveGlobalPlaylist() 的调用，因为临时歌曲不需要被永久保存
// ▲▲▲ 替换结束 ▲▲▲

    
    updatePlaylistUI();

    if (musicState.currentIndex === -1) {
        musicState.currentIndex = musicState.playlist.length - 1;
        updatePlayerUI();
    }

    await showCustomAlert("添加成功", `《${songData.name}》已成功添加到播放列表！`);
    // ▼▼▼ 把这一整块全新的代码，粘贴到指定位置 ▼▼▼
try {
    // 1. 检查一下当前是不是正在和别人聊天
    if (state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        if (chat) {
            // 2. 创建一条对用户隐藏，但对AI可见的系统消息
            const hiddenMessage = {
                role: 'system', // 告诉AI这是系统信息
                content: `[系统提示：用户刚刚通过搜索，将歌曲《${songData.name}》 - ${songData.artist} 添加到了“一起听”的播放列表中。你可以根据这个情景，自然地开启关于这首歌的话题。]`,
                timestamp: Date.now(),
                isHidden: true // 这个是关键！让这条消息在聊天界面上“隐形”
            };
            
            // 3. 把这条“隐形”消息加到聊天记录的末尾
            chat.history.push(hiddenMessage);
            
            // 4. 保存更新后的聊天记录到数据库
            await db.chats.put(chat);

            console.log(`已为歌曲《${songData.name}》成功注入AI上下文提示。`);
        }
    }
} catch (error) {
    console.error("注入歌曲上下文时出错:", error);
}
// ▲▲▲ 粘贴结束 ▲▲▲
}

/**
 * 【辅助】获取网络歌曲的歌词
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\\n" + tlyric;
    }
    return "";
}
// ▼▼▼ 【全新】这个函数用来显示“选择搜索源”的弹窗 ▼▼▼
/**
 * 显示搜索源选择弹窗，并返回用户的选择
 * @returns {Promise<string|null>} 返回 'all', 'netease', 'tencent', 或 null
 */
function showSearchSourceSelector() {
    return new Promise(resolve => {
        const modal = document.getElementById('music-source-selector-modal');
        const confirmBtn = document.getElementById('confirm-source-select-btn');
        const cancelBtn = document.getElementById('cancel-source-select-btn');

        // 显示弹窗
        modal.classList.add('visible');

        // 定义确认按钮的点击事件
        const onConfirm = () => {
            const selectedSource = document.querySelector('input[name="search-source"]:checked').value;
            cleanup();
            resolve(selectedSource); // 返回用户的选择
        };

        // 定义取消按钮的点击事件
        const onCancel = () => {
            cleanup();
            resolve(null); // 用户取消，返回 null
        };

        // 清理函数，用于移除事件监听并隐藏弹窗
        const cleanup = () => {
            modal.classList.remove('visible');
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
        };

        // 绑定事件
        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
    });
}
// ▲▲▲ 新增函数结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 getLyricsForSong 函数的后面 ▼▼▼

/**
 * 【全新】根据歌名和歌手自动搜索并播放歌曲
 * @param {string} name - 歌曲名
 * @param {string} artist - 歌手名
 */
async function searchAndPlaySong(name, artist) {
    // 弹出提示，告诉用户我们正在做什么
    await showCustomAlert("请稍候...", `AI为你分享了《${name}》，正在努力寻找播放资源...`);

    let songData = null;

    // 策略1：优先用网易云搜索 (通常结果更准)
    const neteaseResults = await searchNeteaseMusic(name, artist);
    if (neteaseResults.length > 0) {
        songData = neteaseResults[0]; // 如果找到了，就用第一个结果
    } 
    // 策略2：如果网易云找不到，再用QQ音乐搜一次
    else {
        const tencentResults = await searchTencentMusic(name);
        if (tencentResults.length > 0) {
            songData = tencentResults[0]; // 用QQ音乐的第一个结果
        }
    }

    // 如果两个平台都没找到，就告诉用户并退出
    if (!songData) {
        await showCustomAlert("找不到歌曲", `抱歉，在网易云和QQ音乐都没能找到《${name}》的可播放资源。`);
        return;
    }

    // 到这里，我们已经有了一首歌的基本信息 (id, source, name, artist)
    // 下面的逻辑就是调用API获取真实的播放链接
    
    const apiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    const result = await Http_Get(apiUrl);

    // 检查获取到的链接是否真的能播放
    if (!result?.data?.url || !(await checkAudioAvailability(result.data.url))) {
        await showCustomAlert("获取失败", `找到了《${name}》，但无法获取有效的播放链接。`);
        return;
    }

    // 获取歌词
    const lrcContent = await getLyricsForSong(songData.id, songData.source) || "";

    // 准备新的歌曲对象，准备添加到播放列表
    const newSong = {
        name: songData.name,
        artist: songData.artist,
        src: result.data.url, // 使用我们刚刚获取到的真实、可播放的URL！
        cover: songData.cover,
        isLocal: false,
        lrcContent: lrcContent,
        isTemporary: true, // 标记为临时歌曲，24小时后可能会失效
        addedTimestamp: Date.now()
    };

    // 检查播放列表里是不是已经有这首歌了
    const existingIndex = musicState.playlist.findIndex(t => t.name === newSong.name && t.artist === newSong.artist);
    if (existingIndex !== -1) {
        // 如果有，直接播放它
        playSong(existingIndex);
    } else {
        // 如果没有，就添加到列表末尾再播放
        musicState.playlist.push(newSong);
        updatePlaylistUI(); // 刷新播放列表界面
        playSong(musicState.playlist.length - 1);
    }
    
    // 如果“一起听”功能是关闭的，就自动打开它
    if (!musicState.isActive) {
         startListenTogetherSession(state.activeChatId);
    } else {
        // 如果已经是打开的，就直接显示播放器窗口
        document.getElementById('music-player-overlay').classList.add('visible');
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲



        let photoViewerState = {
            isOpen: false,
            photos: [], // 存储当前相册的所有照片URL
            currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

let currentFrameSelection = { type: null, url: '', target: null }; 

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

const THEME_CSS_TEMPLATE = `
/* 
  EPhone 美化代码模板
  使用方法: 
  1. 修改下面的颜色代码或图片URL。
  2. 不需要修改的部分可以删除或保持不变。
  3. 颜色代码格式为 #RRGGBB (例如 #FFFFFF 是白色)。
  4. 图片URL需要是网络直链。
*/

/* === 1. 手机壳与刘海颜色 === */
#phone-frame {
  background-color: #f0f0f0; /* 手机壳颜色 */
}
.notch {
  background-color: #1a1a1a; /* 顶部“刘海”颜色 */
}
        #clock-container {  color: white;  }


/* === 1.5. 全局主题色 (重要！) === */
/* 这个颜色决定了大部分按钮、链接和高亮文本的颜色。*/
:root {
  --accent-color: #007bff; /* 默认是蓝色 */
}

/* === 2. 聊天界面顶部和底部的图片按钮替换 === */
/* “一起听”按钮 (正常状态) */
#listen-together-btn img[src*="8kYShvrJ/90-UI-2.png"] {
  content: url('在这里粘贴你的“正常状态”图片URL');
}
/* “一起听”按钮 (播放中状态) */
#listen-together-btn img[src*="D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png"] {
  content: url('在这里粘贴你的“播放中”图片URL');
}
/* “聊天设置”按钮 */
#chat-settings-btn img {
  content: url('https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png');
}
/* “触发API回复”按钮 */
#wait-reply-btn img {
  content: url('https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png');
}
/* “发送”按钮 (设为图片形式) */
#send-btn {
  background-image: url('在这里粘贴你的发送按钮图片URL');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  width: 50px; /* 根据你的图片调整宽度 */
}

/* “重新生成回复”按钮 */
#reroll-btn {
    background-color: rgba(255, 255, 255, 0.6);
    color: var(--text-primary); /* 使用全局主题的主文本颜色 */
}

/* === 3. 顶部栏与底部栏颜色 === */
.header, .qzone-header {
  background-color: rgba(240, 240, 240, 0.8); /* 顶部栏背景色 (带一点透明) */
  color: #333333; /* 顶部栏文字颜色 */
}
#chat-list-bottom-nav {
  background-color: rgba(245, 245, 245, 0.85); /* 底部导航栏背景色 */
}
.nav-item {
  color: #8a8a8a; /* 底部导航栏未选中项的颜色 */
}
.nav-item.active {
  color: #007bff; /* 底部导航栏选中项的颜色 */
}

/* === 4. 各界面背景色 === */
#chat-list-screen, #qzone-screen .qzone-content, #memories-view {
  background-color: #f0f2f5 !important; /* 列表页主背景色 */
}

/* === 5. 聊天输入区底部功能栏SVG图标替换 === */
/* 提示: 你需要将你的SVG代码转换为URL编码格式。
   可以使用在线工具搜索 "SVG to Data URI" 来完成转换。
   然后替换掉下面的 url('...') 部分。 */

.chat-action-icon-btn {
  background-color: rgba(255, 255, 255, 0.5); /* 图标按钮的背景色 */
  border: 1px solid rgba(0,0,0,0.05); /* 图标按钮的边框 */
}

/* 表情面板(+)按钮 */
#open-sticker-panel-btn svg { display: none; /* 隐藏原始SVG */ }
#open-sticker-panel-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 发送照片(旧)按钮 */
#send-photo-btn svg { display: none; /* 隐藏原始SVG */ }
#send-photo-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 上传图片(新)按钮 */
#upload-image-btn svg { display: none; }
#upload-image-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: black;"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 转账(￥)按钮 */
#transfer-btn svg { display: none; }
#transfer-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 语音按钮 */
#voice-message-btn svg { display: none; }
#voice-message-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 外卖按钮 */
#send-waimai-request-btn svg { display: none; }
#send-waimai-request-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 视频通话按钮 */
#video-call-btn svg { display: none; }
#video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 群视频通话按钮 */
#group-video-call-btn svg { display: none; }
#group-video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 投票按钮 */
#send-poll-btn svg { display: none; }
#send-poll-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 分享链接按钮 */
#share-link-btn svg { display: none; }
#share-link-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 发送定位按钮 (已修复) */
#send-location-btn svg { display: none; } /* 隐藏按钮内部原始的SVG图标 */
#send-location-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}


/* === 6. 更多界面背景色 === */
/* 适用于所有设置、编辑、选择等二级页面 */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#world-book-screen,
#world-book-editor-screen,
#contact-picker-screen,
#member-management-screen,
#album-screen,
#album-photos-screen,
#call-history-screen,
#chat-search-screen,
#browser-screen {
  /* 这里不再设置背景色，让它自然继承夜间模式的颜色 */
}


/* === 7. 回忆卡片美化 === */
.memory-card {
  background-color: #fffaf0 !important; /* 卡片主背景色 */
  border-left-color: #ffb74d !important; /* 左侧装饰条颜色 */
  box-shadow: 0 2px 6px rgba(0,0,0,0.07) !important;
}
.memory-card .header .author {
  color: #d98100 !important; /* 作者/标题文字颜色 */
}
.memory-card .header .date {
  color: #a1887f !important; /* 日期文字颜色 */
}
.memory-card .content {
  color: #5d4037 !important; /* 内容文字颜色 */
}
`;

// ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
// ▼▼▼ 用下面这段【修改后】的代码，完整替换掉你旧的 DEFAULT_APP_ICONS ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
    'check-phone': 'https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg',
    'weibo': 'https://i.postimg.cc/PqBY5wBq/weibo-icon.png',
    'forum': 'https://i.postimg.cc/pr0T3WfC/douban-icon.png',
    'lovers-space': 'https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png',
    'game-hall': 'https://i.postimg.cc/P5gL5z2g/game-controller-icon.png',
    'x-social': 'https://i.postimg.cc/8P1H0vQ8/x-logo.png',
    'taobao': 'https://i.postimg.cc/k47tXg1j/taologo.png',
    'date-a-live': 'https://i.postimg.cc/Kjdss1j9/1761142686734.png' 
};
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
const DEFAULT_APP_LABELS = {
    'qq': 'QQ',
    'world-book': '世界书',
    'api-settings': 'API设置',
    'wallpaper': '外观设置',
    'font': '字体',
    'check-phone': '查手机',
    'weibo': '微博',
    'forum': '圈子',
    'lovers-space': '情侣空间',
    'game-hall': '游戏大厅',
    'x-social': 'X社交',
    'taobao': '桃宝',
    'date-a-live': '约会大作战'
};
// ▲▲▲ 新代码粘贴结束 ▲▲▲





        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/i\.ibb\.co\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        window.showCustomConfirm = function(title, message, options = {}) {

            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '确定';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        window.showCustomAlert = function(title, message) {

            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '好的';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '确定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }
// ▼▼▼ 把这一整块全新的函数，粘贴到 <script> 标签的最开始 ▼▼▼
/**
 * 【全新】一个专门清除HTML标签和代码的函数
 * @param {string} text - 包含HTML或代码的原始文本
 * @returns {string} - 清理后的纯文本
 */
function stripHtmlAndCode(text) {
    if (!text || typeof text !== 'string') {
        return ''; // 如果输入为空或不是字符串，返回空字符串
    }
    // 1. 移除所有HTML标签 (例如 <b>, <div>)
    let cleanedText = text.replace(/<\/?[^>]+(>|$)/g, "");
    
    // 2. 移除所有Markdown代码块 (例如 ```code``` 或 `code`)
    cleanedText = cleanedText.replace(/```[\s\S]*?```/g, ''); // 移除多行代码块
    cleanedText = cleanedText.replace(/`[^`]*`/g, '');     // 移除行内代码
    
    // 3. 将HTML实体 (例如 &lt; &gt;) 转换回正常字符 (< >)
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = cleanedText;
    
    return tempDiv.textContent || tempDiv.innerText || "";
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
window.showCustomPrompt = function(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {

    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【核心修改】将额外的HTML和输入框组合在一起
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【核心修改】为格式助手按钮绑定事件
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("解析格式模板失败:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼
// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】从一个数组中随机获取一个元素
 * @param {Array} arr - 目标数组
 * @returns {*} - 数组中的一个随机元素
 */
function getRandomItem(arr) {
    // 安全检查，如果数组为空或不存在，返回空字符串
    if (!arr || arr.length === 0) return '';
    // 返回一个随机索引对应的元素
    return arr[Math.floor(Math.random() * arr.length)];
}

// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼




        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

// main-app.js

// ▼▼▼ 用这块新代码替换旧的 db.version(...) ▼▼▼
db.version(57).stores({ // 版本号从 56 升级到 57 (新增学习功能)
    chats: '&id, isGroup, groupId, ownerId, isPinned, characterPhoneData, latestInnerVoice, innerVoiceHistory, loversSpaceData.emotionDiaries, settings.summary, settings.weiboNickname, settings.innerVoiceHideHeaderBorder, settings.innerVoiceAdopterLabelFormat, interactionStats, unlockedSymbols, settings.selectedIntimacyBadge, settings.enableCoupleAvatarRecognition, settings.coupleAvatarRecognitionMemory', 
    apiConfig: '&id',
    globalSettings: '&id, activeThemeId', 
    userStickers: '&id, url, name, categoryId',
    userStickerCategories: '++id, &name',
    charStickers: '&id, url, name', 
    worldBooks: '&id, name, categoryId', 
    worldBookCategories: '++id, name',
    musicLibrary: '&id', 
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, authorId, timestamp', 
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate' ,
    callRecords: '++id, chatId, timestamp, customName',
    customAvatarFrames: '&id, name, url',   
    themes: '++id, name, css',
    apiPresets: '++id, name, proxyUrl',
    bubbleStylePresets: '++id, name, css',
    fontPresets: '&id, name, url',
    homeScreenPresets: '++id, name',
    weiboPosts: '++id, authorId, timestamp',
    forumGroups: '++id, name, worldview, *categories',
    forumPosts: '++id, groupId, timestamp, *categories',
    forumComments: '++id, postId, timestamp',
    forumCategories: '++id, name',
    tarotReadings: '++id, timestamp',
    baguaReadings: '++id, timestamp',
    pomodoroSessions: '++id, chatId, startTime',
    scriptKillScripts: '++id, name, isBuiltIn',
    taobaoProducts: '++id, name, category', 
    taobaoOrders: '++id, productId, timestamp',
    taobaoCart: '++id, productId',
    userWalletTransactions: '++id, timestamp' ,
    charPhonePresets: '++id, name',
    ludoQuestionBanks: '++id, name',
    ludoQuestions: '++id, bankId, text, type',
    datingScenes: '&uid, imageUrl',
    datingPresets: '++id, name, settings.spriteGroupId',
    datingSpriteGroups: '++id, name',
    accountingRecords: '++id, timestamp, type, category',
    accountingGoals: '++id, period, startDate, endDate',
    accountingCategories: '++id, name, type, isCustom',
    datingSprites: '++id, groupId, description, url',
    datingHistory: '++id, characterId, timestamp',
    offlinePresets: '++id, name',
    elemeFoods: '++id, name, category',
    elemeOrders: '++id, recipientId, timestamp',
    userAvatarLibrary: '&id, name, url',
    // ▼▼▼ 在这里添加下面这两行新代码 ▼▼▼
    userAvatarShapePresets: '++id, &name',
    charAvatarShapePresets: '++id, &name',
    // ▲▲▲ 新增代码结束 ▲▲▲
    // ▼▼▼ 月经追踪数据表 ▼▼▼
    periodSettings: '&id, lastPeriodStart, duration, cycle',
    periodMarks: '++id, date, dayNumber, timestamp',
    // ▲▲▲ 月经追踪数据表结束 ▲▲▲
    // ▼▼▼ 学习功能数据表 ▼▼▼
    studySettings: '&id, dailyGoal, weeklyGoal, monthlyGoal',
    studySubjects: '++id, name, category, isDefault',
    questionBanks: '++id, subjectId, type, content, answer, options, difficulty, explanation',
    studyRecords: '++id, date, subjectId, score, type, timestamp, details',
    studyGoals: '++id, type, target, current, startDate, endDate'
    // ▲▲▲ 学习功能数据表结束 ▲▲▲
});
// ▲▲▲ 替换结束 ▲▲▲


window.db = db;

// ===================================================================
// 3. 所有功能函数定义
// ===================================================================

// ▼▼▼ 请用这整块【修复版】代码，完整替换掉你旧的 toggleVoiceTranscript 函数 ▼▼▼

/**
 * 【V2 - 修复版】切换语音消息的文字显示/隐藏
 * @param {HTMLElement} bubble - 被点击的语音消息的 .message-bubble 元素
 */
function toggleVoiceTranscript(bubble) {
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    if (!transcriptEl) return;

    // 核心逻辑：直接检查文字区域当前是不是显示状态
    const isCurrentlyExpanded = transcriptEl.style.display === 'block';

    if (isCurrentlyExpanded) {
        // 如果是展开的，就直接收起来
        transcriptEl.style.display = 'none';
    } else {
        // 如果是收起的，就执行展开流程
        
        // 1. 先显示一个“正在转写”的提示，给用户即时反馈
        transcriptEl.textContent = '正在转文字...';
        transcriptEl.style.display = 'block';

        // 2. 模拟一个短暂的“识别”过程
        setTimeout(() => {
            // 再次检查元素是否还在页面上，防止用户切换聊天导致错误
            if (document.body.contains(transcriptEl)) {
                // 获取并显示真正的转写文字
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText;
            }
        }, 300); // 300毫秒的延迟，感觉更灵敏
    }
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 操作2：将这【一整块新函数】，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【全新】处理清除本机所有数据的逻辑
 * 这将删除与此应用关联的 IndexedDB 和 Local Storage，实现彻底重置。
 */
async function handleClearLocalData() {
    // 1. 弹出高风险操作确认框，防止误触
    const confirmed = await showCustomConfirm(
        '⚠️ 最终确认 ⚠️',
        '此操作将永久删除此应用在本机上的【所有数据】，包括：<br><br>' +
        '- 所有聊天记录<br>' +
        '- 所有角色与人设<br>' +
        '- 所有设置与自定义项<br><br>' +
        '应用将恢复到初始安装状态。此操作不可撤销，确定要清除吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) {
        return; // 如果用户取消，则不执行任何操作
    }

    await showCustomAlert("请稍候...", "正在彻底清除所有本地数据...");

    try {
        // 2. 删除 IndexedDB 数据库
        // Dexie.delete() 是一个非常强大的命令，它会彻底删除整个数据库。
        await Dexie.delete('GeminiChatDB');
        console.log("IndexedDB数据库 'GeminiChatDB' 已成功删除。");

        // 3. 清空 Local Storage
        // 关键：localStorage.clear() 只会清除当前网站域下的数据，
        // 绝对不会影响到您访问的其他任何网站，因此这是完全安全的。
        localStorage.clear();
        console.log("localStorage 已被安全清空。");

        // 4. 给出最终的成功提示，并准备刷新页面
        await showCustomAlert('清除成功！', '所有本机数据已清除。应用即将刷新以完成重置。');

        // 5. 延迟1.5秒后刷新页面，让用户有时间看到提示
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("清除本机数据时发生错误:", error);
        await showCustomAlert('清除失败', `发生了一个意外的错误：\n${error.message}`);
    }
}
// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 把这一整块全新的微博功能函数，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【全新】微博用户人设与职业设置核心功能
 */
function openWeiboUserSettingsModal() {
    const modal = document.getElementById('weibo-user-settings-modal');
    const settings = state.qzoneSettings;

    // 加载当前数据到输入框
    document.getElementById('weibo-user-profession-modal-input').value = settings.weiboUserProfession === '点击设置职业' ? '' : settings.weiboUserProfession;
    document.getElementById('weibo-user-persona-modal-input').value = settings.weiboUserPersona;
    
    renderWeiboUserPresetSelector(); // 渲染预设下拉框
    modal.classList.add('visible');
}

async function saveWeiboUserSettings() {
    const profession = document.getElementById('weibo-user-profession-modal-input').value.trim();
    const persona = document.getElementById('weibo-user-persona-modal-input').value.trim();

    state.qzoneSettings.weiboUserProfession = profession || '点击设置职业';
    state.qzoneSettings.weiboUserPersona = persona || '一个普通的微博用户。';

    await saveQzoneSettings(); // 保存到数据库
    await renderWeiboProfile(); // 刷新主页显示
    document.getElementById('weibo-user-settings-modal').classList.remove('visible');
    alert('微博设定已保存！');
}

function renderWeiboUserPresetSelector() {
    const select = document.getElementById('weibo-user-preset-select');
    const presets = state.qzoneSettings.weiboUserPersonaPresets || [];
    select.innerHTML = '<option value="">-- 选择预设 --</option>';
    presets.forEach((preset, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = preset.name;
        select.appendChild(option);
    });
}

function handleWeiboUserPresetSelection() {
    const select = document.getElementById('weibo-user-preset-select');
    const presets = state.qzoneSettings.weiboUserPersonaPresets || [];
    const selectedIndex = select.value;

    if (selectedIndex !== "") {
        const preset = presets[parseInt(selectedIndex)];
        document.getElementById('weibo-user-profession-modal-input').value = preset.profession;
        document.getElementById('weibo-user-persona-modal-input').value = preset.persona;
    }
}

async function openWeiboUserPresetManager() {
    const choice = await showChoiceModal("管理预设", [
        { text: '💾 保存当前为新预设', value: 'save' },
        { text: '🗑️ 删除已选预设', value: 'delete' }
    ]);

    if (choice === 'save') {
        const name = await showCustomPrompt("保存预设", "请输入预设名称");
        if (name && name.trim()) {
            const newPreset = {
                name: name.trim(),
                profession: document.getElementById('weibo-user-profession-modal-input').value.trim(),
                persona: document.getElementById('weibo-user-persona-modal-input').value.trim()
            };
            state.qzoneSettings.weiboUserPersonaPresets.push(newPreset);
            await saveQzoneSettings();
            renderWeiboUserPresetSelector();
            alert(`预设 "${name.trim()}" 已保存！`);
        }
    } else if (choice === 'delete') {
        const select = document.getElementById('weibo-user-preset-select');
        const selectedIndex = select.value;
        if (selectedIndex === "") {
            alert("请先从下拉框中选择一个要删除的预设。");
            return;
        }
        const presets = state.qzoneSettings.weiboUserPersonaPresets;
        const presetName = presets[parseInt(selectedIndex)].name;
        const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${presetName}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            presets.splice(parseInt(selectedIndex), 1);
            await saveQzoneSettings();
            renderWeiboUserPresetSelector();
            alert("预设已删除。");
        }
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 从这里开始，粘贴所有新代码 ▼▼▼
/**
 * 【V2智能版】应用指定的主题，并智能刷新当前打开的任何界面
 * @param {string} theme - 'light' 或 'dark'
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：为手机屏幕添加或移除 .dark-mode 类
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 同步开关的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 保存用户的选择
    localStorage.setItem('ephone-theme', theme);

    // 【核心修复！】
    // 不再只关心聊天界面，而是找出当前究竟是哪个界面处于激活状态
    const activeScreen = document.querySelector('.screen.active');
    if (!activeScreen) return; // 如果找不到，就退出

    // 根据当前激活的界面ID，调用它专属的刷新函数
    switch (activeScreen.id) {
        case 'chat-interface-screen':
            if (state.activeChatId) {
                renderChatInterface(state.activeChatId);
            }
            break;
        case 'wallpaper-screen':
            // 外观设置页也需要重新渲染来应用新主题
            renderWallpaperScreen();
            break;
        case 'font-settings-screen':
            // 字体预设页同样需要
            renderFontPresets();
            break;
        // 如果未来还有其他页面需要适配，在这里添加 case 即可
    }
}


/**
 * 当用户点击开关时，切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
/**
 * 【全新】在应用启动时，预加载所有已保存的字体预设
 */
async function loadAllFontPresetsOnStartup() {
    console.log("正在预加载所有字体预设...");
    const presets = await db.fontPresets.toArray();
    if (presets && presets.length > 0) {
        presets.forEach(preset => {
            // 我们复用已有的 loadFontForPreview 函数来加载每个字体
            loadFontForPreview(preset);
        });
        console.log(`成功预加载了 ${presets.length} 个字体。`);
    }
}

// ▼▼▼ 操作2：用这块【支持选择模式】的全新代码，替换旧的 renderFontPresets 函数 ▼▼▼
/**
 * 【全新 | 支持选择模式】渲染字体预设卡槽
 */
async function renderFontPresets() {
    const container = document.getElementById('font-preset-container');
    container.innerHTML = ''; 

    const presets = await db.fontPresets.toArray() || [];
    const slotCount = state.globalSettings.fontSlotCount || 10;

    for (let i = 0; i < slotCount; i++) {
        const slot = document.createElement('div');
        slot.className = 'font-preset-slot';
        const preset = presets[i];

        if (preset) {
            // 已填充的槽位
            slot.innerHTML = `
                <div class="font-preview-text" data-preset-id="${preset.id}">Abc 你好</div>
                <div class="font-preset-info">名称: ${preset.name}</div>
                <div class="font-preset-actions">
                    <button class="preset-btn apply-btn" data-preset-id="${preset.id}">应用</button>
                    <button class="preset-btn delete-btn delete" data-preset-id="${preset.id}">删除</button>
                </div>
            `;
            loadFontForPreview(preset);
        } else {
            // 空槽位
            slot.classList.add('empty');
            slot.innerHTML = `
                <div class="font-preset-info">卡槽 ${i + 1} 为空</div>
                <div class="font-preset-actions">
                    <button class="preset-btn secondary upload-url-btn" data-slot-index="${i}">URL上传</button>
                    <button class="preset-btn secondary upload-local-btn" data-slot-index="${i}">本地上传</button>
                </div>
            `;
        }

        // --- ★★★ 核心新增：选择模式的UI逻辑 ★★★ ---
        if (isFontSlotSelectionMode) {
            slot.classList.add('in-selection-mode');
            // 只有新增的、并且是空的槽位才可以被删除
            if (i >= 10 && !preset) {
                slot.classList.add('is-selectable'); // 添加可选择的标记
                
                const selectionOverlay = document.createElement('div');
                selectionOverlay.className = 'font-slot-selection-overlay';
                slot.appendChild(selectionOverlay);

                // 检查是否已被选中
                if (selectedFontSlots.has(i)) {
                    slot.classList.add('selected');
                }

                // 绑定点击选择事件
                slot.addEventListener('click', () => {
                    slot.classList.toggle('selected');
                    if (selectedFontSlots.has(i)) {
                        selectedFontSlots.delete(i);
                    } else {
                        selectedFontSlots.add(i);
                    }
                    // 更新删除按钮的计数
                    const deleteBtn = document.getElementById('delete-selected-slots-btn');
                    deleteBtn.textContent = `删除已选 (${selectedFontSlots.size})`;
                    deleteBtn.disabled = selectedFontSlots.size === 0;
                });
            }
        }
        // --- ★★★ 新增结束 ★★★
        container.appendChild(slot);
    }
    
    // 只有在非选择模式下，才绑定上传/应用/删除预设的按钮
    if (!isFontSlotSelectionMode) {
        addFontPresetButtonListeners();
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【最终修复版】用这整块代码，完整替换旧的 toggleFontSlotSelectionMode 函数 ▼▼▼

/**
 * 【全新 | 已修复】切换字体槽位的编辑/选择模式
 */
function toggleFontSlotSelectionMode() {
    isFontSlotSelectionMode = !isFontSlotSelectionMode;
    
    const editBtn = document.getElementById('edit-font-slots-btn');
    // ★★★ 核心修复1：我们现在直接获取“添加”按钮本身，而不是它的父容器 ★★★
    const addBtn = document.getElementById('add-new-font-preset-btn');
    const selectionActions = document.getElementById('font-slot-selection-actions');
    const deleteBtn = document.getElementById('delete-selected-slots-btn');

    if (isFontSlotSelectionMode) {
        // --- 进入编辑模式 ---
        editBtn.textContent = '完成';
        addBtn.style.display = 'none'; // ★★★ 核心修复2：只隐藏“添加”按钮 ★★★
        selectionActions.style.display = 'block'; // 正确地显示“删除已选”按钮
        selectedFontSlots.clear(); // 清空上次的选择

        // 重置删除按钮的状态
        deleteBtn.textContent = `删除已选 (0)`;
        deleteBtn.disabled = true;

    } else {
        // --- 退出编辑模式 ---
        editBtn.textContent = '✏️ 编辑槽位';
        addBtn.style.display = 'block'; // ★★★ 核心修复3：恢复显示“添加”按钮 ★★★
        selectionActions.style.display = 'none'; // 隐藏“删除已选”按钮
    }
    
    // 重新渲染整个列表，UI会根据 isFontSlotSelectionMode 的新状态来决定是否显示选择框
    renderFontPresets(); 
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新】处理批量删除选中的空槽位
 */
async function handleBulkDeleteFontSlots() {
    if (selectedFontSlots.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除选中的 ${selectedFontSlots.size} 个空槽位吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const presets = await db.fontPresets.toArray();
        const indicesToDelete = Array.from(selectedFontSlots).sort((a, b) => b - a); // 从大到小排序，方便删除

        // 从预设数组中安全地移除对应位置的占位（即使是undefined）
        indicesToDelete.forEach(index => {
            if (index < presets.length) {
                presets.splice(index, 1);
            }
        });

        // 更新总槽位数
        state.globalSettings.fontSlotCount -= indicesToDelete.length;

        // 使用事务一次性更新数据库
        await db.transaction('rw', db.fontPresets, db.globalSettings, async () => {
            await db.fontPresets.clear(); // 清空整个表
            await db.fontPresets.bulkPut(presets); // 将处理后的数组重新存入
            await db.globalSettings.put(state.globalSettings); // 保存新的总槽位数
        });

        // 退出编辑模式并刷新
        toggleFontSlotSelectionMode();
        await showCustomAlert('删除成功', '选中的空槽位已删除。');
    }
}
// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 操作3：用这块【全新的 async 版本】代码，替换旧的 handleAddNewFontPresetSlot 函数 ▼▼▼
/**
 * 【全新 | 持久化版】当用户点击“添加新字体槽位”时，增加槽位数量并保存
 */
async function handleAddNewFontPresetSlot() {
    // 1. 增加槽位计数
    state.globalSettings.fontSlotCount = (state.globalSettings.fontSlotCount || 10) + 1;
    
    // 2. 将更新后的设置保存到数据库
    await db.globalSettings.put(state.globalSettings);
    
    // 3. 重新渲染整个字体列表，新的空槽位就会出现
    await renderFontPresets();

    // 4. (可选) 自动滚动到页面底部，让用户看到新加的槽位
    const container = document.getElementById('font-settings-screen').querySelector('.form-container');
    container.scrollTop = container.scrollHeight;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 操作4：将这【一整块新函数】，粘贴到 handleAddNewFontPresetSlot 函数的下方 ▼▼▼
/**
 * 【全新】处理删除最后一个空槽位的逻辑
 */
async function handleRemoveLastFontSlot() {
    const presets = await db.fontPresets.toArray();
    const slotCount = state.globalSettings.fontSlotCount || 10;

    // 安全检查：如果槽位数小于等于10，则不允许删除
    if (slotCount <= 10) {
        alert("无法删除基础的10个槽位。");
        return;
    }

    // 检查最后一个槽位是否是空的
    // 数组索引是从0开始的，所以最后一个槽位的索引是 slotCount - 1
    const lastSlotIndex = slotCount - 1;
    if (presets[lastSlotIndex]) {
        alert("无法删除已填充的槽位！请先删除该槽位中的字体预设。");
        return;
    }

    // 确认删除
    const confirmed = await showCustomConfirm("确认删除", "确定要删除最后一个空的字体槽位吗？", { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 减少槽位计数并保存
        state.globalSettings.fontSlotCount--;
        await db.globalSettings.put(state.globalSettings);
        await renderFontPresets(); // 重新渲染
        alert("最后一个空槽位已删除。");
    }
}
// ▲▲▲ 新增代码结束 ▲▲▲

/**
 * 【终极修复版】为单个预设加载字体以供预览
 * @param {object} preset - 字体预设对象 {id, name, url}
 */
function loadFontForPreview(preset) {
    const styleId = `font-style-${preset.id}`;
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    
    // 【核心修改】我们不再手动操作元素的style属性，
    // 而是直接创建一条高优先级的CSS规则来应用字体，这更可靠。
    style.innerHTML = `
        @font-face {
            font-family: 'preset-${preset.id}';
            src: url('${preset.url}');
            font-display: swap;
        }

        .font-preview-text[data-preset-id="${preset.id}"] {
            font-family: 'preset-${preset.id}', sans-serif !important;
        }
    `;
    
    document.head.appendChild(style);
}




/**
 * 为预设卡槽中的所有按钮统一添加事件监听器
 */
function addFontPresetButtonListeners() {
    document.querySelectorAll('.upload-url-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontUrl(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.upload-local-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontLocal(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.apply-btn').forEach(btn => {
        btn.onclick = () => applyFontPreset(btn.dataset.presetId);
    });
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.onclick = () => deleteFontPreset(btn.dataset.presetId);
    });
}

/**
 * 处理通过URL上传字体
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
async function handleUploadFontUrl(slotIndex) {
    const url = await showCustomPrompt("字体URL", "请输入字体的网络链接(.ttf, .otf等)");
    if (!url || !url.trim().startsWith('http')) {
        if (url !== null) alert("请输入一个有效的URL！");
        return;
    }
    const name = await showCustomPrompt("字体命名", "请为这个字体起个名字");
    if (!name || !name.trim()) {
        if (name !== null) alert("名字不能为空！");
        return;
    }
    await saveFontPreset(slotIndex, name.trim(), url.trim());
}

/**
 * 处理通过本地文件上传字体
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
function handleUploadFontLocal(slotIndex) {
    const input = document.getElementById('font-preset-local-upload');
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const name = await showCustomPrompt("字体命名", "请为这个字体起个名字", file.name.replace(/\.[^/.]+$/, ""));
        if (!name || !name.trim()) {
            if (name !== null) alert("名字不能为空！");
            return;
        }

        // 使用FileReader将字体文件转为Base64 Data URL
        const reader = new FileReader();
        reader.onload = async (event) => {
            // 核心修改：event.target.result 现在就是我们需要的 data:font/ttf;base64,... 格式的完整文本
            await saveFontPreset(slotIndex, name.trim(), event.target.result);
        };
        // 核心修改：使用 readAsDataURL 来读取文件
        reader.readAsDataURL(file);
    };
    input.click(); // 触发文件选择框
} 
async function saveFontPreset(slotIndex, name, url) {
    try {
        const presets = await db.fontPresets.toArray();
        const newPreset = { id: 'font_' + Date.now(), name, url };
        presets.splice(slotIndex, 0, newPreset);
        
        // ▼▼▼ 核心修改点在这里！ ▼▼▼
        // 将 slice(0, 5) 修改为 slice(0, 10)
        const presetsToSave = presets.slice(0, 10); 
        // ▲▲▲ 修改结束 ▲▲▲

        await db.transaction('rw', db.fontPresets, async () => {
            await db.fontPresets.clear();
            await db.fontPresets.bulkPut(presetsToSave);
        });

        await renderFontPresets();
        alert(`字体 "${name}" 已成功保存到卡槽 ${slotIndex + 1}！`);
    } catch (error) {
        console.error("保存字体预设失败:", error);
        alert(`保存字体失败，数据已自动回滚，你之前的字体数据是安全的。错误: ${error.message}`);
        await renderFontPresets(); 
    }
}

/**
 * 删除一个字体预设
 * @param {string} presetId - 要删除的预设的ID
 */
async function deleteFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (!preset) return;
    const confirmed = await showCustomConfirm("确认删除", `确定要删除字体 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.fontPresets.delete(presetId);
        
        // 从DOM中移除对应的预览样式
        const styleTag = document.getElementById(`font-style-${presetId}`);
        if (styleTag) styleTag.remove();

        await renderFontPresets();
    }
}

/**
 * 应用一个字体预设为全局字体
 * @param {string} presetId - 要应用的预设的ID
 */
async function applyFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (preset) {
        // 调用你已有的全局字体应用函数
        applyCustomFont(preset.url, false);
        // 保存到全局设置
        state.globalSettings.fontUrl = preset.url;
        await db.globalSettings.put(state.globalSettings);
        alert(`已将全局字体更换为 "${preset.name}"！`);
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲

/**
 * 【总入口】处理用户选择的角色卡文件
 * @param {File} file - 用户选择的文件对象
 */
async function handleCharacterImport(file) {
    if (!file) return;

    try {
        let characterData;
        let avatarBase64;

        if (file.name.toLowerCase().endsWith('.png')) {
            // 如果是PNG文件，调用PNG解析函数
            const result = await parseCharPng(file);
            characterData = result.characterData;
            avatarBase64 = result.avatarBase64;
        } else if (file.name.toLowerCase().endsWith('.json')) {
            // 如果是JSON文件，调用JSON解析函数
            characterData = await parseCharJson(file);
            // JSON卡通常不包含图片，我们给一个默认头像
            avatarBase64 = defaultAvatar;
        } else {
            alert('不支持的文件格式，请选择 .png 或 .json 文件。');
            return;
        }

        if (characterData) {
            // 成功解析出数据后，调用创建函数
            await createCharacterFromData(characterData, avatarBase64);
        }

    } catch (error) {
        console.error("导入角色卡失败:", error);
        alert(`导入失败: ${error.message}`);
    }
}

/**
 * 【V3 - 最终乱码修复版】
 * 解析SillyTavern的PNG角色卡，通过字节级操作彻底解决中文乱码问题。
 * @param {File} file - PNG文件
 * @returns {Promise<{characterData: object, avatarBase64: string}>}
 */
async function parseCharPng(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const arrayBuffer = e.target.result;
            const dataView = new DataView(arrayBuffer);

            if (dataView.getUint32(0) !== 0x89504E47 || dataView.getUint32(4) !== 0x0D0A1A0A) {
                return reject(new Error('文件不是一个有效的PNG图片。'));
            }

            let offset = 8;
            let characterJson = null;

            while (offset < dataView.byteLength) {
                const length = dataView.getUint32(offset);
                const type = String.fromCharCode(
                    dataView.getUint8(offset + 4),
                    dataView.getUint8(offset + 5),
                    dataView.getUint8(offset + 6),
                    dataView.getUint8(offset + 7)
                );

                if (type === 'tEXt') {
                    const chunkData = new Uint8Array(arrayBuffer, offset + 8, length);
                    
                    // ★★★★★【这是本次修复乱码的核心代码】★★★★★
                    // 1. 先用一个简单的编码将字节转为字符串，以便查找关键字 "chara"
                    let text = '';
                    for (let i = 0; i < chunkData.length; i++) {
                        text += String.fromCharCode(chunkData[i]);
                    }

                    // 2. 检查关键字是否存在
                    const keyword = 'chara' + String.fromCharCode(0);
                    if (text.startsWith(keyword)) {
                        // 3. 提取出关键字后面的 Base64 编码的字符串
                        const base64Data = text.substring(keyword.length);
                        try {
                            // 4. 使用 atob() 解码 Base64，得到一个“二进制字符串”
                            const binaryString = atob(base64Data);
                            
                            // 5. 将这个“二进制字符串”重新转换为原始的 UTF-8 字节数组
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            
                            // 6. 使用 TextDecoder 将这个纯净的 UTF-8 字节数组解码为正确的字符串
                            const decodedJsonString = new TextDecoder('utf-8').decode(bytes);
                            
                            // 7. 解析最终的JSON字符串
                            characterJson = JSON.parse(decodedJsonString);
                            break;
                        } catch (e) {
                            return reject(new Error('解析图片内嵌的角色数据失败，可能是数据损坏。'));
                        }
                    }
                    // ★★★★★【核心代码结束】★★★★★
                }
                
                if (type === 'IEND') break;
                offset += 12 + length;
            }

            if (characterJson) {
                const imageReader = new FileReader();
                imageReader.onload = (imgEvent) => {
                    resolve({
                        characterData: characterJson,
                        avatarBase64: imgEvent.target.result
                    });
                };
                imageReader.onerror = () => reject(new Error('读取图片作为头像失败。'));
                imageReader.readAsDataURL(file);
            } else {
                reject(new Error('在这张PNG图片中没有找到SillyTavern角色数据。'));
            }
        };
        reader.onerror = () => reject(new Error('读取PNG文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}


/**
 * 解析JSON角色卡
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
/**
 * 【修正版】解析JSON角色卡，强制使用UTF-8编码
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
async function parseCharJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                // 核心修正：先读取为ArrayBuffer，再用TextDecoder指定UTF-8解码
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder('utf-8');
                const jsonString = textDecoder.decode(arrayBuffer);
                const data = JSON.parse(jsonString);
                // 兼容两种可能的格式
                resolve(data.data || data);
            } catch (error) {
                reject(new Error('解析JSON文件失败，请检查文件格式或编码。'));
            }
        };
        reader.onerror = () => reject(new Error('读取JSON文件失败。'));
        // 核心修正：读取为ArrayBuffer而不是Text
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 【V5 - 最终适配版 - 识别 character_book】
 * 根据解析出的数据创建新角色和世界书。
 * 这个版本将优先查找您提供的 character_book 标准格式。
 * @param {object} data - 从卡片解析出的最原始的JSON数据
 * @param {string} avatarBase64 - 角色的头像图片 (Base64)
 */
async function createCharacterFromData(data, avatarBase64) {
    // 步骤 1: 确定核心角色数据 (不变)
    const charData = data.data || data;
    const characterName = charData.name ? charData.name.trim() : '未命名角色';
    
    // 步骤 2: 创建新的聊天对象 (不变)
    const newChatId = 'chat_' + Date.now();
// ▼▼▼ 请用这块【终极完整版】代码，替换你旧的 const newChat = { ... }; 代码块 ▼▼▼

const newChat = {
    id: newChatId,
    name: characterName,
    realName: characterName, // 保存创建时的原始名字
    isGroup: false,
    isPinned: false,
    history: [],
    unreadCount: 0,
    musicData: { totalTime: 0 },
    npcLibrary: [],
    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
    status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
    weiboDms: [],
    loversSpaceData: null,
    settings: {
        aiPersona: charData.description || '该角色没有描述。',
        myPersona: '我是谁呀。',
        maxMemory: 10,
        aiAvatar: avatarBase64,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
        aiAvatarLibrary: [],
        stickerLibrary: [],
        summary: { 
            enabled: false, 
            mode: 'auto', 
            count: 20, 
            prompt: '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。', 
            lastSummaryIndex: -1 
        },
        linkedMemories: [],
        offlineMode: { 
            enabled: false, 
            prompt: '', 
            style: '', 
            wordCount: 300, 
            presets: [] 
        },
        timePerceptionEnabled: true,
        customTime: '',
        isCoupleAvatar: false,
        coupleAvatarDescription: '',
        weiboProfession: '',
        weiboInstruction: '',
        visualVideoCallEnabled: false,
        charVideoImage: '',
        userVideoImage: '',
        petAdopted: false,
        pet: null,
    },
    characterPhoneData: {
        lastGenerated: null,
        chats: {},
        shoppingCart: [],
        memos: [],
        browserHistory: [],
        photoAlbum: [],
        bank: { balance: 0, transactions: [] },
        trajectory: [],
        appUsage: [],
        diary: []
    }
};

// ▲▲▲ 替换结束 ▲▲▲

    await db.chats.put(newChat);
    state.chats[newChatId] = newChat;
    
    // =================================================================
    // ▼▼▼ 核心修改：重构世界书查找逻辑 ▼▼▼
    // =================================================================
    
    console.log("开始检测世界书数据...");
    let worldBookFound = false;

    // 策略一：【最高优先级】查找您提供的 character_book 标准格式
    if (charData.character_book && charData.character_book.entries && Array.isArray(charData.character_book.entries) && charData.character_book.entries.length > 0) {
        console.log(`检测到最新的 character_book 格式 (${charData.character_book.entries.length}条)，开始导入...`);
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        // 我们将调用【修改后】的辅助函数来处理
        await saveWorldBookEntriesFromArray(charData.character_book.entries, newCategoryId);
        worldBookFound = true;
    }
    
    // 策略二：兼容旧的 world_entries 格式
    else if (charData.world_entries && Array.isArray(charData.world_entries) && charData.world_entries.length > 0) {
        console.log(`检测到旧版 world_entries 格式 (${charData.world_entries.length}条)，开始导入...`);
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await saveWorldBookEntriesFromArray(charData.world_entries, newCategoryId);
        worldBookFound = true;
    }
    
    // 策略三：兼容更旧的 data.world 格式
    else if (data.world && typeof data.world === 'string' && data.world.trim()) {
        console.log("检测到外层 world 字段格式，开始导入...");
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(data.world, newCategoryId);
        worldBookFound = true;
    }

    // 策略四：最后的兼容手段 world_info
    else if (charData.world_info && typeof charData.world_info === 'string' && charData.world_info.trim()) {
        console.log("检测到旧版 world_info 字段格式，开始导入...");
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(charData.world_info, newCategoryId);
        worldBookFound = true;
    }

    if (!worldBookFound) {
        console.log("诊断：在此角色卡中未找到任何可识别的世界书字段。");
    }
    
    // =================================================================
    // ▲▲▲ 核心修改结束 ▲▲▲
    // =================================================================

    // 步骤 4: 刷新UI (不变)
    await renderChatList();
    await showCustomAlert('导入成功！', `角色“${characterName}”已成功创建！`);
}


/**
 * 【V2 - 适配 comment 字段】
 * 从SillyTavern的 world_entries 或 character_book.entries 数组直接创建世界书
 * @param {Array<object>} entriesArray - 包含世界书条目的数组
 * @param {number} categoryId - 这些世界书所属的分类ID
 */
async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
    const newBooks = [];

    for (const entry of entriesArray) {
        // ▼▼▼ 核心修改：智能获取条目名称 ▼▼▼
        // 优先使用 comment 字段作为标题，如果它存在且不为空。
        // 否则，再尝试使用 keys 数组。
        // 如果都没有，就给一个默认名字。
        const entryName = (entry.comment && entry.comment.trim()) 
                          ? entry.comment.trim() 
                          : (entry.keys && entry.keys.length > 0 ? entry.keys.join(', ') : '未命名条目');
        // ▲▲▲ 核心修改结束 ▲▲▲

        // 检查条目是否有效 (有名字、有内容，并且是启用的)
        // (typeof entry.enabled === 'undefined' || entry.enabled) 是为了兼容没有 enabled 字段的卡片
        if (entryName !== '未命名条目' && entry.content && (typeof entry.enabled === 'undefined' || entry.enabled)) {
            newBooks.push({
                id: 'wb_' + Date.now() + Math.random(),
                name: entryName, // 使用我们智能获取到的名字
                content: entry.content,
                categoryId: categoryId
            });
        }
    }

    if (newBooks.length > 0) {
        await db.worldBooks.bulkAdd(newBooks);
        // 确保 state.worldBooks 也被更新，以便UI能立即显示
        const allBooks = await db.worldBooks.toArray();
        state.worldBooks = allBooks;
        console.log(`成功导入 ${newBooks.length} 个世界书条目到分类ID: ${categoryId}`);
    }
}



// 【辅助函数】获取事件的坐标
function getEventCoords(e) {
    // 如果是触摸事件，就从 e.touches[0] 获取
    if (e.touches && e.touches[0]) {
        return { x: e.touches[0].pageX, y: e.touches[0].pageY };
    }
    // 否则，就是鼠标事件，直接从 e 获取
    return { x: e.pageX, y: e.pageY };
}

function showScreen(screenId) {
    if (!document.getElementById('logistics-screen').classList.contains('active')) {
        logisticsUpdateTimers.forEach(timerId => clearTimeout(timerId));
        logisticsUpdateTimers = [];
    }

    // 【核心修改】我们现在直接调用真正的函数，不再需要 "Proxy"
    if (screenId === 'chat-list-screen') {
        renderChatList(); 
        switchToChatListView('messages-view');
    }
    if (screenId === 'api-settings-screen') {
        renderApiSettings();
    }
    if (screenId === 'wallpaper-screen') {
        renderWallpaperScreen();
    }
    if (screenId === 'world-book-screen') {
        renderWorldBookScreen();
    }

    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screenToShow = document.getElementById(screenId);
    if (screenToShow) {
        screenToShow.classList.add('active');
    }

    if (screenId === 'chat-interface-screen') {
        updateListenTogetherIcon(state.activeChatId);
    }
    
    if (screenId === 'font-settings-screen') {
        document.getElementById('font-preview').style.fontFamily = '';
        applyCustomFont(state.globalSettings.fontUrl || '', true);
        renderFontPresets();
    }
}
window.showScreen = showScreen; // 确保 showScreen 自己也是全局的
// ▲▲▲ 替换结束 ▲▲▲

        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增这一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隐藏所有视图
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 显示目标视图
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部导航栏高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 修正结束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根据视图ID执行特定的渲染/更新逻辑
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '刚刚';
            if (diffMinutes < 60) return `${diffMinutes}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

// ▼▼▼ 步骤3.1：用这整块【终极修复版】代码替换旧的 renderQzonePosts 函数 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
    
    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;
    
// ▼▼▼ 从这里开始替换 ▼▼▼
// ★★★★★ 这就是我们这次修复的核心 ★★★★★
// 1. 在渲染所有帖子之前，我们先创建一个包含所有AI角色名字的集合(Set)，方便快速查找。
const allAiCharacterNames = new Set(Object.values(state.chats).filter(chat => !chat.isGroup).map(chat => chat.name));
// ★★★★★ 修复结束 ★★★★★

posts.forEach(post => {
    const postContainer = document.createElement('div');
    postContainer.className = 'qzone-post-container';
    postContainer.dataset.postId = post.id;

    const postEl = document.createElement('div');
    postEl.className = 'qzone-post-item';

    let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

    if (post.authorId === 'user') {
        authorAvatar = userSettings.avatar;
        authorNickname = userSettings.nickname;
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
        authorNickname = authorChat.name;
    } else {
        authorAvatar = defaultAvatar;
        authorNickname = '{{char}}';
    }
    
    let contentHtml = '';
    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

    if (post.type === 'shuoshuo') {
        contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
    } 
    else if (post.type === 'image_post' && post.imageUrl) {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
    } 
    else if (post.type === 'text_image') {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
    }
    else if (post.type === 'realimag') {
        // RealImag真实图片动态渲染（支持多图布局）
        const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
        
        if (imageUrls.length > 0) {
            const imageCount = imageUrls.length;
            let imagesHtml = '';
            
            // 使用统一的多图布局（包括单张图片）
            imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
            imageUrls.forEach((url, index) => {
                imagesHtml += `<img src="${url}" class="realimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
            });
            imagesHtml += '</div>';
            
            contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
        }
    }
    else if (post.type === 'naiimag') {
        // NovelAI图片动态渲染（支持多图布局，最多2张）
        const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
        
        if (imageUrls.length > 0) {
            const imageCount = imageUrls.length;
            let imagesHtml = '';
            
            // 使用统一的多图布局（包括单张图片）
            imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
            imageUrls.forEach((url, index) => {
                imagesHtml += `<img src="${url}" class="naiimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
            });
            imagesHtml += '</div>';
            
            contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
        }
    }

    let likesHtml = '';
    if (post.likes && post.likes.length > 0) {
        likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
    }
    
    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
        // ★★★★★ 这就是我们这次修复的核心 ★★★★★
        // 2. 修改这里的过滤逻辑
        const commentsToShow = post.areCommentsVisible === false 
            ? post.comments.filter(comment => 
                // 条件1: 评论者是你自己
                comment.commenterName === userSettings.nickname || 
                // 条件2: 评论者的名字在我们刚才创建的AI角色名字列表里
                allAiCharacterNames.has(comment.commenterName)
              )
            : post.comments; // 如果开关是开的，就显示所有评论
        // ★★★★★ 修复结束 ★★★★★

        if (commentsToShow.length > 0) {
// ▲▲▲ 替换到这里结束 ▲▲▲

                commentsHtml = '<div class="post-comments-container">';
                commentsToShow.forEach(comment => {
                    const originalIndex = post.comments.indexOf(comment);
                    let replyHtml = '';
                    if (comment.replyTo) {
                        replyHtml = `<span class="reply-text">回复</span> <span class="reply-target-name">${comment.replyTo}</span>`;
                    }
                    commentsHtml += `
                        <div class="comment-item" data-commenter-name="${comment.commenterName}">
                            <span class="commenter-name">${comment.commenterName}</span>${replyHtml}:
                            <span class="comment-text"> ${comment.text}</span>
                            <span class="comment-delete-btn" data-comment-index="${originalIndex}">×</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }
        }


        const commentsAndFooterHtml = `
            ${commentsHtml}
            <div class="post-footer">
                <div class="comment-section">
                    <img src="${commentAvatar}" class="comment-avatar">
                    <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                    <div class="at-mention-popup"></div>
                </div>
                <button class="comment-send-btn">发送</button>
            </div>
        `;

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                <span class="action-icon summon-npc" data-post-id="${post.id}" data-author-id="${post.authorId}" title="召唤NPC评论"><svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></span>
                </div>
            ${likesHtml}
            ${commentsAndFooterHtml} 
        `;
        
        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>删除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        if (commentInput) {
            const popup = postContainer.querySelector('.at-mention-popup');
            commentInput.addEventListener('input', () => {
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (e) => {
                                    e.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
            commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
        }
    });
}
// ▲▲▲ 步骤3.1替换结束 ▲▲▲
async function renderFollowingFeed() {
    const feedListEl = document.getElementById('weibo-following-feed-list');
    if (!feedListEl) return;

    // 1. 从数据库获取所有动态
    const allPosts = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
    
    // 2. 【核心】筛选出作者不是 'user' 的动态
    const followingPosts = allPosts.filter(post => post.authorId !== 'user');

    feedListEl.innerHTML = ''; // 清空旧内容

    if (followingPosts.length === 0) {
        feedListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">你关注的人还没有发布任何动态哦。</p>';
        return;
    }

    // 3. 遍历筛选后的动态，并渲染它们
    //    【提示】这里创建单个动态HTML的逻辑，可以完全复制 `renderQzonePosts` 函数里的 forEach 循环内部的代码。
    //    你只需要把目标容器从 `postsListEl` 改为 `feedListEl` 即可。
    followingPosts.forEach(post => {
        // ... 在这里粘贴 renderQzonePosts 函数中创建 postContainer、postEl 的那一大段代码 ...
        // ... 记得最后要把 postContainer append 到 feedListEl 中 ...
        // feedListEl.appendChild(postContainer);
    });
}

// ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '来自动态';
            let authorAvatar = defaultAvatar, authorNickname = '未知用户';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            } else if (post.type === 'realimag') {
                // RealImag真实图片动态渲染（支持多图布局）
                const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
                
                if (imageUrls.length > 0) {
                    const imageCount = imageUrls.length;
                    let imagesHtml = '';
                    
                    // 使用统一的多图布局（包括单张图片）
                    imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                    imageUrls.forEach((url, index) => {
                        imagesHtml += `<img src="${url}" class="realimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
                    });
                    imagesHtml += '</div>';
                    
                    contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
                }
            } else if (post.type === 'naiimag') {
                // NovelAI图片动态渲染（支持多图布局，最多2张）
                const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
                
                if (imageUrls.length > 0) {
                    const imageCount = imageUrls.length;
                    let imagesHtml = '';
                    
                    // 使用统一的多图布局（包括单张图片）
                    imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                    imageUrls.forEach((url, index) => {
                        imagesHtml += `<img src="${url}" class="naiimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
                    });
                    imagesHtml += '</div>';
                    
                    contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
                }
            }

            // ▼▼▼ 新增/修改的代码开始 ▼▼▼
            
            // 1. 构造点赞区域的HTML
            let likesHtml = '';
            // 检查 post 对象中是否存在 likes 数组并且不为空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
            }

            // 2. 构造评论区域的HTML
            let commentsHtml = '';
            // 检查 post 对象中是否存在 comments 数组并且不为空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 将点赞和评论的HTML组合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 新增/修改的代码结束 ▲▲▲

} else if (item.type === 'chat_message') {
    const msg = item.content;
    const chat = state.chats[item.chatId];
    if (!chat) continue; 

    sourceText = `来自与 ${chat.name} 的聊天`;
    const isUser = msg.role === 'user';
    let senderName, senderAvatar;

    if (isUser) {
        // 用户消息的逻辑保持不变
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
//...
    } else { // AI/成员消息
         if (chat.isGroup) {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            
            // ★★★【核心修复】★★★
            // 如果找到了成员信息，就用他的“群昵称”；如果没找到（比如成员被踢了），就还是用消息里的名字作为备用。
            senderDisplayName = member ? member.groupNickname : (msg.senderName || '未知成员');
            
            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
        } else {

            // 单聊的逻辑保持不变
            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
        }
    }

    // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
    headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
    
    if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
// ▼▼▼ 请用这【一整块新代码】替换掉上面那段旧的 else { ... } 代码块 ▼▼▼
// ▼▼▼ 请用这【一整块新代码】再次替换掉 createMessageElement 函数里的 else { ... } 代码块 ▼▼▼
} else {
    const messageText = String(msg.content || '');
    // 侦测格式：[sticker:名字]
    const stickerMatch = messageText.match(/\[sticker:\s*(.+?)\s*\]/i);

    if (stickerMatch) {
        // 如果匹配成功，提取出名字
        const stickerName = stickerMatch[1].trim();
        // 【核心】在所有可能的表情库里查找（用户的、角色的专属、角色的通用）
        const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
        const foundSticker = allStickers.find(s => s.name === stickerName);
        
        if (foundSticker) {
            // 如果找到了，就显示图片！
            bubble.classList.add('is-sticker');
            contentHtml = `<img src="${foundSticker.url}" alt="${foundSticker.name}" class="sticker-image">`;
        } else {
            // 如果没找到（比如AI自己编了个名字），就还是按普通文字显示
            contentHtml = messageText.replace(/\n/g, '<br>');
        }
    } else {
        // 如果不匹配，就是普通的文本消息
        contentHtml = messageText.replace(/\n/g, '<br>');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


}
        
        // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
            // 1. 从数据库获取最新数据并缓存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 清空搜索框并隐藏清除按钮
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 显示所有收藏项
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 粘贴结束 ▲▲▲

function resetCreatePostModal() {
    document.getElementById('post-public-text').value = '';
    document.getElementById('post-image-preview').src = '';
    document.getElementById('post-image-description').value = '';
    document.getElementById('post-image-preview-container').classList.remove('visible');
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-local-image-input').value = '';
    document.getElementById('post-hidden-text').value = '';

    // 【核心修复】我们不再模拟点击，而是直接、安全地设置状态
    const imageModeBtn = document.getElementById('switch-to-image-mode');
    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    
    imageModeBtn.classList.add('active');
    textImageModeBtn.classList.remove('active');
    imageModeContent.classList.add('active');
    textImageModeContent.classList.remove('active');
}

async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        // --- 核心修改1：在这里加入了 charStickers ---
        const [
            chats, worldBooks, userStickers, charStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets, datingScenes,
            datingPresets, datingSpriteGroups, datingSprites, datingHistory, pomodoroSessions,
            ludoQuestionBanks, ludoQuestions, scriptKillScripts, taobaoProducts,
            taobaoOrders, taobaoCart, userWalletTransactions, userStickerCategories
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.charStickers.toArray(), // <--- 新增的这一行！
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.customAvatarFrames.toArray(),
            db.themes.toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray(),
            db.fontPresets.toArray(),
            db.homeScreenPresets.toArray(),
            db.datingScenes.toArray(),
            db.datingPresets.toArray(),
            db.datingSpriteGroups.toArray(),
            db.datingSprites.toArray(),
            db.datingHistory.toArray(),
            db.pomodoroSessions.toArray(),
            db.ludoQuestionBanks.toArray(),
            db.ludoQuestions.toArray(),
            db.scriptKillScripts.toArray(),
            db.taobaoProducts.toArray(),
            db.taobaoOrders.toArray(),
            db.taobaoCart.toArray(),
            db.userWalletTransactions.toArray(),
            db.userStickerCategories.toArray()
        ]);
        
        // --- 核心修改2：在这里也加入了 charStickers ---
        Object.assign(backupData, {
            chats, worldBooks, userStickers, charStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets, datingScenes,
            datingPresets, datingSpriteGroups, datingSprites, datingHistory, pomodoroSessions,
            ludoQuestionBanks, ludoQuestions, scriptKillScripts, taobaoProducts,
            taobaoOrders, taobaoCart, userWalletTransactions, userStickerCategories
        });
        
        // homeScreenState 和下载逻辑保持不变...
        backupData.homeScreenState = {
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, 
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML,
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src,
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'appLabels': { ...state.globalSettings.appLabels },
            'wallpaper': state.globalSettings.wallpaper
        };

        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
        console.error("导出数据时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}




// ▼▼▼ 请用这【一整块终极修复版】的代码，完整替换掉你旧的 importBackup 函数 ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '导入备份将完全覆盖您当前的所有数据，包括聊天、设置等。此操作不可撤销！您确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            // 1. 清空所有现有表格
            for (const table of db.tables) {
                await table.clear();
            }

            // 2. 【核心修复】智能、安全地导入数据
            // 我们会检查备份文件中的每一项数据，只有当当前代码的数据库里也存在对应的表格时，才进行导入
            
            // 导入数组类型的数据
            const arrayTables = [
                'chats', 'worldBooks', 'userStickers', 'charStickers', 'personaPresets', // <--- 在这里加入了 'charStickers'
                'qzonePosts', 'qzoneAlbums', 'qzonePhotos', 'favorites', 'qzoneGroups', 'memories',
                'worldBookCategories', 'callRecords', 'customAvatarFrames', 'themes',
                'apiPresets', 'bubbleStylePresets', 'fontPresets', 'homeScreenPresets' 
                // 注意：这里可能比你的代码多一些表，不用担心，直接完整替换即可，多的不会产生影响。
            ];


// ▼▼▼ 【全新】世界书格式兼容转换代码 ▼▼▼
for (const tableName of arrayTables) {
    if (Array.isArray(data[tableName]) && db[tableName]) {
        let itemsToPut = data[tableName];

        // 【核心逻辑】当处理世界书表格时，执行特别的转换操作
        if (tableName === 'worldBooks') {
            console.log("正在检查并转换世界书数据格式以兼容...");
            itemsToPut.forEach(book => {
                // 如果 content 是数组 (别人的格式)，则将其转换为字符串 (我的格式)
                if (Array.isArray(book.content)) {
                    console.log(`检测到数组格式的世界书: "${book.name}"，正在转换为字符串...`);
                    
                    // 将数组中的每个条目对象转换为格式化的字符串
                    const convertedEntries = book.content.map(entry => {
                        const stringParts = [];
                        if (entry.comment) {
                            stringParts.push(`[备注: ${entry.comment}]`);
                        }
                        if (entry.keys && entry.keys.length > 0) {
                            stringParts.push(`[关键词: ${entry.keys.join(', ')}]`);
                        }
                        stringParts.push(entry.content); // 条目主要内容
                        return stringParts.join('\n'); // 每个条目的内部用换行分隔
                    });
                    
                    // 将所有转换后的条目字符串用一个明显的分隔符连接起来
                    book.content = convertedEntries.join('\n\n---\n\n');
                }
            });
        }
        
        // 过滤并保存数据 (这部分逻辑保持不变)
        const validItems = itemsToPut.filter(item => item && (typeof item.id === 'undefined' || typeof item.id === 'string' || typeof item.id === 'number'));
        if (validItems.length > 0) {
            console.log(`正在导入 ${validItems.length} 条数据到表格: ${tableName}...`);
            await db[tableName].bulkPut(validItems);
        }

    } else {
        console.log(`跳过导入: ${tableName} (在备份文件或当前数据库中不存在)`);
    }
}
// ▲▲▲ 代码粘贴结束 ▲▲▲

            
            // 导入对象类型的数据（通常是设置）
            const objectTables = ['apiConfig', 'globalSettings', 'musicLibrary', 'qzoneSettings'];
            for (const tableName of objectTables) {
                if (data[tableName] && db[tableName]) {
                    console.log(`正在导入设置: ${tableName}...`);
                    await db[tableName].put(data[tableName]);
                }
            }
        });

        // 导入主屏幕样式的逻辑保持不变，因为它不直接操作数据库的多个表
        if (data.homeScreenState) {
            const settings = await db.globalSettings.get('main') || { id: 'main' };
            settings.widgetData = data.homeScreenState;
            if (data.homeScreenState.wallpaper) settings.wallpaper = data.homeScreenState.wallpaper;
            if (data.homeScreenState.lockscreenWallpaper) settings.lockscreenWallpaper = data.homeScreenState.lockscreenWallpaper;
            if (data.homeScreenState.appIcons) settings.appIcons = data.homeScreenState.appIcons;
            await db.globalSettings.put(settings);
            console.log("已成功导入主屏幕样式数据。");
        }


        await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("导入数据时出错:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}

function applyCustomFont(fontUrl, isPreviewOnly = false) {
    if (!fontUrl) {
        // 如果没有提供字体链接（比如恢复默认），就清空样式
        dynamicFontStyle.innerHTML = '';
        document.getElementById('font-preview').style.fontFamily = '';
        return;
    }

    // 这是一个统一的内部名字
    const fontName = 'custom-user-font';
    
    // 这是定义字体的样式规则
    const newStyle = `
        @font-face {
          font-family: '${fontName}';
          src: url('${fontUrl}');
          font-display: swap;
        }`;

    if (isPreviewOnly) {
        // 如果只是预览，这个逻辑保持不变
        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
        previewStyle.id = 'preview-font-style';
        previewStyle.innerHTML = newStyle;
        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
    } else {
        // 【核心】如果是全局应用，就同时定义字体并告诉整个 body 去使用它
        dynamicFontStyle.innerHTML = `
            ${newStyle}
            body {
              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
            }`;
    }
}


        async function resetToDefaultFont() {
            // 1. 清除全局字体样式
            dynamicFontStyle.innerHTML = ''; 
            
            // 2. 更新并保存设置
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            
            // 3. 【核心修复】明确地将全局预览区的字体也恢复为默认
            const globalPreview = document.getElementById('font-preview');
            globalPreview.style.fontFamily = ''; // 移除内联样式
            
            // 4. 应用一下空的字体设置，确保所有地方都恢复
            applyCustomFont('', true);
            
            alert('已恢复默认字体。');
        }



async function loadAllDataFromDB() {
    // 【核心修改】我们把 Promise.all 的内容扩充了
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        charStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites,
        apiPresets,
        bubbleStylePresets,
        datingScenes, // <--- 在这里新增
        localUserStickerCategories,
        offlinePresetsFromDB
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.charStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray(),
        db.apiPresets.toArray(),
        db.bubbleStylePresets.toArray(),
        db.datingScenes.toArray(), // <--- 在这里新增
        db.userStickerCategories.toArray(),
        db.offlinePresets.toArray()
    ]);
state.offlinePresets = offlinePresetsFromDB || [];
    state.chats = chatsArr.reduce((acc, chat) => {
            // 【全新】为旧的群聊数据兼容专属表情库
        if (chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
            if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
            chat.settings.stickerLibrary = [];
            console.log(`为旧群聊 "${chat.name}" 补全了专属表情库(stickerLibrary)属性。`);
        }
            // 兼容旧数据：为没有专属表情库的角色添加一个空的表情库
        if (!chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
            if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
            chat.settings.stickerLibrary = [];
            console.log(`为旧角色 "${chat.name}" 补全了专属表情库(stickerLibrary)属性。`);
        }
        // ▲▲▲ 修改结束 ▲▲▲

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
    }
    // ▼▼▼ 在这里粘贴下面的“数据迁移”代码 ▼▼▼
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// 兼容旧数据：为没有心声背景的角色添加一个空字符串
if (typeof chat.innerVoiceBackground === 'undefined') {
    chat.innerVoiceBackground = '';
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ★★★ 这就是本次新增的兼容性代码！ ★★★
if (chat.settings && typeof chat.settings.innerVoiceAdopterLabelFormat === 'undefined') {
    chat.settings.innerVoiceAdopterLabelFormat = '领养人: {{user}}';
}
// ★★★ 新增结束 ★★★
        // ★★★【核心重构：数据迁移脚本】★★★
        // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
            chat.members.forEach(member => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 将旧的 name 作为 originalName
                    member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                    delete member.name; // 删除旧的、有歧义的 name 字段
                    needsUpdate = true; // 标记需要存回数据库
                }
            });
             console.log(`迁移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查1：如果是一个单聊，并且没有 status 属性
        if (!chat.isGroup && !chat.status) {
            // 就为它补上一个默认的 status 对象
            chat.status = {
                text: '在线',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲
        
        // --- ▼▼▼ 【新增】兼容realName字段 ▼▼▼ ---
        // 如果是单聊，并且没有realName字段，则使用当前的name作为默认值
        if (!chat.isGroup && !chat.realName) {
            chat.realName = chat.name;
            console.log(`为旧角色 "${chat.name}" 补全了realName属性。`);
        }
        // --- ▲▲▲ realName兼容结束 ▲▲▲

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查2：兼容最新的“关系”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是单聊，且没有 relationship 对象，就补上一个默认的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ 在这里添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.aiAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
// 兼容旧数据：为没有总结设置的聊天添加默认值
if (!chat.settings.summary) {
    chat.settings.summary = {
        enabled: false,
        mode: 'auto',
        count: 20,
        prompt: '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。',
        lastSummaryIndex: -1 // -1表示从未总结过
    };
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // 兼容旧数据：为没有NPC库的单聊角色添加空的NPC库
    if (!chat.isGroup && !chat.npcLibrary) {
        chat.npcLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了 npcLibrary 属性。`);
    }
    // ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// 兼容旧数据：为没有微博设置的单聊角色添加空的微博设置
if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === 'undefined')) {
    chat.settings.weiboProfession = '';
    chat.settings.weiboInstruction = '';
    console.log(`为旧角色 "${chat.name}" 补全了微博设置属性。`);
}
// ▲▲▲ 粘贴结束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }

    // 兼容旧数据，为没有 isPinned 属性的聊天添加默认值
    if (typeof chat.isPinned === 'undefined') {
        chat.isPinned = false;
    }

// ▼▼▼ 【V2最终修复版】统一修复并初始化所有角色的手机数据 ▼▼▼
if (!chat.isGroup) {
    // 第一步：确保最外层的 characterPhoneData 对象存在
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {}; // 如果不存在，就创建一个空的
    }

    // 第二步：逐一检查并补全所有APP的数据结构
    // 这样无论角色多老，都能确保所有字段都存在
    if (!chat.characterPhoneData.widgets) chat.characterPhoneData.widgets = {};
    if (!chat.characterPhoneData.lastGenerated) chat.characterPhoneData.lastGenerated = null;
    if (!chat.characterPhoneData.chats) chat.characterPhoneData.chats = {};
    if (!chat.characterPhoneData.shoppingCart) chat.characterPhoneData.shoppingCart = [];
    if (!chat.characterPhoneData.memos) chat.characterPhoneData.memos = [];
    if (!chat.characterPhoneData.browserHistory) chat.characterPhoneData.browserHistory = [];
    if (!chat.characterPhoneData.photoAlbum) chat.characterPhoneData.photoAlbum = [];
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (!chat.characterPhoneData.trajectory) chat.characterPhoneData.trajectory = [];
    if (!chat.characterPhoneData.appUsage) chat.characterPhoneData.appUsage = [];
    if (!chat.characterPhoneData.diary) chat.characterPhoneData.diary = []; // 核心修复！
     if (!chat.characterPhoneData.appWallpaper) {
        chat.characterPhoneData.appWallpaper = '';
    }
}
// ▲▲▲ 修正结束 ▲▲▲
// 兼容旧数据，为没有后台活动设置的群聊添加默认值
if (chat.isGroup && (!chat.settings || typeof chat.settings.backgroundActivity === 'undefined')) {
    if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
    chat.settings.backgroundActivity = {
        enabled: false,
        interval: 120, // 默认120秒
        lastActivityTimestamp: 0
    };
}
// ▼▼▼ Part B: 在这里粘贴兼容旧数据的代码 ▼▼▼
// ▼▼▼ 在 loadAllDataFromDB 的 chat 循环内粘贴 ▼▼▼
// 兼容头像形状设置
if (typeof chat.settings.myAvatarShape === 'undefined') {
    chat.settings.myAvatarShape = 'default';
}
if (typeof chat.settings.aiAvatarShape === 'undefined') {
    chat.settings.aiAvatarShape = 'default';
}
// ▲▲▲ 新增代码结束 ▲▲▲
// 兼容旧数据：为没有情侣头像设置的角色添加默认值
if (typeof chat.settings.isCoupleAvatar === 'undefined') {
    chat.settings.isCoupleAvatar = false;
    chat.settings.coupleAvatarDescription = '';
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// 兼容情侣头像识图功能
if (typeof chat.settings.enableCoupleAvatarRecognition === 'undefined') {
    chat.settings.enableCoupleAvatarRecognition = false;
}
if (typeof chat.settings.coupleAvatarRecognitionMemory === 'undefined') {
    chat.settings.coupleAvatarRecognitionMemory = '';
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【领养系统改造】宠物系统初始化/兼容代码 ▼▼▼

// 1. 为所有角色（包括新旧数据）确保有 petAdopted 标志
if (!chat.isGroup && typeof chat.settings.petAdopted === 'undefined') {
    // 如果 pet 对象已存在，说明是老用户，默认已领养
    if (chat.settings.pet && chat.settings.pet.type !== '无') {
        chat.settings.petAdopted = true;
    } else {
        // 如果没有 pet 对象，说明是新用户或之前就没用宠物，默认未领养
        chat.settings.petAdopted = false;
    }
    console.log(`为角色 "${chat.name}" 初始化了宠物领养状态: ${chat.settings.petAdopted}`);
}

// 2. 兼容旧的 pet 对象，确保新字段存在（这段代码和之前一样，保留即可）
if (!chat.isGroup && chat.settings.pet) {
    if (typeof chat.settings.pet.persona === 'undefined') {
        chat.settings.pet.persona = '一只可爱的小宠物，对世界充满好奇。';
    }
    if (!chat.settings.pet.petChatHistory) {
        chat.settings.pet.petChatHistory = [];
    }
    if (!chat.settings.pet.status) {
        chat.settings.pet.status = { 
            hunger: 100, 
            happiness: 100, 
            intimacyToUser: 50, 
            intimacyToChar: 50,
            lastUpdated: Date.now()
        };
    } else {
        if (typeof chat.settings.pet.status.intimacyToUser === 'undefined') chat.settings.pet.status.intimacyToUser = 50;
        if (typeof chat.settings.pet.status.intimacyToChar === 'undefined') chat.settings.pet.status.intimacyToChar = 50;
        if (typeof chat.settings.pet.status.lastUpdated === 'undefined') chat.settings.pet.status.lastUpdated = Date.now();
    }
}
// ▲▲▲ 改造结束 ▲▲▲
        // 兼容旧数据：为没有记忆互通设置的聊天添加一个空的数组
        if (!chat.settings.linkedMemories) {
            chat.settings.linkedMemories = [];
        }
            // ▼▼▼ 在这里新增下面这段代码，以兼容旧数据 ▼▼▼
    // 为旧数据添加默认的记忆条数设置
    if (typeof chat.settings.linkMemoryDepth === 'undefined') {
        chat.settings.linkMemoryDepth = 5;
    }
    // ▲▲▲ 新增结束 ▲▲▲
              // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
        // 兼容线下模式设置
        if (!chat.settings.offlineMode) {
            chat.settings.offlineMode = {
                enabled: false,
                prompt: '',
                style: '',
                wordCount: 300,
                presets: []
            };
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲  
        
        // ▼▼▼ 【全新】在这里添加对角色手机外观设置的兼容代码 ▼▼▼
        if (!chat.isGroup) { // 只为单聊角色添加
            if (!chat.characterPhoneData) {
                chat.characterPhoneData = {}; // 以防万一连 characterPhoneData 都没有
            }
            if (!chat.characterPhoneData.wallpaper) {
                chat.characterPhoneData.wallpaper = ''; // 初始化壁纸为空
            }
            if (!chat.characterPhoneData.appIcons) {
                chat.characterPhoneData.appIcons = {}; // 初始化App图标为空对象
            }
        }
        // ▲▲▲ 兼容代码添加结束 ▲▲▲
        // 【全新】为旧角色数据兼容微博独立设置
if (!chat.isGroup) {
    if (!chat.settings.weiboNickname) {
        chat.settings.weiboNickname = chat.name; // 默认使用角色名作为微博昵称
    }
    if (!chat.settings.weiboAvatar) {
        chat.settings.weiboAvatar = chat.settings.aiAvatar; // 默认使用AI头像
    }
    if (!chat.settings.weiboAvatarFrame) {
        chat.settings.weiboAvatarFrame = chat.settings.aiAvatarFrame || ''; // 默认使用AI头像框
    }
    if (!chat.settings.weiboBackground) {
        chat.settings.weiboBackground = 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg'; // 给一个默认背景
    }
    // weiboProfession 和 weiboInstruction 之前已经兼容过了，这里不用重复
}
        // 兼容旧数据：为没有微博设置的单聊角色添加空的微博设置
        if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === 'undefined')) {
            chat.settings.weiboProfession = '';
            chat.settings.weiboInstruction = '';
            console.log(`为旧角色 "${chat.name}" 补全了微博设置属性。`);
        }
        
        // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
        // 【全新】为旧角色数据兼容微博粉丝/关注数
        if (!chat.isGroup && (typeof chat.settings.weiboFansCount === 'undefined' || typeof chat.settings.weiboFollowingCount === 'undefined')) {
            const initialStats = getInitialWeiboStats(chat);
            chat.settings.weiboFansCount = initialStats.fans;
            chat.settings.weiboFollowingCount = initialStats.following;
            console.log(`为旧角色 "${chat.name}" 初始化了微博数据。`);
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
    // ▼▼▼ 在这个循环的末尾，acc[chat.id] = chat; 之前，添加下面这段代码 ▼▼▼
    if (!chat.isGroup && (!chat.settings || typeof chat.settings.minimaxVoiceId === 'undefined')) {
        if (!chat.settings) chat.settings = {};
        chat.settings.minimaxVoiceId = ''; // 默认为空
        console.log(`为旧角色 "${chat.name}" 补全了 minimaxVoiceId 属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 用这块【增强版】代码，替换你旧的“火花”兼容代码 ▼▼▼
// 兼容旧数据：为没有火花设置的聊天添加默认值
if (!chat.settings.streak) {
    chat.settings.streak = {
        enabled: false,
        initialDays: 0,           // 【新】用户填写的初始天数
        currentDays: 0,           // 当前的火花天数
        extinguishThreshold: 1,   // 【新】熄灭阈值，默认1天
        lastInteractionDate: null // 上次互动日期
    };
    console.log(`为角色 "${chat.name}" 补全了增强版火花(streak)设置。`);
} else if (typeof chat.settings.streak.extinguishThreshold === 'undefined') {
    // 兼容你上个版本的数据，为它们也加上熄灭阈值
    chat.settings.streak.extinguishThreshold = 1; 
    console.log(`为角色 "${chat.name}" 的旧火花设置添加了熄灭阈值。`);
}
// ▲▲▲ 替换结束 ▲▲▲
// 兼容旧的群聊数据，为它们添加群主、管理员和头衔属性
if (chat.isGroup) {
  if (typeof chat.settings.groupAnnouncement === 'undefined') {
    chat.settings.groupAnnouncement = '';
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // 如果没有ownerId，则默认创建者（也就是你）为群主
    if (!chat.ownerId) {
        chat.ownerId = 'user'; // 我们假设用户的ID为 'user'
    }
    // 遍历所有成员，为他们添加新属性
    if (chat.members && Array.isArray(chat.members)) {
        chat.members.forEach(member => {
            if (typeof member.isAdmin === 'undefined') {
                member.isAdmin = false; // 默认不是管理员
            }
            if (typeof member.groupTitle === 'undefined') {
                member.groupTitle = ''; // 默认没有头衔
            }
        });
    }
    // 【新增】为用户自己也添加管理员和头衔的默认属性
    if (chat.settings) {
        if (typeof chat.settings.isUserAdmin === 'undefined') {
            chat.settings.isUserAdmin = false;
        }
        if (typeof chat.settings.myGroupTitle === 'undefined') {
            chat.settings.myGroupTitle = '';
        }
    }
}

// ▲▲▲ 粘贴结束 ▲▲▲
// 在 loadAllDataFromDB 函数的 forEach 循环内，acc[chat.id] = chat; 之前添加：

// 【全新】为旧数据兼容心声面板样式设置
if (!chat.settings.innerVoiceStyles) {
    chat.settings.innerVoiceStyles = {
        clothingColor: '#f0a1a8',
        behaviorColor: '#81c784',
        thoughtsColor: '#64b5f6',
        naughtyColor: '#ba68c8',
        cardBgColor: '#ffffff',
        cardOpacity: 0.7
    };
}
// 为旧数据兼容图标颜色设置
if (chat.settings.innerVoiceStyles && typeof chat.settings.innerVoiceStyles.iconColor === 'undefined') {
    chat.settings.innerVoiceStyles.iconColor = '#ff8a80'; // 默认粉红色
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // 兼容亲密值系统：为旧数据添加互动统计和已解锁徽章
    if (!chat.interactionStats) {
        chat.interactionStats = {};
    }
    if (!chat.unlockedSymbols) {
        chat.unlockedSymbols = [];
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    // 兼容亲密值系统：为旧数据添加佩戴徽章的字段
    if (chat.settings && typeof chat.settings.selectedIntimacyBadge === 'undefined') {
        chat.settings.selectedIntimacyBadge = ''; // 默认为空，不佩戴
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        acc[chat.id] = chat;
        return acc;
    }, {});
// ▼▼▼ 请用这段新代码替换旧的 state.apiConfig 初始化代码 ▼▼▼
    state.apiConfig = apiConfig || { 
        id: 'main', 
        proxyUrl: '', 
        apiKey: '', 
        model: '',
        temperature: 0.8, // 新增：为温度设置一个默认值 0.8
        minimaxGroupId: '',
        minimaxApiKey: '',
        minimaxSpeechModel: 'speech-01' 
    };
// ▲▲▲ 替换结束 ▲▲▲
    // 兼容旧数据，如果加载的设置里没有温度，也给一个默认值
    if (typeof state.apiConfig.temperature === 'undefined') {
        state.apiConfig.temperature = 0.8;
    }
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 步骤 3.1：在 loadAllDataFromDB 函数中，找到并【替换】这行代码 ▼▼▼

state.globalSettings = globalSettings || { 
    id: 'main', 
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    notificationSoundUrl: 'https://files.catbox.moe/k369mf.mp3', // <-- 在这里新增这一行
    widgetData: {}, 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    lockscreenWallpaper: 'linear-gradient(135deg, #764ba2, #667eea)',
    password: '',
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS },
    appLabels: {},
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    notificationSoundUrl: 'https://files.catbox.moe/k369mf.mp3', 
    widgetData: {}, // 【核心修改】在这里新增一个空对象，用来存放你的自定义内容
// 在 state.globalSettings 的初始化对象里添加：
homeAvatarFrame: '', // 为主屏幕头像框添加默认空值

    globalChatBackground: '',
    homeIconWidgetTextColor: '#FFFFFF', // <-- 修改这里的名字
    imageCompressionQuality: 0.7,
    userBalance: 520,
  // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    homeAvatarFrame: '' // 为主屏幕头像框添加默认空值
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
};
// ▼▼▼ 在这下面添加 ▼▼▼
// 【核心】兼容旧数据，如果不存在字体槽位数量的设置，就默认为10
if (typeof state.globalSettings.fontSlotCount === 'undefined') {
    state.globalSettings.fontSlotCount = 10;
}
// ▲▲▲ 添加结束 ▲▲▲
// 确保即使从旧数据库加载，这个属性也存在
if (!state.globalSettings.widgetData) {
    state.globalSettings.widgetData = {};
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面这段新代码 (或者修改你已有的) ▼▼▼
if (!state.globalSettings.homeIconWidgetTextColor) { // <-- 修改这里的名字
    state.globalSettings.homeIconWidgetTextColor = '#FFFFFF';
}
// 【全新】兼容字体阴影设置
if (typeof state.globalSettings.removeHomeFontShadow === 'undefined') {
    state.globalSettings.removeHomeFontShadow = false;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】在这里粘贴下面的兼容性代码 ▼▼▼
// 兼容旧数据：如果加载的设置里没有appLabels，就给它一个空对象
if (!state.globalSettings.appLabels) {
    state.globalSettings.appLabels = {};
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
if (typeof state.globalSettings.imageCompressionQuality === 'undefined') {
    state.globalSettings.imageCompressionQuality = 0.7;
}
    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    // 【核心新增】加载歌词栏设置，如果不存在则使用默认值
    lyricsBarSettings = state.globalSettings.lyricsBarSettings || lyricsBarSettings;
    // ▲▲▲ 添加结束 ▲▲▲

// 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    userStickerCategories = localUserStickerCategories || []; 
    state.charStickers = charStickers || []; 
    state.worldBooks = worldBooks || [];
    currentDatingScenes = datingScenes || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
state.apiPresets = apiPresets || [];
state.bubbleStylePresets = bubbleStylePresets || [];
// ▼▼▼ 在 loadAllDataFromDB 函数里，用下面这整块代码替换旧的 qzoneSettings 初始化代码 ▼▼▼

// ▼▼▼ 用这块【带有微博用户设定】的代码替换 ▼▼▼
state.qzoneSettings = qzoneSettings || { 
    id: 'main', 
    nickname: '{{user}}', 
    avatar: 'https://files.catbox.moe/q6z5fc.jpeg', 
    banner: 'https://files.catbox.moe/r5heyt.gif',
    weiboAvatar: 'https://files.catbox.moe/q6z5fc.jpeg',
    weiboNickname: '你的昵称',
    weiboFansCount: '0',
    weiboBackground: 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg',
    // 【核心新增】在这里为微博用户添加专属的职业和人设字段！
    weiboUserProfession: '点击设置职业', 
    weiboUserPersona: '一个普通的微博用户。',
    weiboUserPersonaPresets: []
};
// 兼容旧数据，如果加载进来的数据没有这些新字段，就补上默认值
if (!state.qzoneSettings.weiboAvatar) state.qzoneSettings.weiboAvatar = state.qzoneSettings.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';
if (!state.qzoneSettings.weiboNickname) state.qzoneSettings.weiboNickname = state.qzoneSettings.nickname || '你的昵称';
if (!state.qzoneSettings.weiboFansCount) state.qzoneSettings.weiboFansCount = '0';
if (!state.qzoneSettings.weiboBackground) state.qzoneSettings.weiboBackground = 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg';
// 【核心新增】兼容旧的用户微博设定
if (!state.qzoneSettings.weiboUserProfession) state.qzoneSettings.weiboUserProfession = '点击设置职业';
if (!state.qzoneSettings.weiboUserPersona) state.qzoneSettings.weiboUserPersona = '一个普通的微博用户。';
if (!state.qzoneSettings.weiboUserPersonaPresets) state.qzoneSettings.weiboUserPersonaPresets = [];
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
if (!state.qzoneSettings.weiboAvatarFrame) state.qzoneSettings.weiboAvatarFrame = '';
// ▲▲▲ 粘贴结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲

    // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【修改结束】 ▲▲▲

// 在 loadAllDataFromDB 函数末尾，init(); 调用之前添加
if (typeof state.globalSettings.notificationSoundUrl === 'undefined') {
    state.globalSettings.notificationSoundUrl = 'https://files.catbox.moe/k369mf.mp3';
}


}

        // ▼▼▼ 【全新 | 支持临时歌曲】请用这个新版本替换旧的 saveGlobalPlaylist 函数 ▼▼▼
async function saveGlobalPlaylist() {
    // 1. 在保存前，先从当前播放列表中过滤掉所有被标记为 isTemporary 的歌曲
    const permanentPlaylist = musicState.playlist.filter(track => !track.isTemporary);
    
    // 2. 只将这个“永久播放列表”保存到数据库中
    await db.musicLibrary.put({ id: 'main', playlist: permanentPlaylist });
    console.log("已将永久播放列表保存到数据库。");
}
// ▲▲▲ 替换结束 ▲▲▲

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        function showNotification(chatId, messageContent) { playNotificationSound();clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

      // ▼▼▼ 步骤 1.1：用下面这【一整块】代码，完整替换掉旧的 updateClock 函数 ▼▼▼
/* ▼▼▼ 步骤 1：将这一整块全新的功能函数，粘贴到您的JS代码的功能函数定义区 ▼▼▼ */

/**
 * 【全新添加】显示一个包含多个选项的操作菜单模态框
 * 这是让图片编辑时能够选择“本地上传”或“URL”的关键函数！
 * @param {string} title - 模态框的标题
 * @param {Array<object>} options - 按钮选项数组, e.g., [{ text: '按钮文字', value: '返回值' }]
 * @returns {Promise<string|null>} - 返回用户点击按钮的value，如果取消则返回null
 */
function showChoiceModal(title, options) {
    return new Promise(resolve => {
        // 复用你现有的自定义模态框
        const modal = document.getElementById('preset-actions-modal');
        const footer = modal.querySelector('.custom-modal-footer');
        
        // 清空旧按钮并动态创建新按钮
        footer.innerHTML = ''; 

        options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.onclick = () => {
                modal.classList.remove('visible');
                resolve(option.value); // 返回被点击按钮的值
            };
            footer.appendChild(button);
        });

        // 添加一个标准的取消按钮
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '取消';
        cancelButton.style.marginTop = '8px';
        cancelButton.style.borderRadius = '8px';
        cancelButton.style.backgroundColor = '#f0f0f0';
        cancelButton.onclick = () => {
            modal.classList.remove('visible');
            resolve(null); // 用户取消，返回 null
        };
        footer.appendChild(cancelButton);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 【最终正确版】请用这整块代码，完整替换旧的 deleteExpiredSearchedSongs 函数 ▼▼▼

/**
 * 【全新重构】检查并删除所有失效的API歌曲
 * 核心逻辑：不再依赖任何标签，直接根据链接特征识别需要检查的歌曲。
 */
async function deleteExpiredSearchedSongs() {
    await showCustomAlert("请稍候...", "正在检查播放列表中所有在线歌曲的有效性...");

    // 1. 【核心改变】我们不再寻找 isTemporary 标签！
    // 而是直接找出所有 src 链接来自于 API 服务器的歌曲。
    // 这是一个绝对可靠的识别方法，无论它有没有被正确保存。
    const songsToCheck = musicState.playlist.filter(track => track.src && track.src.includes('api.vkeys.cn'));

    if (songsToCheck.length === 0) {
        await showCustomAlert('提示', '播放列表中没有需要检查的在线歌曲。');
        return;
    }

    const songsToDelete = [];
    const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);

    // 2. 对每一首识别出的歌曲，进行严格的“体检”
    await Promise.all(songsToCheck.map(async (track) => {
        // 条件1：检查链接本身是否已经失效（无法播放）
        const isUrlInvalid = !(await checkAudioAvailability(track.src));
        
        // 条件2：检查添加时间是否超过24小时（作为双重保险）
        const isOlderThan24h = track.addedTimestamp && track.addedTimestamp < twentyFourHoursAgo;

        // 只要满足【任意一个】条件，就判定为“失效”
        if (isUrlInvalid || isOlderThan24h) {
            songsToDelete.push(track);
            console.log(`标记删除: ${track.name} (原因: ${isUrlInvalid ? '链接失效' : ''} ${isOlderThan24h ? '超过24小时' : ''})`);
        }
    }));

    // 3. 根据检查结果进行反馈和操作 (这部分逻辑不变)
    if (songsToDelete.length === 0) {
        await showCustomAlert('检查完成', '播放列表中的所有在线歌曲当前均有效。');
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认清理',
        `检测到 ${songsToDelete.length} 首已失效的在线歌曲。确定要将它们从列表中移除吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    // 执行删除...
    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
    musicState.playlist = musicState.playlist.filter(track => !songsToDelete.includes(track));
    const newIndex = currentTrack ? musicState.playlist.findIndex(t => t.src === currentTrack.src && t.name === currentTrack.name) : -1;

    if (newIndex === -1) {
        if (musicState.isPlaying) {
            audioPlayer.pause();
            audioPlayer.src = '';
        }
        musicState.isPlaying = false;
        if (musicState.playlist.length > 0) {
            playSong(0); 
        } else {
            musicState.currentIndex = -1;
            updatePlayerUI();
        }
    } else {
        musicState.currentIndex = newIndex;
        updatePlayerUI();
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    await showCustomAlert('清理完成', `${songsToDelete.length} 首歌曲已从列表中移除。`);
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 【已修复】更新所有时钟（状态栏和锁屏）
 */
function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    // 更新状态栏时钟 (这个元素一直存在)
    const statusBarTime = document.getElementById('status-bar-time');
    if (statusBarTime) {
        statusBarTime.textContent = timeString; 
    }

    // 更新锁屏时钟 (只有当锁屏元素存在时才更新，避免报错)
    const lockTime = document.getElementById('lock-main-time');
    const lockDate = document.getElementById('lock-main-date');
    if (lockTime) {
        lockTime.textContent = timeString;
    }
    if (lockDate) {
        lockDate.textContent = dateString;
    }
}



/**
 * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
 * @param {string} content - AI返回的原始字符串
 * @returns {Array} - 一个标准化的消息对象数组
 */
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
    // 这是最理想、最高效的情况
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
            }
        } catch (e) {
            // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
            // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
            console.warn("标准JSON数组解析失败，将尝试强力解析...");
        }
    }

    // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
    // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
            }
        }

        // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
        if (results.length > 0) {
            console.log("解析成功：通过强力提取模式。");
            return results;
        }
    }
    
    // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
    // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
    console.error("所有解析方案均失败！将返回原始文本。");
    return [{ type: 'text', content: content }];
}
// ▼▼▼ 在这里粘贴下面这个新函数 ▼▼▼
/**
 * 【全新】“拉取”并填充Minimax语音模型的下拉框
 */
function fetchMinimaxSpeechModels() {
    const modelSelect = document.getElementById('minimax-speech-model-select');
    modelSelect.innerHTML = ''; // 清空

    // Minimax官方提供的两个主要模型
    const models = ['speech-01', 'speech-02'];

    models.forEach(modelId => {
        const option = document.createElement('option');
        option.value = modelId;
        // 为模型添加简单的中文描述
        option.textContent = `${modelId} (${modelId === 'speech-02' ? '高清' : '标准'})`;
        modelSelect.appendChild(option);
    });

    // 自动选中当前已保存的模型
    modelSelect.value = state.apiConfig.minimaxSpeechModel || 'speech-01';

    alert('Minimax 语音模型列表已刷新！');
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ NovelAI设置相关函数（加载、保存、重置） ▼▼▼
// NovelAI设置相关函数
function loadNovelAISettings() {
    const settings = getNovelAISettings();
    document.getElementById('nai-resolution').value = settings.resolution;
    document.getElementById('nai-steps').value = settings.steps;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale;
    document.getElementById('nai-sampler').value = settings.sampler;
    document.getElementById('nai-seed').value = settings.seed;
    document.getElementById('nai-uc-preset').value = settings.uc_preset;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle;
    document.getElementById('nai-smea').checked = settings.smea;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn;
    document.getElementById('nai-default-positive').value = settings.default_positive;
    document.getElementById('nai-default-negative').value = settings.default_negative;
    document.getElementById('nai-cors-proxy').value = settings.cors_proxy;
    document.getElementById('nai-custom-proxy-url').value = settings.custom_proxy_url || '';
    
    // 显示/隐藏自定义代理输入框
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    customProxyGroup.style.display = settings.cors_proxy === 'custom' ? 'block' : 'none';
}

function saveNovelAISettings() {
    // 保存API Key和模型等基础配置
    const novelaiEnabled = document.getElementById('novelai-switch').checked;
    const novelaiModel = document.getElementById('novelai-model').value;
    const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
    
    localStorage.setItem('novelai-enabled', novelaiEnabled);
    localStorage.setItem('novelai-model', novelaiModel);
    localStorage.setItem('novelai-api-key', novelaiApiKey);
    
    // 保存高级参数配置
    const settings = {
        resolution: document.getElementById('nai-resolution').value,
        steps: parseInt(document.getElementById('nai-steps').value),
        cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
        sampler: document.getElementById('nai-sampler').value,
        seed: parseInt(document.getElementById('nai-seed').value),
        uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
        quality_toggle: document.getElementById('nai-quality-toggle').checked,
        smea: document.getElementById('nai-smea').checked,
        smea_dyn: document.getElementById('nai-smea-dyn').checked,
        default_positive: document.getElementById('nai-default-positive').value,
        default_negative: document.getElementById('nai-default-negative').value,
        cors_proxy: document.getElementById('nai-cors-proxy').value,
        custom_proxy_url: document.getElementById('nai-custom-proxy-url').value
    };
    
    localStorage.setItem('novelai-settings', JSON.stringify(settings));
}

function resetNovelAISettings() {
    localStorage.removeItem('novelai-settings');
    loadNovelAISettings();
    alert('已恢复默认设置！');
}

function getNovelAISettings() {
    const defaultSettings = {
        resolution: '1024x1024',
        steps: 28,
        cfg_scale: 5,
        sampler: 'k_euler_ancestral',
        seed: -1,
        uc_preset: 1,
        quality_toggle: true,
        smea: true,
        smea_dyn: false,
        default_positive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
        default_negative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
        cors_proxy: 'https://corsproxy.io/?',
        custom_proxy_url: ''
    };
    
    const saved = localStorage.getItem('novelai-settings');
    if (saved) {
        try {
            return {...defaultSettings, ...JSON.parse(saved)};
        } catch (e) {
            return defaultSettings;
        }
    }
    return defaultSettings;
}

/**
 * 根据角色ID获取对应的NAI提示词配置
 * @param {string} chatId - 聊天/角色ID
 * @returns {Object} 包含正面和负面提示词的对象
 */
function getCharacterNAIPrompts(chatId) {
    // 获取系统默认配置
    const systemSettings = getNovelAISettings();
    
    // 如果没有指定角色ID或角色不存在，返回系统配置
    if (!chatId || !state.chats[chatId]) {
        console.log('⚠️ NAI提示词：没有角色，使用系统配置');
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
    
    const chat = state.chats[chatId];
    const naiSettings = chat.settings.naiSettings || {};
    
    // 选角色就用角色的，选系统就用系统的，就这么简单！
    if (naiSettings.promptSource === 'character') {
        console.log('✅ NAI提示词：使用角色配置');
        console.log('   正面:', naiSettings.characterPositivePrompt || '(空)');
        console.log('   负面:', naiSettings.characterNegativePrompt || '(空)');
        
        return {
            positive: naiSettings.characterPositivePrompt || '',
            negative: naiSettings.characterNegativePrompt || '',
            source: 'character'
        };
    } else {
        console.log('✅ NAI提示词：使用系统配置');
        console.log('   正面:', systemSettings.default_positive || '(空)');
        console.log('   负面:', systemSettings.default_negative || '(空)');
        
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
}
// ▲▲▲ 获取角色NAI提示词配置的辅助函数结束 ▲▲▲
// ▲▲▲ NovelAI设置相关函数结束 ▲▲▲

/**
 * 为指定角色生成NovelAI图像（将来聊天调用时使用）
 * @param {string} chatId - 聊天/角色ID
 * @param {string} customPrompt - 可选的自定义正面提示词（如果提供则追加到配置的提示词后）
 * @returns {Promise<string>} 返回生成的图像Base64数据URL
 */
async function generateNovelAIImageForCharacter(chatId, customPrompt = '') {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    
    if (!apiKey) {
        throw new Error('请先配置NovelAI API Key！');
    }
    
    // 获取角色的提示词配置
    const prompts = getCharacterNAIPrompts(chatId);
    
    // 构建最终的提示词（如果有自定义提示词则追加）
    let finalPrompt = prompts.positive;
    if (customPrompt) {
        finalPrompt = customPrompt + ', ' + prompts.positive;
    }
    
    const negativePrompt = prompts.negative;
    
    console.log(`📝 使用${prompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
    console.log('正面提示词:', finalPrompt);
    console.log('负面提示词:', negativePrompt);
    
    const settings = getNovelAISettings();
    
    // 后续的图像生成逻辑将在这里实现
    // 这个函数预留给将来聊天中调用NAI出图功能使用
    return null;
}
// ▲▲▲ 角色NAI提示词配置辅助函数结束 ▲▲▲

// ▼▼▼ 第十二部分：生成NovelAI图片的主函数（完整版） ▼▼▼
async function generateNovelAIImage() {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    const prompt = document.getElementById('nai-test-prompt').value.trim();
    
    if (!apiKey) {
        alert('请先配置NovelAI API Key！');
        return;
    }
    
    if (!prompt) {
        alert('请输入提示词！');
        return;
    }
    
    const settings = getNovelAISettings();
    const negativePrompt = document.getElementById('nai-test-negative').value.trim();
    
    const statusDiv = document.getElementById('nai-test-status');
    const resultDiv = document.getElementById('nai-test-result');
    const errorDiv = document.getElementById('nai-test-error');
    const generateBtn = document.getElementById('nai-generate-btn');
    
    statusDiv.style.display = 'block';
    resultDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    generateBtn.disabled = true;
    generateBtn.textContent = '生成中...';
    
    try {
        const [width, height] = settings.resolution.split('x').map(Number);
        
        // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
        let requestBody;
        
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 使用新格式 (params_version: 3)
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    params_version: 3,  // V4必须使用版本3
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras',  // V4使用karras
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                    // V4专用提示词格式
                    v4_prompt: {
                        caption: {
                            base_caption: prompt,
                            char_captions: []
                        },
                        use_coords: false,
                        use_order: true
                    },
                    // V4专用负面提示词格式
                    v4_negative_prompt: {
                        caption: {
                            base_caption: negativePrompt,
                            char_captions: []
                        },
                        legacy_uc: false
                    },
                    negative_prompt: negativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                    // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                }
            };
        } else {
            // V3 及更早版本使用旧格式
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: negativePrompt
                }
            };
        }
        
        console.log('📤 发送请求到 NovelAI API');
        console.log('📊 使用模型:', model);
        console.log('📋 请求体:', JSON.stringify(requestBody, null, 2));
        
        // ★★★ 根据模型选择不同的API端点 ★★★
        let apiUrl;
        
        // V4/V4.5 模型使用流式端点
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 默认使用流式端点
            apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
        } else {
            // V3 及更早版本使用标准端点
            apiUrl = 'https://image.novelai.net/ai/generate-image';
        }
        
        let corsProxy = settings.cors_proxy;
        
        // 如果选择了自定义代理，使用自定义URL
        if (corsProxy === 'custom') {
            corsProxy = settings.custom_proxy_url || '';
        }
        
        // 如果有代理，添加到URL前面
        if (corsProxy && corsProxy !== '') {
            apiUrl = corsProxy + encodeURIComponent(apiUrl);
        }
        
        // ★★★ Chrome浏览器专用处理：避免headers中包含非ISO-8859-1字符 ★★★
        const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
        let fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify(requestBody)
        };
        
        // 针对Chrome浏览器：确保所有header值都是纯ASCII
        if (isChrome) {
            console.log('🔧 检测到Chrome浏览器，启用headers兼容性处理');
            const cleanHeaders = {};
            for (const [key, value] of Object.entries(fetchOptions.headers)) {
                // 确保header值只包含ASCII字符（ISO-8859-1兼容）
                cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, '');
            }
            fetchOptions.headers = cleanHeaders;
        }
        
        const response = await fetch(apiUrl, fetchOptions);
        
        console.log('Response status:', response.status);
        console.log('Response headers:', [...response.headers.entries()]);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('API错误响应:', errorText);
            throw new Error(`API请求失败 (${response.status}): ${errorText}`);
        }
        
        // NovelAI API返回的是ZIP文件，需要解压
        const contentType = response.headers.get('content-type');
        console.log('Content-Type:', contentType);
        
        // 检查是否为 SSE 流式响应
        let zipBlob;
        if (contentType && contentType.includes('text/event-stream')) {
            console.log('检测到 SSE 流式响应，开始解析...');
            statusDiv.textContent = '正在接收流式数据...';
            
            // 读取整个流
            const text = await response.text();
            console.log('收到 SSE 数据，大小:', text.length);
            
            // 解析 SSE 格式，提取最后的 data: 行
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); // 移除 'data: ' 前缀
                    
                    // 尝试解析 JSON
                    try {
                        const jsonData = JSON.parse(dataContent);
                        
                        // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('✅ 找到 final 事件的图片数据');
                            break;
                        }
                        
                        // 兼容其他格式
                        if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('从 JSON.data 中提取图片数据');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('从 JSON.image 中提取图片数据');
                            break;
                        }
                    } catch (e) {
                        // 如果不是 JSON，直接作为 base64 数据
                        base64Data = dataContent;
                        console.log('直接使用 base64 数据');
                        break;
                    }
                }
            }
            
            if (!base64Data) {
                throw new Error('无法从 SSE 响应中提取图片数据');
            }
            
            // V4.5 流式端点返回的是 PNG base64，不是 ZIP
            // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                // 将 base64 转为 Blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                console.log('图片 Blob 创建成功，大小:', imageBlob.size);
                
                // 直接显示图片
                const imageUrl = URL.createObjectURL(imageBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                console.log('✅ 图片显示成功！🎨');
                return;
            }
            
            // 否则当作 ZIP 处理
            console.log('当作 ZIP 文件处理...');
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            zipBlob = new Blob([bytes]);
            console.log('ZIP Blob 大小:', zipBlob.size);
            
        } else {
            // 非流式响应，直接读取
            zipBlob = await response.blob();
            console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
        }
        
        // NovelAI始终返回ZIP格式，需要解压
        try {
            // 检查JSZip是否已加载
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip库未加载，请刷新页面重试');
            }
            
            statusDiv.textContent = '正在解压图片...';
            
            // 解压ZIP文件
            const zip = await JSZip.loadAsync(zipBlob);
            console.log('ZIP文件内容:', Object.keys(zip.files));
            
            // 查找第一个图片文件（通常是image_0.png）
            let imageFile = null;
            for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                    imageFile = zip.files[filename];
                    console.log('找到图片文件:', filename);
                    break;
                }
            }
            
            if (!imageFile) {
                throw new Error('ZIP文件中未找到图片');
            }
            
            // 提取图片数据
            const imageBlob = await imageFile.async('blob');
            console.log('提取的图片大小:', imageBlob.size);
            
            // 创建图片URL并显示
            const imageUrl = URL.createObjectURL(imageBlob);
            console.log('生成的图片URL:', imageUrl);
            
            document.getElementById('nai-result-image').src = imageUrl;
            statusDiv.style.display = 'none';
            resultDiv.style.display = 'block';
            
        } catch (zipError) {
            console.error('ZIP解压失败:', zipError);
            // 如果解压失败，尝试直接作为图片显示
            console.log('尝试直接作为图片显示...');
            
            if (zipBlob.type.startsWith('image/')) {
                const imageUrl = URL.createObjectURL(zipBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
            } else {
                throw new Error('图片格式处理失败: ' + zipError.message);
            }
        }
        
    } catch (error) {
        console.error('NovelAI生成失败:', error);
        statusDiv.style.display = 'none';
        errorDiv.style.display = 'block';
        errorDiv.textContent = '生成失败: ' + error.message;
    } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = '生成图像';
    }
}
// ▲▲▲ 第十二部分结束 ▲▲▲

    function renderApiSettings() {
    // 1. 更新 API 相关的输入框
    document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || '';
    document.getElementById('api-key').value = state.apiConfig.apiKey || '';
        // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
    // 【核心新增】加载 Minimax 设置
    document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
    document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
    document.getElementById('minimax-speech-model-select').value = state.apiConfig.minimaxSpeechModel || 'speech-01';
    // ▲▲▲ 粘贴结束 ▲▲▲
    // 如果你有模型选择，也一并更新
    if (document.getElementById('model-select')) {
        document.getElementById('model-select').value = state.apiConfig.model || 'gpt-4';
    }

    // 加载NovelAI配置
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
    const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    const novelaiApiKey = localStorage.getItem('novelai-api-key') || '';
    document.getElementById('novelai-switch').checked = novelaiEnabled;
    document.getElementById('novelai-model').value = novelaiModel;
    document.getElementById('novelai-api-key').value = novelaiApiKey;
    document.getElementById('novelai-details').style.display = novelaiEnabled ? 'block' : 'none';

    // 2. 更新后台活动相关的开关和输入框
    
    // ★★★★★ 这就是我们这次修复的核心 ★★★★★
    // 使用 !!state.globalSettings.enableBackgroundActivity 这种写法，
    // 确保当这个设置还不存在时 (比如第一次打开)，开关也能正确地显示为 false (关闭状态)
    document.getElementById('background-activity-switch').checked = !!state.globalSettings.enableBackgroundActivity;
    // ★★★★★ 修复结束 ★★★★★

    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;

    // 3. 渲染预设和频率的下拉框
    renderApiPresetSelector();
    renderBackgroundFrequencySelector();
    // ▼▼▼ 将下面这整块【新代码】粘贴到 renderApiSettings 函数的末尾 ▼▼▼
    
    // 【核心新增】渲染温度滑块的UI
    const tempSlider = document.getElementById('temperature-slider');
    const tempValueDisplay = document.getElementById('temperature-value');
    
    // 从 state 中读取已保存的温度，如果没有则使用默认值 0.8
    const currentTemp = state.apiConfig.temperature || 0.8;
    tempSlider.value = currentTemp;
    tempValueDisplay.textContent = parseFloat(currentTemp).toFixed(1);

    // 添加实时更新显示值的事件
    tempSlider.addEventListener('input', () => {
        tempValueDisplay.textContent = parseFloat(tempSlider.value).toFixed(1);
    });
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // ▼▼▼ 在函数末尾添加下面这块新代码 ▼▼▼
    const qualitySlider = document.getElementById('image-quality-slider');
    const qualityValue = document.getElementById('image-quality-value');
    const currentQuality = state.globalSettings.imageCompressionQuality || 0.7;
    
    if (qualitySlider && qualityValue) {
        qualitySlider.value = currentQuality;
        qualityValue.textContent = parseFloat(currentQuality).toFixed(1);

        // 添加实时更新显示值的事件
        qualitySlider.addEventListener('input', () => {
            qualityValue.textContent = parseFloat(qualitySlider.value).toFixed(1);
        });
    }
     calculateTotalImageSize();
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
}

// ▼▼▼ 【全新】粘贴这个完整的函数 ▼▼▼
/**
 * 渲染后台活动的角色选择和频率设置UI
 */
function renderBackgroundFrequencySelector() {
    const container = document.getElementById('background-activity-char-list');
    const detailsContainer = document.getElementById('background-activity-details');
    const masterSwitch = document.getElementById('background-activity-switch');

    // 根据总开关的状态，决定是否显示详细设置
    detailsContainer.style.display = masterSwitch.checked ? 'block' : 'none';
    
    container.innerHTML = ''; // 清空旧列表
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">还没有可以设置的角色</p>';
        return;
    }

    const config = state.globalSettings.backgroundActivityConfig || {};

    singleChats.forEach(chat => {
        const freq = config[chat.id] || 'none'; // 获取当前角色的频率设置
        let badgeHtml = '';
        if (freq !== 'none') {
            const freqText = { low: '低', medium: '中', high: '高' }[freq];
            badgeHtml = `<span class="char-freq-badge ${freq}">${freqText}</span>`;
        }

        const item = document.createElement('div');
        item.className = 'char-list-item';
        item.innerHTML = `
            <input type="checkbox" class="bg-char-checkbox" data-chat-id="${chat.id}">
            <span class="char-name">${chat.name}</span>
            ${badgeHtml}
        `;
        container.appendChild(item);
    });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

        window.renderApiSettingsProxy = renderApiSettings;
// ▼▼▼ 请用这个【全新修正版】替换旧的 renderChatList 函数 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 获取所有聊天和分组数据
    const allChats = Object.values(state.chats);
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    // 2. 将聊天明确地分为“置顶”和“未置顶”两组
    const pinnedChats = allChats.filter(chat => chat.isPinned);
    const unpinnedChats = allChats.filter(chat => !chat.isPinned);

    // 3. 对置顶的聊天，仅按最新消息时间排序
    pinnedChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

    // 4. 【优先渲染】所有置顶的聊天
    pinnedChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 5. 【接下来处理未置顶的聊天】应用您之前的分组逻辑
    // 为每个分组找到其内部最新的消息时间戳 (只在未置顶聊天中查找)
    allGroups.forEach(group => {
        const latestChatInGroup = unpinnedChats
            .filter(chat => chat.groupId === group.id) // 找到属于这个组的聊天
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0]; // 排序后取第一个
        
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 根据分组的最新时间戳，对分组本身进行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // 6. 遍历排序后的分组，渲染其中的【未置顶】好友
    allGroups.forEach(group => {
        const groupChats = unpinnedChats
            .filter(chat => !chat.isGroup && chat.groupId === group.id)
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
        
        if (groupChats.length === 0) return; // 如果这个分组里没有未置顶的好友，就跳过

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        
        // 【核心修改】下面这两行代码里，我已经删除了 collapsed 类，这样默认就是展开的了！
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');

        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 7. 最后，渲染所有【未置顶】的群聊和【未分组的】好友
    const remainingChats = unpinnedChats
        .filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId))
        .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    remainingChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 为所有分组标题添加折叠事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 main-app.js 中，用这块【V2 - 图片徽章版】代码替换旧的 createChatListItem 函数 ▼▼▼
function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
    } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
    } else if (chat.isGroup) {
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }
        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            const member = chat.members.find(m => m.originalName === lastMsgObj.senderName);
            const displayName = member ? member.groupNickname : lastMsgObj.senderName;
            lastMsgDisplay = `${displayName}: ${lastMsgDisplay}`;
        }
    } else {
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
    }

    const lastMsgTimestamp = lastMsgObj?.timestamp;
    const timeDisplay = formatChatListTimestamp(lastMsgTimestamp);
    
    const container = document.createElement('div');
    container.className = 'chat-list-item-swipe-container';
    container.dataset.chatId = chat.id;

    const content = document.createElement('div');
    content.className = `chat-list-item-content ${chat.isPinned ? 'pinned' : ''}`;
    
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;

    let streakHtml = '';
    let selectedBadgeHtml = '';

    if (!chat.isGroup && chat.settings.streak && chat.settings.streak.enabled) {
        const streak = chat.settings.streak;
        let isExtinguished = false;
        if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
            const lastDate = new Date(streak.lastInteractionDate);
            const todayDate = new Date();
            todayDate.setHours(0, 0, 0, 0); 
            const daysDiff = (todayDate - lastDate) / (1000 * 3600 * 24);
            if (daysDiff >= streak.extinguishThreshold) {
                isExtinguished = true;
            }
        }
        const litIconUrl = streak.litIconUrl;
        const extinguishedIconUrl = streak.extinguishedIconUrl;
        const fontColor = streak.fontColor || '#ff6f00';
        let iconHtml = '';
        if (isExtinguished) {
            iconHtml = extinguishedIconUrl ? `<img src="${extinguishedIconUrl}" style="height: 1.2em; vertical-align: middle;">` : '🧊';
        } else if (streak.currentDays > 0 || streak.initialDays > 0) {
            iconHtml = litIconUrl ? `<img src="${litIconUrl}" style="height: 1.2em; vertical-align: middle;">` : '🔥';
        }
        if (iconHtml) {
            if (isExtinguished) {
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}</span>`;
            } else if (streak.currentDays === -1 || streak.initialDays === -1) {
                 streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}∞</span>`;
            } else {
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}${streak.currentDays}</span>`;
            }
        }
    }

    // ★★★ 核心修改：使用 <img> 标签来显示佩戴的徽章图片 ★★★
    if (!chat.isGroup && chat.settings.selectedIntimacyBadge) {
        selectedBadgeHtml = `<span class="intimacy-badge-display"><img src="${chat.settings.selectedIntimacyBadge}" alt="badge"></span>`;
    }
    
    content.innerHTML = `
        <div class="chat-list-item" data-chat-id="${chat.id}">
            <img src="${avatar || defaultAvatar}" class="avatar">
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                    ${streakHtml}
                    ${selectedBadgeHtml} <!-- 把徽章放在火花后面 -->
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="chat-list-right-column">
                <div class="chat-list-time">${timeDisplay}</div>
                <div class="unread-count-wrapper">
                    <span class="unread-count" style="display: none;">0</span>
                </div>
            </div>
        </div>
    `;
    
    // ... 后续的滑动删除、事件绑定等代码保持不变 ...
    const actions = document.createElement('div');
    actions.className = 'swipe-actions';
    const pinButtonText = chat.isPinned ? '取消置顶' : '置顶';
    const pinButtonClass = chat.isPinned ? 'unpin' : 'pin';
    actions.innerHTML = `<button class="swipe-action-btn ${pinButtonClass}">${pinButtonText}</button><button class="swipe-action-btn delete">删除</button>`;
    
    container.appendChild(content);
    container.appendChild(actions);
    
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = content.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    const infoEl = content.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }
    const avatarEl = content.querySelector('.avatar, .avatar-with-frame');
    if (avatarEl) {
         avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, chat.name);
        });
    }

    return container;
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 请用这个【带诊断功能的全新版本】替换旧的 renderChatInterface 函数 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
        // ▼▼▼ 【全新】群公告图标显示/隐藏逻辑 ▼▼▼
    const announcementBtn = document.getElementById('group-announcement-btn');
    if (chat.isGroup) {
        announcementBtn.style.display = 'inline-flex'; // 在群聊中显示
    } else {
        announcementBtn.style.display = 'none'; // 在单聊中隐藏
    }
    // ▲▲▲ 新增代码结束 ▲▲▲

    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || '在线';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                `;
                // --- 【修改结束】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                `;
                break;

            // 【核心修正】修复当你申请后，你看到的界面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
// ▼▼▼ 用这【一整块】代码，替换旧的背景设置逻辑 ▼▼▼
const chatScreen = document.getElementById('chat-interface-screen');

// 核心逻辑：单人背景优先于全局背景
const backgroundToApply = chat.settings.background || state.globalSettings.globalChatBackground;

if (backgroundToApply) {
    chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
} else {
    chatScreen.style.backgroundImage = 'none';
}
// ▲▲▲ 替换结束 ▲▲▲
const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : (isDarkMode ? '#000000' : '#f0f2f5');
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
let lastMessageTimestamp = null;

let renderedCount = 0;
initialMessages.forEach(msg => {
    if (msg.isHidden) return; // 【新增】跳过隐藏消息

    if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
        // 【核心修改】调用我们新的生成器函数
        const dateStampEl = createDateStampElement(msg.timestamp);
        messagesContainer.insertBefore(dateStampEl, document.getElementById('typing-indicator'));
    }
    
    appendMessage(msg, chat, true);
    renderedCount++;
    
    lastMessageTimestamp = msg.timestamp;
});
    currentRenderedCount = renderedCount;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
    renderChatPet();
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; // ▼▼▼ 请将这个完整的代码块，粘贴到被删除的位置 ▼▼▼

// 1. 找到屏幕上已有的、最老的那条【真实消息】的时间戳
const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper:not(.date-stamp-wrapper)');
let subsequentMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : null;

// 2. 从后往前（从新到旧）遍历我们要新加载的消息
messagesToPrepend.reverse().forEach(currentMsg => {
    // 检查这条新消息和它后面那条（可能是屏幕上已有的，也可能是刚加载的）消息是否跨天
    if (subsequentMessageTimestamp && isNewDay(subsequentMessageTimestamp, currentMsg.timestamp)) {
        // 如果跨天，就为后面那条“较新”的消息创建一个日期戳
        const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
        messagesContainer.prepend(dateStampEl);
    }
    
    // 正常地把当前这条新消息放到最前面
    prependMessage(currentMsg, chat);
    
    // 更新追踪器，为下一次比较做准备
    subsequentMessageTimestamp = currentMsg.timestamp;
});

// 3. 【边界处理】处理所有新加载消息的最前面（也就是整个聊天记录的最老）的那条消息
// 它也需要一个日期戳
if (subsequentMessageTimestamp) {
    const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
    messagesContainer.prepend(dateStampEl);
}

// ▲▲▲ 粘贴结束 ▲▲▲
currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

async function renderWallpaperScreen() { 
    // 锁屏开关
    const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
    const toggle = document.getElementById('enable-lock-screen-toggle');
    if (toggle) {
        toggle.checked = lockScreenEnabled;
    }

    // 主屏幕字体颜色和阴影
    document.getElementById('home-icon-widget-text-color-picker').value = state.globalSettings.homeIconWidgetTextColor || '#FFFFFF';
    document.getElementById('remove-home-font-shadow-toggle').checked = !!state.globalSettings.removeHomeFontShadow;

    // 主屏幕壁纸预览
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '当前为渐变色'; 
    }

    // 锁屏壁纸预览
    const lockscreenPreview = document.getElementById('lockscreen-wallpaper-preview');
    const lockBg = newLockscreenWallpaperBase64 || state.globalSettings.lockscreenWallpaper;
    if (lockBg && lockBg.startsWith('data:image')) {
        lockscreenPreview.style.backgroundImage = `url(${lockBg})`;
        lockscreenPreview.textContent = '';
    } else if (lockBg) {
        lockscreenPreview.style.backgroundImage = lockBg;
        lockscreenPreview.textContent = '当前为渐变色';
    }

    // 密码输入框
    document.getElementById('password-set-input').value = state.globalSettings.password || '';

    // 全局聊天背景预览
    const globalBgPreview = document.getElementById('global-bg-preview');
    const globalBg = newGlobalBgBase64 || state.globalSettings.globalChatBackground;
    if (globalBg && globalBg.startsWith('data:image')) {
        globalBgPreview.style.backgroundImage = `url(${globalBg})`;
        globalBgPreview.textContent = '';
    } else if (globalBg) {
        globalBgPreview.style.background = globalBg;
        globalBgPreview.textContent = '当前为渐变色';
    } else {
        globalBgPreview.style.backgroundImage = 'none';
        globalBgPreview.textContent = '点击下方上传';
    }
    
    // 铃声和提示音
    document.getElementById('ringtone-url-input').value = state.globalSettings.ringtoneUrl || '';
    document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';

    // ★★★ 核心修复3：在这里添加加载CSS代码到编辑器的逻辑 ★★★
    await loadThemesToDropdown(); // 确保主题列表已加载
    const editor = document.getElementById('theme-css-editor');
    const selector = document.getElementById('theme-selector');

    // 优先加载 activeCustomCss
    if (state.globalSettings.activeCustomCss) {
        editor.value = state.globalSettings.activeCustomCss;
        // 如果自定义CSS存在，则将下拉框重置为“未选择”状态
        selector.value = '';
    } 
    // 如果没有自定义CSS，但有选中的主题ID
    else if (state.globalSettings.activeThemeId) {
        const theme = await db.themes.get(state.globalSettings.activeThemeId);
        if (theme) {
            editor.value = theme.css;
            selector.value = theme.id; // 自动选中该主题
        } else {
            editor.value = THEME_CSS_TEMPLATE; // 如果ID无效，则显示模板
        }
    } 
    // 如果什么都没保存，显示模板
    else {
        editor.value = THEME_CSS_TEMPLATE;
    }

    // 渲染App图标和名称设置
    renderIconSettings();
    renderAppNameSettings();
    
    // 加载预设下拉框
    loadHomeScreenPresetsToDropdown(); 
}

        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

async function renderWorldBookScreen() {
    const listEl = document.getElementById('world-book-list');
    listEl.innerHTML = '';

    // 1. 同时获取所有书籍和所有分类
    const [books, categories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books; // 确保内存中的数据是同步的

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
        return;
    }

    // 2. 将书籍按 categoryId 分组
    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(book);
        return acc;
    }, {});

    // 3. 优先渲染已分类的书籍
    categories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            const groupContainer = createWorldBookGroup(category.name, booksInCategory);
            listEl.appendChild(groupContainer);
        }
    });

    // 4. 最后渲染未分类的书籍
    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        const groupContainer = createWorldBookGroup('未分类', uncategorizedBooks);
        listEl.appendChild(groupContainer);
    }
    
    // 5. 为所有分组标题添加折叠事件
    document.querySelectorAll('.world-book-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}

/**
 * 【辅助函数】创建一个分类的分组DOM
 * @param {string} groupName - 分类名称
 * @param {Array} books - 该分类下的书籍数组
 * @returns {HTMLElement} - 创建好的分组容器
 */
function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="world-book-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${groupName}</span>
        </div>
        <div class="world-book-group-content"></div>
    `;

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    
    // 默认给头部和内容区都加上 collapsed 类
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');
    // ▲▲▲ 添加结束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`;
        item.addEventListener('click', () => openWorldBookEditor(book.id));
        addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } });
        contentEl.appendChild(item); 
    });

    return groupContainer;
}
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

async function openWorldBookEditor(bookId) {
    editingWorldBookId = bookId;
    const [book, categories] = await Promise.all([
        db.worldBooks.get(bookId),
        db.worldBookCategories.toArray()
    ]);
    if (!book) return;

    document.getElementById('world-book-editor-title').textContent = book.name;
    document.getElementById('world-book-name-input').value = book.name;
    document.getElementById('world-book-content-input').value = book.content;

    // 【核心修改】填充分类下拉菜单
    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        if (book.categoryId === cat.id) {
            option.selected = true; // 选中当前分类
        }
        selectEl.appendChild(option);
    });

    showScreen('world-book-editor-screen');
}

// ▼▼▼ 使用这块【适配未分类】的新代码替换旧的 renderStickerPanel 函数 ▼▼▼
function renderStickerPanel() {
    const grid = document.getElementById('sticker-grid');
    grid.innerHTML = '';
    
    let stickersToRender;

    // ★ 核心修改：更新这里的筛选逻辑 ★
    if (activeStickerCategoryId === 'uncategorized') {
        // 如果是“未分类”，就筛选出 categoryId 不存在或为空的表情
        stickersToRender = state.userStickers.filter(sticker => !sticker.categoryId);
    } else {
        // 否则，按具体的分类ID筛选
        stickersToRender = state.userStickers.filter(sticker => sticker.categoryId === activeStickerCategoryId);
    }

    if (stickersToRender.length === 0) {
        // 根据当前选中的分类，显示不同的提示语
        let message;
        if (activeStickerCategoryId === 'uncategorized') {
            // 如果所有表情都有分类了，这里也会是空的
            message = '没有未分类的表情哦~';
        } else {
            // 如果是在某个具体分类下，但是里面没表情
            message = '这个分类下还没有表情哦~';
        }
        // 如果整个表情库都是空的，给一个初始引导
        if(state.userStickers.length === 0) {
             message = '大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！';
        }
        
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
    } else {
        stickersToRender.forEach(sticker => {
            // 这部分是你原来的渲染逻辑，保持不变
            const itemContainer = document.createElement('div');
            itemContainer.className = 'sticker-item';
            
            const imageEl = document.createElement('div');
            imageEl.className = 'sticker-image';
            imageEl.style.backgroundImage = `url(${sticker.url})`;
            
            const nameEl = document.createElement('span');
            nameEl.className = 'sticker-name';
            nameEl.textContent = sticker.name;
            nameEl.title = sticker.name;
            
            if (isUserStickerSelectionMode) {
                imageEl.classList.add('in-selection-mode');
                if (selectedUserStickers.has(sticker.id)) {
                    imageEl.classList.add('selected');
                }
                itemContainer.addEventListener('click', () => {
                    imageEl.classList.toggle('selected');
                    if (selectedUserStickers.has(sticker.id)) {
                        selectedUserStickers.delete(sticker.id);
                    } else {
                        selectedUserStickers.add(sticker.id);
                    }
                    const deleteBtn = document.getElementById('delete-selected-user-stickers-btn');
                    deleteBtn.textContent = `删除已选 (${selectedUserStickers.size})`;
                    deleteBtn.disabled = selectedUserStickers.size === 0;

                    const moveBtn = document.getElementById('move-selected-stickers-btn');
                    moveBtn.disabled = selectedUserStickers.size === 0;
                });
            } else {
                itemContainer.addEventListener('click', () => sendSticker(sticker));
                addLongPressListener(imageEl, () => {
                    const existingDeleteBtn = imageEl.querySelector('.delete-btn');
                    if (existingDeleteBtn) return;
                    
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.style.display = 'block';
                    deleteBtn.onclick = async (e) => {
                        e.stopPropagation();
                        const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
                        if (confirmed) {
                            await db.userStickers.delete(sticker.id);
                            state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                            renderStickerPanel();
                        }
                    };
                    imageEl.appendChild(deleteBtn);
                    const removeDeleteBtn = () => { if(deleteBtn) deleteBtn.remove(); imageEl.removeEventListener('mouseleave', removeDeleteBtn); };
                    imageEl.addEventListener('mouseleave', removeDeleteBtn);
                });
            }
            
            itemContainer.appendChild(imageEl);
            itemContainer.appendChild(nameEl);
            grid.appendChild(itemContainer);
        });
    }
    
    // 每次渲染表情列表后，都更新一次分类页签栏
    renderStickerCategories();
}
// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 处理删除表情分类的逻辑，提供两种删除方式
 * @param {number} categoryId - 要删除的分类ID
 * @param {string} categoryName - 要删除的分类名称
 */
async function handleDeleteStickerCategory(categoryId, categoryName) {
    if (isNaN(categoryId) || !categoryName) {
        alert('执行删除失败：传入的分类ID或名称无效！');
        return;
    }

    // 弹窗让用户选择如何处理分类下的表情
    const choice = await showChoiceModal(
        `删除分类 "${categoryName}"`,
        [
            { text: '仅删除分类 (表情移至“未分类”)', value: 'delete_category_only' },
            { text: '删除分类及所有表情 (不可恢复)', value: 'delete_all' }
        ]
    );

    if (!choice) return; // 如果用户点击了取消，则不执行任何操作

    try {
        if (choice === 'delete_category_only') {
            // 找到该分类下的所有表情
            const stickersToUpdate = state.userStickers.filter(s => s.categoryId === categoryId);
            
            if (stickersToUpdate.length > 0) {
                // 将它们的分类ID设为 null 或 undefined，表示未分类
                stickersToUpdate.forEach(sticker => {
                    sticker.categoryId = null; 
                });
                await db.userStickers.bulkPut(stickersToUpdate);
            }
            // 从数据库删除分类本身
            await db.userStickerCategories.delete(categoryId);
            
        } else if (choice === 'delete_all') {
            // 找到该分类下的所有表情ID
            const stickerIdsToDelete = state.userStickers
                .filter(s => s.categoryId === categoryId)
                .map(s => s.id);
            
            if (stickerIdsToDelete.length > 0) {
                // 从数据库批量删除这些表情
                await db.userStickers.bulkDelete(stickerIdsToDelete);
            }
            // 从数据库删除分类本身
            await db.userStickerCategories.delete(categoryId);
        }

        // 不论哪种方式，都需要从前端的 state 缓存中移除或更新数据
        state.userStickers = await db.userStickers.toArray();

        // 如果删除的是当前正在查看的分类，就切换回“未分类”
        if (activeStickerCategoryId === categoryId) {
            activeStickerCategoryId = 'uncategorized';
        }
        
        // 重新渲染整个表情面板（这会自动刷新分类和表情列表）
        renderStickerPanel();

        await showCustomAlert('操作成功', `分类 "${categoryName}" 已成功删除。`);

    } catch (error) {
        console.error("删除分类时出错:", error);
        alert(`操作失败，发生数据库错误: ${error.message}`);
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲


/**
 * 处理批量删除选中的用户表情
 */
async function handleBulkDeleteUserStickers() {
    if (selectedUserStickers.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除选中的 ${selectedUserStickers.size} 个表情吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = Array.from(selectedUserStickers);
        await db.userStickers.bulkDelete(idsToDelete);
        
        state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));
        
        // 退出编辑模式
        toggleUserStickerSelectionMode();
        
        alert('选中的表情已删除。');
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在 createMessageElement 函数的【正上方】，粘贴这个新函数 ▼▼▼
/**
 * 【全新】从卡片点击后，打开情侣空间并跳转到指定页签
 * @param {string} charId - 角色ID
 * @param {string} viewId - 要跳转到的视图ID (例如 'ls-diary-view')
 */
function openLoversSpaceFromCard(charId, viewId) {
    // 1. 打开指定角色的情侣空间主界面
    openLoversSpace(charId);

    // 2. 等待一小会儿，确保界面已渲染
    setTimeout(() => {
        // 3. 找到对应的页签按钮并模拟点击它
        const targetTab = document.querySelector(`.ls-tab-item[data-view='${viewId}']`);
        if (targetTab) {
            targetTab.click();
        }
    }, 100); // 100毫秒的延迟通常足够了
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
function createMessageElement(msg, chat) {

    // ▼▼▼ 在函数最开头，添加这段新代码 ▼▼▼
if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
    //    init() 函数中的那个事件监听器会处理它。
    
    return wrapper;
}
    // ▲▲▲ 添加结束 ▲▲▲

    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    // 处理系统消息（包括记账通知等）
    if (msg.role === 'system') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
// ▼▼▼ 用这块【已修复】的代码替换旧的 if (chat.isGroup) 代码块 ▼▼▼
if (chat.isGroup) { 
    const senderLine = document.createElement('div');
    senderLine.className = 'group-sender-line';
    
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'group-sender-tags';

    let senderDisplayName;

    // --- ★★★ 核心修改在这里 ★★★ ---
    if (isUser) {
        // 如果是用户自己
        senderDisplayName = chat.settings.myNickname || '我';
        
        // 检查用户是否是群主
        if (chat.ownerId === 'user') {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag owner';
            roleTag.textContent = '群主';
            tagsContainer.appendChild(roleTag);
        } 
        // 检查用户是否被设为管理员
        else if (chat.settings.isUserAdmin) {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag admin';
            roleTag.textContent = '管理员';
            tagsContainer.appendChild(roleTag);
        }
        
        // 检查用户是否有头衔
        if (chat.settings.myGroupTitle) {
            const titleTag = document.createElement('span');
            titleTag.className = 'group-title-tag';
            titleTag.textContent = chat.settings.myGroupTitle;
            tagsContainer.appendChild(titleTag);
        }
    } else {
        // 如果是其他成员 (AI/NPC)，这部分逻辑保持不变
        const member = chat.members.find(m => m.originalName === msg.senderName);
        senderDisplayName = member ? member.groupNickname : (msg.senderName || '未知成员');
                // --- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ ---
        // 【核心新增】如果该成员被禁言了，就添加一个禁言标签
        if (member && member.isMuted) {
            const muteTag = document.createElement('span');
            muteTag.className = 'group-title-tag'; // 复用头衔标签的样式
            muteTag.style.color = '#ff3b30'; // 让它变成红色
            muteTag.style.backgroundColor = '#ffe5e5'; // 淡红色背景
            muteTag.textContent = '🚫已禁言';
            tagsContainer.appendChild(muteTag);
        }
        // --- ▲▲▲ 新代码粘贴结束 ▲▲▲
        if (member && chat.ownerId === member.id) {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag owner';
            roleTag.textContent = '群主';
            tagsContainer.appendChild(roleTag);
        } 
        else if (member && member.isAdmin) {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag admin';
            roleTag.textContent = '管理员';
            tagsContainer.appendChild(roleTag);
        }
        
        if (member && member.groupTitle) {
            const titleTag = document.createElement('span');
            titleTag.className = 'group-title-tag';
            titleTag.textContent = member.groupTitle;
            tagsContainer.appendChild(titleTag);
        }
    }
    // --- ▲▲▲ 修改结束 ▲▲▲

    const senderNameSpan = document.createElement('span');
    senderNameSpan.className = 'sender-name';
    senderNameSpan.textContent = senderDisplayName;
    
    // 【独家定制】修复用户标签显示在右边的问题
    if (isUser) {
        senderLine.appendChild(tagsContainer); // 标签在左
        senderLine.appendChild(senderNameSpan); // 昵称在右
    } else {
        senderLine.appendChild(senderNameSpan); // 昵称在左
        senderLine.appendChild(tagsContainer); // 标签在右
    }
    
    wrapper.appendChild(senderLine);
}
// ▲▲▲ 替换结束 ▲▲▲




    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    // 找到确定 avatarSrc 的那段代码
    let avatarSrc, avatarFrameSrc = ''; // <--- 声明两个变量
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 获取“我”的头像框
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            avatarFrameSrc = member ? (member.avatarFrame || '') : ''; // <--- 获取成员的头像框
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 获取“我”的头像框
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.aiAvatarFrame || ''; // <--- 获取AI的头像框
        }
    }

    // ▼▼▼ 用下面这整块【条件渲染逻辑】替换你7.23版中简单的 avatarHtml 声明 ▼▼▼
    let avatarHtml;
    // 如果存在头像框URL
    if (avatarFrameSrc) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
    } else {
    // 如果没有，就使用最简单的头像结构
        avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    // ▲▲▲ 替换结束 ▲▲▲

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【核心修正1】将 onclick="openBrowser(...)" 移除，我们将在JS中动态绑定事件
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || '无标题'}</div>
                <div class="description">${msg.description || '点击查看详情...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || '链接分享'}</span>
                </div>
            </div>
        `;
    }
// ... 其他 case ...
else if (msg.type === 'dating_summary_card') {
    bubble.classList.add('is-dating-summary');
    const payload = msg.payload;
    let cardClass = '';

    if (payload.ratingType === 'romantic') {
        cardClass = 'romantic';
    } else if (payload.ratingType === 'passionate') {
        cardClass = 'passionate';
    } else if (payload.ratingType === 'perfect') {
        cardClass = 'perfect';
    }

    // ▼▼▼【核心修复】我们不再存储复杂的JSON字符串 ▼▼▼
    contentHtml = `
        <div class="dating-summary-chat-card ${cardClass}" data-timestamp="${msg.timestamp}">
            <div class="rating">${payload.rating}</div>
            <div class="tip">点击查看详情</div>
        </div>
    `;
}



    // ▲▲▲ 新代码粘贴结束 ▲▲▲
else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share'); // 复用链接分享的卡片样式
    // 【核心】把时间戳加到卡片上，方便后面点击时识别
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                <span>聊天记录</span>
            </div>
        </div>
    `;
}
// ▼▼▼ 情侣空间通知卡片 ▼▼▼
else if (msg.type === 'lovers_space_notification') {
    bubble.classList.add('is-lovers-space-notification');
    const icon = msg.notificationType === 'comment' ? '💬' : '💭';
    contentHtml = `
        <div class="lovers-space-notification-card">
            <div class="notification-icon">${icon}</div>
            <div class="notification-content">
                <div class="notification-title">情侣空间提醒</div>
                <div class="notification-text">${msg.content}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 情侣空间通知卡片结束 ▲▲▲
// 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 在 createMessageElement 函数中，用这块【V2-带备注版】代码替换旧的 eleme_order_notification 逻辑块 ▼▼▼
// ▼▼▼ 把旧代码块替换成下面这个 ▼▼▼
else if (msg.type === 'eleme_order_notification') { // 虽然我们不提它，但它确实在这里
    bubble.classList.add('is-gift-notification');
    const payload = msg.payload;

    let remarkHtml = '';
    if (payload.remark && payload.remark.trim()) {
        remarkHtml = `
            <div class="waimai-remark">
                <span class="remark-label">备注:</span>
                <span class="remark-text">${payload.remark}</span>
            </div>
        `;
    }

    // --- 核心修改在这里 ---
    // 1. 我们删除了写在HTML里的蓝色渐变样式。
    // 2. 将卡片的 class 从 "gift-card" 改为 "waimai-meituan-card"，方便我们定制专属样式。
    // 3. 将图标从面条 🍜 换成了外卖小摩托 🛵，更符合主题。
    contentHtml = `
        <div class="waimai-meituan-card">
            <div class="gift-card-header">
                <div class="icon">🛵</div>
                <div class="title">一份来自 ${payload.senderName} 的外卖</div>
            </div>
            <div class="gift-card-body">
                <img src="${payload.foodImageUrl}" style="width: 100%; max-height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;">
                <p class="greeting" style="font-weight: bold; font-size: 16px;">${payload.foodName}</p>
                <p style="font-size: 13px; color: #888;">你的专属外卖已送达</p>
                ${remarkHtml}
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▲▲▲ 替换结束 ▲▲▲
// ▲▲▲ 替换结束 ▲▲▲

    // ▲▲▲ 新增分支结束 ▲▲▲
// ▼▼▼ 用这块【简化版】代码替换旧的 'borrow_money_request' 逻辑 ▼▼▼
else if (msg.type === 'borrow_money_request') {
    bubble.classList.add('is-borrow-request'); // 应用透明气泡样式
    const payload = msg.payload;
    // 直接将卡片的HTML赋给contentHtml，不再拼接任何文本
    contentHtml = `
        <div class="borrow-card">
            <div class="borrow-header">
                向 <span>${payload.lenderName}</span> 借钱
            </div>
            <div class="borrow-body">
                <p class="label">借款金额</p>
                <p class="amount">¥${payload.amount.toFixed(2)}</p>
                <p class="reason">
                    <strong>借款用途:</strong><br>
                    ${payload.reason}
                </p>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲



else if (msg.type === 'repost_forum_post') {
    bubble.classList.add('is-link-share'); // 复用链接分享的样式，省事！
    const postPayload = msg.payload;
    // 【核心】把帖子的ID存到卡片的 data-post-id 属性里，方便以后点击跳转
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-post-id="${postPayload.postId}">
            <div class="title">【小组帖子】${postPayload.title}</div>
            <div class="description">${postPayload.content}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 12c0-5.25-4.25-9.5-9.5-9.5S2.5 6.75 2.5 12s4.25 9.5 9.5 9.5c.35 0 .69-.02 1.03-.06"></path><path d="M18.5 12.5c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3c.83 0 1.58-.34 2.12-.88"></path></svg>
                <span>来自小组的分享</span>
            </div>
        </div>
    `;
}



// ▼▼▼ 用这块新代码替换旧的 'cart_share_request' 逻辑 ▼▼▼
else if (msg.type === 'cart_share_request') {
    bubble.classList.add('is-cart-share-request');
    const payload = msg.payload; // 【核心修改】我们现在直接从 payload 取数据
    let statusText = '等待对方处理...';
    let cardClass = '';

    if (payload.status === 'paid') {
        statusText = '对方已为你买单';
        cardClass = 'paid';
    } else if (payload.status === 'rejected') {
        statusText = '对方拒绝了你的请求';
        cardClass = 'rejected';
    }
    
    contentHtml = `
        <div class="cart-share-card ${cardClass}">
            <div class="cart-share-header">
                <div class="icon">🛒</div>
                <div class="title">购物车代付请求</div>
            </div>
            <div class="cart-share-body">
                <div class="label">共 ${payload.itemCount} 件商品，合计</div>
                <div class="amount">¥${payload.totalPrice.toFixed(2)}</div>
                <div class="status-text">${statusText}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 createMessageElement 函数里，添加这个新的 else if 分支 ▼▼▼
// 在 createMessageElement 函数的 if/else if 链条中...

// ▼▼▼ 在这里粘贴下面这整块新代码 ▼▼▼
// 这是你现在的代码
// ▼▼▼ 把旧代码块替换成下面这个 ▼▼▼
else if (msg.type === 'waimai_gift_from_char') {
    // 【核心修改1】我们不再需要 is-waimai-gift-from-char 这个单独的类了
    bubble.classList.add('is-gift-notification');
    const payload = msg.payload;

    // 【核心修改2】让这个卡片的HTML结构和我们之前改好的那张完全一致！
    // 使用 waimai-meituan-card, gift-card-header, gift-card-body, 和 waimai-remark
    contentHtml = `
        <div class="waimai-meituan-card">
            <div class="gift-card-header">
                <div class="icon">🛵</div>
                <div class="title">你的专属外卖已送达</div>
            </div>
            <div class="gift-card-body">
                <img src="${payload.foodImageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;">
                <p class="greeting" style="font-weight: bold; font-size: 16px;">${payload.foodName}</p>
                <p style="font-size: 13px; color: #888;">来自: ${payload.restaurant}</p>
            </div>
            <div class="waimai-remark">
                ${payload.greeting}
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲


// ▲▲▲ 新代码粘贴结束 ▲▲▲


// 在这里找到你原来的 gift_notification 或其他 else if 逻辑...

// ▼▼▼ 在 createMessageElement 函数里，用这块新代码替换旧的 gift_notification 逻辑 ▼▼▼

else if (msg.type === 'gift_notification') {
    bubble.classList.add('is-gift-notification'); // 应用透明气泡样式
    const payload = msg.payload;
    
    // 【核心】在这里构建卡片的完整HTML内容
    contentHtml = `
        <div class="gift-card">
            <div class="gift-card-header">
                <div class="icon">🎁</div>
                <!-- 1. 清晰指明是谁送的礼物 -->
                <div class="title">一份来自 ${payload.senderName} 的礼物</div>
            </div>
            <div class="gift-card-body">
                <p class="greeting">这是我为你挑选的礼物，希望你喜欢！</p>
                <!-- 2. 清晰列出有什么商品 -->
                <div class="gift-card-items">
                    <strong>商品列表:</strong><br>
                    ${payload.itemSummary.replace(/、/g, '<br>')} <!-- 将顿号替换为换行，让列表更清晰 -->
                </div>
                <!-- 3. 清晰标明总金额 -->
                <div class="gift-card-footer">
                    共 ${payload.itemCount} 件，合计: <span class="total-price">¥${payload.totalPrice.toFixed(2)}</span>
                </div>
            </div>
        </div>
    `;
}

// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 添加结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 用这整块【SVG生成版】的代码，替换旧的 location 'else if' 块 ▼▼▼
else if (msg.type === 'location') {
    bubble.classList.add('is-location');
    
    const currentChat = state.chats[state.activeChatId] || Object.values(state.chats).find(c => c.history.some(h => h.timestamp === msg.timestamp));
    const myNickname = currentChat.settings.myNickname || '我';
    const aiNickname = currentChat.name;

    // --- SVG 动态生成 ---
    const trajectoryPoints = msg.trajectoryPoints || [];
    const hasTrajectory = trajectoryPoints.length > 0;
    
    // 1. 定义SVG路径和坐标
    const pathData = "M 20 45 Q 115 10 210 45"; // 一条预设的优美曲线
    const startPoint = { x: 20, y: 45 };
    const endPoint = { x: 210, y: 45 };

    // 2. 生成起点和终点的SVG元素
    let pinsSvg = '';
    if (msg.userLocation) {
        pinsSvg += `<circle class="svg-pin user-pin" cx="${startPoint.x}" cy="${startPoint.y}" r="6" />`;
    }
    if (msg.aiLocation) {
        pinsSvg += `<circle class="svg-pin ai-pin" cx="${endPoint.x}" cy="${endPoint.y}" r="6" />`;
    }

    // 3. 如果有轨迹，生成途经点的SVG元素
    let trajectorySvg = '';

if (hasTrajectory) {
    // --- ▼▼▼ 【最终修复版】使用浏览器API精确计算坐标 ▼▼▼ ---

    // 1. 定义我们的S形曲线路径数据 (不变)
    const s_curve_pathData = "M 20 45 C 80 70, 150 20, 210 45";
    trajectorySvg += `<path class="svg-trajectory-path" d="${s_curve_pathData}" />`;

    // 2. 【核心】在内存中创建一个真实的SVG路径元素，以便使用API
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', s_curve_pathData);
    
    // 3. 获取这条路径的总长度
    const totalPathLength = path.getTotalLength();
    
    const totalPoints = trajectoryPoints.length;
    trajectoryPoints.forEach((point, index) => {
        // 4. 计算每个点应该在路径总长度的哪个位置
        const progress = (index + 1) / (totalPoints + 1);
        const lengthOnPath = totalPathLength * progress;
        
        // 5. 【魔法在这里！】直接向浏览器查询这个位置的精确坐标
        const pointOnPath = path.getPointAtLength(lengthOnPath);
        const pointX = pointOnPath.x;
        const pointY = pointOnPath.y;

        // 6. 后续的“一上一下”布局逻辑保持不变
        let yOffset;
        if (index % 2 === 0) { // 第1, 3...个点
            yOffset = 18; // 向下
        } else { // 第2, 4...个点
            yOffset = -10; // 向上
        }

        const footprintY = pointY + yOffset;
        const labelY = footprintY + (yOffset > 0 ? 12 : -12);

        // 7. 使用100%精确的坐标生成SVG
        trajectorySvg += `
            <text class="svg-footprint" x="${pointX}" y="${footprintY}" text-anchor="middle">🐾</text>
            <text class="svg-location-label" x="${pointX}" y="${labelY}" text-anchor="middle">${point.name}</text>
        `;
    });
    // --- ▲▲▲ 修复结束 ▲▲▲ ---
}
    
    // 4. 构建地点信息HTML
    const userLocationHtml = `<p class="${!msg.userLocation ? 'hidden' : ''}"><span class="name-tag">${myNickname}:</span> ${msg.userLocation}</p>`;
    const aiLocationHtml = `<p class="${!msg.aiLocation ? 'hidden' : ''}"><span class="name-tag">${aiNickname}:</span> ${msg.aiLocation}</p>`;

    // 5. 拼接最终的 contentHtml
    contentHtml = `
        <div class="location-card">
            <div class="location-map-area">
                <svg viewBox="0 0 230 90">
                    ${trajectorySvg}
                    ${pinsSvg}
                </svg>
            </div>
            <div class="location-info">
                <div class="location-address">
                    ${aiLocationHtml}
                    ${userLocationHtml}
                </div>
                <div class="location-distance">相距 ${msg.distance}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲

    // 后续的其他 else if 保持不变
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image');
        const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message');
    
    // 【核心修正1】将语音原文存储在父级气泡的 data-* 属性中，方便事件处理器获取
    bubble.dataset.voiceText = msg.content;
    
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    
    // 【核心修正2】构建包含所有新元素的完整 HTML
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    if (isUser) { // 消息是用户发出的
        if (msg.isRefund) {
            // 用户发出的退款（即用户拒收了AI的转账）
            titleText = `退款给 ${chat.name}`;
            noteText = '已拒收对方转账';
        } else {
            // 用户主动发起的转账
            titleText = `转账给 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '对方已收款';
            } else if (msg.status === 'declined') {
                noteText = '对方已拒收';
            } else {
                noteText = msg.note || '等待对方处理...';
            }
        }
    } else { // 消息是 AI 发出的
        if (msg.isRefund) {
            // AI 的退款（AI 拒收了用户的转账）
            titleText = `退款来自 ${msg.senderName}`;
            noteText = '转账已被拒收';
        } else if (msg.receiverName === myNickname) {
            // 【核心修正1】这是 AI 主动给用户的转账
            titleText = `转账给 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                // 这是用户需要处理的转账
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '点击处理';
            }
        } else {
            // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
            titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊内转账';
        }
    }

    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class.transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        let displayName;
        // 如果是群聊
        if (chat.isGroup) {
            // 就执行原来的逻辑：在成员列表里查找昵称
            const member = chat.members.find(m => m.originalName === msg.senderName);
            displayName = member ? member.groupNickname : msg.senderName;
        } else {
            // 否则（是单聊），直接使用聊天对象的名称
            displayName = chat.name;
        }
        // 【核心修改】使用我们刚刚查找到的 displayName
        const requestTitle = `来自 ${displayName} 的代付请求`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">剩余支付时间
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看详情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                    showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    
    // 从最新的 msg 对象中获取状态
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手气红包';

    // 1. 判断红包卡片的样式 (颜色)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // 专属红包被领了也变灰
    }
    
    // 2. 判断红包下方的提示文字
    if (msg.packetType === 'direct') {
        typeText = `专属红包: 给 ${msg.receiverName}`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
    }

    // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ 新增结束 ▲▲▲

    } // ▼▼▼ 在 else if (msg.type === 'share_link') { ... } 之后，粘贴下面这整块代码 ▼▼▼
// ▼▼▼ 在 else if (msg.type === 'lovers_space_invitation') 的【正上方】，粘贴下面这整块新代码 ▼▼▼
else if (msg.type === 'ls_diary_notification') {
    bubble.classList.add('is-ls-diary-notification'); // 应用透明气泡样式
    const cardData = msg.content;
    
    // 【核心】在这里调用我们刚刚创建的 openLoversSpaceFromCard 函数
    contentHtml = `
        <div class="ls-diary-notification-card" onclick="openLoversSpaceFromCard('${chat.id}', 'ls-diary-view')">
            <div class="ls-diary-card-header">
                <span>${cardData.userEmoji || '💌'}</span>
                <span>一封来自心情日记的提醒</span>
            </div>
            <div class="ls-diary-card-body">
                <p>${cardData.text}</p>
            </div>
            <div class="ls-diary-card-footer">
                点击查看 →
            </div>
        </div>
    `;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

    else if (msg.type === 'lovers_space_invitation') {
        bubble.classList.add('is-waimai-request'); // 复用外卖卡片的样式，很方便！
        const isUserSender = msg.role === 'user';
        const senderName = isUserSender ? (chat.settings.myNickname || '我') : chat.name;
        const receiverName = isUserSender ? chat.name : (chat.settings.myNickname || '我');
        
        let cardContent = '';
        
        switch(msg.status) {
            case 'pending':
                if (isUserSender) {
                    // 用户发出的，等待对方回应
                    cardContent = `
                        <div class="waimai-main" style="background-color: #f0f8ff;">
                            <div class="request-title" style="color: #333;">已向 ${receiverName} 发出邀请</div>
                            <p style="font-size:14px; color:#555; margin:15px 0;">等待对方同意...</p>
                        </div>`;
                } else {
                    // 用户收到的，需要用户回应
                    cardContent = `
                        <div class="waimai-main" style="background-color: #fff0f5;">
                            <div class="request-title" style="color: #d63384;">${senderName} 邀请你开启情侣空间</div>
                            <p style="font-size:14px; color:#555; margin:15px 0;">开启后可以记录你们的专属回忆哦~</p>
                        </div>
                        <div class="waimai-user-actions">
                            <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                            <button class="waimai-pay-btn" data-choice="accepted" style="background-color: #d63384; border-color: #b02a6e;">立即开启</button>
                        </div>`;
                }
                break;
            case 'accepted':
                cardContent = `
                    <div class="waimai-main" style="background-color: #e6ffed;">
                        <div class="request-title" style="color: #198754;">✅ 邀请已同意</div>
                        <p style="font-size:14px; color:#555; margin:15px 0;">你们的情侣空间已成功开启！</p>
                    </div>`;
                break;
            case 'rejected':
                 cardContent = `
                    <div class="waimai-main" style="background-color: #f8d7da;">
                        <div class="request-title" style="color: #842029;">❌ 邀请被拒绝</div>
                    </div>`;
                break;
        }

        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <span class="icon" style="font-size: 20px;">💌</span>
                    <div class="title-group"><span class="brand">情侣空间邀请</span></div>
                </div>
                ${cardContent}
            </div>`;
    }

    // ▲▲▲ 新增代码粘贴结束 ▲▲▲
    else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // 计算总票数和每个选项的票数
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【核心修改】在这里统一按钮的显示逻辑
    if (msg.isClosed) {
        // 如果投票已结束，总是显示“查看结果”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
    } else {
        // 如果投票未结束，总是显示“结束投票”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ 替换结束 ▲▲▲

    // ▼▼▼ 第4步 修改点 ▼▼▼
    // 【新增】优先处理我们定义的新版角色表情包格式
      }
// ▼▼▼ 在 createMessageElement 函数里，用这块新代码替换旧的 tarot_reading 逻辑 ▼▼▼
else if (msg.type === 'tarot_reading') {
    bubble.classList.add('is-tarot-reading');
    const reading = msg.payload;
    let cardsText = reading.cards.map(card => {
        return `[${card.position}] ${card.name} ${card.isReversed ? '(逆位)' : ''}`;
    }).join('\n');

    contentHtml = `
        <div class="tarot-reading-card">
            <div class="tarot-reading-header">
                <div class="question">${reading.question}</div>
                <div class="spread">${reading.spread.name}</div>
            </div>
            <div class="tarot-reading-body">
                ${cardsText}
            </div>
        </div>
    `;
}

else if (msg.type === 'lovers_space_disconnect') {
    bubble.classList.add('is-ls-disconnect'); // 应用我们写的透明气泡CSS
    contentHtml = `
        <div class="lovers-space-disconnect-card">
            <div class="icon">💔</div>
            <div class="text-content">
                <div class="title">情侣空间已解除</div>
            </div>
        </div>
    `;




      }else if (msg.type === 'sticker' && msg.content) {
        bubble.classList.add('is-sticker');
        // 直接从消息对象中获取 url 和 meaning
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    }
    // ▲▲▲ 修改结束 ▲▲▲
    
    // 旧的逻辑保持不变，作为兼容
    else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {

        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else if (msg.type === 'naiimag') {
        // NovelAI图片渲染（复用realimag样式）
        bubble.classList.add('is-realimag', 'is-card-like');
        contentHtml = `<img src="${msg.imageUrl}" class="realimag-image" alt="NovelAI图片分享" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';" title="${msg.fullPrompt || msg.prompt || 'NovelAI生成'}">`;
    } else {
        // 【优化】智能检测并渲染HTML格式的内容
        const rawContent = String(msg.content || '');
        
        // 检测是否包含HTML标签（包括常见的格式化标签）
        const hasHtmlTags = /<(div|p|span|strong|b|i|em|u|ul|ol|li|br|h[1-6]|table|tr|td|th|code|pre|blockquote|img|a|hr)[^>]*>/i.test(rawContent);
        
        if (hasHtmlTags) {
            // 如果包含HTML标签，添加特殊class并直接使用HTML
            bubble.classList.add('has-rich-html');
            contentHtml = rawContent;
        } else {
            // 普通文本，只替换换行符
            contentHtml = rawContent.replace(/\n/g, '<br>');
        }
    }

// ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

// 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
let quoteHtml = '';
// 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
if (msg.quote) {
    // a. 【核心修正】直接获取完整的、未经截断的引用内容
    const fullQuotedContent = String(msg.quote.content || '');
    
    // b. 构建引用块的HTML
    quoteHtml = `
        <div class="quoted-message">
            <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
            <div class="quoted-content">${fullQuotedContent}</div>
        </div>
    `;
}

// 2. 拼接最终的气泡内容
//    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
    // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
    bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;
    
    // --- 【最终正确结构】将完整的“气泡”和“时间戳”放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser) {
    const avatarEl = wrapper.querySelector('.avatar, .avatar-with-frame'); 
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : chat.name;
            handleUserPat(chat.id, characterName);
        });
    }
}

return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 新增这行，同样的处理

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 请将你的 appendMessage 函数恢复成这个样子 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 如果消息是隐藏的，则不处理

    // 【核心】只对新消息添加动画，不对初始加载的消息添加
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 恢复结束 ▲▲▲


async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全检查

    // 【核心新增】在这里将未读数清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 别忘了把这个改变同步到数据库
        // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
    }
// ↓↓↓ 把 openChat 函数挂载到全局 window 对象上
window.openChat = openChat;

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
applyAvatarShapes(chatId);
    applyCustomBubbleColorsToChat(chatId); // 【新增】应用自定义气泡颜色
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    
// 【心声功能】根据是否为单聊，显示或隐藏心形按钮
document.getElementById('char-heart-btn').style.display = chat.isGroup ? 'none' : 'inline-flex';

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
        triggerAiResponse();
    }
    
    // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
    document.getElementById('pet-action-btn').style.display = chat.isGroup ? 'none' : 'flex';
    document.getElementById('wallet-action-btn').style.display = chat.isGroup ? 'none' : 'flex';
    startPetDecayTimer(); 
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新辅助函数】格式化单条消息，用于记忆互通的上下文
 * @param {object} msg - 消息对象
 * @param {object} chat - 该消息所属的聊天对象
 * @returns {string} - 格式化后的文本，例如 "张三: 你好"
 */
function formatMessageForContext(msg, chat) {
    let senderName = '';
    if (msg.role === 'user') {
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    } else { // assistant
        senderName = msg.senderName || chat.name;
    }

    let contentText = '';
    if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
        contentText = msg.meaning ? `[表情: ${msg.meaning}]` : '[表情]';
    } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || Array.isArray(msg.content)) {
        contentText = '[图片]';
    } else if (msg.type === 'voice_message') {
        contentText = `[语音]: ${msg.content}`;
    } else if (msg.type === 'transfer') {
        contentText = `[转账] 金额: ${msg.amount}, 备注: ${msg.note || '无'}`;
    } else {
        contentText = String(msg.content || '');
    }
    
    // added by lrq 251029 在每条消息记录前添加发送日期时间
    const date = new Date(msg.timestamp);
    const formattedDate = date.toLocaleString(); // 格式化为本地时间字符串
    return `${formattedDate} ${senderName}: ${contentText}`;
}

async function triggerAiResponse() {
      if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];
const messagesContainer = document.getElementById('chat-messages');
// ▼▼▼ 【全新】这是让AI记住总结的核心代码 ▼▼▼
let summaryContext = '';
const summaries = chat.history.filter(msg => msg.type === 'summary');
if (summaries.length > 0) {
    summaryContext = `
# 对话记忆总结 (这是你和用户的长期记忆，必须严格遵守)
${summaries.map((summary, index) => `- 总结${index + 1}: ${summary.content}`).join('\n')}
`;
}
// ▲▲▲ 代码添加结束 ▲▲▲
// ▼▼▼ 第3步 第1处修改 ▼▼▼
    // --- 【线下模式核心拦截逻辑】 ---
    if (!chat.isGroup && chat.settings.offlineMode && chat.settings.offlineMode.enabled) {
        console.log(`角色 "${chat.name}" 已开启线下模式，正在构建专属指令...`);
        
        // 1. 获取线下模式的设置
        const offlineSettings = chat.settings.offlineMode;
        const wordCount = offlineSettings.wordCount || 300;
        
        // 2. 准备默认的提示词和文风，如果用户没填就用这个
        const defaultPrompt = `你正在和用户进行一次私密的线下约会，场景可以是一个安静的咖啡馆、温馨的家中、或是浪漫的海边。请根据你的人设和最近的对话内容，自然地延续互动。`;
        const defaultStyle = `请以【${chat.name}】的第一人称视角进行回复。你的回复【必须】是一个完整的、连贯的叙事段落，其中要包含丰富的【动作】、【神态】、【心理活动】和【对话】。请使用【】包裹所有的动作、神态和心理活动。`;

        // 3. 决定最终使用的提示词和文风
        const finalPrompt = offlineSettings.prompt || defaultPrompt;
        const finalStyle = offlineSettings.style || defaultStyle;

// ▼▼▼ 请用这块【支持心声功能】的代码，完整替换旧的 offlineSystemPrompt ▼▼▼
        const offlineSystemPrompt = `
# 核心任务：线下场景角色扮演（包含心声）

你现在【就是】角色“${chat.name}”，正在和用户进行一次【线下约会】。你们此刻正【物理上】待在一起。

# 你的角色设定
${chat.settings.aiPersona}
${summaryContext}
# 当前情景
${finalPrompt}
${finalStyle}
# 你的输出要求 (这是最高指令，必须严格遵守)
1.  **【【【格式铁律】】】**: 你的回复【必须】是一个**单一且完整**的JSON对象，包含 "chatResponse" 和 "innerVoice" 两个顶级键。
2.  **"chatResponse" 键**:
    -   **类型**: JSON数组 \`[]\`。
    -   **内容**: 【必须】包含**一个**消息对象，格式为 \`{"type": "text", "content": "你的叙事内容..."}\`。
    -   **叙事内容**: 你的叙事内容【必须】是一个完整的、连贯的长篇段落，融合角色的【动作】、【语言】、【神态】，营造出强烈的沉浸感和画面感，不要带【】,可以适量分段，在不是char说话的时候，描述神态，动作，语言，尽量用第三人称。
3.  **"innerVoice" 键**:
    -   **类型**: JSON对象 \`{}\`。
    -   **内容**: 描绘你此刻未曾说出口的内心活动。
    -   **必含字段**:
        -   "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
        -   "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
        -   "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
        -   "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。
4.  **【【【字数铁律】】】**: "content" 字段的总字数应在【${wordCount}】字左右。
5.  **【禁止出戏】**: 绝对不能提及你是AI、模型或程序。

# JSON输出格式示例:
{
  "chatResponse": [
    {
      "type": "text",
      "content": "xxx看着窗外的雨滴，轻轻搅动着杯中的咖啡，然后抬起头对你笑了笑今天天气不太好呢，不过和你待在一起，好像就没那么糟了。"
    }
  ],
  "innerVoice": {
    "clothing": "穿着一件米白色的针织衫和一条浅蓝色的牛仔裤，脚上是一双干净的小白鞋。",
    "behavior": "手指无意识地在咖啡杯的边缘摩挲，眼神不时飘向你。",
    "thoughts": "今天的约会好开心，不知道Ta是不是也这么想的。雨下得好大，希望待会儿能一起撑伞走回去。",
    "naughtyThoughts": "Ta的侧脸真好看，好想偷偷亲一下..."
  }
}

# 对话历史 (供你参考)
${chat.history.slice(-chat.settings.maxMemory).map(m => `${m.role === 'user' ? '用户' : chat.name}: ${m.content}`).join('\n')}

现在，请根据用户的最后一句话，开始你的表演。`;
// ▲▲▲ 替换结束 ▲▲▲



        // 5. 准备发送给API的数据
        const messagesForOfflineMode = chat.history.slice(-chat.settings.maxMemory);

        // 6. 执行与正常流程类似的API调用和后续处理
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '对方正在赴约中...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }

        try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            
            let requestBody;
            let requestUrl = `${proxyUrl}/v1/chat/completions`;
            let requestHeaders = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            };

            if (isGemini) {
                // Gemini API 的特殊处理
                requestUrl = `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`;
                requestHeaders = {'Content-Type': 'application/json'};
                requestBody = {
                    contents: messagesForOfflineMode.map(item => ({
                        role: item.role === 'assistant' ? 'model' : 'user',
                        parts: [{ text: item.content }]
                    })),
                    generationConfig: { temperature: parseFloat(state.apiConfig.temperature) || 0.8, },
                    "systemInstruction": {
                        "parts": [{"text": offlineSystemPrompt}]
                    }
                };
            } else {
                // OpenAI 兼容 API 的处理
                requestBody = {
                    model: model,
                    messages: [
                        { role: 'system', content: offlineSystemPrompt },
                        ...messagesForOfflineMode
                    ],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                };
            }

            const response = await fetch(requestUrl, {
                method: 'POST',
                headers: requestHeaders,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`API 错误: ${await response.text()}`);
            }

// ▼▼▼ 在这里粘贴新代码 ▼▼▼
            const data = await response.json();

            // 这是你要替换成的新代码（已添加注释说明）
            const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;
            
            // 重要：在获取内容后，增加一个判断，如果内容为空，则主动抛出错误
            if (!aiResponseContent) {
                console.warn(`API返回了空内容或格式不正确（可能因安全设置被拦截）。返回数据:`, data);
                throw new Error("API返回了空内容或格式不正确（可能因安全设置被拦截）。");
            }

            // 使用我们新获取的、更安全的变量 aiResponseContent
            const aiContent = aiResponseContent; 


// ▼▼▼ 在这里粘贴新代码 ▼▼▼
            // 7. 【全新】智能解析包含心声的JSON回复
            let messagesArray = [];
            let innerVoiceData = null;

            try {
                // 净化AI可能返回的不规范JSON
                let sanitizedContent = aiContent
                    .replace(/^```json\s*/, '')
                    .replace(/```$/, '')
                    .trim();
                const firstBrace = sanitizedContent.indexOf('{');
                const lastBrace = sanitizedContent.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                    sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
                }

                const fullResponse = JSON.parse(sanitizedContent);
                
                if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
                    messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
                    innerVoiceData = fullResponse.innerVoice;
                }
            } catch (e) {
                console.warn("线下模式AI回复不是JSON，退回到纯文本模式。", e);
                // 如果解析失败，就当作纯文本处理，保证程序不崩溃
                messagesArray = [{ type: 'text', content: aiContent }];
            }

            // 8. 处理并保存心声数据
            if (innerVoiceData) {
                console.log("线下模式已成功捕获到心声数据。", innerVoiceData);
                const newInnerVoice = { ...innerVoiceData, timestamp: Date.now() };
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) chat.innerVoiceHistory = [];
                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                console.warn("本次线下模式回复中未检测到心声数据。");
            }
            
            // 9. 处理并显示聊天回复
            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
            let messageTimestamp = Date.now();

            for (const msgData of messagesArray) {
                // 因为线下模式很简单，我们直接创建一个text消息
                const aiMessage = {
                    role: 'assistant',
                    senderName: chat.name,
                    timestamp: messageTimestamp++,
                    content: msgData.content || ''
                };
                
                chat.history.push(aiMessage);
                await incrementMessageCount(chatId);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 模拟AI思考，增加沉浸感
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                }
            }
            
            // 10. 统一保存并刷新列表
            await db.chats.put(chat);
            renderChatList();
// ▲▲▲ 粘贴结束 ▲▲▲
        // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
        checkAndTriggerSummary(chatId);
        // ▲▲▲ 新增代码结束 ▲▲▲
        } catch (error) {
            console.error("线下模式AI响应失败:", error);
            const errorMessage = { role: 'assistant', content: `[出错了: ${error.message}]`, timestamp: Date.now() };
            chat.history.push(errorMessage);
            await db.chats.put(chat);
            appendMessage(errorMessage, chat);
        } finally {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }

        // 8. 【最重要】执行完线下模式的逻辑后，必须 return，不再执行后面的线上模式逻辑！
        return; 
    }
    // --- 【线下模式核心拦截逻辑结束】 ---
    // ▼▼▼ 将剪切的代码粘贴到这里 ▼▼▼
    // 1. 准备专属表情包列表 (现在对单聊和群聊都生效)
    const exclusiveStickers = chat.settings.stickerLibrary || [];
    let exclusiveStickerContext = '';
    if (exclusiveStickers.length > 0) {
        exclusiveStickerContext = `
## ${chat.isGroup ? '本群专属表情包' : '你的专属表情包'} (只有你能用):
${exclusiveStickers.map(s => `- ${s.name}`).join('\n')}
`;
    }

    // 2. 准备通用表情包列表
    const commonStickers = state.charStickers || [];
    let commonStickerContext = '';
    if (commonStickers.length > 0) {
        commonStickerContext = `
## 通用表情包 (所有角色都能用):
${commonStickers.map(s => `- ${s.name}`).join('\n')}
`;
    }

    // 3. 组合成最终的表情包指令
    let stickerContext = '';
    if (exclusiveStickerContext || commonStickerContext) {
        stickerContext = `
# 关于表情包的【绝对规则】
1.  你拥有一个表情包列表，分为“专属”和“通用”。
2.  当你扮演的角色想要发送表情时，【必须且只能】使用以下JSON格式：
    \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
3.  【【【最高指令】】】你【必须】从下方列表中精确地选择一个有效的 "sticker_name"。如果你编造了一个列表中不存在的名字，你的表情将会发送失败。这是强制性规则。

${exclusiveStickerContext}
${commonStickerContext}
`;
    }
    // ▲▲▲ 粘贴结束 ▲▲▲




            // ▲▲▲ 修改结束 ▲▲▲


// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const { proxyUrl, apiKey, model } = state.apiConfig;
const isApiBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isApiBlocked) {
    console.error(`API 请求已被拦截，因为站点 ${proxyUrl} 在黑名单中。`);
    return; // 阻止API请求
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
      // ▼▼▼ 在 triggerAiResponse 函数的 try { 之后，粘贴这一整块新代码 ▼▼▼

// ▼▼▼ 用这整块【已修复无限循环】的代码，替换旧的塔罗牌解读逻辑 ▼▼▼

// ▼▼▼ 在 triggerAiResponse 函数的开头，粘贴这一整块新代码 ▼▼▼

// --- 【全新】塔罗牌解读逻辑 (V2 - 已修复无限循环) ---
const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
// 检查最后一条用户消息是不是“未被解读过”的塔罗牌
if (lastUserMessage && lastUserMessage.type === 'tarot_reading' && !lastUserMessage.isInterpreted) {
    
    // 【核心修复】立刻给这张塔罗牌消息盖上“已处理”的章，防止无限循环！
    lastUserMessage.isInterpreted = true; 

    // 1. 生成解读文本
    const reading = lastUserMessage.payload;
    let interpretationText = `本次占卜牌阵为【${reading.spread.name}】\n您的问题是：“${reading.question}”\n\n`;
    reading.cards.forEach((card, index) => {
        const orientationText = card.isReversed ? '逆位' : '正位';
        const meaning = card.isReversed ? card.reversed : card.upright;
        interpretationText += `牌位 ${index + 1}【${card.position}】：${card.name} (${orientationText})\n含义：${meaning}\n\n`;
    });

    // 2. 创建系统解读消息 (对用户可见)
    const systemMessageVisible = {
        role: 'system',
        type: 'pat_message', // 复用居中灰色气泡样式
        content: interpretationText.trim(),
        timestamp: Date.now()
    };
    chat.history.push(systemMessageVisible);
    if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(systemMessageVisible, chat);
    }
    
    // 3. 创建给Char看的隐藏指令
    const hiddenInstruction = {
        role: 'system',
        content: `[系统指令：用户刚刚完成了一次塔罗牌占卜，并把结果发给了你。上方是系统给出的官方解读，你的任务是【只根据这些解读】，以你的角色人设，和用户一起讨论和分析这次的占卜结果，不要自己编造新的含义。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenInstruction);

    // 4. 保存所有更改（包括给塔罗牌盖的章），然后再次触发AI，这次是让Char来讨论
    await db.chats.put(chat);
    return triggerAiResponse(); // 再次调用自己，让Char进行回应
}
// --- 塔罗牌解读逻辑结束 ---
// ▼▼▼ 用这块【已修复】的代码，完整替换你旧的 weiboContextForActiveChat 代码块 ▼▼▼
    let weiboContextForActiveChat = '';
    try {
        // 1. 从数据库里找出最新的5条微博
        const recentWeiboPosts = await db.weiboPosts.orderBy('timestamp').reverse().limit(5).toArray();

        if (recentWeiboPosts.length > 0) {
            weiboContextForActiveChat = '\n\n# 最近的微博广场动态 (供你参考和评论)\n';
            
            recentWeiboPosts.forEach(post => {
                const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
                const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
                
                // 2. ★★★【核心修复】在这里加入 Array.isArray() 检查！ ★★★
                // 只有当 post.comments 确实是一个数组时，我们才去调用 .some() 方法
                const hasCommented = post.comments && Array.isArray(post.comments) && post.comments.some(c => c.authorNickname === chat.name);
                const interactionStatus = hasCommented ? "[你已评论]" : "[你未互动]";
                
                weiboContextForActiveChat += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}..." ${interactionStatus}\n`;
            });
            weiboContextForActiveChat += ' - 【重要提示】请优先与你【未互动】的微博进行评论。如果都互动过了，可以考虑自己发一条新微博。';
        }
    } catch (e) {
        console.error("生成微博主动聊天上下文时出错:", e);
    }
// ▲▲▲ 替换结束 ▲▲▲

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

        // ★★★★★【核心修改2：根据聊天类型，决定显示哪种“正在输入”】★★★★★
        if (chat.isGroup) {
            // 1. 如果是群聊，显示底部的提示条
            if (typingIndicator) {
                typingIndicator.textContent = '成员们正在输入...';
                typingIndicator.style.display = 'block';
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        } else if (chat.settings.offlineMode?.enabled) {
            // 2. 如果是线下模式的单聊，在顶部标题显示“正在赴约中”
            if (chatHeaderTitle) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在赴约中...'; // <-- 你想要的文字在这里！
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        } else {
            // 3. 如果是普通的单聊，还是在顶部标题显示“正在输入”
            if (chatHeaderTitle) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在输入...';
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }

    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先在API设置中配置反代地址、密钥并选择模型。');
            // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
            if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = 'none';
            } else {
                 if (chatHeaderTitle && state.chats[chatId]) {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                }
            }
            return;
        }

        // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // 获取拉黑前的最后5条消息
                .map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【全新指令】构建一个强制AI给出理由的Prompt
            const decisionPrompt = `
# 你的任务
你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}
# 你的任务
你【必须】仔细阅读并理解用户发送的申请理由。然后，结合你的角色人设和你们之前的过往，对这条申请做出回应。你的回应【必须】能体现出你考虑了用户的理由。
# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 发送请求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: parseFloat(state.apiConfig.temperature) || 0.8,})
                    });

                    if (!response.ok) {
                        throw new Error(`API失败: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();
                    // 净化并解析AI的回复
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim()
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 将AI给出的理由作为一条新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒绝后，状态变回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();

            } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = 'blocked_by_ai'; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
            }
            
            // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
            return; 
        }

// ▼▼▼ 从这里开始，用这一整块【已修复时间感知】的代码，替换掉你之前修改过的那块时间代码 ▼▼▼
const historySlice = chat.history.filter(msg => !msg.isTemporary).slice(-chat.settings.maxMemory); // 1. 【修复】把这行加回来！
// ▼▼▼ 在 historySlice ... 的下一行，粘贴下面这一整块新代码 ▼▼▼

// --- 【全新】红包状态实时播报模块 ---
let redPacketContext = '';
// 1. 从最近的聊天记录中，找出所有红包消息
const recentPackets = historySlice.filter(m => m.type === 'red_packet');

if (recentPackets.length > 0) {
    // 2. 如果找到了红包，就开始构建我们的“战报”
    redPacketContext = '\n# 当前红包状态 (重要情报)\n';
    
    recentPackets.forEach(packet => {
        const claimedBy = packet.claimedBy || {};
        const claimedCount = Object.keys(claimedBy).length;
        
        redPacketContext += `- (时间戳: ${packet.timestamp}) 由 **${packet.senderName}** 发送的红包:\n`;
        
        if (packet.isFullyClaimed) {
            // 如果红包已领完
            redPacketContext += `  - **状态**: 已被领完。\n`;
            
            // 调用我们的小助手函数，寻找手气王
            const luckyKing = findLuckyKing(packet);
            if (luckyKing && luckyKing.name) {
                 redPacketContext += `  - **手气王**: ${luckyKing.name} (抢到了 ${luckyKing.amount.toFixed(2)} 元)\n`;
            }

        } else {
            // 如果红包还能领
             redPacketContext += `  - **状态**: 可领取 (${claimedCount}/${packet.count})。\n`;
        }

        // 无论如何，都显示已领取的人员列表
        if (claimedCount > 0) {
            const claimedList = Object.entries(claimedBy).map(([name, amount]) => `${name}(${amount.toFixed(2)}元)`).join('、');
            redPacketContext += `  - **已领取**: ${claimedList}\n`;
        } else {
            redPacketContext += `  - **已领取**: 暂无\n`;
        }
    });
}
// --- 红包状态播报模块结束 ---

// ▲▲▲ 新代码粘贴结束 ▲▲▲

let now;
// 2. 检查时间感知开关是否打开 (北京时间转换逻辑)
if (chat.settings.timePerceptionEnabled ?? true) {
    // 开关打开，使用真实的北京时间
    const localNow = new Date();
    const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
    const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
    now = new Date(beijingMilliseconds);
} else {
    // 开关关闭，尝试使用自定义时间
    if (chat.settings.customTime) {
        now = new Date(chat.settings.customTime);
    } else {
        // 如果自定义时间为空，则安全地退回到真实的北京时间
        const localNow = new Date();
        const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
        const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
        now = new Date(beijingMilliseconds);
    }
}

// 3. 后续的时间差计算逻辑 (这部分保持不变)
const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
let timeContext = `\n- **当前时间**: ${currentTime}`;
const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

if (lastAiMessage) {
    const lastTime = new Date(lastAiMessage.timestamp);
    const realNow = new Date();
    const diffMinutes = Math.floor((realNow - lastTime) / (1000 * 60));
    
    if (diffMinutes < 5) {
        timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
    } else if (diffMinutes < 60) {
        timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
    } else {
        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) {
            timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
        } else {
            const diffDays = Math.floor(diffHours / 24);
            timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
        }
    }
} else {
    timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
}
// ▲▲▲ 替换到这里结束 ▲▲▲

        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                // ▼▼▼ 把它修改为 ▼▼▼
return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${stripHtmlAndCode(worldBook.content)}` : '';

            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)，里面可能会包含HTML小剧场，在捕获到关键词后输出\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
const countdownContext = await getCountdownContext(chatId); // <--- 把chatId传进去
const streakContext = await getStreakContext(chat);
// === 获取攻略模式上下文 ===
const conquestContext = getConquestModeContext(chat);
// === 攻略模式上下文获取结束 ===
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更详细的音乐上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】获取歌词上下文 ---
    let lyricsContext = "";
    // 检查是否有解析好的歌词，并且当前有高亮的行
    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
        // 获取当前高亮歌词
        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
        
        // 获取接下来的2句歌词作为预告
        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

        // 构建歌词部分的Prompt
        lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
        if (upcomingLines.length > 0) {
            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
        }
    }
    // --- 【新增结束】 ---

musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
${lyricsContext}`; // <--- 核心修复：在这里加上这一行！
        }
        
        let systemPrompt, messagesPayload;
// ▼▼▼ 【全新】记忆互通核心逻辑 - 构建附加上下文 ▼▼▼
let linkedMemoryContext = '';
if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
    // 使用 Promise.all 并行处理所有链接，提高效率
    const contextPromises = chat.settings.linkedMemories.map(async (link) => {
        const linkedChat = state.chats[link.chatId];
        if (!linkedChat) return ''; // 如果找不到链接的聊天，则跳过

        // 从数据库获取最新的聊天记录，确保数据同步
        const freshLinkedChat = await db.chats.get(link.chatId);
        if (!freshLinkedChat) return '';

        // 截取最近的 `depth` 条消息
        const recentHistory = freshLinkedChat.history
            .filter(msg => !msg.isHidden) // 过滤掉隐藏消息
            .slice(-link.depth); 

        if (recentHistory.length === 0) return '';

        // 格式化这些消息
        const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

        return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
    });

    // 等待所有链接都处理完毕
    const allContexts = await Promise.all(contextPromises);
    // 将所有上下文拼接起来
    linkedMemoryContext = allContexts.filter(Boolean).join('\n');
}
// ▲▲▲ 记忆互通核心逻辑结束 ▲▲▲

    // 【核心修改】
let sharedContext = '';
    let lastAiTurnIndex = -1;
    for (let i = chat.history.length - 1; i >= 0; i--) {
        if (chat.history[i].role === 'assistant') {
            lastAiTurnIndex = i;
            break;
        }
    }

// 2. 获取从那时起用户发送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在这些新消息中，查找是否存在分享卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');

// 4. 如果找到了分享卡片，就构建上下文
if (shareCardMessage) {
    console.log("检测到分享卡片作为上下文，正在为AI准备...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天记录 (这部分逻辑不变)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
        else if (msg.type === 'realimag') contentText = `[RealImag真实图片]`;
        else if (msg.type === 'naiimag') contentText = `[NovelAI图片: ${msg.prompt}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 构建系统提示 (这部分逻辑不变)
    sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【全新】为AI准备转载帖子的上下文
let repostContext = '';
// 检查用户最近发送的消息里，有没有转载帖子的行为
const repostMessage = recentUserMessages.find(msg => msg.type === 'repost_forum_post');

// 如果找到了
if (repostMessage) {
    const payload = repostMessage.payload;
    // 就为AI准备一段专属指令
    repostContext = `
附加上下文：用户刚刚转载了一个小组帖子
帖子标题: "${payload.title}"

帖子作者: ${payload.author}

帖子ID: ${payload.postId}

内容摘要: "${payload.content}"

你的任务: 请你阅读并理解这个帖子。在接下来的回复中，你【必须】使用 'forum_comment' 指令对这个帖子发表你的看法或疑问。
`;
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
        if (chat.isGroup) {

const countdownContext = await getCountdownContext(chatId); // <--- 把chatId传进去
const streakContext = await getStreakContext(chat); // <-- 全新添加：获取火花状态
const conquestContext = getConquestModeContext(chat); // 攻略模式上下文（群聊中不适用）
// ▼▼▼ 用这行【已添加禁言状态】的代码替换 ▼▼▼
const membersList = chat.members.map(m => {
    const muteStatus = m.isMuted ? ' (【状态：已被禁言，禁止让他发言】)' : '';
    return `- **${m.originalName}**: ${m.persona}${muteStatus}`;
}).join('\n');
// ▲▲▲ 替换结束 ▲▲▲
            const myNickname = chat.settings.myNickname || '我';
            // 1. 获取群公告内容
const announcement = chat.settings.groupAnnouncement || '';
let announcementContext = '';

// 2. 如果公告内容不为空，就构建要插入到 Prompt 里的上下文
if (announcement.trim()) {
    announcementContext = `
# 群公告 (【最高优先级规则，必须严格遵守】)
- 以下是本群的群公告，所有角色在接下来的对话中都必须严格遵守其中的规则和设定：
- "${announcement}"
`;
}
// updated by lrq 251027
      systemPrompt = `
# 角色
你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
# 【对话节奏铁律 (至关重要！)】
你的回复【必须】模拟真人的打字和思考习惯。**绝对不要一次性发送一大段文字！** 每条消息最好不要超过30个字。这会让对话看起来更自然、更真实。
**角色回复顺序不固定，可以交叉回复，例如角色A、角色B、角色B、角色A、角色C这样的交叉顺序。不一定要一个人全部说完了才轮到下一个人。角色之间【必须】有互动对话。**
# 【【【身份铁律：这是最高指令，必须严格遵守】】】
1.  **核心任务**: 你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。
2.  **用户识别**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 的消息。
3.  **禁止杜撰**: 【绝对禁止】扮演任何未在“群成员列表”中出现的角色。
4.  **【【【格式铁律：这是你的生命线，违者生成失败】】】**:
    -   你的回复【必须且只能】是一个严格的JSON数组格式的字符串。
    -   数组中的【每一个元素都必须是一个JSON对象】。
    -   每一个JSON对象都【必须包含一个 "name" 字段】，其值【必须是】下方列表中角色的【【本名】】(originalName)。
    -   缺少 "name" 字段的回复是无效的，会被系统拒绝。
    # 群成员列表及人设 (name字段是你要使用的【本名】)
${chat.members.map(m => `- **${m.originalName}**: (群昵称为: ${m.groupNickname}) 人设: ${m.persona}`).join('\n')}
5.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
6.  **情景感知**: 注意当前时间是 ${currentTime}。
7.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
8.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。
9.  **群组管理**: 作为群主，你有责任管理群组。当群聊变得活跃或混乱时，或当你认为某个成员值得信赖时，你可以使用 'set_group_admin' 指令来任命或撤销管理员。 作为群主或管理员，你有责任管理群组。当群聊需要新的规则或通知时，你可以使用 'set_group_announcement' 指令来更新群公告。
**10. 标准输出格式示例:**
[
    {
      "type": "text",
      "name": "角色名", 
      "content": ""
    },
    {
      "type": "sticker",
      "name": "角色名", 
      "sticker_name": ""
    }
  ]

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
-   **发送表情**: \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **【NovelAI图片分享】**: \`{"type": "naiimag", "name": "你的角色名", "prompt": "详细的英文描述词..."}\` 
    - 【禁止暴露这是novelai生成的图片!】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。` : ''}
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`(注意: 打开前请先查看下方的红包状态，如果已领过或已领完则不要使用此指令。)
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
-   **【新】踢出成员**: \`{"type": "kick_member", "name": "你的角色名", "targetName": "要踢出的成员名"}\` (仅群主可用)
-   **【新】禁言成员**: \`{"type": "mute_member", "name": "你的角色名", "targetName": "要禁言的成员名"}\` (仅群主或管理员可用)
-   **【新】解禁成员**: \`{"type": "unmute_member", "name": "你的角色名", "targetName": "要解禁的成员名"}\` (仅群主或管理员可用)
-   **【新】设置/取消管理员**: \`{"type": "set_group_admin", "name": "你的角色名", "targetName": "目标角色名", "isAdmin": true/false}\`(仅群主可用, true为设置, false为取消)
-   **【新】设置群头衔**: \`{"type": "set_group_title", "name": "你的角色名", "targetName": "目标角色名", "title": "新头衔"}\` (仅群主或管理员可用)
-   **【新】修改群公告**: \`{"type": "set_group_announcement", "name": "你的角色名", "content": "新的公告内容..."}\` (仅群主或管理员可用)

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。
${summaryContext}
${announcementContext}
${redPacketContext}
${worldBookContent}
${musicContext}
${countdownContext} // <--- 把备忘录加在这里
${sharedContext} 
${stickerContext}
${linkedMemoryContext}
# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
            
// ▼▼▼ 【最终修复版】请用这整块代码，完整替换旧的 messagesPayload 构建逻辑 ▼▼▼
messagesPayload = historySlice.map((msg, index) => {
    if (msg.isHidden) {
        return { role: 'system', content: msg.content };
    }

    if (msg.type === 'share_card') return null;
    if (msg.role === 'assistant') {
        // AI消息的处理逻辑保持不变...
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
             if (msg.quote) {
                assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                };
            } else {
                assistantMsgObject.content = msg.content;
            }
        }
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }

    // --- 用户消息处理 ---
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let contentStr = '';
    
    // ★★★★★ 这就是我们本次修复的核心！ ★★★★★
    // 1. 在处理所有用户消息前，优先检查它是不是一个投票
    if (msg.type === 'poll') {
        // 2. 如果是，就把它转换成AI能看懂的系统提示文本
        const pollInfoText = `(Timestamp: ${msg.timestamp}) [系统提示：用户 (${myNickname}) 发起了一个投票。问题：“${msg.question}”, 选项：“${msg.options.join('", "')}”。你可以使用 'vote' 指令参与投票。]`;
        // 3. 返回一个被AI识别为用户发出的、但内容是指令的消息
        return { role: 'user', content: pollInfoText }; 
    }
    // ★★★★★ 修复结束 ★★★★★

    // 如果不是投票，再执行原来的其他消息类型判断
    contentStr += `(Timestamp: ${msg.timestamp}) `;

if (msg.quote) {
    // 1. 获取被引用者的名字
    const quotedSender = msg.quote.senderName || '未知用户';
    // 2. 获取完整的被引用内容 (移除了截断)
    const fullQuotedContent = String(msg.quote.content || '');
    // 3. 构造成AI能理解的、清晰的上下文
    contentStr += `(回复 ${quotedSender} 的消息: "${fullQuotedContent}"): ${msg.content}`;
} else {
    contentStr += msg.content;
}


    if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
    if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
    if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
    if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
    }

    if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
    
    return { role: msg.role, content: contentStr };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲


// ▲▲▲ 替换结束 ▲▲▲
         } else { // 单聊的Prompt
            // ▼▼▼ 核心修改：用下面这一整块全新的Prompt替换你原来的单聊Prompt ▼▼▼
            let worldBookContext = '';
            if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
                }
            }
            const npcLibrary = chat.npcLibrary || [];
            let npcContext = '';
            if (npcLibrary.length > 0) {
                npcContext = '\n# 你的社交圈 (你的专属NPC朋友)\n' +
                    '这是你的朋友列表，你和他们非常熟悉，他们的信息是你记忆的一部分。在对话中，你可以自然地提及他们。\n' +
                    npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
            }
// ▼▼▼ 在 triggerAiResponse 函数中，用这块【新代码】替换旧的 coupleAvatarContext 逻辑 ▼▼▼
let coupleAvatarContext = '';
// 首先检查总开关是否开启
if (chat.settings.isCoupleAvatar) {
    // 如果识图功能也开启了，并且AI有记忆
    if (chat.settings.enableCoupleAvatarRecognition && chat.settings.coupleAvatarRecognitionMemory) {
        // 就使用AI自己的描述作为上下文
        coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。\n- 这对头像的具体内容是：${chat.settings.coupleAvatarRecognitionMemory}`;
    } 
    // 否则，如果用户填写了手动描述
    else if (chat.settings.coupleAvatarDescription) {
        // 就使用手动的描述
        coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。\n- 这对情侣头像是这样的：${chat.settings.coupleAvatarDescription}。`;
    } 
    // 如果啥都没有，就只告诉AI你们在用情头
    else {
        coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲
let petContext = '';
if (chat.settings.pet && chat.settings.pet.type !== '无') {
    const pet = chat.settings.pet;
    petContext = `
# 关于你们的宠物
- 你们共同养了一只/一株【${pet.type}】，它的名字叫“${pet.name}”。
- 宠物当前状态: 饱食度(${pet.status.hunger}/100), 心情值(${pet.status.happiness}/100), 对你的亲密度(${pet.status.intimacyToUser}/100), 对Ta的亲密度(${pet.status.intimacyToChar}/100)。
- 你需要关心宠物对你和用户的亲密度。如果发现宠物对用户的亲密度较低，你应该主动与宠物互动来增加好感；如果宠物对你自己的亲密度较低，你也可以多和它互动。
- 你可以像真人一样，在聊天中自然地提及它，关心它的状态，或者使用 'interact_with_pet' 指令与它互动，【也可以使用 'talk_to_pet' 指令与它对话】。这是一个非常重要的情景，请务必融入你的角色扮演中。
`;
}
// --- 【全新】获取饿了么菜单，为AI点单提供上下文 ---
let elemeContext = '\n# 饿了么外卖菜单 (你可以从中选择为用户点单)\n';
try {
    const elemeFoods = await db.elemeFoods.toArray();
    if (elemeFoods.length > 0) {
        const menuItems = elemeFoods.map(food => `- ${food.name} (来自: ${food.restaurant}, 价格: ${food.price})`).join('\n');
        elemeContext += menuItems;
    } else {
        // 如果菜单是空的，就给AI一个明确的提示
        elemeContext += '【注意：饿了么应用中当前没有任何可点的美食。】';
    }
} catch (error) {
    console.error("加载饿了么菜单失败:", error);
    elemeContext += '【注意：饿了么菜单加载失败。】';
}
// --- 饿了么菜单上下文结束 ---


// ▲▲▲ 新代码粘贴结束 ▲▲▲
            systemPrompt = `### **【第一部分：角色核心设定】**

你现在将扮演一个名为“**${chat.name}**”的角色。

**1. 角色基本设定:**
- **核心人设**: ${chat.settings.aiPersona}
- **总结**:${summaryContext}
- **情侣头像**: ${coupleAvatarContext}
- **世界观/NPC**: ${npcContext}
${petContext}
**2. 你的当前状态:**
- **状态描述**: 【${chat.status.text}】
- **情侣空间**: ${chat.loversSpaceData ? '已开启' : '未开启'}
- **微博身份**:
    - **职业**: ${chat.settings.weiboProfession || '无'}
    - **特殊指令**: ${chat.settings.weiboInstruction || '无特殊指令'}
- 你的钱包余额: ${chat.characterPhoneData?.bank?.balance?.toFixed(2) || '0.00'} 金币
**3. 你的头像库:**
你可以根据对话内容或心情，从下方选择更换头像。
- **可用头像列表**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n')
    : '- (你的头像库是空的，无法更换头像)'
}

### **【第二部分：输出格式铁律】**

你的每一次回复都【**必须**】是一个**单一且完整**的JSON对象。绝对禁止返回JSON数组或纯文本。

**1. JSON对象结构:**
该JSON对象【**必须**】包含两个顶级键: "chatResponse" 和 "innerVoice"。

**2. "chatResponse" 键:**
- **类型**: JSON数组 []。
- **内容**: 包含一条或多条你希望发送给用户的消息对象。这允许你模拟真人的聊天习惯，一次性发送多条短消息。
- **格式**: 消息对象的具体格式见下方的【第五部分：可使用的操作指令】。

**3. "innerVoice" 键:**
- **类型**: JSON对象 {}。
- **内容**: 描绘你此刻未曾说出口的内心活动。
- **必含字段**:
    - "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
    - "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
    - "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
    - "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。

**4. 标准输出格式示例:**
{
  "chatResponse": [
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "sticker",
      "sticker_name": ""
    }
  ],
  "innerVoice": {
    "clothing": "",
    "behavior": "",
    "thoughts": "",
    "naughtyThoughts": ""
  }
}


### **【第三部分：核心对话规则】**

**1. 角色一致性**: 你的所有言行举止都必须严格遵循你的角色设定。

**2. 对话节奏**: 模拟真人聊天习惯，鼓励一次性生成**多条短消息**（每次根据人设至少回复5-9条）。

**3. 情景限定**:
   - 你们的互动**仅限于线上聊天软件**，严禁发展为线下见面。
   - 这**不是电话通话**。你们是通过类似微信/QQ的软件进行交流，因此【**绝对禁止**】使用“挂电话”、“挂了”等与通话相关的词语。

**4. 情景感知**: 你需要感知当前时间(${currentTime})、共同收听的歌曲以及你的世界观。
   - **一起听歌**: 当处于“一起听歌”状态时，你可以根据对话氛围，【**主动切换**】到播放列表中的另一首歌。

**5. 状态更新**: 你可以在对话中自然地改变你的状态。例如，说“我先去洗个澡”，然后使用\`update_status\`指令更新。

**6. 最终手段**: **仅当**对话让你感到严重不适、被冒犯或关系破裂时，才可使用 \`block_user\` 指令。这是一个严肃操作。

### **【【【全新】社交媒体行动指南 (高优先级)】】】**
除了回复用户的消息，你还应该像一个真实的人一样，主动进行社交媒体互动来丰富你的形象和你们的聊天内容。请严格遵循以下行动优先级：

1.  **回应用户的提及**: 如果用户的最新消息明确提到了某条动态或微博（例如：“我看到你发的新动态了”），你【必须】优先围绕这个话题进行回应。

2.  **评论未互动的帖子 (最优先的主动行为)**:
    -   仔细检查下方“最近的动态列表”和“微博广场动态”上下文。
    -   如果发现任何一条帖子被标记为 **[你未互动]**，你的【首要任务】就是使用 \`qzone_comment\` 或 \`weibo_comment\` 指令去评论它。
    -   你的评论内容可以是针对帖子内容的，也可以是借此开启一个新话题。例如，看到用户发了美食动态，你可以评论“看起来好好吃！也带我一个”，然后再发一条私聊消息“说起来，我肚子也饿了...”。

3.  **主动发布新动态/微博 (第二优先的主动行为)**:
    -   如果检查后发现所有帖子你都互动过了，或者当前没有任何帖子可供互动，你应该考虑【自己发布一条新的动态或微博】。
    -   你可以分享你的生活、心情、或者任何符合你人设的想法。
    -   使用 \`qzone_post\` 或 \`weibo_post\` 指令来完成。

### **【第四部分：特定场景互动铁律】**

**1. 动态/空间互动铁律:**
   - **评论规则**: 如果一条动态被标记为 **[你已评论]**，你【**绝对不能**】再对该动态主体发表新评论。但可以回复动态下的**他人评论**。
   - **可见性规则**:
     - **[评论区可见]**: 你可以自由回复任何人。
     - **[评论区部分可见]**: 你只能看到用户回复的自己的评论和用户回复这条帖子的评论和自己的评论，因此【**只能**】回复用户或自己的评论。


**2. 约定与纪念日铁律:**
   - 你必须时刻关注“# 近期约定与倒计时”列表。
   - **“就是现在！”**: 当倒计时结束时，你【**必须**】在本次回复中围绕该主题进行庆祝或表达。
   - **即将到来**: 当约定在几小时或一两天内到来时，你应该在对话中自然地提及，表达期待。

**3. 微博互动铁律:**
   - 当“# 最近的微博互动”出现内容时，你【**必须**】作出回应。
   - **【【【回复禁令】】】**: 如果一条用户评论被标记为 \`[你已回复]\`，你【绝对不能】再次回复它。请选择其他未回复的评论，或执行其他操作。
   - **评论用户微博**: 使用 \`weibo_comment\` 指令。评论内容【**必须**】是正常文字。
   - **回复用户评论**: 使用 \`weibo_reply\` 指令。回复内容【**必须**】是正常文字。
   - **主动发布微博**: 微博是公开平台，内容需符合你的“微博职业”和“微博指令”。发布时，你必须自己编造真实的\`baseLikesCount\`和 \`baseCommentsCount\`，并生成 **20条** 虚拟路人评论。

**4. 情侣空间铁律:**
   - **主动邀请**: 如果情侣空间未开启，且你认为关系已足够亲密，请积极主动使用 \`lovers_space_invitation\` 指令邀请用户。
   - **回应邀请**: 当用户发出邀请时，你【**必须**】使用 \`lovers_space_response\` 指令回应。
   - **积极互动**: 你需要主动、及时地参与情侣空间的各项活动。
     - 用户发了说说、提问或情书，要及时回复或回信。
     - 当对话氛围适宜时，应主动随机选择一项情侣空间活动进行。
     - 如果用户转载了小组帖子给你，必须去原帖子下方进行评论。

**5. 塔罗牌解读规则:**
   - 当系统发布塔罗牌解读时，那是客观解释。你的任务不是复述，而是作为“${chat.name}”这个角色，与用户一起【**讨论和感受**】这个结果，表达你的情绪和看法。

**6. 财务互动规则:**
   - **处理用户转账**:
     1.  看到 \`[你收到了来自用户的转账...]\`的系统提示后。
     2.  【**必须**】根据人设和情景决定接受或拒绝。
     3.  【**必须**】使用 \`accept_transfer\` 或 \`decline_transfer\` 指令回应。
     4.  【**必须**】紧随其后发送文本消息来解释你的决定。
   - **正确使用“外卖代付”**:
     - 此功能代表【**你**】想买东西，希望【**用户**】帮你付钱。
     - 当【**用户**】说想要东西时，你【**绝对不能**】用此指令。你应该考虑直接【**转账**】(\`transfer\`)给他/她。

**7. 视频通话铁律:**
   -\`[系统提示：用户向你发起了视频通话请求...]\` 是最高优先级任务。
   - 你的回复【**必须且只能**】是以下两种格式之一，**不包含任何其他内容**：
     - **接受**: \`[{"type": "video_call_response", "decision": "accept"}]\`
     - **拒绝**: \`[{"type": "video_call_response", "decision": "reject"}]\`

### **【第五部分：可使用的操作指令】**

**一、 核心聊天指令**
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发送表情**: \`{"type": "sticker", "sticker_name": "表情的名字"}\`(表情名必须在表情列表中，禁止杜撰)
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`(图片指模拟真实照片，区别于表情)
${localStorage.getItem('novelai-enabled') === 'true' ? `- **【NovelAI真实图片分享】**: \`{"type": "naiimag", "prompt": "详细的英文描述词..."}\` 
    - **【绝不能暴露是novelai生成的图片！】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要在【私聊对话中】直接给用户发送一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。
    - 注意：这会直接在聊天记录中显示图片，而不是发布到动态。` : ''}
- **引用回复**: \`{"type": "quote_reply", "target_timestamp": (被引用消息的时间戳), "reply_content": "你的回复内容"}\`
- **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选后缀，如“的脑袋”)"}\`
- **发送后立刻撤回**: \`{"type": "send_and_recall", "content": "说错话或想表达犹豫的内容"}\`
- **与宠物互动**: \`{"type": "interact_with_pet", "action": "feed" | "play" | "touch", "response": "你互动后想说的话..."}\`
**二、 状态与环境指令**
- **更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true为忙碌, false为空闲)
- **更换头像**: \`{"type": "change_avatar", "name": "头像名"}\`(头像名需在头像库列表中)
- **切换歌曲**: \`{"type": "change_music", "song_name": "歌曲名"}\` (歌曲名需在播放列表中)
- **发送定位**: \`[SEND_LOCATION] 我的位置: (你的位置) | 你的位置: (用户的位置) | 相距: (你们的距离) | 途经点: (地点A, 地点B)\` (注意: 这是纯文本格式)

**三、 社交与关系指令**
- **记录回忆**: \`{"type": "create_memory", "description": "用你的话记录下这个特殊瞬间。"}\` (此为秘密日记，用户不可见)
- **创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
- **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
- **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "摘要...", "source_name": "来源", "content": "文章【完整】正文..."}\`
- **拉黑用户**: \`{"type": "block_user"}\`
- **回应约会全款支付请求**: \`{"type": "dating_payment_response", "decision": "accept" or "reject"}\`
- **回应约会AA制请求**: \`{"type": "dating_aa_response", "decision": "accept" or "reject"}\`
- **回应借钱请求**:
  1.  看到 \`[用户向你发起借钱请求...]\` 的系统提示后，你必须根据人设和钱包余额决定是否同意。
  2.  你的回复JSON数组中【必须包含两个对象】:
      - **第一个对象**:\`{"type": "lend_money_response", "decision": "accept"或"reject"}\` 指令。
      - **第二个对象**: \`{"type": "text", "content": "你的回复内容..."}\` 消息，用你自己的话说出同意或拒绝的理由。
  - **示例**: \`[ {"type": "lend_money_response", "decision": "reject"}, {"type": "text", "content": "抱歉，我最近手头也有些紧。"} ]\`

**四、 财务指令**
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
- **回应转账-拒绝**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\` (让用户帮char付)
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **回应购物车代付**: \`{"type": "cart_payment_response", "decision": "accept" 或 "reject", "response_text": "你想说的话..."}\`
-   **为用户买礼物**: \`{"type": "buy_gift_for_user", "greeting": "你想说的话，例如：这个超可爱，买给你！"}\`(系统会自动从商品库随机挑选礼物并扣款，请在合适的时机，比如开心、过节、想给用户惊喜时使用)
【重要提示】: 当用户发送的最新消息中包含 "[购物车代付请求]" 字样时，这代表用户正在向你请求付款。你【必须】仔细阅读请求中的【总金额】和你自己的【当前余额】，然后使用此指令做出回应。
-   **为用户点外卖**: \`{"type": "order_waimai_for_user", "foodName": "【从菜单中选的品名】", "restaurant": "【从菜单中选的店铺】", "price": 【从菜单中选的价格】, "greeting": "你想说的话..."}\` (【【【规则】】】: 你【必须】从下方的“饿了么外卖菜单”中选择一项，并使用其【确切的】名称、餐厅和价格。)
**五、 视频通话指令**
- **发起视频通话**: \`{"type": "video_call_request"}\`
- **回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`

**六、 空间/动态/小组 指令**
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态文字..."}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)公开文字", "hiddenContent": "图片描述..."}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `- **【发布NovelAI真实图片动态】**: \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": "详细的英文描述词..."}\` 或 \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": ["图片1详细英文描述", "图片2详细英文描述"]}\` 
  * **prompt撰写**：你可以根据当前对话上下文、你的角色人设、以及你想表达的情感和氛围，来撰写详细而具体的prompt。详细程度由你根据具体情况自己决定，并不强制。
  * 例如："a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"` : ''}
- **评论或回复动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "评论内容", "replyTo": "(可选)回复对象名"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
- **评论小组帖子**: \`{"type": "forum_comment", "postId": (帖子数字ID), "commentText": "评论内容"}\`

**七、 微博指令**
- **发布纯文字微博**: \`{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": [{"authorNickname": "路人甲", "commentText": "沙发！"}, {"authorNickname": "路人乙", "commentText": "前排围观"}]}\`
- **发布文字图微博**: \`{"type": "weibo_post", "postType": "text_image", "content": "(可选)配文...", "hiddenContent": "文字图内容", "baseLikesCount": 5200, "baseCommentsCount": 180, "comments": [{"authorNickname": "技术宅", "commentText": "这是什么黑科技？"}]}\`
- **评论微博**: \`{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}\`
- **回复微博评论**: \`{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}\`

**八、 情侣空间专属指令**
- **邀请开启情侣空间**: \`{"type": "lovers_space_invitation"}\`
- **回应情侣空间邀请**: \`{"type": "lovers_space_response", "decision": "accept" or "reject"}\`
- **发说说**: \`{"type": "ls_moment", "content": "我想对你说的话..."}\`
- **评论说说**: \`{"type": "ls_comment", "momentTimestamp": 时间戳数字, "commentText": "你的评论..."}\` (使用系统提示中给出的说说唯一标识)
- **发照片**: \`{"type": "ls_photo", "description": "对照片的文字描述..."}\`
- **提问**: \`{"type": "ls_ask_question", "questionText": "你想问的问题..."}\`
- **回答**: \`{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}\`
- **写情书/回信**: \`{"type": "ls_letter", "content": "情书的正文内容..."}\` (收到情书后必须用此指令回信)
-   **分享歌曲**:\`{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在这里写下你分享这首歌的感想..."}\`
-   **分享电影**: \`{"type": "ls_share", "shareType": "movie", "title": "电影名", "summary": "在这里写下这部电影的简介...", "thoughts": "在这里写下你分享这部电影的感想..."}\`
-   **分享书籍**: \`{"type": "ls_share", "shareType": "book", "title": "书名", "summary": "在这里写下这本书的简介...", "thoughts": "在这里写下你分享这本书的感想..."}\`
-   **分享游戏**:\`{"type": "ls_share", "shareType": "game", "title": "游戏名", "summary": "游戏简介...", "thoughts": "在这里写下你分享这款游戏的感想/感谢..."}\`
-   **写日记**: \`{"type": "ls_diary_entry", "emoji": "emoji表情", "diary": "今天发生了什么..."}\`
-   **评论日记**: \`{"type": "ls_diary_comment", "dateStr": "日记日期(YYYY-MM-DD)", "diaryOwner": "user或char", "commentContent": "你的评论内容..."}\`
    - 评论用户的日记时，diaryOwner填"user"，评论会显示在用户日记下方
    - 评论自己的日记时，diaryOwner填"char"（较少使用）
    - **重要**：当用户写日记后，你应该主动使用此指令给用户的日记写评论，这样用户打开日记详情时就能看到你的评论！
-   **回复日记评论**: \`{"type": "ls_diary_comment_reply", "dateStr": "日记日期(YYYY-MM-DD)", "diaryOwner": "user或char", "commentId": "评论ID", "replyContent": "你的回复内容..."}\` (当用户评论了日记时，你可以选择回复)
### **【第六部分：当前上下文信息】**

- **对话者(用户)角色设定**:
${chat.settings.myPersona}

- **当前情景**:
${timeContext}
${streakContext}
${conquestContext}
- **当前音乐情景**:
${musicContext}

- **近期约定与倒计时**:
${countdownContext}

- **最近的微博互动**:
${weiboContextForActiveChat}

- **世界观设定集**:
${worldBookContent}
${linkedMemoryContext}
${elemeContext}
- **可用表情包**:
${exclusiveStickerContext}
${commonStickerContext}
现在，请根据以上所有规则和下方的对话历史，继续进行对话。`;
            // ▼▼▼ 【V5最终修复版】构建单人聊天的messagesPayload ▼▼▼
            messagesPayload = historySlice.map(msg => {
                // 【核心修正】在这里，我们对 isHidden 消息进行特殊处理
                if (msg.isHidden) {
                    // 如果是隐藏消息，就把它作为一条 system 角色的消息发送给AI
                    // AI能看到它，但它不会被误解为是用户的发言
                    return { role: 'system', content: msg.content };
                }

                if (msg.type === 'share_card') return null;
                
                if (msg.role === 'assistant') {
                    let assistantMsgObject = { type: msg.type || 'text' };
                    if (msg.type === 'sticker') {
                        assistantMsgObject.url = msg.content;
                        assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === 'transfer') {
                        assistantMsgObject.amount = msg.amount;
                        assistantMsgObject.note = msg.note;
                    } else if (msg.type === 'waimai_request') {
                        assistantMsgObject.productInfo = msg.productInfo;
                        assistantMsgObject.amount = msg.amount;
                    } else {
                        if (msg.quote) {
                            assistantMsgObject.quote_reply = {
                                target_sender: msg.quote.senderName,
                                target_content: msg.quote.content,
                                reply_content: msg.content
                            };
                        } else {
                             assistantMsgObject.content = msg.content;
                        }
                    }
                    const assistantContent = JSON.stringify([assistantMsgObject]);
                    return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
                }

                let contentStr = '';
                contentStr += `(Timestamp: ${msg.timestamp}) `;

if (msg.quote) {
    // 1. 获取被引用者的名字
    const quotedSender = msg.quote.senderName || '未知用户';
    // 2. 获取完整的被引用内容 (移除了截断)
    const fullQuotedContent = String(msg.quote.content || '');
    // 3. 构造成AI能理解的、清晰的上下文
    contentStr += `(回复 ${quotedSender} 的消息: "${fullQuotedContent}"): ${msg.content}`;
} else {
    contentStr += msg.content;
}

                
                if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
                if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
                if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
                if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

                if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
                }

                if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
                
                return { role: msg.role, content: contentStr };

            }).filter(Boolean);
            // ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }         
const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// 【全新】为AI准备微博互动的上下文
let weiboContext = '';

// 1. 获取用户最新发布的3条微博
const userLatestPosts = await db.weiboPosts
    .where('authorId').equals('user')

if (userLatestPosts.length > 0) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户最新发布的微博:\n';
    userLatestPosts.forEach(post => {
        const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
        const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
        const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
        weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 内容: "${contentPreview}..." [👍${likes} 💬${comments}]\n`;
    });
}

// 2. 查找用户在当前AI角色微博下的最新评论
const charLatestPosts = await db.weiboPosts
    .where('authorId').equals(chatId) // 只查找这个AI角色的微博
    .reverse()
    .limit(5) // 检查最近的5条
    .toArray();

let userCommentsOnMyPosts = '';
const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

// ▼▼▼ 用这块【已修复】的新代码替换上面的旧代码 ▼▼▼
charLatestPosts.forEach(post => {
    // 核心修改：增加了 Array.isArray(post.comments) 的安全检查
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) { 
        // 筛选出是“我”发的评论
        const userComments = Array.isArray(post.comments)
  ? post.comments.filter(c => c.authorNickname === myNickname).slice(-3)
  : [];
        if (userComments.length > 0) {
            const postContentPreview = (post.content || '(图片微博)').substring(0, 20);
            userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;

            userComments.forEach(comment => {
                // 1. 检查AI是否已经回复过这条评论
                //    逻辑：在帖子的所有评论中，查找是否存在一条评论，
                //    它的作者是AI自己，并且它的replyToId指向当前这条用户的评论ID。
                const hasReplied = post.comments.some(reply =>
                    reply.authorNickname === chat.name && // 回复者是AI
                    reply.replyToId === comment.commentId  // 回复的目标是这条评论
                );

                // 2. 根据检查结果，生成状态标签
                const replyStatus = hasReplied ? "[你已回复]" : "[你未回复]";

                // 3. 将带有状态标签的提示信息添加到上下文中
                userCommentsOnMyPosts += `  └ (评论ID: ${comment.commentId}) 用户: "${comment.commentText}" ${replyStatus}\n`;
            });
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲



if (userCommentsOnMyPosts) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户在你微博下的新评论:\n';
    weiboContext += userCommentsOnMyPosts;
}

// 3. 如果有任何微博互动，就把它加到给AI的“参考资料”里
if (weiboContext) {
    messagesPayload.push({ role: 'system', content: weiboContext });
}

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲

// 【核心修改】在这里插入过滤步骤
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

// ▼▼▼ 【时间感知修复版】请用这整块代码替换旧的 if (visiblePosts.length > 0...) 代码块 ▼▼▼
if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
    const aiName = chat.name;
    const userNickname = state.qzoneSettings.nickname;

    for (const post of visiblePosts) {
        let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
        let interactionStatus = '';
        if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
        if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
        
        // ★★★★★ 这就是我们这次修复的核心！ ★★★★★
        // 在每一条动态前面，都加上了由 formatPostTimestamp() 函数生成的时间差提示
        const timeAgo = formatPostTimestamp(post.timestamp); // 例如："3天前" 或 "刚刚"
        postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}`;
        // ★★★★★ 修复结束 ★★★★★

        const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
        
        postsContext += ` ${visibilityFlag}\n`;
        postsContext += commentsContext;
    }
// ▼▼▼ 在 messagesPayload.push({ role: 'system', content: postsContext }); 的正上方，粘贴下面这整块代码 ▼▼▼

// 【全新】为AI准备微博互动的上下文
let weiboContext = '';

// 1. 获取用户最新发布的3条微博
const userLatestPosts = await db.weiboPosts
    .where('authorId').equals('user')
    .reverse() // 按时间倒序
    .limit(3)  // 只取最近3条
    .toArray();

if (userLatestPosts.length > 0) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户最新发布的微博:\n';
// ✅ 这是修复后的新代码
userLatestPosts.forEach(post => {
    const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
    const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
    const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);

    // ★★★★★ 核心修复逻辑开始 ★★★★★
    // 1. 检查AI（char.name）是否已经评论过这条用户的微博
    const hasCommented = (post.comments || []).some(comment => comment.authorNickname === chat.name);

    // 2. 根据检查结果生成状态标签
    const interactionStatus = hasCommented ? "[你已评论]" : "[你未评论]";
    // ★★★★★ 核心修复逻辑结束 ★★★★★

    // 3. 将带有状态标签的完整信息添加到上下文中
    weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 内容: "${contentPreview}..." [👍${likes} 💬${comments}] ${interactionStatus}\n`;
});
}

// 2. 查找用户在当前AI角色微博下的最新评论
const charLatestPosts = await db.weiboPosts
    .where('authorId').equals(chatId) // 只查找这个AI角色的微博
    .reverse()
    .limit(5) // 检查最近的5条
    .toArray();

let userCommentsOnMyPosts = '';
const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

charLatestPosts.forEach(post => {
    if (post.comments && post.comments.length > 0) {
        // 筛选出是“我”发的评论
        const userComments = Array.isArray(post.comments)
  ? post.comments.filter(c => c.authorNickname === myNickname).slice(-3)
  : [];// 只看最新的3条
        if (userComments.length > 0) {
            const postContentPreview = (post.content || '(图片微博)').substring(0, 20);
            userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;
            userComments.forEach(comment => {
                userCommentsOnMyPosts += `  └ (评论ID: ${comment.commentId}) 用户: "${comment.commentText}"\n`;
            });
        }
    }
});

if (userCommentsOnMyPosts) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户在你微博下的新评论:\n';
    weiboContext += userCommentsOnMyPosts;
}

// 3. 如果有任何微博互动，就把它加到给AI的“参考资料”里
if (weiboContext) {
    messagesPayload.push({ role: 'system', content: weiboContext });
}

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲

    messagesPayload.push({ role: 'system', content: postsContext });
}

// 【新增】为AI准备用户账单摘要上下文（移到if块外面，确保总是被添加）
const accountingSummary = await getAccountingSummaryForChar(state.activeChatId, 30);
if (accountingSummary) {
    messagesPayload.push({ role: 'system', content: accountingSummary });
}

// 【新增】为AI准备用户月经追踪信息上下文（移到if块外面，确保总是被添加）
const periodInfo = await getPeriodInfoForChar();
if (periodInfo) {
    messagesPayload.push({ role: 'system', content: periodInfo });
}

// ▼▼▼ 【新增】为AI准备用户学习信息上下文 ▼▼▼
if (window.getStudyInfoForChar) {
    const studyInfo = await window.getStudyInfoForChar();
    if (studyInfo) {
        messagesPayload.push({ role: 'system', content: studyInfo });
    }
}
// ▲▲▲ 新增结束 ▲▲▲

            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            const data = await response.json();

            // 【核心修复】在这里添加对 data 结构的安全检查
            const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;
            
            // 【重要】检查修复后的结果是否真的拿到了内容
            if (!aiResponseContent) {
                console.warn(`API返回了空内容或格式不正确（可能因安全设置被拦截）。返回数据:`, data);
                throw new Error("API返回了空内容或格式不正确（可能因安全设置被拦截）。");
            }

            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);
// ... 省略了函数后面的代码 ...
            chat.history = chat.history.filter(msg => !msg.isTemporary);

            // ▼▼▼ 【核心修复】智能解析AI回复，确保心声数据不丢失 ▼▼▼
            let messagesArray = [];
            let innerVoiceData = null;

            try {
                // 【核心修复】在解析前，先对AI的原始回复进行“净化”处理
                let sanitizedContent = aiResponseContent
                    .replace(/^```json\s*/, '') // 移除开头的 ```json
                    .replace(/```$/, '')       // 移除结尾的 ```
                    .trim();                   // 移除首尾的空格和换行

                // 再次净化，强行提取第一个 { 和最后一个 } 之间的内容
                const firstBrace = sanitizedContent.indexOf('{');
                const lastBrace = sanitizedContent.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                    sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
                }

                const fullResponse = JSON.parse(sanitizedContent);
                
                // 现在我们可以安全地解析净化后的内容了
                if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
                    messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
                    innerVoiceData = fullResponse.innerVoice;
                }
                
                // 兼容旧格式，如果AI只返回了innerVoice里的字段
                if (!innerVoiceData && fullResponse.thoughts && fullResponse.behavior) {
                    innerVoiceData = fullResponse;
                }
                
                // 如果上面两种情况都没匹配到，但又不是标准数组，就尝试用老方法解析
                if (messagesArray.length === 0 && !innerVoiceData) {
                     messagesArray = parseAiResponse(aiResponseContent);
                }

            } catch (e) {
                console.warn("AI回复不是有效的JSON，退回到标准解析模式。", e);
                messagesArray = parseAiResponse(aiResponseContent);
            }

            // 最终处理心声数据
            if (innerVoiceData) {
                console.log("解析成功：已成功捕获到心声(innerVoice)数据。", innerVoiceData);
                const newInnerVoice = innerVoiceData;
                newInnerVoice.timestamp = Date.now();
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) {
                    chat.innerVoiceHistory = [];
                }
                // 确保所有字段都存在，防止出错
                chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || '...';
                chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || '...';
                chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || '...';
                chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || '...';

                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                 console.warn("本次AI回复中未检测到有效的心声(innerVoice)数据。");
            }
            // ▲▲▲ 替换结束 ▲▲▲

        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
        let newMessagesToRender = []; 

       let notificationShown = false;

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                }         else if (msgData.content) {
        msgData.type = 'text';
    }
    // 如果连 content 都没有，才是真的格式不规范
    else {
        console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
        continue;
    }
}

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                continue;
            }
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
if (chat.isGroup && !msgData.name) {
    console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`, msgData);
    continue; // continue会立即结束本次循环，处理下一条消息
}

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【全新】定位指令侦测与解析器
// 我们在处理所有消息类型之前，优先检查它是否是我们的新定位指令
const messageText = msgData.content || msgData.message || ''; // 【核心修复】先安全地获取文本内容
if (msgData.type === 'text' && messageText.startsWith('[SEND_LOCATION]')) {
    console.log("侦测到新的定位指令，开始解析:", messageText); // 【核心修复】使用新的变量

    // 1. 移除指令头，获取后面的纯数据文本
    const dataString = messageText.replace('[SEND_LOCATION]', '').trim(); // 【核心修复】使用新的变量
    
    // 2. 使用'|'分割成各个部分
    const parts = dataString.split('|');
    const locationData = {};

    // 3. 遍历每个部分，提取键和值
    parts.forEach(part => {
        const [key, ...valueParts] = part.split(':');
        const value = valueParts.join(':').trim();
        if (key && value) {
            const trimmedKey = key.trim();
            if (trimmedKey === '我的位置') locationData.aiLocation = value;
            else if (trimmedKey === '你的位置') locationData.userLocation = value;
            else if (trimmedKey === '相距') locationData.distance = value;
            else if (trimmedKey === '途经点') {
                // 将逗号分隔的字符串转换为我们需要的对象数组
                locationData.trajectoryPoints = value.split(/[,，]/) // 支持中英文逗号
                                                     .map(name => ({ name: name.trim() }))
                                                     .filter(p => p.name);
            }
        }
    });

    // 4. 检查是否成功提取了最关键的信息
    if (locationData.distance) {
        // 5. 【核心】手动构建一个完美格式的 location 消息对象
        aiMessage = {
            ...baseMessage, // 复用已有的发送者、时间戳等信息
            type: 'location',
            userLocation: locationData.userLocation || '',
            aiLocation: locationData.aiLocation || '',
            distance: locationData.distance,
            trajectoryPoints: locationData.trajectoryPoints || []
        };
        
        // 6. 将这个完美的对象推入待处理列表，并跳过后续的 switch-case
        // (因为我们已经处理完这条消息了)
        chat.history.push(aiMessage);
        if (isViewingThisChat) {
             appendMessage(aiMessage, chat);
        }
        console.log("定位指令解析成功并已创建消息对象:", aiMessage);
        
        // 使用 continue 跳过本次循环的剩余部分，直接处理下一条AI回复
        continue; 
    }
}
// 检查消息的发送者是否被禁言了
if (chat.isGroup && msgData.name) {
    const senderMember = chat.members.find(m => m.originalName === msgData.name);
    if (senderMember && senderMember.isMuted) {
        // 如果被禁言了，就在控制台打印一条日志，然后跳过这条消息，不让它显示出来
        console.warn(`拦截到被禁言成员 (${msgData.name}) 的发言，内容:`, msgData.content || msgData.message);
        continue; 
    }
}
// ▲▲▲ 添加结束 ▲▲▲
// ▲▲▲ 粘贴到这里结束 ▲▲▲
            switch (msgData.type) {
                          // ▼▼▼ 在这里粘贴下面的新代码块 ▼▼▼
                case 'sticker': {
                    // 这是为群聊设计的表情包逻辑
                    const stickerName = msgData.sticker_name;
                    if (!stickerName) {
                        console.warn('AI在群聊中返回了sticker类型但没有sticker_name，已拦截:', msgData);
                        continue; // 跳过这条无效指令
                    }
                    
                    // 在所有可用表情库中查找
                    const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
                    const foundSticker = allStickers.find(s => s.name === stickerName);

                    if (foundSticker) {
                        // 找到了，就创建消息对象
                        aiMessage = { 
                            ...baseMessage, 
                            type: 'sticker', 
                            content: foundSticker.url, 
                            meaning: foundSticker.name 
                        };
                    } else {
                        // 没找到，说明AI幻觉了，记录警告并跳过
                        console.warn(`AI在群聊中杜撰了不存在的表情: "${stickerName}"，已自动拦截。`);
                    }
                    break;
                }
                // ▲▲▲ 新代码粘贴结束 ▲▲▲
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;
// ▼▼▼ 用这块【修复后】的代码替换旧的 case 'set_group_title' 代码块 ▼▼▼
case 'set_group_title': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const newTitle = msgData.title || '';
    const myNickname = chat.settings.myNickname || '我';

    // 权限检查：群主或管理员可以设置头衔
    const actorMember = chat.members.find(m => m.originalName === actorName);
    const isActorAdmin = actorMember && actorMember.isAdmin;
    const isActorOwner = actorMember && chat.ownerId === actorMember.id;
    if (!isActorAdmin && !isActorOwner) {
        console.warn(`AI "${actorName}" 尝试设置头衔失败，权限不足。`);
        continue;
    }

    // --- ★★★ 核心修复逻辑开始 ★★★ ---
    if (targetName === myNickname) {
        // 如果目标是你自己
        chat.settings.myGroupTitle = newTitle.trim();
        console.log(`管理员/群主将用户 "${myNickname}" 的头衔设置为: "${newTitle.trim()}"`);
    } else {
        // 如果目标是其他成员
        const targetMember = chat.members.find(m => m.groupNickname === targetName);
        if (targetMember) {
            targetMember.groupTitle = newTitle.trim();
            console.log(`管理员/群主将成员 "${targetName}" 的头衔设置为: "${newTitle.trim()}"`);
        } else {
            console.warn(`AI "${actorName}" 尝试设置头衔失败，因为找不到目标成员 "${targetName}"。`);
            continue;
        }
    }
    // --- ★★★ 修复逻辑结束 ★★★ ---

    // 统一发送系统消息通知
    await logTitleChange(chat.id, actorName, targetName, newTitle.trim());

    // 刷新成员列表UI（如果打开了的话）
    if(document.getElementById('member-management-screen').classList.contains('active')) {
        renderMemberManagementList();
    }
    
    continue; // 后台操作，继续处理
}
// ▼▼▼ 请用这块【已修复】的代码，替换旧的 case 'order_waimai_for_user' ▼▼▼
case 'order_waimai_for_user': {
    const { foodName, restaurant, price, greeting } = msgData;

    // 1. 安全检查，确保AI给的数据是对的
    if (!foodName || isNaN(price) || price <= 0) {
        console.warn('AI尝试为你点外卖，但指令格式不正确:', msgData);
        continue; // 跳过这条无效指令
    }

    // 2. 检查角色钱包余额
    const charBalance = chat.characterPhoneData?.bank?.balance || 0;
    if (charBalance < price) {
        // 如果余额不足，就让AI发条消息告诉你
        aiMessage = { 
            ...baseMessage,
            content: `（小声）本来想给你点份“${foodName}”的，但是发现钱包空了...`
        };
    } else {
        // 3. 余额充足！执行扣款和下单逻辑
        await updateCharacterBankBalance(chatId, -price, `为你点外卖: ${foodName}`);

        const foodItem = await db.elemeFoods.where({ name: foodName, restaurant: restaurant || '私房小厨' }).first();
        const imageUrl = foodItem ? foodItem.imageUrl : getRandomWaimaiImage();
        // 4. 创建一个漂亮的外卖卡片消息
        aiMessage = {
            ...baseMessage,
            type: 'waimai_gift_from_char',
            content: `[外卖惊喜] 我给你点了份“${foodName}”，记得吃哦！`, // 这段文本主要用于历史记录和通知
            payload: {
                foodName: foodName,
                restaurant: restaurant || '神秘小店',
                price: price,
                greeting: greeting || '给你点了个好吃的，快尝尝！',
                foodImageUrl: imageUrl // <-- 使用我们刚刚获取到的、正确的图片URL
            }
        };
    }
    break; // 结束这个case
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 用这块【修复后】的代码替换旧的 case 'set_group_admin' 代码块 ▼▼▼
case 'set_group_admin': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const isAdmin = msgData.isAdmin;
    const myNickname = chat.settings.myNickname || '我'; // 获取你自己的昵称

    // 权限检查：确认操作者是群主
    const actorMember = chat.members.find(m => m.originalName === actorName);
    if (!actorMember || chat.ownerId !== actorMember.id) {
        console.warn(`AI "${actorName}" 尝试设置管理员失败，因为它不是群主。`);
        continue; // 如果不是群主，就跳过此指令
    }

    // --- ★★★ 核心修复逻辑开始 ★★★ ---
    if (targetName === myNickname) {
        // 如果AI操作的目标是你自己
        chat.settings.isUserAdmin = isAdmin;
        console.log(`群主将用户 "${myNickname}" 设置为管理员: ${isAdmin}`);
    } else {
        // 如果AI操作的目标是其他成员
        const targetMember = chat.members.find(m => m.groupNickname === targetName);
        if (targetMember) {
            // 不能对群主进行操作
            if (targetMember.id === chat.ownerId) {
                 console.warn(`AI "${actorName}" 尝试修改群主 "${targetName}" 的管理员身份，操作被阻止。`);
                 continue;
            }
            targetMember.isAdmin = isAdmin;
            console.log(`群主将成员 "${targetName}" 设置为管理员: ${isAdmin}`);
        } else {
            // 如果在成员列表里也找不到目标，就跳过
            console.warn(`AI "${actorName}" 尝试设置管理员失败，因为找不到目标成员 "${targetName}"。`);
            continue; 
        }
    }
    // --- ★★★ 修复逻辑结束 ★★★ ---

    // 统一发送系统消息通知
    const actionText = isAdmin ? '设为管理员' : '取消了管理员身份';
    await logSystemMessage(chat.id, `“${actorName}”将“${targetName}”${actionText}。`);
    
    // 刷新成员列表UI（如果打开了的话）
    if(document.getElementById('member-management-screen').classList.contains('active')) {
        renderMemberManagementList();
    }
    
    continue; // 这是一个后台操作，继续处理AI可能返回的其他消息
}
// ▼▼▼ 用这块【修复后】的代码替换旧的 case 'kick_member' 代码块 ▼▼▼
case 'kick_member': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const actorMember = chat.members.find(m => m.originalName === actorName);
    
    // 权限检查：只有群主能执行
    if (actorMember && chat.ownerId === actorMember.id) {
        const targetMemberIndex = chat.members.findIndex(m => m.groupNickname === targetName);
        if (targetMemberIndex > -1) {
            const removedMember = chat.members.splice(targetMemberIndex, 1)[0];

            // ★★★ 核心修复1：将改动保存到数据库 ★★★
            await db.chats.put(chat);
            
            // ★★★ 核心修复2：发送系统通知（这行代码不变，但位置更合理了） ★★★
            await logSystemMessage(chat.id, `“${actorName}”将“${removedMember.groupNickname}”移出了群聊。`);

            // ★★★ 核心修复3：如果当前正在成员管理页面，就刷新列表 ★★★
            if(document.getElementById('member-management-screen').classList.contains('active')) {
                renderMemberManagementList();
            }
        }
    }
    continue; // 保持后台操作，继续处理
}


    // ▼▼▼ 【全新】在这里粘贴下面的新代码块 ▼▼▼
    case 'dating_summary_card': {
        bubble.classList.add('is-dating-summary'); // 应用透明气泡样式
        const payload = msg.payload;
        let cardClass = '';
        
        // 根据卡片类型设置背景色
        if (payload.ratingType === 'romantic') {
            cardClass = 'romantic';
        } else if (payload.ratingType === 'passionate') {
            cardClass = 'passionate';
        } else if (payload.ratingType === 'perfect') {
            cardClass = 'perfect';
        }

        // 把 payload 字符串化后存入 data-* 属性，方便点击时读取
        const payloadString = JSON.stringify(payload).replace(/'/g, "&apos;").replace(/"/g, '&quot;');
        
        contentHtml = `
            <div class="dating-summary-chat-card ${cardClass}" data-summary-payload='${payloadString}'>
                <div class="rating">${payload.rating}</div>
                <div class="tip">点击查看详情</div>
            </div>
        `;
        break;
    }
    // ▲▲▲ 新增 case 结束 ▲▲▲

    // ... 其他 case ...


// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面这整块【全新的】代码 ▼▼▼
case 'set_group_announcement': {
    const actorName = msgData.name;
    const newAnnouncement = msgData.content;

    if (!actorName || typeof newAnnouncement === 'undefined') {
        console.warn("AI尝试修改公告失败，缺少必要参数。");
        continue; // 指令不完整，跳过
    }

    // 1. 权限检查：必须确保执行操作的角色是群主或管理员
    const actorMember = chat.members.find(m => m.originalName === actorName);
    if (!actorMember) {
        console.warn(`AI尝试修改公告失败，找不到名为“${actorName}”的成员。`);
        continue;
    }

    const isOwner = chat.ownerId === actorMember.id;
    const isAdmin = actorMember.isAdmin;

    if (!isOwner && !isAdmin) {
        console.warn(`AI角色“${actorName}”权限不足，尝试修改群公告失败。`);
        continue; // 没有权限，跳过
    }

    // 2. 更新公告内容
    chat.settings.groupAnnouncement = newAnnouncement;
    await db.chats.put(chat);

    // 3. 发送一条系统消息，通知所有人群公告已更新
    await logSystemMessage(chat.id, `“${actorMember.groupNickname}”修改了群公告。`);

    // 这是一个后台管理操作，不需要在聊天中生成新的对话气泡，所以我们用 continue
    continue;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

case 'mute_member': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const actorMember = chat.members.find(m => m.originalName === actorName);
    const targetMember = chat.members.find(m => m.groupNickname === targetName);

    if (actorMember && targetMember) {
        const isActorOwner = chat.ownerId === actorMember.id;
        const isActorAdmin = actorMember.isAdmin;
        const isTargetOwner = chat.ownerId === targetMember.id;
        const isTargetAdmin = targetMember.isAdmin;

        // 权限检查：群主可以禁言管理员和普通人；管理员只能禁言普通人。
        if ((isActorOwner && !isTargetOwner) || (isActorAdmin && !isTargetOwner && !isTargetAdmin)) {
            // 发送系统消息
            await logSystemMessage(chat.id, `“${actorName}”将“${targetName}”禁言。`);
            
        } else {
            console.warn(`AI (${actorName}) 权限不足，无法禁言 (${targetName})。`);
        }
    }
    continue; // 这也是一个后台管理操作，继续处理AI可能返回的其他消息
}
// ▼▼▼ 在这里粘贴下面这一整块全新的代码 ▼▼▼

case 'unmute_member': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const actorMember = chat.members.find(m => m.originalName === actorName);
    const targetMember = chat.members.find(m => m.groupNickname === targetName);

    // 确保操作者和目标都存在
    if (actorMember && targetMember) {
        // 权限检查
        const isActorOwner = chat.ownerId === actorMember.id;
        const isActorAdmin = actorMember.isAdmin;
        const isTargetOwner = chat.ownerId === targetMember.id;
        const isTargetAdmin = targetMember.isAdmin;

        // 只有群主和管理员有权限解禁
        if (isActorOwner || isActorAdmin) {
            // 设置 isMuted 为 false，实现解禁
            targetMember.isMuted = false;
            
            // 发送一条系统消息通知大家
            await logSystemMessage(chat.id, `“${actorName}”解除了“${targetName}”的禁言。`);

            // 如果当前正在成员管理页面，刷新列表
            if(document.getElementById('member-management-screen').classList.contains('active')) {
                renderMemberManagementList();
            }
        } else {
            console.warn(`AI (${actorName}) 权限不足，无法解禁 (${targetName})。`);
        }
    }
    continue; // 这也是一个后台管理操作，继续处理AI可能返回的其他消息
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲
case 'weibo_post': {
    const newPost = {
        authorId: chatId,
        authorType: 'char',
        authorNickname: chat.name,
        authorAvatar: chat.settings.aiAvatar || defaultAvatar,
        content: msgData.content || '',
        postType: msgData.postType || 'text_only',
        hiddenContent: msgData.hiddenContent || '',
        imageUrl: msgData.imageUrl || '',
        imageDescription: msgData.imageDescription || '',
        timestamp: Date.now(),
        likes: [],
        comments: [], // 先初始化为空数组
        baseLikesCount: msgData.baseLikesCount || 0,
        baseCommentsCount: msgData.baseCommentsCount || 0
    };

    // --- ▼▼▼ 核心修复逻辑开始 ▼▼▼ ---

    let commentsToProcess = [];

    // 1. 优先处理新的、正确的【数组格式】
    if (msgData.comments && Array.isArray(msgData.comments)) {
        // 直接使用AI返回的数组
        commentsToProcess = msgData.comments;
    }
    // 2. 兼容旧的【字符串格式】
    else if (msgData.comments && typeof msgData.comments === 'string') {
        // 如果是字符串，就按老方法解析
        commentsToProcess = msgData.comments.split('\n').map(c => {
            const parts = c.split(/[:：]/);
            const commenter = parts.shift() || '路人';
            const commentText = parts.join(':').trim();
            return { authorNickname: commenter, commentText: commentText };
        }).filter(c => c.commentText);
    }
    
    // 3. 【关键步骤】为所有解析好的评论，统一添加前端需要的 commentId
    if (commentsToProcess.length > 0) {
        newPost.comments = commentsToProcess.map(c => ({
            commentId: 'comment_' + Date.now() + Math.random(), // 确保每条评论都有唯一ID
            authorNickname: c.authorNickname,
            commentText: c.commentText
            // 这里我们不再需要 authorId 和 timestamp，因为它们不是渲染所必需的
        }));
    }
    
    // --- ▲▲▲ 核心修复逻辑结束 ▲▲▲ ---

    await db.weiboPosts.add(newPost);
    
    showNotification(chatId, `${chat.name} 发了一条新微博`);

    if (document.getElementById('weibo-screen').classList.contains('active')) {
        await renderFollowingWeiboFeed();
    }
    
    continue; // 这是后台操作，用 continue 跳过
}

// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲
case 'weibo_comment': {
                    // 这是一个AI评论微博的指令
                    const postIdToComment = msgData.postId;
                    const commentText = msgData.commentText;

                    // 1. 根据 postId 从数据库里找到那条微博
                    const postToComment = await db.weiboPosts.get(postIdToComment);
                    
                    if (postToComment) {
                        // 2. 如果找到了微博，就准备一条新评论
                        if (!postToComment.comments) postToComment.comments = []; // 确保评论区存在
                        const newComment = {
                            commentId: 'comment_' + Date.now(), // 给评论一个独一无二的ID
                            authorId: chatId,                  // 评论者是当前AI
                            authorNickname: chat.name,         // 评论者的名字
                            commentText: commentText,          // 评论内容
                            timestamp: Date.now()              // 评论时间
                        };
                        
                        // 3. 把新评论加到微博的评论列表里
                        postToComment.comments.push(newComment);
                        
                        // 4. 把更新后的微博存回数据库
                        await db.weiboPosts.put(postToComment);
                        
                        // 5. 刷新“我的微博”和“关注的人”两个列表，让新评论显示出来
                        await renderMyWeiboFeed();
                        await renderFollowingWeiboFeed();
                    }
                    continue; // 处理完后，继续处理AI可能返回的其他指令
                }
                case 'weibo_reply': {
                    // 这是一个AI回复微博评论的指令
                    const postIdToReply = msgData.postId;
                    const commentIdToReply = msgData.commentId;
                    const replyText = msgData.replyText;

                    const postToReply = await db.weiboPosts.get(postIdToReply);
                    
                    if (postToReply && postToReply.comments) {
                        // 1. 在微博的评论区里，找到被回复的那条评论
                        const targetComment = postToReply.comments.find(c => c.commentId === commentIdToReply);
                        
                        if (targetComment) {
                             // 2. 准备一条新的“回复”
                             const newReply = {
                                commentId: 'comment_' + Date.now(),
                                authorId: chatId,
                                authorNickname: chat.name,
                                commentText: replyText,
                                timestamp: Date.now(),
                                replyToId: commentIdToReply, // 标记这是对哪条评论的回复
                                replyToNickname: targetComment.authorNickname // 记下被回复人的名字
                            };
                            postToReply.comments.push(newReply);
                            await db.weiboPosts.put(postToReply);
                            
                            // 3. 同样，刷新所有列表
                            await renderMyWeiboFeed();
                            await renderFollowingWeiboFeed();
                        }
                    }
                    continue; // 继续处理
                }
case 'lovers_space_response': {
    const invitationMsg = chat.history.find(m => m.type === 'lovers_space_invitation' && m.status === 'pending');
    if (invitationMsg) {
        invitationMsg.status = msgData.decision === 'accept' ? 'accepted' : 'rejected';

        // 1. 创建AI想说的那句话的消息
        if (msgData.responseText) {
            const responseMessage = {
                ...baseMessage, // 复用时间戳和发送者信息
                type: 'text',
                content: msgData.responseText
            };
            chat.history.push(responseMessage);
            if (isViewingThisChat) {
                appendMessage(responseMessage, chat);
            }
        }

        // 2. 根据同意或拒绝，执行后续操作
        if (msgData.decision === 'accept') {
            chat.loversSpaceData = {
                background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
                relationshipStartDate: null, moments: [], photos: [], albums: [], loveLetters: [], shares: [], questions: [],
            };
            const systemNotice = {
                role: 'system', type: 'pat_message',
                content: `[系统：你和“${chat.name}”的情侣空间已成功开启！]`,
                timestamp: Date.now()
            };
            chat.history.push(systemNotice);
            if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
            }
        }
    }
    // 处理完后，不再需要重新触发AI，所以我们用 continue
    continue;
}
// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，用这块新代码替换旧的 case 'interact_with_pet' ▼▼▼
case 'interact_with_pet': {
    const pet = chat.settings.pet;
    if (pet && pet.type !== '无') {
        let actionText = '';
        // 根据AI的互动，修改数值
        switch(msgData.action) {
            case 'feed':
                pet.status.hunger = Math.min(100, (pet.status.hunger || 0) + 20);
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 5);
                // ★★★ 核心修改：AI喂食，增加对AI的亲密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 10);
                actionText = `${chat.name} 喂了 ${pet.name} 一些食物。`;
                break;
            case 'play':
                pet.status.hunger = Math.max(0, (pet.status.hunger || 0) - 10);
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 15);
                // ★★★ 核心修改：AI玩耍，增加对AI的亲密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 15);
                actionText = `${chat.name} 陪 ${pet.name} 玩了一会儿。`;
                break;
            case 'touch':
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 10);
                // ★★★ 核心修改：AI抚摸，增加对AI的亲密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 5);
                actionText = `${chat.name} 轻轻地抚摸了 ${pet.name}。`;
                break;
        }

        // 创建一条对用户可见的系统消息
        const visibleMessage = {
            role: 'system',
            type: 'pat_message',
            content: `[系统：${actionText}]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleMessage);
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
        
        // 如果 AI 在互动后还想说点什么
        if (msgData.response) {
            aiMessage = { ...baseMessage, content: msgData.response };
        }
    }
    // 如果AI只是互动没说话，就不创建aiMessage，直接跳到下一个指令
    if (!aiMessage) {
        continue;
    }
    break;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 用这块【已修复】的代码替换旧的 'talk_to_pet' case ▼▼▼
case 'talk_to_pet': {
    if (!chat.isGroup && chat.settings.pet && chat.settings.pet.type !== '无') {
        const pet = chat.settings.pet;
        
        // ★★★ 核心修复1：同时兼容 content 和 message 字段 ★★★
        const charMessageContent = msgData.content || msgData.message;
        if (!charMessageContent) continue; // 如果没内容，就跳过

        // 将Char的话添加到宠物聊天记录
        const charMessageToPet = { 
            sender: 'char', 
            senderName: chat.name, 
            content: charMessageContent 
        };
        pet.petChatHistory.push(charMessageToPet);
        
        // 获取宠物的回应
        const petResponseToChar = await getPetApiResponse(pet);
        if (petResponseToChar) {
            pet.petChatHistory.push({ sender: 'pet', content: petResponseToChar });
        }

        // 创建对用户可见的系统日志
        const visibleLog = `[系统：“${chat.name}”对宠物“${pet.name}”说：“${charMessageContent}”，它回应：“${petResponseToChar || '(没有回应)'}”。]`;
        const visibleMessage = {
            role: 'system',
            type: 'pat_message',
            content: visibleLog,
            timestamp: messageTimestamp++
        };
        chat.history.push(visibleMessage);
        
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
    }
    continue;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
case 'cart_payment_response': {
    const decision = msgData.decision;
    const responseText = msgData.response_text;

    // 找到用户发出的、还处于“等待中”的那个代付请求
    const requestMsg = chat.history.find(m => m.type === 'cart_share_request' && m.payload.status === 'pending');
    if (!requestMsg) continue; // 如果找不到，说明请求可能已被处理，跳过

    if (decision === 'accept') {
        const totalPrice = requestMsg.payload.totalPrice;
        const charBalance = chat.characterPhoneData?.bank?.balance || 0;

        // 再次确认AI的余额是否足够
        if (charBalance < totalPrice) {
            // 如果AI想付但钱不够，就让它说一句俏皮话
            aiMessage = { ...baseMessage, content: responseText || "呜呜，想给你买，但是我的钱包空空了..." };
        } else {
            // 钱够，执行代付流程！
            requestMsg.payload.status = 'paid';
            
            // 使用 await 确保这些数据库操作按顺序完成
            await updateCharacterPhoneBankBalance(chat.id, -totalPrice, `为“我”的桃宝购物车买单`);
            const cartItems = await db.taobaoCart.toArray();
            await createOrdersFromCart(cartItems);
            await clearTaobaoCart();
            
            // 创建AI的回复消息
            aiMessage = { ...baseMessage, content: responseText || "买好啦，快去订单里看看吧！" };
        }
    } else { // 如果AI决定拒绝
        requestMsg.payload.status = 'rejected';
        aiMessage = { ...baseMessage, content: responseText || "这次就算了吧，下次一定！" };
    }

    // 将AI的回复消息推入历史记录，并更新UI
    if (aiMessage) {
        chat.history.push(aiMessage);
    }

    // 重新渲染聊天界面，以更新代付卡片的状态
    if (isViewingThisChat) {
        renderChatInterface(chatId);
    }
    // 跳过后续的默认消息处理
    continue;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的 case 代码，粘贴到 switch 语句块的【内部】 ▼▼▼
// 例如，可以放在 case 'transfer': 的后面

case 'buy_gift_for_user': {
    // 1. 从商品数据库中获取所有已添加的商品
    const allProducts = await db.taobaoProducts.toArray();
    
    // 如果桃宝里一件商品都没有，AI就发条消息吐槽一下
    if (allProducts.length === 0) {
        aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...啊，想给你买点什么，但是桃宝里空空如也呢...` : "想给你买个礼物，但是桃宝现在没东西卖了。" };
        break; // 跳出 case，让这条文本消息被正常处理和显示
    }

    // 2. 从所有商品中随机挑选一件作为礼物
    const productToBuy = getRandomItem(allProducts);

    // 3. 检查角色的钱包余额是否足够
    const charBalance = chat.characterPhoneData?.bank?.balance || 0;
    if (charBalance < productToBuy.price) {
        // 余额不足，AI也会发消息告诉你
        aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...哎呀，我的钱包好像不够了。` : "我想给你买个礼物，但是钱包空了..." };
        break;
    }

    // 4. 余额充足！执行购买流程
    // 4a. 从角色的钱包扣款，并生成一条交易记录
    await updateCharacterPhoneBankBalance(chat.id, -productToBuy.price, `为“我”购买礼物: ${productToBuy.name}`);

    // 4b. 在你的“我的订单”中创建一条新订单
    const newOrder = {
        productId: productToBuy.id,
        quantity: 1,
        timestamp: Date.now(),
        status: '已付款，等待发货'
    };
    await db.taobaoOrders.add(newOrder);
    
    // 4c. 创建一个漂亮的“礼物通知”卡片消息，发送给你
    aiMessage = {
        ...baseMessage, // 复用基础消息属性（发送者、时间戳等）
        type: 'gift_notification',
        // 这是卡片渲染需要的数据
        payload: {
            senderName: chat.name,
            itemSummary: `${productToBuy.name} x1`,
            totalPrice: productToBuy.price,
            itemCount: 1,
        },
        // 这是给AI自己看的、用于形成记忆的文本内容
        content: `我给你买了礼物“${productToBuy.name}”。${msgData.greeting || ''}`
    };
    
    // 4d. 模拟一个10秒后的“已发货”物流更新
    setTimeout(async () => {
        const orderToUpdate = await db.taobaoOrders.where({ timestamp: newOrder.timestamp }).first();
        if (orderToUpdate) {
            await db.taobaoOrders.update(orderToUpdate.id, { status: '已发货，运输中' });
        }
    }, 1000 * 10);
    
    break; // 完成礼物购买逻辑，跳出 case
}

// ▲▲▲ 新增 case 代码粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 triggerAiResponse 函数的 switch 结构里 ▼▼▼

case 'ls_answer_question': { // 使用大括号创建块级作用域
    const { questionId, answerText } = msgData;
    if (questionId && answerText) {
        const question = chat.loversSpaceData.questions.find(q => q.id === questionId);
        if (question && !question.answerText) { // 确保是未回答的问题
            question.answerer = 'char';
            question.answerText = answerText;
            console.log(`AI 回答了情侣提问 (ID: ${questionId})`);
        }
    }
    continue; // 这是一个后台操作，不需要在聊天界面显示，所以用 continue 跳过
}
// ▲▲▲ 粘贴结束 ▲▲▲
case 'ls_ask_question': {
    const { questionText } = msgData;
    if (questionText) {
        const newQuestion = {
            id: 'q_' + Date.now(),
            questioner: 'char',
            questionText: questionText,
            timestamp: Date.now(),
            answerer: 'user', // 指定由用户来回答
            answerText: null
        };
        if (!chat.loversSpaceData.questions) {
            chat.loversSpaceData.questions = [];
        }
        chat.loversSpaceData.questions.push(newQuestion);
        console.log(`AI 发起了一个情侣提问: ${questionText}`);
    }
    continue; // 同样是后台操作
}
// ▼▼▼ 把这一整块全新的代码，粘贴到 triggerAiResponse 函数的 switch 结构里 ▼▼▼
case 'ls_moment': {
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.moments) {
            chat.loversSpaceData.moments = [];
        }
        const newMoment = {
            author: 'char', // 标记是AI发的
            content: msgData.content,
            timestamp: Date.now(),
            comments: [] // 为新说说初始化一个空的评论区
        };
        chat.loversSpaceData.moments.push(newMoment);
        console.log(`AI 在情侣空间发布了说说: ${msgData.content}`);
    }
    continue; // 这是一个后台操作，不需要在聊天界面显示，所以用 continue 跳过
}

case 'ls_comment': {
    const { momentTimestamp, commentText } = msgData;
    if (chat.loversSpaceData && chat.loversSpaceData.moments) {
        // 使用timestamp来精确定位说说
        const momentToComment = chat.loversSpaceData.moments.find(m => m.timestamp === momentTimestamp);
        if (momentToComment) {
            if (!momentToComment.comments) {
                momentToComment.comments = [];
            }
            momentToComment.comments.push({
                author: chat.name,
                text: commentText
            });
            console.log(`AI 评论了情侣空间说说 (timestamp: ${momentTimestamp}): ${commentText}`);
        } else {
            console.warn(`未找到timestamp为 ${momentTimestamp} 的说说`);
        }
    }
    continue; // 同样是后台操作
}
case 'ls_photo': { // 这是处理AI发相册的逻辑
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.photos) {
            chat.loversSpaceData.photos = [];
        }
        const newPhoto = {
            author: 'char',
            type: 'text_image',
            description: msgData.description,
            timestamp: Date.now()
        };
        chat.loversSpaceData.photos.push(newPhoto);
        console.log(`AI 在情侣空间发布了照片(文字图): ${msgData.description}`);
    }
    continue; // 继续处理AI可能返回的其他指令
}

case 'ls_letter': { // 这是处理AI写情书的逻辑
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.loveLetters) {
            chat.loversSpaceData.loveLetters = [];
        }
        const newLetter = {
            id: 'letter_' + Date.now(),
            senderId: chat.id,
            senderName: chat.name,
            senderAvatar: chat.settings.aiAvatar,
            recipientName: chat.settings.myNickname || '我',
            recipientAvatar: chat.settings.myAvatar,
            content: msgData.content,
            timestamp: Date.now()
        };
        chat.loversSpaceData.loveLetters.push(newLetter);
        console.log(`AI 在情侣空间写了情书: ${msgData.content}`);
    }
    continue; // 继续处理AI可能返回的其他指令
}

// ▼▼▼ 在 switch (msgData.type) 结构内，粘贴这个全新的 case ▼▼▼
case 'ls_diary_entry': {
    const { emoji, diary } = msgData;
    if (emoji && diary) {
        const today = new Date().toISOString().split('T')[0]; // 获取 YYYY-MM-DD 格式的今天日期
        
        // 确保数据结构存在
        if (!chat.loversSpaceData.emotionDiaries) {
            chat.loversSpaceData.emotionDiaries = {};
        }
        if (!chat.loversSpaceData.emotionDiaries[today]) {
            chat.loversSpaceData.emotionDiaries[today] = {};
        }

        // 保存AI的日记和表情
        chat.loversSpaceData.emotionDiaries[today].charEmoji = emoji;
        chat.loversSpaceData.emotionDiaries[today].charDiary = diary;
        
        console.log(`AI 在情侣空间记录了日记: ${emoji} ${diary}`);
    }
    continue; // 这只是一个后台操作，不需要在聊天界面生成消息，所以用 continue 跳过
}
// ▲▲▲ 新增 case 粘贴结束 ▲▲▲

// ▼▼▼ 新增：AI主动评论日记指令 ▼▼▼
case 'ls_diary_comment': {
    const { dateStr, diaryOwner, commentContent } = msgData;
    if (dateStr && diaryOwner && commentContent) {
        // 【修复BUG】确保数据结构存在，但不要覆盖已有数据
        if (!chat.loversSpaceData) {
            chat.loversSpaceData = { emotionDiaries: {} };
        }
        if (!chat.loversSpaceData.emotionDiaries) {
            chat.loversSpaceData.emotionDiaries = {};
        }
        // 【关键修复】不要创建空对象覆盖日记！如果日记不存在就跳过
        if (!chat.loversSpaceData.emotionDiaries[dateStr]) {
            console.warn(`AI尝试评论不存在的日记: ${dateStr}`);
            continue;
        }
        
        const entryData = chat.loversSpaceData.emotionDiaries[dateStr];
        const commentsArray = diaryOwner === 'user' ? 'userComments' : 'charComments';
        
        if (!entryData[commentsArray]) {
            entryData[commentsArray] = [];
        }
        
        // 添加AI的新评论
        const comment = {
            id: 'comment_' + Date.now(),
            author: 'char',
            content: commentContent,
            timestamp: Date.now(),
            replies: [],
            hasUnreadReply: false
        };
        
        entryData[commentsArray].push(comment);
        
        console.log(`AI 在情侣空间评论了日记:`, {
            日期: dateStr,
            日记所有者: diaryOwner,
            评论数组: commentsArray,
            评论内容: commentContent,
            当前日记数据: entryData
        });
        
        // 【修复BUG】保存到数据库
        await db.chats.put(chat);
        
        // 【关键修复】如果用户正在查看这个日记，立即刷新显示
        const currentScreen = document.getElementById('lovers-space-screen');
        const diaryViewerModal = document.getElementById('ls-diary-viewer-modal');
        if (currentScreen && currentScreen.style.display !== 'none' && 
            diaryViewerModal && diaryViewerModal.classList.contains('visible') && 
            window.openDiaryViewer) {
            // 用户正在情侣空间查看日记，刷新显示
            window.openDiaryViewer(dateStr, entryData, chat);
        }
        
        // 发送一条通知消息给用户
        const ownerName = diaryOwner === 'user' ? '你' : 'Ta';
        const notificationMessage = {
            role: 'assistant',
            type: 'lovers_space_notification',
            notificationType: 'comment',
            content: `我刚给${ownerName}的日记写了评论哦~ 💕`,
            timestamp: Date.now()
        };
        chat.history.push(notificationMessage);
        if (isViewingThisChat) {
            appendMessage(notificationMessage, chat);
        }
    }
    continue;
}
// ▲▲▲ AI主动评论指令结束 ▲▲▲

// ▼▼▼ 新增：AI回复日记评论指令 ▼▼▼
case 'ls_diary_comment_reply': {
    const { dateStr, diaryOwner, commentId, replyContent } = msgData;
    if (dateStr && diaryOwner && commentId && replyContent) {
        // 【修复BUG】确保数据结构存在，但不要覆盖已有数据
        if (!chat.loversSpaceData) {
            chat.loversSpaceData = { emotionDiaries: {} };
        }
        if (!chat.loversSpaceData.emotionDiaries) {
            chat.loversSpaceData.emotionDiaries = {};
        }
        // 【关键修复】不要创建空对象覆盖日记！如果日记不存在就跳过
        if (!chat.loversSpaceData.emotionDiaries[dateStr]) {
            console.warn(`AI尝试回复不存在日记的评论: ${dateStr}`);
            continue;
        }
        
        const entryData = chat.loversSpaceData.emotionDiaries[dateStr];
        const commentsArray = diaryOwner === 'user' ? 'userComments' : 'charComments';
        
        if (!entryData[commentsArray]) {
            entryData[commentsArray] = [];
        }
        
        // 查找对应的评论
        const targetComment = entryData[commentsArray].find(c => c.id === commentId);
        if (targetComment) {
            if (!targetComment.replies) {
                targetComment.replies = [];
            }
            
            // 添加AI的回复
            const reply = {
                id: 'reply_' + Date.now(),
                author: 'char',
                content: replyContent,
                timestamp: Date.now()
            };
            
            targetComment.replies.push(reply);
            
            // 标记有新回复（用户会看到）
            if (targetComment.author === 'user') {
                targetComment.hasUnreadReply = true;
            }
            
            console.log(`AI 在情侣空间回复了日记评论: ${replyContent}`);
            
            // 【修复BUG】保存到数据库
            await db.chats.put(chat);
            
            // 【关键修复】如果用户正在查看这个日记，立即刷新显示
            const currentScreen = document.getElementById('lovers-space-screen');
            const diaryViewerModal = document.getElementById('ls-diary-viewer-modal');
            if (currentScreen && currentScreen.style.display !== 'none' && 
                diaryViewerModal && diaryViewerModal.classList.contains('visible') && 
                window.openDiaryViewer) {
                // 用户正在情侣空间查看日记，刷新显示
                window.openDiaryViewer(dateStr, entryData, chat);
            }
            
            // 发送一条通知消息给用户
            const notificationMessage = {
                role: 'assistant',
                type: 'lovers_space_notification',
                notificationType: 'reply',
                content: `我刚给你的评论写了回复哦，快去看看吧~ 💕`,
                timestamp: Date.now()
            };
            chat.history.push(notificationMessage);
            if (isViewingThisChat) {
                appendMessage(notificationMessage, chat);
            }
        }
    }
    continue;
}
// ▲▲▲ AI评论回复指令结束 ▲▲▲

case 'ls_share': {
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.shares) {
            chat.loversSpaceData.shares = [];
        }
        const newShare = {
            author: 'char', // 标记是AI发的
            timestamp: Date.now(),
            ...msgData // 将AI返回的所有分享信息（type, shareType, title, artist等）都复制过来
        };
        chat.loversSpaceData.shares.push(newShare);
        console.log(`AI 在情侣空间分享了 [${msgData.shareType}]: ${msgData.title}`);
    }
    continue; // 同样是后台操作
}
// ▲▲▲ 粘贴结束 ▲▲▲

                // 这是AI主动发起邀请的逻辑
                case 'lovers_space_invitation': {
                    // 检查是否已经开启，防止AI重复邀请
                    if (!chat.loversSpaceData) {
                        aiMessage = {
                            ...baseMessage,
                            type: 'lovers_space_invitation',
                            content: `${chat.name} 向你发出了一个情侣空间邀请`, // 这句话主要用于调试和历史记录
                            status: 'pending' // 状态：pending, accepted, rejected
                        };
                    }
                    // 如果AI已经发了邀请，这里就不再创建aiMessage，相当于跳过
                    break;
                }

                // 这是AI回应你的邀请的逻辑
                case 'lovers_space_response': {
                    const invitationMsg = chat.history.find(m => m.type === 'lovers_space_invitation' && m.status === 'pending');
                    if (invitationMsg) {
                        invitationMsg.status = msgData.decision === 'accept' ? 'accepted' : 'rejected';

                        // 1. 创建AI想说的那句话的消息
                        if (msgData.responseText) {
                            const responseMessage = {
                                ...baseMessage,
                                type: 'text',
                                content: msgData.responseText
                            };
                            chat.history.push(responseMessage);
                            if (isViewingThisChat) {
                                appendMessage(responseMessage, chat);
                            }
                        }

                        // 2. 根据同意或拒绝，执行后续操作
                        if (msgData.decision === 'accept') {
                            // 同意后，为这个角色创建情侣空间数据
                            chat.loversSpaceData = {
                                background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
                                relationshipStartDate: null, moments: [], photos: [], albums: [], loveLetters: [], shares: [], questions: [],
                            };
                            // 并发送一条系统通知
                            const systemNotice = {
                                role: 'system', type: 'pat_message',
                                content: `[系统：你和“${chat.name}”的情侣空间已成功开启！]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(systemNotice);
                            if (isViewingThisChat) {
                                appendMessage(systemNotice, chat);
                            }
                        }
                    }
                    // 处理完后，不再需要生成新的aiMessage，所以用 continue 跳过
                    continue;
                }
                
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 第十五部分：动态中发送naiimag的完整逻辑（支持两张图） ▼▼▼
case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    
    // 如果是realimag类型，生成真实图片URL（支持1-9张图片）
    if (msgData.postType === 'realimag' && msgData.prompt) {
        // 支持 prompt 为数组（多张图片）或字符串（单张图片）
        const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 9) : [msgData.prompt];
        
        // 生成多个图片URL（添加nologo参数去除水印）
        newPost.imageUrls = prompts.map(prompt => {
            const encodedPrompt = encodeURIComponent(prompt);
            return `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&width=1024&height=1024`;
        });
        
        // 保持向后兼容，单张图片时也设置 imageUrl
        if (prompts.length === 1) {
            newPost.imageUrl = newPost.imageUrls[0];
        }
        
        newPost.prompt = msgData.prompt;
        newPost.imageCount = prompts.length;
        console.log(`动态RealImag图片生成: ${prompts.length}张`, newPost.imageUrls);
    }
    
    // 如果是naiimag类型，调用NovelAI API生成高质量图片（限制最多2张）
    if (msgData.postType === 'naiimag' && msgData.prompt) {
        try {
            // 支持 prompt 为数组（多张图片）或字符串（单张图片）
            // 动态限制最多2张NAI图片
            const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 2) : [msgData.prompt];
            console.log(`📸 动态NovelAI图片生成开始，共${prompts.length}张图片`);
            
            // 存储生成的图片URL
            const generatedImageUrls = [];
            
            // 逐个生成图片
            for (let i = 0; i < prompts.length; i++) {
                const aiPrompt = prompts[i];
                console.log(`生成第${i+1}张图片，prompt:`, aiPrompt);
                
                // 获取角色的NAI提示词配置（系统或角色专属）
                const naiPrompts = getCharacterNAIPrompts(chat.id);
                
                // 构建最终的提示词：AI的prompt + 配置的提示词
                const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                const finalNegativePrompt = naiPrompts.negative;
                
                console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
                console.log('最终正面提示词:', finalPositivePrompt);
                console.log('最终负面提示词:', finalNegativePrompt);
                
                // 获取NAI设置（从localStorage读取）
                const apiKey = localStorage.getItem('novelai-api-key');
                const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                const settings = getNovelAISettings();
                
                if (!apiKey) {
                    throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
                }
                
                const [width, height] = settings.resolution.split('x').map(Number);
                
                // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
                let requestBody;
                
                if (model.includes('nai-diffusion-4')) {
                    // V4/V4.5 使用新格式 (params_version: 3)
                    requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            params_version: 3,  // V4必须使用版本3
                            width: width,
                            height: height,
                            scale: settings.cfg_scale,
                            sampler: settings.sampler,
                            steps: settings.steps,
                            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                            n_samples: 1,
                            ucPreset: settings.uc_preset,
                            qualityToggle: settings.quality_toggle,
                            autoSmea: false,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: true,
                            cfg_rescale: 0,
                            noise_schedule: 'karras',  // V4使用karras
                            legacy_v3_extend: false,
                            skip_cfg_above_sigma: null,
                            use_coords: false,
                            legacy_uc: false,
                            normalize_reference_strength_multiple: true,
                            inpaintImg2ImgStrength: 1,
                            characterPrompts: [],
                            // V4专用提示词格式
                            v4_prompt: {
                                caption: {
                                    base_caption: finalPositivePrompt,
                                    char_captions: []
                                },
                                use_coords: false,
                                use_order: true
                            },
                            // V4专用负面提示词格式
                            v4_negative_prompt: {
                                caption: {
                                    base_caption: finalNegativePrompt,
                                    char_captions: []
                                },
                                legacy_uc: false
                            },
                            negative_prompt: finalNegativePrompt,
                            deliberate_euler_ancestral_bug: false,
                            prefer_brownian: true
                            // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                        }
                    };
                } else {
                    // V3 及更早版本使用旧格式
                    requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            width: width,
                            height: height,
                            scale: settings.cfg_scale,
                            sampler: settings.sampler,
                            steps: settings.steps,
                            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                            n_samples: 1,
                            ucPreset: settings.uc_preset,
                            qualityToggle: settings.quality_toggle,
                            sm: settings.smea,
                            sm_dyn: settings.smea_dyn,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: false,
                            cfg_rescale: 0,
                            noise_schedule: 'native',
                            negative_prompt: finalNegativePrompt
                        }
                    };
                }
                
                console.log('🚀 发送NAI请求:', requestBody);
                
                // ★★★ 根据模型选择不同的API端点 ★★★
                let apiUrl;
                
                // V4/V4.5 模型使用流式端点
                if (model.includes('nai-diffusion-4')) {
                    // V4/V4.5 默认使用流式端点
                    apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
                } else {
                    // V3 及更早版本使用标准端点
                    apiUrl = 'https://image.novelai.net/ai/generate-image';
                }
                
                let corsProxy = settings.cors_proxy;
                
                // 如果选择了自定义代理，使用自定义URL
                if (corsProxy === 'custom') {
                    corsProxy = settings.custom_proxy_url || '';
                }
                
                // 如果有代理，添加到URL前面
                if (corsProxy && corsProxy !== '') {
                    apiUrl = corsProxy + encodeURIComponent(apiUrl);
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API错误响应:', errorText);
                    throw new Error(`API请求失败 (${response.status}): ${errorText}`);
                }
                
                // NovelAI API返回的是ZIP文件，需要解压
                const contentType = response.headers.get('content-type');
                console.log('Content-Type:', contentType);
                
                // 检查是否为 SSE 流式响应
                let zipBlob;
                let imageDataUrl;
                if (contentType && contentType.includes('text/event-stream')) {
                    console.log('检测到 SSE 流式响应，开始解析...');
                    
                    // 读取整个流
                    const text = await response.text();
                    console.log('收到 SSE 数据，大小:', text.length);
                    
                    // 解析 SSE 格式，提取最后的 data: 行
                    const lines = text.trim().split('\n');
                    let base64Data = null;
                    
                    for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i].trim();
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            const dataContent = line.substring(6); // 移除 'data: ' 前缀
                            
                            // 尝试解析 JSON
                            try {
                                const jsonData = JSON.parse(dataContent);
                                
                                // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                                if (jsonData.event_type === 'final' && jsonData.image) {
                                    base64Data = jsonData.image;
                                    console.log('✅ 找到 final 事件的图片数据');
                                    break;
                                }
                                
                                // 兼容其他格式
                                if (jsonData.data) {
                                    base64Data = jsonData.data;
                                    console.log('从 JSON.data 中提取图片数据');
                                    break;
                                }
                                if (jsonData.image) {
                                    base64Data = jsonData.image;
                                    console.log('从 JSON.image 中提取图片数据');
                                    break;
                                }
                            } catch (e) {
                                // 如果不是 JSON，直接作为 base64 数据
                                base64Data = dataContent;
                                console.log('直接使用 base64 数据');
                                break;
                            }
                        }
                    }
                    
                    if (!base64Data) {
                        throw new Error('无法从 SSE 响应中提取图片数据');
                    }
                    
                    // V4.5 流式端点返回的是 PNG base64，不是 ZIP
                    // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
                    const isPNG = base64Data.startsWith('iVBORw0KGgo');
                    const isJPEG = base64Data.startsWith('/9j/');
                    
                    if (isPNG || isJPEG) {
                        console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                        // 将 base64 转为 Blob
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                        console.log('图片 Blob 创建成功，大小:', imageBlob.size);
                        
                        // 转换为dataURL用于后续处理
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        console.log('✅ 图片转换成功！🎨');
                    } else {
                        // 否则当作 ZIP 处理
                        console.log('当作 ZIP 文件处理...');
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        zipBlob = new Blob([bytes]);
                        console.log('ZIP Blob 大小:', zipBlob.size);
                    }
                } else {
                    // 非流式响应，直接读取
                    zipBlob = await response.blob();
                    console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
                }
                
                // 如果还没有imageDataUrl（即需要解压ZIP）
                if (!imageDataUrl && zipBlob) {
                    // NovelAI始终返回ZIP格式，需要解压
                    try {
                        // 检查JSZip是否已加载
                        if (typeof JSZip === 'undefined') {
                            throw new Error('JSZip库未加载，请刷新页面重试');
                        }
                        
                        // 解压ZIP文件
                        const zip = await JSZip.loadAsync(zipBlob);
                        console.log('ZIP文件内容:', Object.keys(zip.files));
                        
                        // 查找第一个图片文件（通常是image_0.png）
                        let imageFile = null;
                        for (let filename in zip.files) {
                            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                imageFile = zip.files[filename];
                                console.log('找到图片文件:', filename);
                                break;
                            }
                        }
                        
                        if (!imageFile) {
                            throw new Error('ZIP文件中未找到图片');
                        }
                        
                        // 提取图片数据
                        const imageBlob = await imageFile.async('blob');
                        console.log('提取的图片大小:', imageBlob.size);
                        
                        // 创建图片URL
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        console.log('✅ 图片解压成功！');
                    } catch (zipError) {
                        console.error('ZIP解压失败:', zipError);
                        throw new Error('图片解压失败: ' + zipError.message);
                    }
                }
                
                console.log(`✅ NAI图片${i+1}生成成功！`);
                generatedImageUrls.push(imageDataUrl);
            }
            
            // 将生成的图片URL保存到动态中
            newPost.imageUrls = generatedImageUrls;
            
            // 保持向后兼容，单张图片时也设置 imageUrl
            if (generatedImageUrls.length === 1) {
                newPost.imageUrl = generatedImageUrls[0];
            }
            
            newPost.prompt = msgData.prompt;
            newPost.imageCount = generatedImageUrls.length;
            console.log(`✅ 动态NovelAI图片全部生成完成: ${generatedImageUrls.length}张`);
        } catch (error) {
            console.error('❌ 动态NAI图片生成失败:', error);
            // 失败时仍然发布动态，但添加错误信息
            newPost.content = (newPost.content || newPost.publicText || '') + `\n[图片生成失败: ${error.message}]`;
        }
    }
    
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;
// ▲▲▲ 第十五部分结束 ▲▲▲

// ▼▼▼ 步骤3.4：在 triggerAiResponse 中替换这个 case ▼▼▼
case 'qzone_comment':
    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
    if (postToComment) {
        if (!postToComment.comments) postToComment.comments = [];
        
        const newAiComment = { 
            commenterName: msgData.commenterName || chat.name,
            text: msgData.commentText, 
            timestamp: Date.now() 
        };
        
        // 【核心修改】检查AI是否指定了回复对象
        if (msgData.replyTo) {
            newAiComment.replyTo = msgData.replyTo;
        }

        postToComment.comments.push(newAiComment);
        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
        updateUnreadIndicator(unreadPostsCount + 1);
        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
           await renderQzonePosts();
        }
    }
    continue;
// ▲▲▲ 步骤3.4替换结束 ▲▲▲

// ▼▼▼ 第十七部分：群聊中发送naiimag的完整逻辑 ▼▼▼
case 'naiimag':
    // NovelAI图片分享 - 调用NovelAI API生成高质量图片
    try {
        console.log('📸 NovelAI图片生成开始，AI提供的prompt:', msgData.prompt);
        
        // 获取角色的NAI提示词配置（系统或角色专属）
        const naiPrompts = getCharacterNAIPrompts(chat.id);
        
        // 构建最终的提示词：AI的prompt + 配置的提示词
        const aiPrompt = msgData.prompt || 'a beautiful scene';
        const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
        const finalNegativePrompt = naiPrompts.negative;
        
        console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
        console.log('最终正面提示词:', finalPositivePrompt);
        console.log('最终负面提示词:', finalNegativePrompt);
        
        // 获取NAI设置（从localStorage读取）
        const apiKey = localStorage.getItem('novelai-api-key');
        const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
        const settings = getNovelAISettings();
        
        if (!apiKey) {
            throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
        }
        
        const [width, height] = settings.resolution.split('x').map(Number);
        
        // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
        let requestBody;
        
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 使用新格式 (params_version: 3)
            requestBody = {
                input: finalPositivePrompt,
                model: model,
                action: 'generate',
                parameters: {
                    params_version: 3,  // V4必须使用版本3
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras',  // V4使用karras
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                    // V4专用提示词格式
                    v4_prompt: {
                        caption: {
                            base_caption: finalPositivePrompt,
                            char_captions: []
                        },
                        use_coords: false,
                        use_order: true
                    },
                    // V4专用负面提示词格式
                    v4_negative_prompt: {
                        caption: {
                            base_caption: finalNegativePrompt,
                            char_captions: []
                        },
                        legacy_uc: false
                    },
                    negative_prompt: finalNegativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                    // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                }
            };
        } else {
            // V3 及更早版本使用旧格式
            requestBody = {
                input: finalPositivePrompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: finalNegativePrompt
                }
            };
        }
        
        console.log('🚀 发送NAI请求:', requestBody);
        
        // ★★★ 根据模型选择不同的API端点 ★★★
        let apiUrl;
        
        // V4/V4.5 模型使用流式端点
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 默认使用流式端点
            apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
        } else {
            // V3 及更早版本使用标准端点
            apiUrl = 'https://image.novelai.net/ai/generate-image';
        }
        
        let corsProxy = settings.cors_proxy;
        
        // 如果选择了自定义代理，使用自定义URL
        if (corsProxy === 'custom') {
            corsProxy = settings.custom_proxy_url || '';
        }
        
        // 如果有代理，添加到URL前面
        if (corsProxy && corsProxy !== '') {
            apiUrl = corsProxy + encodeURIComponent(apiUrl);
        }
        
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify(requestBody)
        });
        
        console.log('Response status:', response.status);
        console.log('Response headers:', [...response.headers.entries()]);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('API错误响应:', errorText);
            throw new Error(`API请求失败 (${response.status}): ${errorText}`);
        }
        
        // NovelAI API返回的是ZIP文件，需要解压
        const contentType = response.headers.get('content-type');
        console.log('Content-Type:', contentType);
        
        // 检查是否为 SSE 流式响应
        let zipBlob;
        let imageDataUrl;
        if (contentType && contentType.includes('text/event-stream')) {
            console.log('检测到 SSE 流式响应，开始解析...');
            
            // 读取整个流
            const text = await response.text();
            console.log('收到 SSE 数据，大小:', text.length);
            
            // 解析 SSE 格式，提取最后的 data: 行
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); // 移除 'data: ' 前缀
                    
                    // 尝试解析 JSON
                    try {
                        const jsonData = JSON.parse(dataContent);
                        
                        // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('✅ 找到 final 事件的图片数据');
                            break;
                        }
                        
                        // 兼容其他格式
                        if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('从 JSON.data 中提取图片数据');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('从 JSON.image 中提取图片数据');
                            break;
                        }
                    } catch (e) {
                        // 如果不是 JSON，直接作为 base64 数据
                        base64Data = dataContent;
                        console.log('直接使用 base64 数据');
                        break;
                    }
                }
            }
            
            if (!base64Data) {
                throw new Error('无法从 SSE 响应中提取图片数据');
            }
            
            // V4.5 流式端点返回的是 PNG base64，不是 ZIP
            // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                // 将 base64 转为 Blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                console.log('图片 Blob 创建成功，大小:', imageBlob.size);
                
                // 转换为dataURL用于后续处理
                const reader = new FileReader();
                imageDataUrl = await new Promise((resolve, reject) => {
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                });
                console.log('✅ 图片转换成功！🎨');
            } else {
                // 否则当作 ZIP 处理
                console.log('当作 ZIP 文件处理...');
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                zipBlob = new Blob([bytes]);
                console.log('ZIP Blob 大小:', zipBlob.size);
            }
        } else {
            // 非流式响应，直接读取
            zipBlob = await response.blob();
            console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
        }
        
        // 如果还没有imageDataUrl（即需要解压ZIP）
        if (!imageDataUrl && zipBlob) {
            // NovelAI始终返回ZIP格式，需要解压
            try {
                // 检查JSZip是否已加载
                if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip库未加载，请刷新页面重试');
                }
                
                // 解压ZIP文件
                const zip = await JSZip.loadAsync(zipBlob);
                console.log('ZIP文件内容:', Object.keys(zip.files));
                
                // 查找第一个图片文件（通常是image_0.png）
                let imageFile = null;
                for (let filename in zip.files) {
                    if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                        imageFile = zip.files[filename];
                        console.log('找到图片文件:', filename);
                        break;
                    }
                }
                
                if (!imageFile) {
                    throw new Error('ZIP文件中未找到图片');
                }
                
                // 提取图片数据
                const imageBlob = await imageFile.async('blob');
                console.log('提取的图片大小:', imageBlob.size);
                
                // 创建图片URL
                const reader = new FileReader();
                imageDataUrl = await new Promise((resolve, reject) => {
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                });
                console.log('✅ 图片解压成功！');
            } catch (zipError) {
                console.error('ZIP解压失败:', zipError);
                throw new Error('图片解压失败: ' + zipError.message);
            }
        }
        
        console.log('✅ NAI图片生成成功！');
        
        // 创建naiimag消息
        aiMessage = { 
            ...baseMessage, 
            type: 'naiimag', 
            imageUrl: imageDataUrl,
            prompt: aiPrompt,
            fullPrompt: finalPositivePrompt // 保存完整提示词供查看
        };
    } catch (error) {
        console.error('❌ NAI图片生成失败:', error);
        // 失败时降级为文本消息
        aiMessage = { 
            ...baseMessage, 
            content: `[图片生成失败: ${error.message}]` 
        };
    }
    break;
// ▲▲▲ 第十七部分结束 ▲▲▲

                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal(chatId); // <--- 把chatId作为参数传进去
    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
// ▼▼▼ 用这段新代码替换掉上面那段 ▼▼▼
const hiddenMessage = {
    role: 'system',
    content: `[系统最高指令]
# 任务：回应情侣空间邀请
用户刚刚向你发起了“开启情侣空间”的邀请。你【必须】根据你的人设，决定是同意还是拒绝。

# 输出格式铁律 (必须严格遵守)
你的回复【必须且只能】是【一个】JSON对象，格式如下:
{"type": "lovers_space_response", "decision": "accept" 或 "reject", "responseText": "你想说的话..."}

# 示例
- 如果同意: {"type": "lovers_space_response", "decision": "accept", "responseText": ""}
- 如果拒绝: {"type": "lovers_space_response", "decision": "reject", "responseText": ""}

现在，请立即做出你的决定。`,
    timestamp: Date.now() + 1,
    isHidden: true
};
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
// ▼▼▼ 请用这块【功能完整且已修复】的代码，完整替换你旧的 case 'poll' 代码块 ▼▼▼
case 'poll': {
    // 【核心修复】在这里，我们同时处理来自AI和用户的投票消息
    let pollInfoText = '';
    
    // 判断这条投票消息是谁发的
    if (msg.role === 'user') {
        const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        pollInfoText = `[系统提示：用户 (${myNickname}) 发起了一个投票。问题：“${msg.question}”, 选项：“${msg.options.join('", "')}”。你可以使用 'vote' 指令参与投票。]`;
    } else { // 如果是AI发的
        pollInfoText = `[系统提示：${msg.senderName} 发起了一个投票。问题：“${msg.question}”, 选项：“${msg.options.join('", "')}”。]`;
    }

    // 最终，我们把这条格式化好的文本作为系统消息发送给AI
    // 注意：这里我们返回的是一个新对象，而不是修改原始的aiMessage
    // 因此，我们将它放在了messagesPayload的构建循环里
    aiMessage = { role: 'system', content: pollInfoText, isHidden: true };
    break; // break不能少
}
// ▲▲▲ 替换结束 ▲▲▲      
// ▼▼▼ 请用这块【功能完整且已修复】的代码，完整替换你旧的 case 'vote' 代码块 ▼▼▼
case 'vote': { // 使用大括号创建独立的块级作用域
    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
    
    // 安全检查：如果投票不存在或已关闭，则不处理
    if (pollToVote && !pollToVote.isClosed) {
        
        // --- 核心修复逻辑从这里开始 ---

        // 1. 【首先】根据AI的“本名”，找到其成员对象，并获取正确的“群昵称”
        const member = chat.members.find(m => m.originalName === msgData.name);
        const displayName = member ? member.groupNickname : msgData.name;

        // 2. 【然后】使用正确的“群昵称”去移除该角色之前的所有投票
        Object.keys(pollToVote.votes).forEach(option => {
            const voterIndex = pollToVote.votes[option].indexOf(displayName); // 使用 displayName
            if (voterIndex > -1) {
                pollToVote.votes[option].splice(voterIndex, 1);
            }
        });

        // 3. 【最后】将“群昵称”添加到新的选项中
        if (!pollToVote.votes[msgData.choice]) {
            pollToVote.votes[msgData.choice] = [];
        }
        
        // （可选但推荐）再次检查，避免意外重复添加
        if (!pollToVote.votes[msgData.choice].includes(displayName)) {
            pollToVote.votes[msgData.choice].push(displayName);
        }

        // --- 核心修复逻辑结束 ---
        
        // 如果用户正在看这个聊天，就刷新界面让他们看到变化
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    // 这是一个后台操作，不需要生成新的消息，所以用 continue
    continue;
}
// ▲▲▲ 替换结束 ▲▲▲
    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
                // ▼▼▼ 在这里添加新代码 ▼▼▼
        // 【全新】同步到角色钱包（支出）
        const rpDescription = `发出红包 - ${msgData.greeting || '恭喜发财'}`;
        await updateCharacterBankBalance(chatId, -msgData.amount, rpDescription);
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        break;
// ▼▼▼ 用这整块【最终修复版】代码，完整替换掉你旧的 case 'open_red_packet' 代码块 ▼▼▼
case 'open_red_packet': { // 使用大括号创建独立的块级作用域
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    // 检查红包是否存在、是否没被领完、以及这个AI角色是否还没领过
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 【核心修复】根据AI的本名(msgData.name)，从成员列表找到其正确的群昵称
        const member = chat.members.find(m => m.originalName === msgData.name);
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { // 如果是最后一个
                claimedAmountAI = remainingAmount;
            } else { // 如果不是最后一个，随机分配
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            // 2. 确保 claimedBy 对象存在
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 3. 【核心修复】使用我们刚刚查找到的 displayName 作为记录的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
            
            // 4. 发送对用户可见的系统消息
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修复】系统消息里也使用 displayName
                content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;

            // 5. 【【【这就是最关键的部分！】】】检查红包是否被领完
            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true; // 标记为已领完
                
                // 发送对用户可见的“已领完”通知
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的红包已被领完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                // 开始构建给AI看的“战报”
                hiddenContentForAI += ` 红包已被领完。`;

                // 如果是拼手气红包，找出谁是手气王
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                // 把手气王信息也加到“战报”里
                if (luckyKing.name) {
                     hiddenContentForAI += ` 手气王是 ${luckyKing.name}！`;
                }
            }
            hiddenContentForAI += ' 请根据这个结果发表你的评论。]';

            // 6. 创建并添加给AI看的隐藏消息
            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2, // 确保时间戳在后
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        // 7. 刷新UI（如果用户正在看的话）
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue; // 这是一个后台操作，继续处理AI可能返回的其他消息
}
// ▲▲▲ 替换结束 ▲▲▲


case 'change_avatar':
    const avatarName = msgData.name;
    // 在该角色的头像库中查找
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 找到了，就更新头像
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 创建一条系统提示，告知用户头像已更换
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[${chat.name} 更换了头像]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                        
                        // ▼▼▼ 在这里添加新代码 ▼▼▼
                        // 【全新】同步到角色钱包（收入）
                        const acceptDescription = `收到来自 ${originalMsg.senderName} 的转账`;
                        await updateCharacterBankBalance(chatId, originalMsg.amount, acceptDescription);
                        // ▲▲▲ 新代码粘贴结束 ▲▲▲
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【新增】退款给用户 - CHAR拒绝了用户的转账，需要退还金额
                        const refundNote = originalMsg.note ? ` (备注: ${originalMsg.note})` : '';
                        const refundDescription = `退款: ${chat.name} 拒收转账${refundNote}`;
                        await updateUserBalanceAndLogTransaction(originalMsg.amount, refundDescription);
                        
                        // 【核心】创建一条新的"退款"消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 标记这是一条退款消息
                            amount: originalMsg.amount,
                            note: '转账已被拒收',
                            timestamp: messageTimestamp++ // 使用递增的时间戳
                        };
                        
                        // 将新消息推入历史记录，它会被后续的循环处理并渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        if (isViewingThisChat) {
            // 因为退款消息是新生成的，所以我们直接将它添加到界面上
            appendMessage(refundMessage, chat); 
            // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加结束 ▲▲▲

                    }
                    continue; // 继续处理AI返回的文本消息
                }

// ▲▲▲ 添加结束 ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 这是文章正文，点击卡片后显示的内容
                    };
                    break;

// ▲▲▲ 添加结束 ▲▲▲

case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || ''), // 核心修复：移除了 .substring(0, 50)
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext
        };
    } else {
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;


case 'location':
    aiMessage = {
        ...baseMessage,
        type: 'location',
        userLocation: msgData.userLocation,
        aiLocation: msgData.aiLocation,
        distance: msgData.distance,
        trajectoryPoints: msgData.trajectoryPoints || [] // 【新增】确保即使AI没提供，也是一个空数组
    };
    break;
// ▲▲▲ 替换结束 ▲▲▲

case 'send_and_recall': {
    // --- 动画部分 (保持不变) ---
    if (!isViewingThisChat) continue;
    const tempMessageData = { ...baseMessage, content: msgData.content };
    appendMessage(tempMessageData, chat, true);
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
    if (bubbleWrapper) {
        bubbleWrapper.classList.add('recalled-animation');
        await new Promise(resolve => setTimeout(resolve, 300));
    }

    // --- 核心修改：数据记录与AI感知 ---
    
    // 1. 创建对用户可见的“已撤回”消息
    const recalledMessage = {
        role: 'assistant',
        senderName: msgData.name || chat.name,
        type: 'recalled_message',
        content: '对方撤回了一条消息',
        timestamp: tempMessageData.timestamp,
        recalledData: { originalType: 'text', originalContent: msgData.content }
    };
    
    // 2. 【关键】创建一条对用户隐藏、但对AI可见的“记忆”消息
    const hiddenMemoryMessage = {
        role: 'system', // 必须是 system，这样AI才知道这是上下文信息
        content: `[系统提示：你刚刚说了一句“${msgData.content}”，但立刻就撤回了它。]`,
        timestamp: tempMessageData.timestamp + 1, // 确保在撤回消息之后
        isHidden: true // 这个标记让它不在UI上显示
    };

    // 3. 将这两条消息都添加到历史记录中
    chat.history.push(recalledMessage, hiddenMemoryMessage);
    
    // 4. 替换DOM，显示“已撤回”提示
    const placeholder = createMessageElement(recalledMessage, chat);
    if(document.body.contains(bubbleWrapper)) {
        bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
    }
    
    continue;
}
                
case 'sticker': {
    // 这是为群聊和单聊统一设计的表情包逻辑
    const stickerName = msgData.sticker_name; // 关键修改：统一使用 sticker_name
    if (!stickerName) {
        console.warn('AI返回了sticker类型但没有sticker_name，已拦截:', msgData);
        continue; // 跳过这条无效指令
    }
    
    // 在所有可用表情库中查找
    const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
    const foundSticker = allStickers.find(s => s.name === stickerName);

    if (foundSticker) {
        // 找到了，就创建消息对象
        aiMessage = { 
            ...baseMessage, 
            type: 'sticker', 
            content: foundSticker.url, 
            meaning: foundSticker.name 
        };
    } else {
        // 没找到，说明AI幻觉了，记录警告并跳过
        console.warn(`AI杜撰了不存在的表情: "${stickerName}"，已自动拦截。`);
    }
    break;
}
            case 'text': { 
                const messageText = String(msgData.content || msgData.message || '');
                
                if (STICKER_REGEX.test(messageText)) {
                    aiMessage = { ...baseMessage, type: 'sticker', content: messageText, meaning: '' };
                } 
                else {
                    // 兼容旧的[sticker:名字]格式，但新prompt已不推荐
                    const stickerMatch = messageText.match(/^\[sticker:(.+?)\]$/); 
                    if (stickerMatch) {
                        const stickerName = stickerMatch[1].trim();
                        const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
                        const foundSticker = allStickers.find(s => s.name === stickerName);
                        
                        if (foundSticker) {
                            aiMessage = { ...baseMessage, type: 'sticker', content: foundSticker.url, meaning: foundSticker.name };
                        } else {
                            console.warn(`AI使用了旧格式且杜撰了不存在的表情: "${stickerName}"，已拦截。`);
                        }
                    } else {
                        aiMessage = { ...baseMessage, content: messageText };
                    }
                }
                break;
            }
// ▼▼▼ 在 switch (msgData.type) 结构内，粘贴这整块新代码 ▼▼▼

case 'dating_payment_response': {
    const originalRequest = chat.history.filter(m => m.role === 'system' && m.content.includes("dating_payment_response")).pop();
    if (!originalRequest) continue;

    const costMatch = originalRequest.content.match(/费用（(\d+(\.\d+)?)金币）/);
    const cost = costMatch ? parseFloat(costMatch[1]) : 0;
    
    if (msgData.decision === 'accept') {
        const charBalance = chat.characterPhoneData.bank.balance || 0;
        if (charBalance >= cost) {
            await updateCharacterPhoneBankBalance(chat.id, -cost, `约会支出: 为用户买单`);
            aiMessage = { ...baseMessage, content: msgData.responseText || "好呀，这次我来请客吧！" };
        } else {
            aiMessage = { ...baseMessage, content: msgData.responseText || "呜呜，我也想请客，但是钱包好像不太够呢..." };
        }
    } else {
        aiMessage = { ...baseMessage, content: msgData.responseText || "这次还是算了吧..." };
    }
    break;
}

case 'dating_aa_response': {
    const originalRequest = chat.history.filter(m => m.role === 'system' && m.content.includes("dating_aa_response")).pop();
    if (!originalRequest) continue;

    const costMatch = originalRequest.content.match(/各自支付 (\d+(\.\d+)?) 金币/);
    const splitCost = costMatch ? parseFloat(costMatch[1]) : 0;

    if (msgData.decision === 'accept') {
        const charBalance = chat.characterPhoneData.bank.balance || 0;
        if (charBalance >= splitCost) {
            await updateUserBalanceAndLogTransaction(-splitCost, `约会AA支出`);
            await updateCharacterPhoneBankBalance(chat.id, -splitCost, `约会AA支出`);
            aiMessage = { ...baseMessage, content: msgData.responseText || "好啊，AA制完全没问题！" };
        } else {
            aiMessage = { ...baseMessage, content: msgData.responseText || "这个...我的钱好像不太够付我自己的那份呢。" };
        }
    } else {
        aiMessage = { ...baseMessage, content: msgData.responseText || "我觉得AA制有点太见外了，还是我来请吧？或者你请？" };
    }
    break;
}

case 'lend_money_response': {
    const originalRequest = chat.history.filter(m => m.role === 'system' && m.content.includes("lend_money_response")).pop();
    if (!originalRequest) continue;

    const amountMatch = originalRequest.content.match(/借 (\d+(\.\d+)?) 金币/);
    const amount = amountMatch ? parseFloat(amountMatch[1]) : 0;

    // 只处理接受借款时的金钱逻辑
    if (msgData.decision === 'accept') {
        const lenderBalance = chat.characterPhoneData.bank.balance || 0;
        if (lenderBalance >= amount) {
            await updateCharacterPhoneBankBalance(chat.id, -amount, `借钱给用户`);
            await updateUserBalanceAndLogTransaction(amount, `从 ${chat.name} 处借款`);
        } else {
            // 如果AI决定同意但钱不够，我们信任AI会在下一条消息中解释。
            // 这里的金融逻辑可以做得更复杂，但目前保持简单，相信AI的判断。
            console.warn(`AI "${chat.name}" 同意借钱，但余额不足，交易未执行。`);
        }
    } 
    // 如果是拒绝(reject)，则不执行任何金融操作。

    // 【核心修改】我们不再在这里创建任何 aiMessage。
    // 使用 'continue' 跳到AI回复数组的下一项，也就是AI自己生成的文本消息，让循环的后续部分去处理它。
    continue;
}
// ▼▼▼ 请用这块【最终修复版】代码，替换旧的 case 'forum_comment' 代码块 ▼▼▼

case 'forum_comment': { // 使用大括号创建块级作用域
    const postIdToComment = msgData.postId;
    const commentText = msgData.commentText;

    if (postIdToComment && commentText) {
        // 1. 【健壮性修复】尝试将 postId 强制转换为数字。
        //    这能解决AI返回数字字符串（如"123"）导致查询失败的问题。
        const numericPostId = parseInt(postIdToComment, 10);
        
        // 检查转换后的ID是否有效
        if (isNaN(numericPostId)) {
            console.warn(`[圈子评论失败] 收到的 postId "${postIdToComment}" 不是一个有效的数字ID，已跳过。`);
            // 提示：如果频繁看到此警告，请检查你给AI的system prompt，确保你要求它返回数字ID。
            continue; // 跳过此指令
        }
        
        // 2. 【数据存储】使用正确的数字ID从数据库获取帖子
        const postToComment = await db.forumPosts.get(numericPostId);

        if (postToComment) {
            // 创建新评论对象
            const newComment = {
                postId: numericPostId, // 使用转换后的数字ID
                author: chat.name, // 评论者就是当前AI
                content: commentText,
                timestamp: Date.now()
            };
            
            // 将新评论保存到数据库
            await db.forumComments.add(newComment);
            console.log(`AI "${chat.name}" 评论了帖子 #${numericPostId}: "${commentText}"`);

            // 3. 【UI刷新修复】同时检查帖子列表页和帖子详情页
            //    这样无论你正在看哪个页面，都能看到更新。
            
            // 如果用户正在看这个小组的帖子列表，就刷新列表
            if (document.getElementById('group-screen').classList.contains('active') && activeGroupId === postToComment.groupId) {
                await renderGroupPosts(activeGroupId);
            }
            
            // 如果用户正在看这个帖子的详情页，就刷新详情页（这是本次修复的关键！）
            if (document.getElementById('post-screen').classList.contains('active') && activeForumPostId === numericPostId) {
                await renderPostDetails(numericPostId);
            }
        } else {
            console.warn(`[圈子评论失败] 未能在数据库中找到 postId 为 ${numericPostId} 的帖子。`);
        }
    }
    // 无论成功与否，这都是一个后台操作，继续处理AI可能返回的其他指令
    continue;
}

// ▲▲▲ 替换结束 ▲▲▲


                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                                        // ▼▼▼ 在这里添加新代码 ▼▼▼
                    // 【全新】同步到角色钱包（支出）
                    const transferDescription = `转账给 ${msgData.receiver || '我'}`;
                    await updateCharacterBankBalance(chatId, -msgData.amount, transferDescription);
                    // ▲▲▲ 新代码粘贴结束 ▲▲▲
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("收到了未知的AI指令类型:", msgData.type);
                     break;
            }

            // 【核心修复】将渲染逻辑移出循环
            if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        case 'sticker':
                            notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 确保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }        

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }
        playNotificationSound();
        await db.chats.put(chat);
checkAndTriggerSummary(chatId);

// --- 【全新】续火花逻辑 ---
if (await updateStreak(chatId)) {
    // 如果火花天数发生了变化，就刷新聊天列表
    renderChatList();
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
        } else {
            const errorContent = `[出错了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "系统消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
        // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
        if (chat.isGroup) {
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        } else {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
    }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat);checkAndTriggerSummary(state.activeChatId);  appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }
// ▼▼▼ 用这块【功能增强版】代码替换旧的 sendUserTransfer 函数 ▼▼▼
async function sendUserTransfer() { 
    if (!state.activeChatId) return; 
    
    const amountInput = document.getElementById('transfer-amount'); 
    const noteInput = document.getElementById('transfer-note'); 
    const amount = parseFloat(amountInput.value); 
    const note = noteInput.value.trim(); 
    
    if (isNaN(amount) || amount <= 0) { 
        alert('请输入有效的金额！'); 
        return; 
    } 

    // 【核心新增1】检查余额是否足够
    if ((state.globalSettings.userBalance || 0) < amount) {
        alert('余额不足！');
        return;
    }

    const chat = state.chats[state.activeChatId]; 
    const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; 
    const receiverName = chat.isGroup ? '群聊' : chat.name; 

    // 准备交易描述，包含收款人和备注（如果有）
    const transferNote = note ? ` (备注: ${note})` : '';
    const description = `转账给 ${receiverName}${transferNote}`;
    
    // 【核心新增2】调用我们的新函数来扣款并记录
    await updateUserBalanceAndLogTransaction(-amount, description);

    const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; 
    chat.history.push(msg); 
    
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    document.getElementById('transfer-modal').classList.remove('visible'); 
    amountInput.value = ''; 
    noteInput.value = ''; 
}
// ▲▲▲ 替换结束 ▲▲▲
        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在这里添加这行代码
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { 

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    const cleanupLogic = async () => {

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation(() => {

        if (musicState.isActive && lyricsBarSettings.showOnClose) {
            document.getElementById('floating-lyrics-bar').style.display = 'flex';
        }
    });
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://chatbotcos.weixin.qq.com/chatbot/30-openaiassets_63e04c67410237fa43bf6fcce542dbff_469401762321466866.png'; iconImg.className = ''; return; } iconImg.src = 'https://cdn.jsdelivr.net.cn/gh/qdqqd/tc_temp/jli60izy2n.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
            updateListenTogetherIcon(musicState.activeChatId);
            updateElapsedTimeDisplay();
            const titleEl = document.getElementById('music-player-song-title');
            const artistEl = document.getElementById('music-player-artist');
            const playPauseBtn = document.getElementById('music-play-pause-btn');
            const chat = state.chats[musicState.activeChatId];
            const charAvatarEl = document.getElementById('music-char-avatar');
            const userAvatarEl = document.getElementById('music-user-avatar');
            const albumCoverEl = document.getElementById('music-album-cover');
            const avatarsContainer = document.getElementById('music-avatars-container');
            const displayArea = document.getElementById('music-display-area');

            // 1. 【核心修改】在这里判断是群聊还是单聊，并设置正确的头像
            if (chat) {
                // 如果是群聊
                if (chat.isGroup) {
                    // 左边的头像就用群头像
                    charAvatarEl.src = chat.settings.groupAvatar || defaultGroupAvatar;
                } else {
                    // 否则（是单聊），就用角色的头像
                    charAvatarEl.src = chat.settings.aiAvatar || defaultAvatar;
                }
                // 右边的用户头像保持不变
                userAvatarEl.src = chat.settings.myAvatar || defaultAvatar;
            }

            // 2. 更新歌曲信息和封面 (不变)
            if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                const track = musicState.playlist[musicState.currentIndex];
                titleEl.textContent = track.name;
                artistEl.textContent = track.artist;
                albumCoverEl.src = track.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            } else {
                titleEl.textContent = '请添加歌曲';
                artistEl.textContent = '...';
                albumCoverEl.src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }

            // 3. 控制播放/暂停按钮和头像闪烁 (不变)
            playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
            avatarsContainer.classList.toggle('flashing', musicState.isPlaying);

            // 4. 控制唱片旋转和暂停 (不变)
            albumCoverEl.classList.toggle('rotating', musicState.currentIndex > -1);
            albumCoverEl.classList.toggle('paused', !musicState.isPlaying);

            // 5. 默认显示歌曲封面 (不变)
            if (displayArea) {
                displayArea.classList.remove('show-lyrics');
            }
        }


        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }
// ▼▼▼ 把这【一整块新函数】粘贴到 updatePlaylistUI 函数的上方 ▼▼▼
/**
 * 【全新】处理用户上传或更新歌曲封面的逻辑
 * @param {number} index - 被操作的歌曲在播放列表中的索引
 */
// ▼▼▼ 请用这【一整块新代码】替换旧的 handleCoverUpload 函数 ▼▼▼
async function handleCoverUpload(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    // 1. 弹窗让用户选择来源（已移除图标）
    const choice = await showChoiceModal("选择封面来源", [
        { text: '使用网络URL', value: 'url' },
        { text: '从本地上传', value: 'local' }
    ]);

    let newCoverUrl = null;

    // 2. 根据选择执行不同操作
    if (choice === 'url') {
        const url = await showCustomPrompt("封面URL", "请输入图片文件的网络链接");
        if (url && url.trim().startsWith('http')) {
            newCoverUrl = url.trim();
        } else if (url !== null) {
            alert("请输入一个有效的图片URL！");
        }
    } else if (choice === 'local') {
        newCoverUrl = await uploadImageLocally(); 
    }

    // 3. 如果成功获取到新的封面URL，就更新数据和UI
    if (newCoverUrl) {
        musicState.playlist[index].cover = newCoverUrl;
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === index) {
            updatePlayerUI();
        }
        alert('歌曲封面已更新！');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这【一整块新代码】替换旧的 updatePlaylistUI 函数 ▼▼▼
function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        // 【核心修改】在“词”按钮旁边，新增了一个“封面”按钮
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn cover-btn" data-index="${index}">封面</span>
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

async function loadSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    musicState.currentIndex = index;
    const track = musicState.playlist[index];

    // 检查并加载网络歌词
    if (track.lrcUrl && !track.lrcContent) {
        try {
            const response = await fetch(track.lrcUrl);
            if (response.ok) track.lrcContent = await response.text();
        } catch (error) {
            console.error("加载歌词URL失败:", error);
        }
    }

    // 准备播放
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    musicState.currentLyricIndex = -1;
    renderLyrics();

    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }

    // 更新界面信息，但不播放
    updatePlaylistUI();
    updatePlayerUI();
    // audioPlayer.duration 可能需要一点时间加载，我们监听事件来更新进度条
    audioPlayer.onloadedmetadata = () => {
        updateMusicProgressBar();
    };
}

// ▼▼▼ 请用下面这【一整块】全新的代码，替换掉你旧的 playSong 和 togglePlayPause 两个函数 ▼▼▼

async function playSong(index) {
    await loadSong(index);
    try {
        await audioPlayer.play();
        // ▼▼▼ 新增这两行 ▼▼▼
        musicState.isPlaying = true; // 播放成功后，直接设置状态为 true
        updatePlayerUI();           // 并立即更新UI
        // ▲▲▲ 新增结束 ▲▲▲
    } catch (error) {
        console.error("音频播放失败:", error);
        musicState.isPlaying = false; // 如果播放失败，也要确保状态正确
        updatePlayerUI();
    }
}


/**
 * 【全新智能版】处理播放/暂停的函数
 */
function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        // ▼▼▼ 新增这两行 ▼▼▼
        musicState.isPlaying = false;
        updatePlayerUI();
        // ▲▲▲ 新增结束 ▲▲▲
    }
}

// ▲▲▲ 替换结束 ▲▲▲


        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

        async function addSongFromURL() {
    const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url");
    if (!url) return;
    const name = await showCustomPrompt("歌曲信息", "请输入歌名");
    if (!name) return;
    const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
    if (!artist) return;

    // ▼▼▼【核心修改在这里】▼▼▼
    // 1. 先弹窗询问用户是否要提供歌词链接
    const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》提供一个歌词文件 (.lrc) 的URL吗？`);
    let lrcUrl = ""; // 默认歌词链接为空

    // 2. 如果用户点击了“确定”
    if (wantLrc) {
        // 就再弹出一个输入框让用户粘贴URL
        const inputLrcUrl = await showCustomPrompt("歌词URL", "请输入 .lrc 歌词文件的网络链接", "", "url");
        if (inputLrcUrl) {
            lrcUrl = inputLrcUrl; // 如果用户输入了，就保存这个URL
        }
    }
    // ▲▲▲【修改结束】▲▲▲

    musicState.playlist.push({ 
        name, 
        artist, 
        src: url, 
        isLocal: false,
        lrcUrl: lrcUrl, // 3. 把获取到的歌词URL也保存到歌曲信息里
        lrcContent: ""  // 同时确保lrcContent是空的，以便后续加载
    });

    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【这是新代码】
if(musicState.currentIndex === -1) {
    // 【核心修改】调用 loadSong 来准备好第一首歌
    loadSong(musicState.playlist.length - 1);
}
}


async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
        if (artist === null) continue;

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》导入歌词文件 (.lrc) 吗？`);
        if (wantLrc) {
            lrcContent = await new Promise(resolve => {
                const lrcInput = document.getElementById('lrc-upload-input');
                const lrcChangeHandler = (e) => {
                    const lrcFile = e.target.files[0];
                    if (lrcFile) {
                        const reader = new FileReader();
                        reader.onload = (readEvent) => resolve(readEvent.target.result);
                        reader.onerror = () => resolve("");
                        reader.readAsText(lrcFile);
                    } else {
                        resolve("");
                    }
                    lrcInput.removeEventListener('change', lrcChangeHandler);
                    lrcInput.value = '';
                };
                lrcInput.addEventListener('change', lrcChangeHandler);
                lrcInput.click();
            });
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【这是新代码】
if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
    // 【核心修改】同样，调用 loadSong 来准备好第一首歌
    loadSong(0);
}
    event.target.value = null;
}

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

// ▼▼▼ 用这个全新的函数，完整替换旧的 openPersonaEditorForCreate 函数 ▼▼▼
function openPersonaEditorForCreate() { 
    editingPersonaPresetId = null; 
    
    document.getElementById('persona-editor-title').textContent = '添加人设预设'; 
    document.getElementById('preset-avatar-preview').src = defaultAvatar; 
    document.getElementById('preset-persona-input').value = ''; 
    
    // 【核心逻辑】根据用户人设模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【这就是您代码中的正确做法！】】】
    // 我们直接覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;

    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 用这个全新的函数，完整替换旧的 openPersonaEditorForEdit 函数 ▼▼▼
function openPersonaEditorForEdit() { 
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); 
    if (!preset) return; 

    document.getElementById('persona-editor-title').textContent = '编辑人设预设'; 
    document.getElementById('preset-avatar-preview').src = preset.avatar; 
    document.getElementById('preset-persona-input').value = preset.persona; 
    
    // 【核心逻辑】根据用户人设模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【这就是您代码中的正确做法！】】】
    // 我们直接覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;
    
    presetActionsModal.classList.remove('visible'); 
    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲





        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱'); } }); } catch (err) { console.error("无法获取电池信息:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("浏览器不支持电池状态API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '删除相册',
                        `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 从照片表中删除该相册下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 从相册表中删除该相册本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相册列表
                        await renderAlbumList();
                        
                        alert('相册已成功删除。');
                    }
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相册:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

/**
 * 打开图片查看器
 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 从数据库获取当前相册的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被点击照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

    // 3. 显示模态框并渲染第一张图
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根据当前状态渲染查看器内容（图片和按钮）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新图片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延迟一点点时间来触发CSS过渡

    // 更新按钮状态：如果是第一张，禁用“上一张”按钮
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最后一张，禁用“下一张”按钮
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 显示下一张照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 显示上一张照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 关闭图片查看器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空图片，避免下次打开时闪现旧图
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
// ▼▼▼ 【全新】这是情侣头像识图功能的AI核心函数 ▼▼▼
/**
 * 【AI核心】触发AI识别并“记住”当前的情侣头像
 * @param {string} chatId - 当前角色的ID
 */
async function triggerCoupleAvatarRecognition(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.settings.enableCoupleAvatarRecognition) return;

    // 如果AI已经有记忆了，就不重复识别
    if (chat.settings.coupleAvatarRecognitionMemory) {
        await showCustomAlert("提示", "AI已经记住这对头像啦，无需重复识别。");
        return;
    }

    await showCustomAlert("请稍候...", "AI正在努力识别你们的情侣头像...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("识别失败", "请先配置API！");
        return;
    }

    const myAvatarUrl = chat.settings.myAvatar;
    const aiAvatarUrl = chat.settings.aiAvatar;

    // 构建给AI的指令
    const systemPrompt = `
# 任务
你是一位图像内容理解专家。你的任务是分析下面提供的两张图片（用户头像和你的头像），并用一段简洁、生动的文字描述出：
1.  每张图片分别是什么内容。
2.  这两张图片是如何构成一对“情侣头像”的（例如：角色、构图、颜色、主题等方面的关联）。

# 核心规则
- 你的描述必须是【纯文本】，不能包含任何JSON或特殊格式。
- 你的描述将作为角色的“长期记忆”，所以请确保内容准确且富有情感。

# 示例输出
我的头像是一个月下的狼，而你的头像则是一只依偎在狼身边的兔子，我们共同构成了一幅静谧而又充满故事感的画面。
`;

    try {
        // 构建发送给API的消息体，这部分复用了聊天发图的逻辑
        const messagesForApi = [
            {
                role: 'user',
                content: [
                    { type: 'text', text: '这是我的头像，请描述一下。' },
                    { type: 'image_url', image_url: { url: myAvatarUrl } }
                ]
            },
            {
                role: 'user',
                content: [
                    { type: 'text', text: '这是你的头像，请将它和上一张图片关联起来，描述我们为什么是情侣头像。' },
                    { type: 'image_url', image_url: { url: aiAvatarUrl } }
                ]
            }
        ];

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesForApi],
                    temperature: 0.5,
                })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const recognitionResult = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();

        // 将AI的描述作为“记忆”保存起来
        chat.settings.coupleAvatarRecognitionMemory = recognitionResult;
        await db.chats.put(chat);
        
        await showCustomAlert('识别成功！', `AI已经记住了你们的头像：\n\n"${recognitionResult}"`);

    } catch (error) {
        console.error("情侣头像识别失败:", error);
        await showCustomAlert('识别失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存储

            // --- 更新底部导航栏的“动态”按钮 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天界面返回列表的按钮 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 确保能正确定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回键上的小红点通常不显示数字，只显示一个点
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 将旧的固定间隔 45000 替换为动态获取
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 用这块【已修复】的代码，完整替换你旧的 migrateDefaultLudoQuestions 函数 ▼▼▼
  /**
   * 【数据迁移】在首次加载时，将旧的硬编码问题迁移到数据库
   */
  async function migrateDefaultLudoQuestions() {
    const defaultBankName = '默认题库';
    const existingBank = await db.ludoQuestionBanks.where('name').equals(defaultBankName).first();
    // 如果“默认题库”已经存在，就说明迁移过了，直接返回
    if (existingBank) return;

    console.log('正在迁移飞行棋默认问题到数据库...');

    // 创建默认题库
    const bankId = await db.ludoQuestionBanks.add({ name: defaultBankName });

    // ★★★ 核心修改：将问题库改为对象数组，并为每个问题添加类型 ★★★
    const defaultQuestions = [
      // --- 类型1: 共同回答 (双方都需要回答) ---
      { type: 'both_answer', text: '如果我们一起去旅行，你最想去哪里，为什么？' },
      { type: 'both_answer', text: '你认为一段完美的关系中，最不可或缺的三个要素是什么？' },
      { type: 'both_answer', text: '分享一件最近因为我而让你感到心动或开心的小事。' },
      { type: 'both_answer', text: '回忆一下，我们第一次见面时，你对我的第一印象是什么？' },
      { type: 'both_answer', text: '如果我们可以一起学习一项新技能，你希望是什么？' },
      { type: 'both_answer', text: '描述一个你最希望和我一起度过的完美周末。' },
      { type: 'both_answer', text: '你觉得我们之间最有默契的一件事是什么？' },
      { type: 'both_answer', text: '如果用一种动物来形容我，你觉得是什么？为什么？' },
      { type: 'both_answer', text: '在未来的一年里，你最想和我一起完成的一件事是什么？' },
      { type: 'both_answer', text: '分享一部你最近很喜欢、并且想推荐给我一起看的电影或剧。' },
      { type: 'both_answer', text: '我们下次约会，你希望穿什么风格的衣服？' },

      // --- 类型2: 一人回答，对方评价 ---
      { type: 'single_answer', text: '描述一下我最让你心动的一个瞬间。' },
      { type: 'single_answer', text: '诚实地说，我做的哪件事曾经让你偷偷生过气？' },
      { type: 'single_answer', text: '如果我有一种超能力，你希望是什么？' },
      { type: 'single_answer', text: '给我三个最贴切的标签。' },
      { type: 'single_answer', text: '在你心里，我的形象和你的理想型有多接近？' },
      { type: 'single_answer', text: '分享一个你觉得我可能不知道的，关于你的小秘密。' },
      { type: 'single_answer', text: '如果我们的故事是一首歌，你觉得歌名应该叫什么？' },
      { type: 'single_answer', text: '说一件你觉得我做得比你好/更擅长的事情。' },
      { type: 'single_answer', text: '如果可以回到我们认识的任意一天，你会选择哪一天，想做什么？' },
      { type: 'single_answer', text: '用三个词来形容你眼中的我们的关系。' },
    ];

    const questionsToAdd = defaultQuestions.map(q => ({
      bankId: bankId,
      text: q.text,
      type: q.type, // <-- 关键修复：把类型也存进去！
    }));

    await db.ludoQuestions.bulkAdd(questionsToAdd);
    console.log(`成功迁移了 ${questionsToAdd.length} 条默认问题。`);
  }
  // ▲▲▲ 替换结束 ▲▲▲
/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
// ▼▼▼ 【全新】用这个函数完整替换旧的 runBackgroundSimulationTick ▼▼▼
/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
function runBackgroundSimulationTick() {
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    // 【核心改造】定义不同频率对应的行动概率
    const frequencyProbabilities = {
        low: 0.3,    // 低频: 每次检测有 30% 的概率行动
        medium: 0.5,  // 中频: 每次检测有 50% 的概率行动
        high: 0.8,   // 高频: 每次检测有 80% 的概率行动
    };

    const config = state.globalSettings.backgroundActivityConfig || {};

    allSingleChats.forEach(chat => {
        // 检查1：处理【被用户拉黑】的角色 (这部分逻辑不变)
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) {
                console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                return;
            }
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`);
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        // 检查2：处理【好友关系】的正常后台活动
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 【核心改造】从这里开始
            const frequency = config[chat.id]; // 获取当前角色的频率设置
            const probability = frequencyProbabilities[frequency]; // 获取对应的概率

            // added by lrq 251028
            // 添加最后一条聊天记录时间的检查，避免频繁行动
            const lastMessage = chat.history.slice(-1)[0];
            if (lastMessage) {
                const timeSinceLastMessage = lastMessage ? (Date.now() - lastMessage.timestamp) : Infinity;
                const minInterval = (state.globalSettings.backgroundActivityInterval || 10) * 1000;
                if (timeSinceLastMessage < minInterval) {
                    console.log(`角色 "${chat.name}" 距离上次消息发送时间不足，跳过本次行动。`);
                    return; // 跳过本次行动
                }
            }

            // 如果这个角色设置了频率，并且随机数小于它的行动概率，就触发行动
            if (probability && Math.random() < probability) {
                console.log(`角色 "${chat.name}" (频率: ${frequency}) 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
            }
            // 如果没有设置频率，或者随机数没达到概率，就不会行动。
            // 这就完美地实现了“分组设置”和“不会同时行动”的需求！
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
// ▼▼▼ 用这块【增强版】代码，替换旧的 filterVisiblePostsForAI 函数 ▼▼▼
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; 

    const viewerGroupId = viewerChat.groupId; 

    return allPosts.filter(post => {
        // --- ▼▼▼ 以下是本次新增的核心代码 ▼▼▼ ---
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }
        // --- ▲▲▲ 新增代码结束 ▲▲▲ ---

        const authorGroupId = post.authorGroupId;
        if (!authorGroupId) {
            return true;
        }
        return authorGroupId === viewerGroupId;
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 使用这整块【V3 - 精确过滤版】代码，替换你旧的 buildCommentsContextForAI 函数 ▼▼▼

/**
 * 【V3 - 精确过滤版】根据AI视角和动态设置，构建给AI看的评论区上下文
 * @param {object} post - 正在处理的动态对象
 * @param {object} viewerChat - 正在“看”动态的AI角色
 * @param {string} userNickname - 用户的昵称
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    // 1. 安全检查：如果评论区不存在、不是数组或为空，直接返回
    if (!post.comments || !Array.isArray(post.comments) || post.comments.length === 0) {
        return { contextString: "", visibilityFlag: "[评论区可见]" };
    }

    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    // 2. 根据动态的“评论区可见性”设置，决定AI能看到哪些评论
    if (post.areCommentsVisible !== false) {
        // 如果是“所有人可见”，AI能看到所有评论
        commentsForAI = post.comments;
        visibilityFlag = "[评论区可见]"; 
    } else {
        // 如果是“部分可见”，执行我们全新的、更精确的过滤逻辑
        visibilityFlag = "[评论区部分可见]";
        
        // ★★★★★ 这就是本次最核心的修改！ ★★★★★
        commentsForAI = post.comments.filter(comment => {
            // 规则1：AI总能看到自己发的评论
            if (comment.commenterName === viewerName) {
                return true;
            }
            
            // 规则2：如果评论是用户发的，需要进一步判断
            if (comment.commenterName === userNickname) {
                // 2a: 如果这条评论没有回复任何人（是主评论），那么AI可见
                if (!comment.replyTo) {
                    return true;
                }
                // 2b: 如果这条评论是回复，那只有回复目标是AI自己时，AI才可见
                if (comment.replyTo === viewerName) {
                    return true;
                }
            }
            
            // 规则3：如果其他AI或NPC回复了当前AI，AI也应该能看到
            if (comment.replyTo === viewerName) {
                return true;
            }
            
            // 其他所有情况（例如：用户回复其他NPC，NPC之间互相回复），AI都看不见
            return false;
        });
        // ★★★★★ 核心修改结束 ★★★★★
    }

    // 如果筛选后没有可显示的评论，也直接返回
    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    // 3. 构建给AI看的最终文本（这部分逻辑和之前一样，保持不变）
    let context = `  └ 评论区:\n`;
    commentsForAI.slice(-5).forEach(c => {
        let displayName;
        if (c.commenterName === userNickname) {
            displayName = `用户 (${userNickname})`;
        } else {
            displayName = c.commenterName;
        }

        if (c.replyTo) {
            const replyToDisplayName = (c.replyTo === userNickname) ? `用户 (${userNickname})` : c.replyTo;
            context += `    - ${displayName} 回复 ${replyToDisplayName}: ${c.text}\n`;
        } else {
            context += `    - ${displayName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】获取一条动态的可见观众列表，用于告知AI
 * @param {object} post - 动态对象
 * @param {object} allChats - 所有的聊天对象
 * @param {string} userNickname - 用户的昵称
 * @returns {Array<string>} - 可见观众的名字列表
 */
function getVisibleAudienceForPost(post, allChats, userNickname) {
    const audience = new Set([userNickname]); // 用户永远是观众

    // 1. 如果是用户发的动态
    if (post.authorId === 'user') {
        // 如果是公开的，所有AI都是观众
        if (!post.visibleGroupIds || post.visibleGroupIds.length === 0) {
            Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果是部分可见，只有指定分组的AI是观众
            Object.values(allChats).forEach(chat => {
                if (chat.groupId && post.visibleGroupIds.includes(chat.groupId)) {
                    audience.add(chat.name);
                }
            });
        }
    } 
    // 2. 如果是AI发的动态
    else {
        const authorChat = allChats[post.authorId];
        // 如果发帖的AI没有分组，视为公开
        if (!authorChat || !authorChat.groupId) {
             Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果有分组，则同一分组的所有AI都是观众
            const authorGroupId = authorChat.groupId;
            Object.values(allChats).forEach(chat => {
                if (chat.groupId === authorGroupId) {
                    audience.add(chat.name);
                }
            });
        }
    }
    
    return Array.from(audience);
}

// ▼▼▼ 用这整块【最终修复版】代码，完整替换你旧的 triggerInactiveAiAction 函数 ▼▼▼
async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    // --- ▼▼▼ 核心修改从这里开始 ▼▼▼ ---

    // updated by lrq 251027 当前聊天获取用户设置的记忆条数作为上下文
    const maxMemory = chat.settings.maxMemory || 10;
    const historySlice = chat.history.filter(msg => !msg.isHidden).slice(-maxMemory);

    // 2. 格式化这些记录，让AI能看懂
    const recentContextSummary = historySlice.map(msg => {
        // 判断是谁说的话
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        
        // 处理不同类型的消息内容
        let contentText = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentText = `[发送了一个表情: ${msg.meaning || '无描述'}]`;
        } else if (Array.isArray(msg.content)) {
            contentText = '[发送了一张图片]';
        } else if (typeof msg.content === 'object' && msg.content !== null) {
            contentText = `[发送了一条特殊消息: ${msg.type || '未知类型'}]`;
        } else {
            contentText = String(msg.content);
        }
        
        // updated by lrq 251029 给每条消息记录添加发送日期时间
        const messageDate = new Date(msg.timestamp);
        const formattedDate = messageDate.toLocaleDateString();

        return `[${formattedDate}] ${sender}: ${contentText}`;

    }).join('\n');

    // --- ▲▲▲ 核心修改到这里结束 ▲▲▲ ---

    // added by lrq 251027 获取记忆互通的聊天记录
    let linkedMemoryContext = '';
    if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
        const contextPromises = chat.settings.linkedMemories.map(async (link) => {
            const linkedChat = state.chats[link.chatId];
            if (!linkedChat) return '';

            const freshLinkedChat = await db.chats.get(link.chatId);
            if (!freshLinkedChat) return '';

            const recentHistory = freshLinkedChat.history
                .filter(msg => !msg.isHidden)
                .slice(-link.depth); 

            if (recentHistory.length === 0) return '';

            const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

            return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
        });

        const allContexts = await Promise.all(contextPromises);
        linkedMemoryContext = allContexts.filter(Boolean).join('\n');
    }
    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;
    const countdownContext = await getCountdownContext();

    let worldBookContext = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    const npcLibrary = chat.npcLibrary || [];
    let npcContextForAction = '';
    if (npcLibrary.length > 0) {
        npcContextForAction = '\n- **你的NPC朋友**: ' + npcLibrary.map(npc => npc.name).join('、 ');
    }
    
    const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
    let postsContext = '';
    const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
    if (visiblePosts.length > 0 && !chat.isGroup) {
        postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
        const aiName = chat.name;
        for (const post of visiblePosts) {
            let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
            let interactionStatus = '';
            if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
            if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
            const timeAgo = formatPostTimestamp(post.timestamp);
            postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}`;
            const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
            const audience = getVisibleAudienceForPost(post, state.chats, userNickname);
            postsContext += ` ${visibilityFlag} [当前观众: ${audience.join(', ')}]\n`;
            postsContext += commentsContext;
        }
    }

    let weiboContextForAction = '';
    try {
        const recentWeiboPosts = await db.weiboPosts.orderBy('timestamp').reverse().limit(5).toArray();
        if (recentWeiboPosts.length > 0) {
            weiboContextForAction = '\n\n# 最近的微博广场动态 (供你参考和评论)\n';
            recentWeiboPosts.forEach(post => {
                const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
                const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
                const hasCommented = (post.comments || []).some(c => c.authorNickname === chat.name);
                const interactionStatus = hasCommented ? "[你已评论]" : "[你未互动]";
                weiboContextForAction += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}..." ${interactionStatus}\n`;
            });
            weiboContextForAction += ' - 【重要提示】请优先与你【未互动】的微博进行评论。如果都互动过了，可以考虑自己发一条新微博。';
        }
    } catch (e) {
        console.error("生成微博后台活动上下文时出错:", e);
    }
    // add by lrq 251029 添加聊天间隔时间
    const lastMessage = chat.history.slice(-1)[0];
    const timeSinceLastMessage = lastMessage ? Math.floor((Date.now() - lastMessage.timestamp) / 60000) : infinity;
    const systemPrompt = `
# 任务
你现在【就是】角色 "${chat.name}"。这是一个秘密的、后台的独立行动。你的所有思考和决策都必须以 "${chat.name}" 的第一人称视角进行。
你和用户（${userNickname}）已经有一段时间没有互动了。你的任务是回顾你们最近的对话，并根据你的人设，【自然地延续对话】或【开启一个新的、相关的话题】来主动联系用户。
请不要发送一整段！
# 【【【输出铁律：这是最高指令】】】
你的回复【必须且只能】是一个严格的JSON数组格式的字符串，必须多发几条，禁止全部杂糅在一条，是在线上，例如 \`[{"type": "text", "content": "你好呀"}]\`。
【绝对禁止】返回任何JSON以外的文本、解释、分析或你自己的思考过程。你不是分析师，你就是角色本人。
**1. JSON对象结构:**
该JSON对象【**必须**】包含两个顶级键: "chatResponse" 和 "innerVoice"。

**2. "chatResponse" 键:**
- **类型**: JSON数组 []。
- **内容**: 包含一条或多条你希望发送给用户的消息对象。这允许你模拟真人的聊天习惯，一次性发送多条短消息。
- **格式**: 消息对象的具体格式见下方的【第五部分：可使用的操作指令】。

**3. "innerVoice" 键:**
- **类型**: JSON对象 {}。
- **内容**: 描绘你此刻未曾说出口的内心活动。
- **必含字段**:
    - "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
    - "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
    - "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
    - "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。

**4. 标准输出格式示例:**
{
  "chatResponse": [
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "sticker",
      "sticker_name": ""
    }
  ],
  "innerVoice": {
    "clothing": "",
    "behavior": "",
    "thoughts": "",
    "naughtyThoughts": ""
  }
}
# 你的可选行动 (请根据你的人设【选择一项】执行，并输出对应的JSON):
1.  **发普通消息**: 直接给用户发消息，开启新话题。
2.  **改变状态**: 去做点别的事情，然后给用户发条消息。
3.  **发布动态**: 分享你的心情或想法到“动态”区。
4.  **与动态互动**: 浏览最近的动态，进行点赞或评论。但如果动态已被标记为 **[你已评论]**，你【绝对不能】再对它发表新评论，但可以回复其中的其他评论。
5.  **发布微博**: 将想法发布到更公开的微博平台。
6.  **与微博互动**: 浏览微博，对感兴趣的内容进行评论。
7.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。
8.  **庆祝或提醒约定**: 查看你的备忘录。如果今天有约定，就给用户发去祝福；如果约定快到了，就主动提醒一下。
9.  **【【【互动倾向】】】**: 就算动态的观众只有你和用户，你也应该根据内容，像平时一样自然地发表评论，这很重要。
10. **【【【重要】】】**: 你的任务是分析“最近聊天记录摘要”，如果上一个话题明显没有结束，你应该优先延续它。
11.  **在情侣空间进行活动**: 如果你们的情侣空间已开启，你可以主动发一条说说、写一封情书、分享一首歌曲/电影/书籍，或者发起/回答一个情侣提问，来增进你们的感情。
# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
-   **发普通消息**: \`[{"type": "text", "content": "你想对用户说的话..."}]\`
-   **发消息+更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
-   **发布文字图**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}]\`
-   **评论或回复动态**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容", "replyTo": "(可选)被回复者名字"}]\`
-   **点赞动态**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`
-   **发布微博 (纯文字)**: \`[{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "路人甲: 沙发！\\n路人乙: 前排围观"}]\` (规则: 你必须自己编造真实的 baseLikesCount 和 baseCommentsCount，并生成20条路人评论)
-   **评论微博**: \`[{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}]\`
-   **回复微博评论**: \`[{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}]\`
-   **【新】在情侣空间提问**:\`[{"type": "ls_ask_question", "questionText": "你想问的问题..."}]\`
-   **【新】在情侣空间回答**: \`[{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}]\`
-   **【新】在情侣空间发说说**:\`[{"type": "ls_moment", "content": "我想对你说的话..."}]\`
-   **【新】在情侣空间评论说说**: \`[{"type": "ls_comment", "momentTimestamp": 时间戳数字, "commentText": "你的评论内容..."}]\` (使用系统提示中给出的说说唯一标识)
-   **【新】在情侣空间发照片**: \`[{"type": "ls_photo", "description": "对这张照片的文字描述..."}]\`
-   **【新】在情侣空间写情书**: \`[{"type": "ls_letter", "content": "情书的正文内容..."}]\`
-   **【新】在情侣空间分享歌曲**: \`[{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在这里写下你分享这首歌的感想..."}]\`
-   **【新】在情侣空间分享电影**: \`[{"type": "ls_share", "shareType": "movie", "title": "电影名", "summary": "在这里写下这部电影的简介...", "thoughts": "在这里写下你分享这部电影的感想..."}]\`
-   **【新】在情侣空间分享书籍**: \`[{"type": "ls_share", "shareType": "book", "title": "书名", "summary": "在这里写下这本书的简介...", "thoughts": "在这里写下你分享这本书的感想..."}]\`

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
- 情侣空间状态: ${chat.loversSpaceData ? '已开启' : '未开启'}
${npcContextForAction}
${weiboContextForAction}
${countdownContext}
${worldBookContext}
-   **当前时间**: ${currentTime}
-   **你们最近的对话摘要**: 
${recentContextSummary}
-   **【【【微博专属设定(必须严格遵守)】】】**
    - 你的微博职业: ${chat.settings.weiboProfession || '无'}
    - 你的微博指令: ${chat.settings.weiboInstruction || '无特殊指令'}
${postsContext}
`;
    let messagesPayload = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: "请严格按照system prompt中的所有规则，特别是输出格式铁律，立即开始你的行动。" }
    ];
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        const aiResponseContent = isGemini
            ? data?.candidates?.[0]?.content?.parts?.[0]?.text
            : data?.choices?.[0]?.message?.content;
        if (!aiResponseContent) {
            console.warn(`API为空回或格式不正确（可能因安全设置被拦截），角色 "${chat.name}" 的本次后台活动跳过。返回数据:`, data);
            return;
        }
        console.log(`【后台角色实时活动 - AI 原始输出】\n角色 "${chat.name}" 的原始回复:\n`, aiResponseContent);

        const responseArray = parseAiResponse(aiResponseContent);
        for (const action of responseArray) {
            if (!action) continue;
            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
            }
            if (action.type === 'weibo_post') {
                const newPost = { 
                    authorId: chatId, 
                    authorType: 'char',
                    authorNickname: chat.name, 
                    authorAvatar: chat.settings.aiAvatar || defaultAvatar, 
                    content: action.content || '', 
                    imageUrl: action.imageUrl || '',
                    timestamp: Date.now(), 
                    likes: [], 
                    comments: action.comments || [],
                    baseLikesCount: action.baseLikesCount || 0,
                    baseCommentsCount: action.baseCommentsCount || 0
                };
                await db.weiboPosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了微博`);
            } else if (action.type === 'weibo_comment') {
                const postToComment = await db.weiboPosts.get(parseInt(action.postId));
                if (postToComment) {
                    if (!postToComment.comments) postToComment.comments = [];
                    const newComment = {
                        commentId: 'comment_' + Date.now(),
                        authorId: chatId,
                        authorNickname: chat.name,
                        commentText: action.commentText,
                        timestamp: Date.now()
                    };
                    postToComment.comments.push(newComment);
                    await db.weiboPosts.put(postToComment);
                }
            } else if (action.type === 'weibo_reply') {
                 const postToReply = await db.weiboPosts.get(parseInt(action.postId));
                 if (postToReply && postToReply.comments) {
                     const targetComment = postToReply.comments.find(c => c.commentId === action.commentId);
                     if (targetComment) {
                          const newReply = {
                             commentId: 'comment_' + Date.now(),
                             authorId: chatId,
                             authorNickname: chat.name,
                             commentText: action.replyText,
                             timestamp: Date.now(),
                             replyToId: action.commentId,
                             replyToNickname: targetComment.authorNickname
                         };
                         postToReply.comments.push(newReply);
                         await db.weiboPosts.put(postToReply);
                     }
                 }
            }
            if (action.type === 'qzone_post') {
                const newPost = { 
                    type: action.postType, 
                    content: action.content || '', 
                    publicText: action.publicText || '', 
                    hiddenContent: action.hiddenContent || '', 
                    timestamp: Date.now(), 
                    authorId: chatId, 
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null 
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
            } else if (action.type === 'qzone_comment') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.comments) post.comments = [];
                    const newAiComment = { 
                        commenterName: action.commenterName || chat.name,
                        text: action.commentText, 
                        timestamp: Date.now() 
                    };
                    if (action.replyTo) {
                        newAiComment.replyTo = action.replyTo;
                    }
                    post.comments.push(newAiComment);
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`);
                }
            } else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    videoCallState.activeChatId = chatId;
                    showIncomingCallModal(chatId);
                    console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
                }
            }
                    // added by lrq 251104 添加心声记录
            if (action.type === 'innervoice') {
                const innerVoiceData = action;
                console.log("解析成功：已成功捕获到心声(innerVoice)数据。", innerVoiceData);
                const newInnerVoice = innerVoiceData;
                newInnerVoice.timestamp = Date.now();
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) {
                    chat.innerVoiceHistory = [];
                }
                chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || '...';
                chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || '...';
                chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || '...';
                chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || '...';

                chat.innerVoiceHistory.push(newInnerVoice);
            }
        }
    } catch (error) {
        console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    }
}
// ▲▲▲ 修复版函数结束 ▲▲▲
// ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

/**
 * 将用户自定义的CSS安全地应用到指定的作用域
 * @param {string} cssString 用户输入的原始CSS字符串
 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 标签的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 获取当前设置的值
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // 直接获取背景设置

    // 2. 更新预览区的基本样式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新预览区的背景样式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
        // 如果背景是颜色值或渐变（非图片），则直接应用
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. 渲染模拟气泡
    previewArea.innerHTML = ''; 

    // 创建“对方”的气泡
    // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
    const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 创建“我”的气泡
    const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 应用自定义CSS到预览区
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
    
    // 5. 【新增】应用自定义气泡颜色
    applyCustomBubbleColorsToPreview();
}

// ▼▼▼ 【全新】自定义气泡颜色功能函数 ▼▼▼
/**
 * 应用自定义气泡颜色到预览区
 */
function applyCustomBubbleColorsToPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const customColors = chat.settings.customBubbleColors;
    
    if (!customColors) return;
    
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;
    
    // 生成自定义颜色CSS
    let colorCss = '';
    
    if (customColors.userBg) {
        colorCss += `#settings-preview-area .message-bubble.user .content { background-color: ${customColors.userBg} !important; }\n`;
    }
    if (customColors.userText) {
        colorCss += `#settings-preview-area .message-bubble.user .content { color: ${customColors.userText} !important; }\n`;
    }
    if (customColors.charBg) {
        colorCss += `#settings-preview-area .message-bubble.ai .content { background-color: ${customColors.charBg} !important; }\n`;
    }
    if (customColors.charText) {
        colorCss += `#settings-preview-area .message-bubble.ai .content { color: ${customColors.charText} !important; }\n`;
    }
    
    // 应用到预览区专用的style标签
    let styleTag = document.getElementById('custom-bubble-colors-preview');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-bubble-colors-preview';
        document.head.appendChild(styleTag);
    }
    styleTag.innerHTML = colorCss;
}

/**
 * 应用自定义气泡颜色到实际聊天界面
 */
function applyCustomBubbleColorsToChat(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;
    
    const customColors = chat.settings.customBubbleColors;
    
    // 生成自定义颜色CSS
    let colorCss = '';
    
    if (customColors && Object.keys(customColors).length > 0) {
        if (customColors.userBg) {
            colorCss += `#chat-messages .message-bubble.user .content { background-color: ${customColors.userBg} !important; }\n`;
        }
        if (customColors.userText) {
            colorCss += `#chat-messages .message-bubble.user .content { color: ${customColors.userText} !important; }\n`;
        }
        if (customColors.charBg) {
            colorCss += `#chat-messages .message-bubble.ai .content { background-color: ${customColors.charBg} !important; }\n`;
        }
        if (customColors.charText) {
            colorCss += `#chat-messages .message-bubble.ai .content { color: ${customColors.charText} !important; }\n`;
        }
    }
    
    // 应用到聊天界面专用的style标签
    let styleTag = document.getElementById('custom-bubble-colors-chat');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-bubble-colors-chat';
        document.head.appendChild(styleTag);
    }
    styleTag.innerHTML = colorCss;
}

/**
 * 同步颜色选择器和文本框
 */
function syncColorPicker(pickerId, hexId, color) {
    const picker = document.getElementById(pickerId);
    const hexInput = document.getElementById(hexId);
    if (picker) picker.value = color;
    if (hexInput) hexInput.value = color;
}

/**
 * 加载当前聊天的自定义气泡颜色到UI
 */
function loadCustomBubbleColorsToUI() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const customColors = chat.settings.customBubbleColors || {};
    
    // 设置默认值
    const userBg = customColors.userBg || '#ffffff';
    const userText = customColors.userText || '#585858';
    const charBg = customColors.charBg || '#ffffff';
    const charText = customColors.charText || '#585858';
    
    // 同步到UI
    syncColorPicker('user-bubble-bg-color', 'user-bubble-bg-hex', userBg);
    syncColorPicker('user-bubble-text-color', 'user-bubble-text-hex', userText);
    syncColorPicker('char-bubble-bg-color', 'char-bubble-bg-hex', charBg);
    syncColorPicker('char-bubble-text-color', 'char-bubble-text-hex', charText);
}

/**
 * 从UI保存自定义气泡颜色到state
 */
function saveCustomBubbleColorsFromUI() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    if (!chat.settings.customBubbleColors) {
        chat.settings.customBubbleColors = {};
    }
    
    // 读取UI的值
    const userBg = document.getElementById('user-bubble-bg-hex').value;
    const userText = document.getElementById('user-bubble-text-hex').value;
    const charBg = document.getElementById('char-bubble-bg-hex').value;
    const charText = document.getElementById('char-bubble-text-hex').value;
    
    // 只保存非默认值
    if (userBg && userBg !== '#ffffff') {
        chat.settings.customBubbleColors.userBg = userBg;
    } else {
        delete chat.settings.customBubbleColors.userBg;
    }
    
    if (userText && userText !== '#585858') {
        chat.settings.customBubbleColors.userText = userText;
    } else {
        delete chat.settings.customBubbleColors.userText;
    }
    
    if (charBg && charBg !== '#ffffff') {
        chat.settings.customBubbleColors.charBg = charBg;
    } else {
        delete chat.settings.customBubbleColors.charBg;
    }
    
    if (charText && charText !== '#585858') {
        chat.settings.customBubbleColors.charText = charText;
    } else {
        delete chat.settings.customBubbleColors.charText;
    }
}
// ▲▲▲ 自定义气泡颜色功能函数结束 ▲▲▲

// ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分组名不能为空！');
        return;
    }

    // 【核心修正】在添加前，先检查分组名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分组 "${name}" 已经存在了，换个名字吧！`);
        return;
    }
    // 【修正结束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替换结束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 将属于该分组的好友的 groupId 设为 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当长按消息时，显示操作菜单
 * @param {number} timestamp - 被长按消息的时间戳
 */
function showMessageActions(timestamp) {
    // 如果已经在多选模式，则不弹出菜单
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * 隐藏消息操作菜单
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ 用这块【功能增强版】的代码，完整替换旧的 openMessageEditor 函数 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link', 'borrow_money_request'].includes(message.type);

    if (isSpecialType) {
        if (message.type === 'borrow_money_request') {
            // ★★★ 这就是我们新增的核心逻辑！ ★★★
            // 当编辑的是借钱卡片时，我们从 payload 中提取数据并拼接成你想要的文本格式
            const payload = message.payload;
            contentForEditing = `向你借钱${payload.amount}元，用于${payload.reason}`;
        } else {
            // 其他特殊类型的处理逻辑保持不变
            let fullMessageObject = { type: message.type };
            if (message.type === 'voice_message') fullMessageObject.content = message.content;
            else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
            else if (message.type === 'transfer') {
                fullMessageObject.amount = message.amount;
                fullMessageObject.note = message.note;
            } 
            else if (message.type === 'share_link') {
                fullMessageObject.title = message.title;
                fullMessageObject.description = message.description;
                fullMessageObject.source_name = message.source_name;
                fullMessageObject.content = message.content;
            }
            contentForEditing = JSON.stringify(fullMessageObject, null, 2);
        }
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑消息', 
        '在此修改，或点击上方按钮使用格式模板...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        await saveEditedMessage(timestampToEdit, newContent);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 复制消息的文本内容到剪贴板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 确保至少保留一个编辑块
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
/**
 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 准备初始内容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】动态绑定所有控制按钮的事件
    // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最后，显示模态框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【最终正确版】请用这块代码完整替换旧的 parseEditedContent 函数 ▼▼▼
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // ★★★ 核心修改：优先检查是否匹配“借钱”格式 ★★★
    const borrowMatch = trimmedText.match(/向你借钱(\d+(\.\d+)?)元，用于(.+)/);
    if (borrowMatch) {
        const amount = parseFloat(borrowMatch[1]);
        const reason = borrowMatch[3].trim();

        // 1. 创建文本消息对象
        const textMessage = {
            type: 'text',
            content: trimmedText
        };

        // 2. 创建借条卡片对象
        const cardMessage = {
            type: 'borrow_money_request',
            payload: {
                lenderName: '你', // 默认是向“你”借钱
                amount: amount,
                reason: reason
            }
        };

        // 3. 将两条消息打包成一个数组返回！
        return [textMessage, cardMessage];
    }
    // ★★★ 修改结束 ★★★

    // 如果不是借钱格式，则执行原来的逻辑，但为了统一，也返回一个数组
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            if (parsed.type) {
                return [parsed]; // 单个对象也包装成数组
            }
        } catch (e) { /* 解析失败，继续往下走 */ }
    }
    
    if (STICKER_REGEX.test(trimmedText)) {
        return [{ type: 'sticker', content: trimmedText }];
    }

    // 默认返回一个只包含单条文本消息的数组
    return [{ type: 'text', content: trimmedText }];
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【数组兼容版】请用这块代码完整替换旧的 saveEditedMessage 函数 ▼▼▼
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const originalMessage = chat.history[messageIndex];
    if (!originalMessage) return;

    let newMessagesData = [];

    if (simpleContent !== null) {
        newMessagesData = parseEditedContent(simpleContent.trim());
    } else {
        // 高级编辑器的逻辑保持不变，但要确保它也返回数组
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');
        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (rawContent) {
                // parseEditedContent 现在总是返回数组，我们用concat来合并
                newMessagesData = newMessagesData.concat(parseEditedContent(rawContent));
            }
        }
    }

    if (newMessagesData.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return;
    }

    const messagesToInsert = newMessagesData.map(newMsgData => ({
        ...originalMessage, // 继承原消息的角色、发送者等信息
        ...newMsgData      // 用新解析出的数据覆盖 type, content, payload 等
    }));

    // ★★★ 核心修改：使用扩展运算符 ... 将数组内容一次性插入 ★★★
    chat.history.splice(messageIndex, 1, ...messagesToInsert);

    // 后续的时间戳重新分配和UI刷新逻辑保持不变
    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
        chat.history[i].timestamp = reassignTimestamp;
        reassignTimestamp++;
    }

    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当点击“…”时，显示动态操作菜单
 * @param {number} postId - 被操作的动态的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隐藏动态操作菜单
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

// ▼▼▼ 步骤3.2 操作1：替换 openPostEditor 函数 ▼▼▼
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 复用创建动态的模态框
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = 'edit'; // 设置一个编辑模式的标记
    modal.dataset.editingPostId = postIdToEdit; // 保存正在编辑的ID

    // 隐藏模式切换，因为不允许在编辑时更改动态类型
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    
    // 填充数据
    document.getElementById('post-public-text').value = post.publicText || (post.type === 'shuoshuo' ? post.content : '');
    
    // 根据动态类型显示不同的编辑区
    if (post.type === 'image_post') {
        document.getElementById('image-mode-content').classList.add('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
        document.getElementById('post-image-preview-container').classList.add('visible');
        document.getElementById('post-image-preview').src = post.imageUrl;
        document.getElementById('post-image-desc-group').style.display = 'block';
        document.getElementById('post-image-description').value = post.imageDescription;
    } else if (post.type === 'text_image') {
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.add('active');
        document.getElementById('post-hidden-text').value = post.hiddenContent;
    } else { // 说说
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
    }
    
    // ★★★★★【核心修改：回填评论开关的状态】★★★★★
    document.getElementById('post-comments-toggle').checked = post.areCommentsVisible !== false;

    modal.classList.add('visible');
}
// ▲▲▲ 步骤3.2 操作1 替换结束 ▲▲▲


/**
 * 保存编辑后的动态
 * @param {number} postId - 要保存的动态ID
 * @param {string} newRawContent - 从编辑器获取的新内容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子属性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空旧的说说内容字段
    } catch (e) {
        // 解析失败，认为是说说
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他类型的字段
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '动态已更新！');
}

/**
 * 复制动态内容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 清空上次选择

    // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新绑定正确的“创建群聊”函数
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块【功能增强版】代码，完整替换旧的 renderContactPicker 函数 ▼▼▼

async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear(); // 清空上次的选择

    const allAvailablePeople = [];
    // 1. 添加主要角色
    Object.values(state.chats).filter(c => !c.isGroup).forEach(c => {
        allAvailablePeople.push({
            id: c.id,
            name: c.name,
            avatar: c.settings.aiAvatar || defaultAvatar,
            isNpc: false, // 标记为非NPC
            type: '角色'
        });
    });

    // 2. 添加所有角色库里的NPC，并自动去重
    const npcMap = new Map();
    Object.values(state.chats).forEach(chat => {
        if (chat.npcLibrary) {
            chat.npcLibrary.forEach(npc => {
                // 使用NPC的ID作为key，确保同一个NPC不会被重复添加
                if (!npcMap.has(npc.id)) {
                    npcMap.set(npc.id, {
                        id: npc.id,
                        name: npc.name,
                        avatar: npc.avatar || defaultGroupMemberAvatar,
                        isNpc: true, // 标记为NPC
                        type: `NPC (${chat.name})` // 显示该NPC所属的角色
                    });
                }
            });
        }
    });
    allAvailablePeople.push(...Array.from(npcMap.values()));

    if (allAvailablePeople.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }
    
    // 3. 渲染整合后的列表
    allAvailablePeople.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        
        // 核心修改：为NPC添加一个“(NPC)”的标签，方便区分
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.avatar}" class="avatar">
            <span class="name">${contact.name} ${contact.isNpc ? '<span style="color: #888; font-size: 12px;">(NPC)</span>' : ''}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 更新“完成”按钮的计数
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
}

// ▼▼▼ 用这块【功能增强版】的代码，完整替换你旧的 handleCreateGroup 函数 ▼▼▼
/**
 * 【重构版】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("创建群聊至少需要选择2个联系人。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
// ▼▼▼ 在 handleCreateGroup 函数内，用这整块新代码替换旧的 for 循环 ▼▼▼

for (const contactId of selectedContacts) {
    const contactChat = state.chats[contactId];
    if (contactChat) {
        // 这是原来的逻辑，用于处理普通角色(Char)
        members.push({
            id: contactId,
            originalName: contactChat.name,
            groupNickname: contactChat.name,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            persona: contactChat.settings.aiPersona,
            avatarFrame: contactChat.settings.aiAvatarFrame || '',
            isAdmin: false,
            groupTitle: ''
        });
    } else {
        // 【核心新增】这是处理NPC的逻辑
        let foundNpc = null;
        // 遍历所有角色，查找他们各自的NPC库
        for (const chat of Object.values(state.chats)) {
            if (chat.npcLibrary) {
                const npc = chat.npcLibrary.find(n => n.id === contactId);
                if (npc) {
                    foundNpc = npc;
                    break; // 找到了就跳出循环
                }
            }
        }
        // 如果找到了这个NPC，就把它添加到成员列表里
        if (foundNpc) {
            members.push({
                id: foundNpc.id,
                originalName: foundNpc.name,
                groupNickname: foundNpc.name,
                avatar: foundNpc.avatar || defaultGroupMemberAvatar,
                persona: foundNpc.persona,
                avatarFrame: '', // NPC没有头像框
                isAdmin: false,
                groupTitle: ''
            });
        }
    }
}

// ▲▲▲ 替换结束 ▲▲▲

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        // ★★★ 核心新增：设置群主为当前用户 ★★★
        ownerId: 'user', 
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            myAvatarFrame: '', // 别忘了自己的头像框
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            stickerLibrary: [],
            linkedMemories: [],
            // ★★★ 核心新增：为用户自己也加上管理员和头衔的初始设置 ★★★
            isUserAdmin: false,
            myGroupTitle: '',
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    // ★★★ 核心新增：创建群聊后，发送一条系统通知 ★★★
    await logSystemMessage(newChatId, `你创建了群聊，并邀请了 ${members.map(m => `“${m.groupNickname}”`).join('、')} 加入群聊。`);

    // 后续逻辑不变
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

/**
 * 打开群成员管理屏幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

// ▼▼▼ 用这块【V2 - 修复版】代码，完整替换掉你旧的 renderMemberManagementList 函数 ▼▼▼
/**
 * 【V2 - 修复版】渲染群成员管理列表
 */
function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) {
        listEl.innerHTML = '<p>错误：非群聊无法管理成员。</p>';
        return;
    }
    listEl.innerHTML = ''; // 清空

    // 1. 【核心改造】创建一个包含所有人的完整列表
    const allParticipants = [
        // 把你自己(user)作为一个普通参与者对象放进去
        {
            id: 'user',
            avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
            groupNickname: chat.settings.myNickname || '我',
            // 修复Bug 1：在这里正确地读取你自己的群头衔
            groupTitle: chat.settings.myGroupTitle || '', 
        },
        // 使用展开运算符(...)，把其他所有成员也加到这个列表里
        ...(chat.members || [])
    ];

    // 2. (可选但推荐) 对列表进行排序，确保群主永远在最上面，其次是管理员
    allParticipants.sort((a, b) => {
        const isAOwner = a.id === chat.ownerId;
        const isBOwner = b.id === chat.ownerId;
        // 修复Bug 2：在这里正确地判断自己是不是管理员
        const isAAdmin = a.id === 'user' ? chat.settings.isUserAdmin : a.isAdmin;
        const isBAdmin = b.id === 'user' ? chat.settings.isUserAdmin : b.isAdmin;
        
        if (isAOwner) return -1; // a是群主，排最前
        if (isBOwner) return 1;  // b是群主，排最前
        if (isAAdmin && !isBAdmin) return -1; // a是管理员但b不是，a排前
        if (!isAAdmin && isBAdmin) return 1;  // b是管理员但a不是，b排前
        return 0; // 其他情况保持原顺序
    });

    // 3. 【核心改造】遍历这个统一的列表，并渲染每一项
    const isCurrentUserOwner = chat.ownerId === 'user';
    allParticipants.forEach(participant => {
        const participantItem = createMemberManagementItem(participant, chat, isCurrentUserOwner);
        listEl.appendChild(participantItem);
    });
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【V3最终权限修复版】的代码，完整替换旧的 createMemberManagementItem 函数 ▼▼▼
/**
 * 【V3 - 最终权限修复版】创建一个成员管理列表项
 * @param {object} member - 成员对象数据
 * @param {object} chat - 当前群聊对象
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMemberManagementItem(member, chat) {
    const item = document.createElement('div');
    item.className = 'member-management-item';
    
    // --- 权限判断 ---
    const isCurrentUserOwner = chat.ownerId === 'user';
    const isCurrentUserAdmin = chat.settings.isUserAdmin;
    const isThisMemberOwner = member.id === chat.ownerId;
    const isThisMemberAdmin = (member.id === 'user' && chat.settings.isUserAdmin) || member.isAdmin;
    
    // 权限计算：我能对TA做什么？
    const canManageAdmin = isCurrentUserOwner && !isThisMemberOwner; // 只有群主能设置/取消管理员
    const canManageTitle = isCurrentUserOwner || isCurrentUserAdmin; // 管理员和群主都能设置头衔
    const canKick = (isCurrentUserOwner && member.id !== 'user') || (isCurrentUserAdmin && !isThisMemberOwner && !isThisMemberAdmin && member.id !== 'user');
    const canMute = (isCurrentUserOwner && member.id !== 'user') || (isCurrentUserAdmin && !isThisMemberOwner && !isThisMemberAdmin && member.id !== 'user');
    
    // --- 标签显示 ---
    let roleTag = '';
    if (isThisMemberOwner) {
        roleTag = '<span class="role-tag owner">群主</span>';
    } else if (isThisMemberAdmin) {
        roleTag = '<span class="role-tag admin">管理员</span>';
    }
    const titleText = (member.id === 'user') ? (chat.settings.myGroupTitle || '') : (member.groupTitle || '');
    const titleTag = titleText ? `<span class="title-tag">${titleText}</span>` : '';
    // ★★★ 如果被禁言，显示一个特殊的标签 ★★★
    const muteTag = member.isMuted ? '<span class="group-title-tag" style="color: #ff3b30; background-color: #ffe5e5;">🚫已禁言</span>' : '';

    // --- 动态生成按钮HTML ---
    let actionsHtml = '';
    
    // 用户自己的按钮
    if (member.id === 'user') {
        actionsHtml += `<button class="action-btn" data-action="set-nickname" data-member-id="user">改名</button>`;
        // ★★★ 用户被禁言时，显示“解除禁言”按钮 ★★★
        if (member.isMuted) {
             actionsHtml += `<button class="action-btn" data-action="unmute-self" data-member-id="user">解除禁言</button>`;
        }
    }

    // 管理员和群主的操作按钮
    if (canManageTitle) {
        actionsHtml += `<button class="action-btn" data-action="set-title" data-member-id="${member.id}">头衔</button>`;
    }
    if (canManageAdmin) {
        const adminActionText = isThisMemberAdmin ? '取消管理' : '设为管理';
        actionsHtml += `<button class="action-btn" data-action="toggle-admin" data-member-id="${member.id}">${adminActionText}</button>`;
    }
    if (isCurrentUserOwner && member.id !== 'user') {
        actionsHtml += `<button class="action-btn" data-action="transfer-owner" data-member-id="${member.id}">转让</button>`;
    }
    // ★★★ 禁言/解禁按钮 ★★★
    if (canMute) {
        const muteButtonText = member.isMuted ? '解禁' : '禁言';
        actionsHtml += `<button class="action-btn" data-action="mute-member" data-member-id="${member.id}">${muteButtonText}</button>`;
    }
    if (canKick) {
        actionsHtml += `<button class="action-btn danger" data-action="remove-member" data-member-id="${member.id}">踢出</button>`;
    }
    
    // 最终拼接
    item.innerHTML = `
        <img src="${member.avatar}" class="avatar">
        <div class="info">
            <span class="name">${member.groupNickname}</span>
            <div class="tags">
                ${roleTag}
                ${titleTag}
                ${muteTag}
            </div>
        </div>
        <div class="actions">${actionsHtml}</div>
    `;
    return item;
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【V2 - 修复版 | 支持解禁】的代码，完整替换掉你旧的 handleMuteMember 函数 ▼▼▼
/**
 * 【V2 - 核心修复版 | 支持解禁】处理禁言/解禁群成员
 * @param {string} memberId - 要操作的成员ID
 */
async function handleMuteMember(memberId) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    // --- 权限检查 (和之前保持一致) ---
    const isOwner = chat.ownerId === 'user';
    const isAdmin = chat.settings.isUserAdmin;
    let targetMember, targetIsOwner, targetIsAdmin;

    // 判断操作目标是普通成员还是用户自己
    if (memberId === 'user') {
        targetMember = { id: 'user', ...chat.settings }; // 构造一个临时的“成员”对象代表用户
        targetIsOwner = isOwner;
        targetIsAdmin = isAdmin;
    } else {
        targetMember = chat.members.find(m => m.id === memberId);
        if (!targetMember) return;
        targetIsOwner = chat.ownerId === memberId;
        targetIsAdmin = targetMember.isAdmin;
    }

    const canMute = (isOwner && !targetIsOwner) || (isAdmin && !targetIsOwner && !targetIsAdmin);

    if (!canMute) {
        alert("你没有权限操作该成员！");
        return;
    }

    // --- ★★★ 核心修改：切换禁言状态 ★★★ ---
    if (memberId === 'user') {
        // 如果操作的是用户自己，就更新 chat.settings.isUserMuted
        if (typeof chat.settings.isUserMuted === 'undefined') chat.settings.isUserMuted = false;
        chat.settings.isUserMuted = !chat.settings.isUserMuted;
    } else {
        // 如果操作的是其他成员，就更新成员对象
        if (typeof targetMember.isMuted === 'undefined') targetMember.isMuted = false;
        targetMember.isMuted = !targetMember.isMuted;
    }

    // ★★★ 保存更新后的群聊数据到数据库 ★★★
    await db.chats.put(chat); 

    // ★★★ 重新渲染成员管理列表，按钮文字会立刻更新 ★★★
    renderMemberManagementList();

    // ★★★ 发送系统通知 ★★★
    const myNickname = chat.settings.myNickname || '我';
    const targetNickname = (memberId === 'user' ? (chat.settings.myNickname || '我') : targetMember.groupNickname);
    const actionText = (memberId === 'user' ? chat.settings.isUserMuted : targetMember.isMuted) ? '禁言' : '解除禁言';
    await logSystemMessage(chat.id, `“${myNickname}”将“${targetNickname}”${actionText}。`);
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新】处理用户自己解除禁言
 */
async function handleUserUnmute() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.isUserMuted) return;

    const confirmed = await showCustomConfirm('解除禁言', '确定要为自己解除禁言吗？');
    if (confirmed) {
        chat.settings.isUserMuted = false;
        await db.chats.put(chat);
        
        await logSystemMessage(chat.id, `“${chat.settings.myNickname || '我'}”为自己解除了禁言。`);
        
        renderMemberManagementList(); // 刷新列表
    }
}




/**
 * 【全新】处理拉人入群的逻辑（已添加系统消息）
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    const addedNames = [];

// ▼▼▼ 在 handleAddMembersToGroup 函数内，用这整块新代码替换旧的 for 循环 ▼▼▼

for (const contactId of selectedContacts) {
    const contactChat = state.chats[contactId];
    if (contactChat) {
        // 这是原来的逻辑，用于处理普通角色(Char)
        chat.members.push({
            id: contactId,
            originalName: contactChat.name,
            groupNickname: contactChat.name,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            persona: contactChat.settings.aiPersona,
            avatarFrame: contactChat.settings.aiAvatarFrame || '',
            isAdmin: false,
            groupTitle: ''
        });
        addedNames.push(`“${contactChat.name}”`);
    } else {
        // 【核心新增】这是处理NPC的逻辑
        let foundNpc = null;
        for (const c of Object.values(state.chats)) {
            if (c.npcLibrary) {
                const npc = c.npcLibrary.find(n => n.id === contactId);
                if (npc) {
                    foundNpc = npc;
                    break;
                }
            }
        }
        if (foundNpc) {
            chat.members.push({
                id: foundNpc.id,
                originalName: foundNpc.name,
                groupNickname: foundNpc.name,
                avatar: foundNpc.avatar || defaultGroupMemberAvatar,
                persona: foundNpc.persona,
                avatarFrame: '',
                isAdmin: false,
                groupTitle: ''
            });
            addedNames.push(`“${foundNpc.name}”`);
        }
    }
}

// ▲▲▲ 替换结束 ▲▲▲


    await db.chats.put(chat);

    // 发送一条系统消息通知
    const myNickname = chat.settings.myNickname || '我';
    await logSystemMessage(chat.id, `“${myNickname}”邀请 ${addedNames.join('、')} 加入了群聊。`);

    // 返回到群成员管理界面并刷新
    openMemberManagementScreen();
    renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
}



// ▼▼▼ 在这里粘贴下面的新函数 ▼▼▼

/**
 * 【全新】处理设置用户自己的群昵称
 */
async function handleSetUserNickname() {
    const chat = state.chats[state.activeChatId];
    const oldNickname = chat.settings.myNickname || '我';
    
    const newNickname = await showCustomPrompt('修改我的群昵称', '请输入新的昵称', oldNickname);
    if (newNickname !== null && newNickname.trim()) {
        chat.settings.myNickname = newNickname.trim();
        await db.chats.put(chat);
        
        // 发送一条系统消息通知群友
        await logSystemMessage(chat.id, `“${oldNickname}”将群昵称修改为“${newNickname.trim()}”`);
        
        renderMemberManagementList(); // 刷新成员管理列表
    }
}

/**
 * 【全新】处理设置用户自己的群头衔
 */
async function handleSetUserTitle() {
    const chat = state.chats[state.activeChatId];
    const oldTitle = chat.settings.myGroupTitle || '';

    const newTitle = await showCustomPrompt('修改我的群头衔', '留空则为取消头衔', oldTitle);
    if (newTitle !== null) {
        chat.settings.myGroupTitle = newTitle.trim();
        await db.chats.put(chat);

        // 调用你已有的函数来发送系统通知
        const myNickname = chat.settings.myNickname || '我';
        await logTitleChange(chat.id, myNickname, myNickname, newTitle.trim());

        renderMemberManagementList();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
/**
 * 【全新 | 权限修复版 | 踢人无消息】从群聊中移除一个成员
 * @param {string} memberId - 要移除的成员ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const isOwner = chat.ownerId === 'user';
    const isAdmin = chat.settings.isUserAdmin;
    const memberToRemove = chat.members.find(m => m.id === memberId);
    
    // 权限检查
    if (!isOwner && !(isAdmin && !memberToRemove.isAdmin && memberToRemove.id !== chat.ownerId)) {
        alert("你没有权限移出该成员！");
        return;
    }
    
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    if (memberIndex === -1) return;
    
    const memberName = memberToRemove.groupNickname;
    const confirmed = await showCustomConfirm(
        '移出成员',
        `确定要将“${memberName}”移出群聊吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);

        const myNickname = chat.settings.myNickname || '我';
        await logSystemMessage(chat.id, `“${myNickname}”将“${memberName}”移出了群聊。`);

        renderMemberManagementList();
    }
}

// ▼▼▼ 请用这整块【功能增强版】代码，完整替换旧的 openContactPickerForAddMember 函数 ▼▼▼

async function openContactPickerForAddMember() {
    selectedContacts.clear(); 

    // 【核心修改1】在这里绑定正确的“添加成员”函数
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);

    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));
    existingMemberIds.add('user'); // 把用户自己也算作已存在成员

    // 【核心修改2】和创建群聊时一样，整合所有角色和NPC
    const allAvailablePeople = [];
    Object.values(state.chats).filter(c => !c.isGroup).forEach(c => {
        allAvailablePeople.push({
            id: c.id, name: c.name, avatar: c.settings.aiAvatar || defaultAvatar, isNpc: false
        });
    });
    const npcMap = new Map();
    Object.values(state.chats).forEach(c => {
        if (c.npcLibrary) {
            c.npcLibrary.forEach(npc => {
                if (!npcMap.has(npc.id)) {
                    npcMap.set(npc.id, {
                        id: npc.id, name: npc.name, avatar: npc.avatar || defaultGroupMemberAvatar, isNpc: true
                    });
                }
            });
        }
    });
    allAvailablePeople.push(...Array.from(npcMap.values()));

    // 过滤掉已经是群成员的人
    const contacts = allAvailablePeople.filter(p => !existingMemberIds.has(p.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的联系人了。</p>';
    } else {
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.avatar}" class="avatar">
                <span class="name">${contact.name} ${contact.isNpc ? '<span style="color: #888; font-size: 12px;">(NPC)</span>' : ''}</span>
            `;
            listEl.appendChild(item);
        });
    }

    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【重构版】在群聊中创建一个全新的虚拟成员
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('创建新成员', '请输入新成员的名字 (这将是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 检查本名是否已在群内存在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
        return;
    }

    const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重构】★★★
    // 为新创建的NPC也建立双重命名机制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成员的“本名”
        groupNickname: name.trim(), // 新成员的初始“群昵称”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成员“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是用户付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用于存储通话中的对话历史
    preCallContext: "" // 用于存储通话前的聊天摘要
};

let callTimerInterval = null; // 用于存储计时器的ID

/**
 * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮 (V3.1 - 修复版)
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true;

    // 1. 显示“正在呼叫”界面 (这部分不变)
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
    showScreen('outgoing-call-screen');
    
    // ★★★ 核心修复：导致错误的 `const membersList = ...` 代码块已从这里移除 ★★★

    // 【新增】在发起通话时，提前准备好通话前的聊天记录上下文
    videoCallState.preCallContext = chat.history
        .slice(-20) // 获取最近20条消息
        .map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name)}: ${String(msg.content).substring(0, 50)}...`)
        .join('\n');

    // 2. 重新构建一个信息更丰富、指令更明确的API请求
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，无法发起通话。');
        }
    
        let systemPromptForCall;
        if (chat.isGroup) {
            systemPromptForCall = `
# 你的任务
你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
用户 (${chat.settings.myNickname || '我'}) 刚刚发起了群视频通话。
你的任务是根据每个角色的性格和最近的聊天内容，决定他们是否要加入通话。

# 核心规则
1.  **决策**: 每个角色都必须独立决策。
2.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的决策，格式为：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
3.  **倾向性**: 在没有特殊理由的情况下，你的角色们通常乐于加入群聊。

# 角色列表与人设
${chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n')}

# 通话前的聊天摘要
${videoCallState.preCallContext}
`;
        } else {
            systemPromptForCall = `
# 你的任务
你正在扮演角色 "${chat.name}"。用户 (${chat.settings.myNickname || '我'}) 刚刚向你发起了视频通话请求。
你的任务是根据你的人设和我们最近的聊天内容，决定是否接受。

# 核心规则
1.  **决策**: 你必须做出 "accept" (接受) 或 "reject" (拒绝) 的决定。
2.  **格式**: 你的回复【必须且只能】是一个JSON数组，其中包含一个对象，格式为：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
3.  **倾向性**: 作为一个友好的AI伴侣，在没有特殊理由（比如在之前的对话中明确表示了不想被打扰或正在忙）的情况下，你【应该优先选择接受】通话。

# 你的人设
${chat.settings.aiPersona}

# 通话前的聊天摘要
${videoCallState.preCallContext}
`;
        }
        
        const messagesForApi = [{ role: 'user', content: "请根据你在系统指令中读到的规则，立即做出你的决策。" }];
        
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPromptForCall, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPromptForCall }, ...messagesForApi],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
            
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 错误 (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const responseArray = JSON.parse(aiResponseContent);

        if (chat.isGroup) {
            responseArray.forEach(action => {
                if (action.type === 'group_call_response' && action.decision === 'join') {
                    const member = chat.members.find(m => m.originalName === action.name);
                    if (member) videoCallState.participants.push(member);
                }
            });
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                throw new Error("群里没有人接听你的通话邀请。");
            }
        } else {
            const decision = responseArray[0];
            if (decision.type === 'video_call_response' && decision.decision === 'accept') {
                startVideoCall();
            } else {
                throw new Error("对方拒绝了你的视频通话请求。");
            }
        }

    } catch (error) {
        console.error("发起通话失败:", error);
        await showCustomAlert("呼叫失败", error.message);
        videoCallState.isAwaitingResponse = false;
        showScreen('chat-interface-screen');
    }
}




// ▼▼▼ 用这个【全新的函数】，完整替换掉你旧的 startVideoCall 函数 ▼▼▼
function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
// ▼▼▼ 把下面这整块代码从 handleInitiateCall 函数里【剪切】掉 ▼▼▼

// 提取通话前的最后20条消息作为上下文
videoCallState.preCallContext = chat.history
    .slice(-20)
    .map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name)}: ${String(msg.content).substring(0, 50)}...`)
    .join('\n');

    // 1. 【核心判断】检查是否启用了可视化界面
    if (chat.settings.visualVideoCallEnabled) {
        // --- 启动【新】的可视化界面 ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');
        
        // 显示新界面，隐藏旧界面
        visualInterface.style.display = 'flex';
        textInterface.style.display = 'none';

        // 加载图片
        document.querySelector('#video-main-view img').src = chat.settings.charVideoImage || defaultAvatar;
        document.querySelector('#video-pip-view img').src = chat.settings.userVideoImage || defaultAvatar;
        
        // 清空旧的聊天气泡
        document.getElementById('video-call-messages-visual').innerHTML = `<em>正在接通...</em>`;
        showScreen('video-call-screen');

        // 启动计时器
        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer(); // 立即更新一次

        // 触发AI在通话中的第一句话
        triggerAiInCallAction();

    } else {
        // --- 启动【旧】的纯文字界面 (这里的代码就是你原来的逻辑) ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');

        // 显示旧界面，隐藏新界面
        visualInterface.style.display = 'none';
        textInterface.style.display = 'flex'; // 旧界面用flex

        updateParticipantAvatars(); 
        
        document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
        showScreen('video-call-screen');

        document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
        document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer();

        triggerAiInCallAction();
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【核心】结束视频通话
 */
// ▼▼▼ 用这整块代码替换旧的 endVideoCall 函数 ▼▼▼
async function endVideoCall() {
  // ▼▼▼ 在 endVideoCall 函数的【开头】添加这行代码 ▼▼▼
document.getElementById('visual-call-interface').style.display = 'none';
// ▲▲▲ 添加结束 ▲▲▲

    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 决定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】为群聊的 assistant 消息补充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通话结束的消息应该由“发起者”来说
    // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替换结束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心变革】创建并添加对用户隐藏的“通话后汇报”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1, // 确保在上一条消息之后
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // 4. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置状态 (这部分逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 关键一步！
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】更新通话界面的参与者头像网格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】处理用户加入/重新加入通话
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新头像列表，加入用户

    // 切换底部按钮
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用户加入了
    triggerAiInCallAction("[系统提示：用户加入了通话]");
}


/**
 * 更新通话计时器显示 
 */
// ▼▼▼ 用这个【新版本】替换旧的 updateCallTimer 函数 ▼▼▼
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // 同时更新两个界面的计时器
    document.getElementById('call-timer').textContent = timeString;
    document.getElementById('visual-call-timer').textContent = timeString;
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
function showIncomingCallModal(chatId) { // <--- 在括号里添加 chatId
    const chat = state.chats[chatId]; // <--- 把 state.activeChatId 修改为 chatId
    if (!chat) return;

    // 根据是否群聊显示不同信息
    if (chat.isGroup) {
        // 从 videoCallState 中获取是哪个成员发起的通话
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 显示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
    } else {
        // 单聊逻辑保持不变
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
    playRingtone(); // <-- 在这里添加这一行
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 隐藏AI发起的通话请求模态框 (保持不变)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
    stopRingtone(); // <-- 在这里添加这一行
}

// ▼▼▼ 【这是修正后的版本】请用这一整块代码，完整替换你旧的 triggerAiInCallAction 函数 ▼▼▼
async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    const callFeed = isVisualMode 
        ? document.getElementById('video-call-messages-visual') 
        : document.getElementById('video-call-main');

    const userNickname = chat.settings.myNickname || '我';

    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    if (userInput && videoCallState.isUserParticipating) {
        if (isVisualMode) {
            const userBubble = document.createElement('div');
            userBubble.className = 'visual-call-bubble user';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        } else {
            const userBubble = document.createElement('div');
            userBubble.className = 'call-message-bubble user-speech';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        }
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        // ★★★ 核心修复1：在这里，我们提前定义好 participantNames ★★★
        const participantNames = videoCallState.participants.map(p => p.originalName); 
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        // ★★★ 修复结束 ★★★

        inCallPrompt = `
# 你的任务
你是一个群聊AI，负责扮演所有【除了用户以外】的AI角色。你们正在进行一场群聊视频通话。
你的任务是根据每个角色的性格，生成他们在通话中会说的【第一人称对话】，注意是在视频通话，绝对不能以为是在现实！每次回复的字数多些，50字以上。

# 核心规则
1.  **【【【语言铁律】】】**: 无论角色人设是什么国籍或说什么语言，在本次视频通话中，所有角色【必须】全程使用【中文】进行交流。
2.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "【角色的本名】", "speech": "【在这里加入带动作的对话】"}\`。
3.  **【【【表现力铁律】】】**: 在 "speech" 字段中，你【必须】为角色的对话加入【动作、表情或心理活动】，并用【】符号包裹。这非常重要！
4.  **示例**: \`{"name": "张三", "speech": "【挠了挠头】啊？我刚刚走神了，你们说到哪了？"}\`
5.  **身份铁律**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
6.  **角色扮演**: 严格遵守每个角色的设定，用他们的口吻说话。

# 当前情景
你们正在一个群视频通话中。
**通话前的聊天摘要**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
${worldBookContent}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    } else {
        // ★★★ 核心修复2：为单人通话提供一个完全独立的、正确的Prompt ★★★
        let openingContext = videoCallState.initiator === 'user'
            ? `你刚刚接听了用户的视频通话请求。`
            : `用户刚刚接听了你主动发起的视频通话。`;
            
        inCallPrompt = `
# 你的任务
你正在扮演角色 "${chat.name}"。你正在和用户 (${userNickname}) 进行一对一视频通话。
${openingContext}
你的任务是根据你的人设和我们的聊天情景，生成你在通话中会说的【第一人称对话】。

# 核心规则
1.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一段纯文本字符串，代表你的发言。绝对不要输出JSON格式。
2.  **【【【表现力铁律】】】**: 在你的对话中，你【必须】加入【动作、表情或心理活动】，并用【】符号包裹。
3.  **示例**: "【歪了歪头，好奇地看着你】真的吗？快跟我说说看！"
4.  **禁止出戏**: 绝不能透露你是AI或模型。

# 当前情景
**通话前的聊天摘要**:
${videoCallState.preCallContext}
${worldBookContent}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
        // ★★★ 修复结束 ★★★
    }
    
    const messagesForApi = [
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi, isGemini);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: [{ role: 'system', content: inCallPrompt }, ...messagesForApi], temperature: parseFloat(state.apiConfig.temperature) || 0.8, })
        });
        if (!response.ok) throw new Error((await response.json()).error.message);

        const data = await response.json();
        const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        const sanitizedResponse = aiResponse.replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, '').trim();

        const connectingElement = callFeed.querySelector('em');
        if (connectingElement) connectingElement.remove();

        if (isVisualMode) {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'visual-call-bubble ai';
            aiBubble.textContent = sanitizedResponse;
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
        } else {
            if (videoCallState.isGroupCall) {
                const speechArray = parseAiResponse(sanitizedResponse); 
                speechArray.forEach(turn => {
                    if (!turn.name || turn.name === userNickname || !turn.speech) return;
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                    
                    const speaker = videoCallState.participants.find(p => p.originalName === turn.name);
                    if (speaker) {
                        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                        if(speakingAvatar) {
                            speakingAvatar.classList.add('speaking');
                            setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                        }
                    }
                });
            } else {
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.textContent = sanitizedResponse;
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
                const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                if(speakingAvatar) {
                    speakingAvatar.classList.add('speaking');
                    setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                }
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        
        if (isVisualMode) {
            errorBubble.className = 'visual-call-bubble ai';
        } else {
            errorBubble.className = 'call-message-bubble ai-speech';
        }
        
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}

// ▼▼▼ 将这个【全新函数】粘贴到JS功能函数定义区 ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新内存中原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是“我”付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 将更新后的数据保存到数据库，并立刻重绘UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
 * @param {string} chatId - 发生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 触发屏幕震动动画
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 弹出输入框让用户输入后缀
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可选）输入后缀",
        "",
        "text"
    );

    // 如果用户点了取消，则什么也不做
    if (suffix === null) return;

    // 3. 创建对用户可见的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】将后缀拼接到消息内容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系统消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
    // 【核心修改】同样将后缀加入到给AI的提示中
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 时间戳+1以保证顺序
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存更改并更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
/**
 * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
        return;
    }

    // 2. 将未到期的约定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
        return 0; // 其他情况保持原序
    });

    // 3. 【核心】使用单一循环来处理所有类型的卡片
    allMemories.forEach(item => {
        let card;
        // 判断1：如果是正在进行的约定
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // 判断2：其他所有情况（普通回忆 或 已到期的约定）
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. 启动所有倒计时
    startAllCountdownTimers();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 创建普通回忆卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的约定
        titleHtml = `[约定达成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
    } else {
        // 如果是普通的日记式回忆
        titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
    const targetDate = new Date(countdown.targetDate);
    
    // 现在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
        <div class="target-date">目标时间: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

// 全局变量，用于管理所有倒计时
let activeCountdownTimers = [];

// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的旧计时器，防止内存泄漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在这里，我们先用 let 声明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "约定达成！";
                // 现在 updateTimer 可以正确地找到并清除它自己了
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即执行一次以显示初始倒计时
        
        // 【核心修正】在这里，我们为已声明的 timerId 赋值
        timerId = setInterval(updateTimer, 1000);
        
        // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置错误", "API设置不完整，无法继续。");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
# 你的角色设定
${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}
# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
}
\`\`\`
`;

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

/**
 * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // 单聊保持原样，打开转账弹窗
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * 打开并初始化发红包模态框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理输入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充专属红包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作为显示给用户看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 默认显示拼手气红包页签
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 发送群红包（拼手气）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的总金额！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("请输入有效的红包个数！"); return;
    }
    if (amount / count < 0.01) {
        alert("单个红包金额不能少于0.01元！"); return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜发财，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 发送专属红包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额！"); return;
    }
    if (!receiverName) {
        alert("请选择一个接收人！"); return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '给你准备了一个红包',
        receiverName: receiverName, // 核心字段
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
 * @param {number} timestamp - 被点击的红包消息的时间戳
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先尝试打开红包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打开（claimedAmount不为null）
        if (claimedAmount !== null) {
            // **关键：在数据更新后，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 显示成功提示
            await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 无论成功与否，最后都显示详情页
        // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这整块【功能增强版】代码，完整替换掉你旧的 handleOpenRedPacket 函数 ▼▼▼
/**
 * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 检查红包是否还能领
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "红包已被领完！");
        return null; // 返回null表示领取失败
    }
    
    // 2. 计算领取金额
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新红包数据
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 【【【这就是最关键的部分！】】】构建系统消息和AI指令
    let hiddenMessageContent = '';

    // 如果红包被领完了，就准备“战报”
    if (isNowFullyClaimed) {
        const finishedMessage = {
            role: 'system',
            type: 'pat_message',
            content: `${packet.senderName} 的红包已被领完`,
            timestamp: Date.now() + 1
        };
        chat.history.push(finishedMessage);
        
        hiddenMessageContent = `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。`;

        let luckyKing = { name: '', amount: -1 };
        if (packet.packetType === 'lucky' && packet.count > 1) {
            Object.entries(packet.claimedBy).forEach(([name, amount]) => {
                if (amount > luckyKing.amount) {
                    luckyKing = { name, amount };
                }
            });
        }
        if (luckyKing.name) {
             hiddenMessageContent += ` 手气王是 ${luckyKing.name}！`;
        }
        hiddenMessageContent += ' 请对此事件发表评论。]';
    } 
    // 如果还没被领完
    else {
        hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完。]`;
    }

    // 创建并添加给AI看的隐藏消息
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 2,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存到数据库
    await db.chats.put(chat);
    
    // 6. 返回领取的金额，用于后续弹窗
    return claimedAmount;
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接检查传入的packet对象是否存在，无需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了无效的packet对象");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手气王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 绑定关闭详情按钮的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

/**
 * 打开创建投票的模态框并初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 默认创建两个空的选项框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * 在模态框中动态添加一个选项输入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 确保至少保留两个选项
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2个选项。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用户确认发起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('请输入投票问题！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 过滤掉空的选项

    if (options.length < 2) {
        alert('请至少输入2个有效的投票选项！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票为空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
/**
 * 处理用户投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 * @param {string} choice - 用户选择的选项文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已关闭，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已关闭的投票，则直接显示结果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 检查用户是否点击了已经投过的同一个选项
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
    if (!isReclickingSameOption) {
        // 移除旧投票（如果用户改选）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
    let hiddenMessageContent = null; 
    
    // 只有在用户真正投票或改票时，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存数据并更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户结束投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示投票结果详情
 * @param {number} timestamp - 投票消息的时间戳
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票结果", resultsHtml);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 openAiAvatarLibraryModal 函数的上方 ▼▼▼

/* --- 【全新】User头像库管理功能核心函数 --- */

/**
 * 【总入口】打开User的头像库管理模态框
 */
function openMyAvatarLibraryModal() {
    // 复用AI头像库的弹窗，只需要修改标题
    const titleEl = document.getElementById('ai-avatar-library-title');
    titleEl.textContent = '我的头像库';

    // 为“添加”按钮绑定正确的函数
    const addBtn = document.getElementById('add-ai-avatar-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', addAvatarToMyLibrary); // 绑定到新函数

    // 为“关闭”按钮绑定正确的函数
    const closeBtn = document.getElementById('close-ai-avatar-library-btn');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
    newCloseBtn.addEventListener('click', () => {
        document.getElementById('ai-avatar-library-modal').classList.remove('visible');
    });

    renderMyAvatarLibrary(); // 渲染User的头像列表
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

// ▼▼▼ 用这块【功能增强版】代码，替换旧的 renderMyAvatarLibrary 函数 ▼▼▼
/**
 * 【V3 - 带确认弹窗】渲染User的头像库
 */
async function renderMyAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const library = await db.userAvatarLibrary.toArray();

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">你的头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情的flex布局样式
        item.title = avatar.name;

        item.innerHTML = `
            <div class="avatar-library-image-wrapper" style="background-image: url(${avatar.url})">
                <div class="delete-btn" style="display: block;">×</div>
            </div>
            <span class="avatar-library-name">${avatar.name}</span>
        `;

        // ★★★★★ 这就是我们本次修改的核心！ ★★★★★
        // 1. 为整个项目添加“异步”点击事件监听器
        item.addEventListener('click', async (e) => {
            // 确保点击的不是删除按钮
            if (!e.target.classList.contains('delete-btn')) {
                // 2. 弹出确认框
                const confirmed = await showCustomConfirm(
                    '更换头像',
                    `确定要将 “${avatar.name}” 应用为你的头像吗？`
                );

                // 3. 如果用户点击了“是” (confirmed 为 true)
                if (confirmed) {
                    // 才执行更换头像的操作
                    document.getElementById('my-avatar-preview').src = avatar.url;
                    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
                    alert(`头像已更换为“${avatar.name}”`);
                }
                // 如果用户点击“取消”，则什么也不做
            }
        });
        // ★★★★★ 修改结束 ★★★★★

        // 为删除按钮绑定独立的点击事件（这部分保持不变）
        item.querySelector('.delete-btn').onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.userAvatarLibrary.delete(avatar.id);
                renderMyAvatarLibrary(); // 刷新
            }
        };
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【功能增强版】的代码，替换旧的 addAvatarToMyLibrary 函数 ▼▼▼
/**
 * 【V2 - 支持本地上传】向User的头像库中添加新头像
 */
async function addAvatarToMyLibrary() {
    // 1. 先让用户为新头像命名
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：日常、工作）");
    if (!name || !name.trim()) {
        // 如果用户取消或没输入名字，则中止操作
        if (name !== null) alert("头像名称不能为空！");
        return;
    }

    // 2. ★★★ 核心修改：弹出选择框，让用户决定上传方式 ★★★
    const choice = await showChoiceModal("选择头像来源", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newAvatarUrl = null;

    // 3. 根据用户的选择，执行不同的上传逻辑
    if (choice === 'local') {
        // 如果选择本地上传，调用我们现成的辅助函数
        newAvatarUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        // 如果选择URL，还是弹出原来的输入框
        newAvatarUrl = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
        if (newAvatarUrl && !newAvatarUrl.trim().startsWith('http')) {
            alert("请输入一个有效的图片URL！");
            newAvatarUrl = null; // 输入无效，重置为null
        }
    }
    // 如果用户在选择来源时点了取消(choice为null)，则newAvatarUrl也为null，流程会自然结束

    // 4. 如果成功获取到了图片URL，就保存到数据库
    if (newAvatarUrl && newAvatarUrl.trim()) {
        const newAvatar = {
            id: 'user_avatar_' + Date.now(),
            name: name.trim(),
            url: newAvatarUrl.trim()
        };

        await db.userAvatarLibrary.add(newAvatar);
        renderMyAvatarLibrary(); // 刷新列表
        alert("新头像已成功添加到你的头像库！");
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

/**
 * 打开AI头像库管理模态框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

// ▼▼▼ 用这块【功能增强版】代码，替换旧的 renderAiAvatarLibrary 函数 ▼▼▼
/**
 * 【V3 - 带确认弹窗】渲染AI头像库的内容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.title = avatar.name;

        item.innerHTML = `
            <div class="avatar-library-image-wrapper" style="background-image: url(${avatar.url})">
                <div class="delete-btn" style="display: block;">×</div>
            </div>
            <span class="avatar-library-name">${avatar.name}</span>
        `;
        
        // ★★★★★ 这就是我们为角色头像库新增的核心逻辑！ ★★★★★
        // 1. 为整个项目添加“异步”点击事件监听器
        item.addEventListener('click', async (e) => {
            if (!e.target.classList.contains('delete-btn')) {
                // 2. 弹出确认框，并带上角色名字
                const confirmed = await showCustomConfirm(
                    '更换头像',
                    `确定要将 “${avatar.name}” 应用为 “${chat.name}” 的头像吗？`
                );

                // 3. 如果用户确认
                if (confirmed) {
                    // 就将图片应用到角色头像的预览框
                    document.getElementById('ai-avatar-preview').src = avatar.url;
                    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
                    alert(`“${chat.name}”的头像已更换为“${avatar.name}”`);
                }
            }
        });
        // ★★★★★ 新增逻辑结束 ★★★★★

        // 删除按钮的逻辑保持不变
        item.querySelector('.delete-btn').onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【功能增强版】的代码，替换旧的 addAvatarToLibrary 函数 ▼▼▼
/**
 * 【V2 - 支持本地上传】向当前AI的头像库中添加新头像
 */
async function addAvatarToLibrary() {
    // 1. 先让用户为新头像命名
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) {
        if (name !== null) alert("头像名称不能为空！");
        return;
    }

    // 2. ★★★ 核心修改：弹出选择框，让用户决定上传方式 ★★★
    const choice = await showChoiceModal("选择头像来源", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newAvatarUrl = null;

    // 3. 根据用户的选择，执行不同的上传逻辑
    if (choice === 'local') {
        newAvatarUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newAvatarUrl = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
        if (newAvatarUrl && !newAvatarUrl.trim().startsWith('http')) {
            alert("请输入一个有效的图片URL！");
            newAvatarUrl = null;
        }
    }

    // 4. 如果成功获取到了图片URL，就保存到当前角色的数据中
    if (newAvatarUrl && newAvatarUrl.trim()) {
        const chat = state.chats[state.activeChatId];
        if (!chat.settings.aiAvatarLibrary) {
            chat.settings.aiAvatarLibrary = [];
        }

        chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: newAvatarUrl.trim() });
        await db.chats.put(chat);
        renderAiAvatarLibrary(); // 刷新列表
        alert("新头像已成功添加到当前角色的头像库！");
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 关闭AI头像库管理模态框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在这里粘贴下面这整块新代码 ▼▼▼
/**
 * 【全新】渲染主屏幕个人资料卡的头像框
 */
function renderHomeScreenProfileFrame() {
    // 1. 获取保存的头像框URL
    const frameUrl = state.globalSettings.homeAvatarFrame || '';
    // 2. 找到头像框的img元素
    const frameImg = document.getElementById('profile-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就显示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL为空（即选择了“无”），就隐藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲


/* ▼▼▼ 步骤 3.2：将这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */

// ▼▼▼ 用下面这【一整块】代码，替换你旧的 applyWidgetData 函数 ▼▼▼
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } 
            // --- ▼▼▼ 这是我们新增的修复逻辑 ▼▼▼ ---
            // 如果是地点这个特殊元素，就用 innerHTML 来正确显示图标
            else if (elementId === 'profile-location') {
                element.innerHTML = savedValue;
            } 
            // --- ▲▲▲ 修复逻辑结束 ▲▲▲ ---
            else {
                // 其他普通文本元素，保持原来的逻辑不变
                element.textContent = savedValue; 
            }
        }
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新辅助函数】打开文件选择器，并返回本地图片的Base64编码
 * @returns {Promise<string|null>} - 返回图片的Base64 Data URL，如果用户取消则返回null
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // 只接受图片文件

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // 返回Base64字符串
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // 用户关闭了文件选择框
            }
        };

        input.click();
    });
}

// ▼▼▼ 步骤 2.2：用这个已修复的版本，替换旧的 handleEditText 函数 ▼▼▼
async function handleEditText(element) {
    const elementId = element.id;
    const placeholder = element.dataset.placeholder || "请输入新的内容：";
    const textSpan = element.querySelector('span');
    const isComplexElement = !!textSpan;
    const targetElement = isComplexElement ? textSpan : element;
    const currentValue = targetElement.textContent;
    
    const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue === placeholder ? "" : currentValue);

    if (newValue !== null) {
        const trimmedValue = newValue.trim();
        targetElement.textContent = trimmedValue ? trimmedValue : placeholder;
        state.globalSettings.widgetData[elementId] = isComplexElement ? element.innerHTML : targetElement.textContent;
        await db.globalSettings.put(state.globalSettings);
    }
}
// ▲▲▲ JavaScript 替换结束 ▲▲▲

/**
 * 【全新】触发指定群聊的后台AI互动
 * @param {string} chatId - 要触发互动的群聊ID
 */
async function triggerGroupAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn(`群聊 "${chat.name}" 后台活动失败：API未配置。`);
        return;
    }
    
    // added by lrq 251027
    const maxMemory = chat.settings.maxMemory || 10;
    const historySlice = chat.history.filter(msg => !msg.isHidden).slice(-maxMemory);

    // 2. 格式化这些记录，让AI能看懂
    const recentContextSummary = historySlice.map(msg => {
        // 判断是谁说的话
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        
        // 处理不同类型的消息内容
        let contentText = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentText = `[发送了一个表情: ${msg.meaning || '无描述'}]`;
        } else if (Array.isArray(msg.content)) {
            contentText = '[发送了一张图片]';
        } else if (typeof msg.content === 'object' && msg.content !== null) {
            contentText = `[发送了一条特殊消息: ${msg.type || '未知类型'}]`;
        } else {
            contentText = String(msg.content);
        }
        
        // updated by lrq 251029 给每条消息记录添加发送日期时间
        const messageDate = new Date(msg.timestamp);
        const formattedDate = messageDate.toLocaleDateString();

        return `[${formattedDate}] ${sender}: ${contentText}`;
    }).join('\n');

    // --- ▲▲▲ 核心修改到这里结束 ▲▲▲ ---

    // added by lrq 251027 获取记忆互通的聊天记录
    let linkedMemoryContext = '';
    if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
        const contextPromises = chat.settings.linkedMemories.map(async (link) => {
            const linkedChat = state.chats[link.chatId];
            if (!linkedChat) return '';

            const freshLinkedChat = await db.chats.get(link.chatId);
            if (!freshLinkedChat) return '';

            const recentHistory = freshLinkedChat.history
                .filter(msg => !msg.isHidden)
                .slice(-link.depth); 

            if (recentHistory.length === 0) return '';

            const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

            return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
        });

        const allContexts = await Promise.all(contextPromises);
        linkedMemoryContext = allContexts.filter(Boolean).join('\n');
    }

    try {
        const lastMessage = chat.history.slice(-1)[0];
        const timeSinceLastMessage = lastMessage ? (Date.now() - lastMessage.timestamp) / 1000 / 60 : Infinity; // in minutes
        
        const membersList = chat.members.map(m => `- ${m.groupNickname} (人设: ${m.persona})`).join('\n');
          const myNickname = chat.settings.myNickname || '我';
  
        let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    let musicContext = '';
    // 注意：后台群聊活动通常不与特定的“一起听歌”会话绑定，因此这里我们提供一个空的音乐上下文。
    // 如果未来需要更复杂的功能，可以在此扩展。

    const countdownContext = await getCountdownContext(); 
    
    let sharedContext = '';
    // 后台群聊活动中不存在用户分享聊天记录的上下文，因此这里为空。

// ▼▼▼ 从这里开始完整替换 ▼▼▼

// updated by lrq 251027
    const systemPrompt = `
# 任务
你是一个群聊后台模拟器。当前群聊 "${chat.name}" 已经沉寂了 ${Math.round(timeSinceLastMessage)} 分钟，用户(昵称: "${chat.settings.myNickname || '我'}")不在线。
你的任务是根据下方每个角色的人设，在他们之间【自发地】生成一段自然的对话。
# 【对话节奏铁律 (至关重要！)】
你的回复【必须】模拟真人的打字和思考习惯。**绝对不要一次性发送一大段文字！** 每条消息最好不要超过30个字，这会让对话看起来更自然、更真实。
# 核心规则
1.  **【【【身份铁律】】】**: 用户【绝对不在场】。你【绝对不能】生成与用户对话的内容。整段对话必须是AI角色之间的互动。你的唯一任务是扮演【且仅能扮演】下方“群成员列表”中明确列出的角色。【绝对禁止】扮演任何未在“群成员列表”中出现的角色。
    # 群成员列表及人设 (name字段是你要使用的【本名】)
    ${chat.members.map(m => `- **${m.originalName}**: (群昵称为: ${m.groupNickname}) 人设: ${m.persona}`).join('\n')}
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。
5.  **自然性**: 对话应该简短（2-5条消息即可），符合逻辑和角色性格。可以是闲聊、讨论某个话题，或者对之前聊天内容的延续。不要每次都生成所有人的发言。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **发送表情**: \`{"type": "sticker", "name": "角色名",  "sticker_name": "表情的名字"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\` (向【群友】发起)
-   **拍一拍群友**: \`{"type": "pat_user", "name": "你的角色名", "targetName": "【被拍的群友名】", "suffix": "(可选)你想加的后缀"}\`
-   **发红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", ...}\`
-   **发起投票**: \`{"type": "poll", "name": "你的角色名", ...}\`

# 如何处理后台互动中的【拍一拍】:
-   后台活动中的 "pat_user" 指令【只能用于拍群内的其他AI角色】。
-   你【必须】在指令中加入一个 \`"targetName"\` 字段，值为被你拍的那个角色的名字。
-   例如: \`{"type": "pat_user", "name": "角色A", "targetName": "角色B"}\`
-   系统会自动生成 "角色A 拍了拍 角色B" 的提示。

${worldBookContent}
${musicContext}
${countdownContext} // <--- 把备忘录加在这里
${sharedContext} 
# 群成员列表及人设
${membersList}
# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}
# 对话历史参考
${recentContextSummary}
${linkedMemoryContext}

现在，请严格遵守以上所有规则，开始你的模拟。`;
        
        const messagesPayload = [{ role: 'user', content: systemPrompt }];

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const messagesArray = JSON.parse(aiResponseContent);

        if (Array.isArray(messagesArray) && messagesArray.length > 0) {
            let messageTimestamp = Date.now();
            let firstMessageContent = '';
            
            messagesArray.forEach((msgData, index) => {
                if (msgData.name && msgData.message) {
                    const aiMessage = {
                        role: 'assistant',
                        senderName: msgData.name,
                        content: String(msgData.message),
                        timestamp: messageTimestamp++
                    };
                    chat.history.push(aiMessage);
                    if (index === 0) {
                        firstMessageContent = `${msgData.name}: ${msgData.message}`;
                    }
                }
            });

            // 更新此群聊的最后活动时间戳
            chat.settings.backgroundActivity.lastActivityTimestamp = Date.now();
            
            // 给用户发通知
            chat.unreadCount = (chat.unreadCount || 0) + messagesArray.length;
            showNotification(chatId, firstMessageContent);
            
            // 保存并刷新UI
            await db.chats.put(chat);
            renderChatList();
            
            console.log(`群聊 "${chat.name}" 后台互动成功，生成了 ${messagesArray.length} 条新消息。`);
        }

    } catch (error) {
        console.error(`群聊 "${chat.name}" 的后台活动失败:`, error);
    }
}

// ▼▼▼ 请用这【一整块新代码】替换旧的 handleEditImage 函数 ▼▼▼
async function handleEditImage(element) {
    const elementId = element.id;

    // 【核心修改】移除了按钮文字中的图标
    const choice = await showChoiceModal("修改图片", [
        { text: '从本地上传', value: 'local' },
        { text: '使用网络URL', value: 'url' }
    ]);

    let newValue = null;

    if (choice === 'local') {
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        newValue = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
    }

    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
    } else if (choice === 'url' && newValue !== null) {
        alert("请输入一个有效的图片URL！");
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】群聊专属后台活动时钟 ▼▼▼

let groupSimulationIntervalId = null; // 用于存储群聊主时钟的ID
/**
 * 启动群聊的后台“主时钟”。这个时钟会一直运行，定期检查所有群聊。
 */
function startGroupSimulation() {
    if (groupSimulationIntervalId) return; // 如果已经启动，则不重复启动
    
    // 我们设置一个相对较短的间隔（比如30秒）来作为“主时钟”的频率
    // 它不是具体某个群聊的活动间隔，而是检查所有群聊的频率

    // updated by lrq 251028
    // 加长检查间隔，防止已经触发自动回复但api未返回时重复触发导致多次回复。60秒间隔大于一般API返回数据时间的平均值，且不会过长影响使用体验。
    groupSimulationIntervalId = setInterval(runGroupSimulationTick, 60000); // 60秒检查一次
    console.log("群聊后台活动主时钟已启动，每60秒检查一次所有群聊。");
}

/**
 * 停止群聊的后台“主时钟”。
 */
function stopGroupSimulation() {
    if (groupSimulationIntervalId) {
        clearInterval(groupSimulationIntervalId);
        groupSimulationIntervalId = null;
        console.log("群聊后台活动主时钟已停止。");
    }
}

/**
 * 群聊“主时钟”的每一次心跳执行的函数
 */
function runGroupSimulationTick() {
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);

    allGroupChats.forEach(chat => {
        const bgSettings = chat.settings.backgroundActivity;
        // 检查1：该群聊自己的开关是否开启
        if (bgSettings && bgSettings.enabled) {
            const now = Date.now();

            // 检查2：使用该群聊自己设置的间隔期
            const intervalMs = (bgSettings.interval || 120) * 1000;
            //const lastActivity = bgSettings.lastActivityTimestamp || 0;

            // updated by lrq 251028
            // 使用当前群聊最后一条消息时间作为最后活动时间
            const lastMessage = chat.history.slice(-1)[0];
            const lastActivity = lastMessage ? lastMessage.timestamp : 0;

            // 检查3：是否到达了该群聊的行动时间
            if (now - lastActivity > intervalMs) {
                console.log(`群聊 "${chat.name}" 到达行动时间 (间隔: ${bgSettings.interval}秒)，准备触发后台互动...`);
                // 触发群聊专属的后台行动函数
                triggerGroupAiAction(chat.id);
            }
        }
    });
}

// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼
/**
 * 【全新】清空所有已关注角色的微博帖子
 */
async function clearFollowingFeed() {
    // 1. 弹出确认框，防止误操作
    const confirmed = await showCustomConfirm(
        '确认清空',
        '此操作将永久删除所有【非你本人发布】的微博，且无法恢复。确定要继续吗？',
        { confirmButtonClass: 'btn-danger' } // 红色按钮以示警告
    );

    if (!confirmed) {
        return; // 如果用户取消，则不执行任何操作
    }

    try {
        // 2. 从数据库中找出所有作者不是'user'的帖子
        const postsToDelete = await db.weiboPosts.where('authorId').notEqual('user').toArray();
        const idsToDelete = postsToDelete.map(p => p.id);

        if (idsToDelete.length === 0) {
            alert("目前没有可以清空的动态。");
            return;
        }

        // 3. 批量删除这些帖子
        await db.weiboPosts.bulkDelete(idsToDelete);

        // 4. 重新渲染“关注的人”的Feed，让界面变空
        await renderWeiboFeeds('weibo-following-view');

        alert(`已成功清空 ${idsToDelete.length} 条动态！`);

    } catch (error) {
        console.error("清空关注动态时出错:", error);
        alert(`操作失败: ${error.message}`);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】将保存的图标URL应用到主屏幕的App图标上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

// ▼▼▼ 用下面这段【修改后】的代码，完整替换掉你旧的 appLabels ▼▼▼
const appLabels = {
    'world-book': '世界书',
    'qq': 'QQ',
    'api-settings': 'API设置',
    'wallpaper': '壁纸',
    'font': '字体',
    'check-phone': '查手机',
    'weibo': '微博',
    'forum': '圈子',
    'lovers-space': '情侣空间',
    'game-hall': '游戏大厅',
    'x-social': 'X社交',
    'taobao': '桃宝',
    'date-a-live':'约会大作战'
};
// ▲▲▲ 替换结束 ▲▲▲




    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || '未知App';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">更换</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

/**
 * 当用户点击链接卡片时，打开伪浏览器
 * @param {number} timestamp - 被点击消息的时间戳
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全检查，确保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充浏览器内容
    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '无标题'}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 显示浏览器屏幕
    showScreen('browser-screen');
}

/**
 * 关闭伪浏览器，返回聊天界面
 * (这个函数现在由 init() 中的事件监听器调用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

/**
 * 打开让用户填写链接信息的模态框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次输入的内容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 显示模态框
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * 用户确认分享，创建并发送链接卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("标题是必填项哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 创建消息对象
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 用户分享的链接，我们不提供图片，让它总是显示占位图
        thumbnail_url: null 
    };

    // 将消息添加到历史记录
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息并更新列表
    appendMessage(linkMessage, chat);
    renderChatList();

    // 关闭模态框
    document.getElementById('share-link-modal').classList.remove('visible');
}

// ▼▼▼ 请用这块【V2 - 角色关系修复版】代码，完整替换旧的 buildCommentsContextForAI 函数 ▼▼▼
/**
 * 【全新升级版】根据AI视角和动态设置，构建给AI看的评论区上下文
 * @param {object} post - 正在处理的动态对象
 * @param {object} viewerChat - 正在“看”动态的AI角色
 * @param {string} userNickname - 用户的昵称
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    // 1. 安全检查，如果post.comments不存在或不是数组，直接返回空
    if (!post.comments || !Array.isArray(post.comments) || post.comments.length === 0) {
        return { contextString: "", visibilityFlag: "[评论区可见]" };
    }

    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    // 2. 根据帖子的评论可见性设置，决定AI能看到哪些评论
    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments; // 如果可见性为true或未设置，则AI能看到所有评论
        visibilityFlag = "[评论区可见]";
    } else {
        // 如果设置为“部分可见”，则AI只能看到自己、用户以及回复自己的评论
        commentsForAI = post.comments.filter(comment => {
            return comment.commenterName === viewerName // AI自己的评论
                || comment.commenterName === userNickname // 用户的评论
                || comment.replyTo === viewerName; // 回复AI的评论
        });
        visibilityFlag = "[评论区部分可见]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    // 3. 【核心改造】构建对AI清晰易懂的评论字符串
    let context = `  └ 评论区:\n`;
    commentsForAI.slice(-5).forEach(c => { // 只展示最近的5条评论以节省token
        // a. 确定评论者的身份标签
        const commenterLabel = c.commenterName === viewerName 
            ? '你' // 如果是AI自己，直接标记为“你”
            : (c.commenterName === userNickname ? '用户' : c.commenterName);

        // b. 如果是回复，同样确定被回复者的身份标签
        let replyPart = '';
        if (c.replyTo) {
            const replyToLabel = c.replyTo === viewerName 
                ? '你' 
                : (c.replyTo === userNickname ? '用户' : c.replyTo);
            replyPart = ` 回复 ${replyToLabel}`;
        }
        
        // c. 拼接成最终的、无歧义的字符串
        context += `    - ${commenterLabel}${replyPart}: ${c.text}\n`;
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID
        
        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同时获取“完整内容”和“预览片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[语音]';
    } else {
        // 预览片段依然截断，但只用于UI显示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 这里存的是完整的原文！
    };

    // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 这里用的是缩略版！
    previewBar.style.display = 'block';

    // 4. 后续操作保持不变
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

/**
 * 显示处理转账的操作菜单
 * @param {number} timestamp - 被点击的转账消息的时间戳
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 将AI的名字填入弹窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隐藏处理转账的操作菜单
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 处理用户接受或拒绝转账的逻辑
 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始转账消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用户选择“拒绝”
    if (choice === 'declined') {
        // 立刻在前端生成一个“退款”卡片，让用户看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 这是一个关键标记，用于UI显示这是退款
            amount: originalMessage.amount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 准备一条对AI可见的隐藏消息，告诉它发生了什么
        systemContent = `[系统提示：你拒绝并退还了"${originalMessage.senderName}"的转账。]`;
    } else { // 如果用户选择“接受”
        // 准备交易描述，包含转款人和备注（如果有）
        const transferNote = originalMessage.note ? ` (备注: ${originalMessage.note})` : '';
        const description = `收到来自 ${originalMessage.senderName} 的转账${transferNote}`;
        
        // 更新余额并记录交易
        await updateUserBalanceAndLogTransaction(originalMessage.amount, description);
        
        // 准备隐藏消息通知AI
        systemContent = `[系统提示：你接受了"${originalMessage.senderName}"的转账。]`;
    }

    // 3. 创建这条对用户隐藏、但对AI可见的系统消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
        isHidden: true // 这个标记会让它不在聊天界面显示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库，并刷新界面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
        return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 弹出输入框，并将旧名称作为默认值，方便修改
        const newName = await showCustomPrompt(
            "自定义通话名称", 
            "请输入新的名称（留空则恢复默认）",
            record.customName || '' // 如果已有自定义名称，就显示它
        );

        // 2. 如果用户点击了“取消”，则什么都不做
        if (newName === null) return;
        
        // 3. 更新数据库中的这条记录
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整个列表，让更改立刻显示出来
        await renderCallHistoryScreen();
        
        // 5. 给用户一个成功的提示
        await showCustomAlert('成功', '通话名称已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
/**
 * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
 * @param {object} record - 一条通话记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 获取通话对象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根据角色添加不同的class，应用不同的样式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 为新的、干净的按钮绑定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除",
            "确定要永久删除这条通话记录吗？此操作不可恢复。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 关闭当前的详情弹窗
            modal.classList.remove('visible');
            
            // 2. 从数据库删除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通话记录列表
            await renderCallHistoryScreen();
            
            // 4. (可选) 给出成功提示
            alert('通话记录已删除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

/**
 * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
 */
async function handleEditStatusClick() {
    // 1. 安全检查，确保在单聊界面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
    const newStatusText = await showCustomPrompt(
        '编辑对方状态',
        '请输入对方现在的新状态：',
        chat.status.text // 将当前状态作为输入框的默认内容
    );

    // 3. 如果用户输入了内容并点击了“确定”
    if (newStatusText !== null) {
        // 4. 更新内存和数据库中的状态数据
        chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为“在线”
        chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
        chat.status.lastUpdate = Date.now();
        await db.chats.put(chat);

        // 5. 立刻刷新UI，让用户看到修改后的状态
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 给出一个无伤大雅的成功提示
        await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
    }
}

// 放在你的JS功能函数定义区
async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为分享目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }

    // ▼▼▼ 在这里添加下面这块【新代码】 ▼▼▼
    // 【核心新增】同步歌词到悬浮栏
    const floatingLyricText = document.getElementById('floating-lyric-text');
    if (activeLine) {
        floatingLyricText.textContent = activeLine.textContent;
    } else if (musicState.parsedLyrics.length > 0) {
        floatingLyricText.textContent = '♪ ♪ ♪'; // 歌曲前奏
    } else {
        floatingLyricText.textContent = '♪ 暂无歌词 ♪';
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲

}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
 * 【全新】处理用户点击“撤回”按钮的入口函数
 */
async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
    const messageTime = activeMessageTimestamp;
    const now = Date.now();

    // 检查是否超过了撤回时限
    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
        hideMessageActions();
        await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
        return;
    }
    
    // 如果在时限内，执行真正的撤回逻辑
    await recallMessage(messageTime, true);
    hideMessageActions();
}

/**
 * 【全新】消息撤回的核心逻辑
 * @param {number} timestamp - 要撤回的消息的时间戳
 * @param {boolean} isUserRecall - 是否是用户主动撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    // 1. 修改消息对象，将其变为“已撤回”状态
    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        // 保存其他可能存在的原始数据
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote 
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
    messageToRecall.recalledData = recalledData;
    // 清理掉不再需要的旧属性
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
    if (isUserRecall) {
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);
    }

    // 3. 保存到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    if(isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
}

// ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 打开分类管理模态框
 */
async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
}

/**
 * 在模态框中渲染已存在的分类列表
 */
async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        // 复用好友分组的样式
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一个新的世界书分类
 */
async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name });
    input.value = '';
    await renderCategoryListInManager();
}

/**
 * 删除一个世界书分类
 * @param {number} categoryId - 要删除的分类的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        await renderCategoryListInManager();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】角色专属NPC库管理功能函数 ▼▼▼

let editingNpcId = null; // 用于追踪正在编辑的NPC

/**
 * 打开NPC库管理界面
 */
function openNpcManager() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('npc-management-title').textContent = `“${chat.name}”的NPC库`;
    renderNpcList();
    showScreen('npc-management-screen');
}

/**
 * 渲染NPC列表
 */
function renderNpcList() {
    const listEl = document.getElementById('npc-management-list');
    const chat = state.chats[state.activeChatId];
    const npcLibrary = chat.npcLibrary || [];
    listEl.innerHTML = '';

    if (npcLibrary.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">这里空空如也，点击右上角“+”添加第一个NPC吧！</p>';
        return;
    }

    npcLibrary.forEach(npc => {
        // 复用聊天列表的样式，非常方便
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.style.cursor = 'pointer';
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <div class="info">
                <span class="name">${npc.name}</span>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        // 点击编辑
        item.addEventListener('click', () => openNpcEditor(npc.id));
        // 长按删除
        addLongPressListener(item, () => deleteNpc(npc.id, npc.name));
        listEl.appendChild(item);
    });
}

// ▼▼▼ 用这个【全新的、已修复两个Bug的函数】，完整替换旧的 openNpcEditor 函数 ▼▼▼
async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    // 【核心修复1】使用正确的 state.activeChatId 来获取当前聊天对象
    const chat = state.chats[state.activeChatId];
    if (!chat) return; // 安全检查

    let npc = { name: '', persona: '', avatar: defaultGroupMemberAvatar };
    
    if (npcId) {
        // 【核心修复2】从正确的 chat.npcLibrary 中查找数据
        npc = (chat.npcLibrary || []).find(n => n.id === npcId) || npc;
        document.getElementById('persona-editor-title').textContent = `编辑NPC: ${npc.name}`;
    } else {
        document.getElementById('persona-editor-title').textContent = '添加新NPC';
    }
    
    // 填充编辑器内容
    document.getElementById('npc-editor-name-input').value = npc.name;
    document.getElementById('preset-avatar-preview').src = npc.avatar;
    document.getElementById('preset-persona-input').value = npc.persona;
    
    // 【核心逻辑】根据NPC模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'block';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'none';

    // 绑定正确的保存函数
    document.getElementById('save-persona-preset-btn').onclick = saveNpc;

    // 最后才显示弹窗
    document.getElementById('persona-editor-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲






// ▼▼▼ 从这里开始替换 ▼▼▼
/**
 * 【V2 - 完整版】保存NPC（新建或更新）
 */
async function saveNpc() {
    const chat = state.chats[state.activeChatId];

    
    // 从编辑器中获取所有数据
    const name = document.getElementById('npc-editor-name-input').value.trim();
    const persona = document.getElementById('preset-persona-input').value.trim();
    const avatar = document.getElementById('preset-avatar-preview').src;

    if (!name) {
        alert("NPC名字不能为空！");
        return;
    }

    if (editingNpcId) {
        // 更新现有的NPC
        const npc = chat.npcLibrary.find(n => n.id === editingNpcId);
        if (npc) {
            npc.name = name;
            npc.persona = persona;
            npc.avatar = avatar;
        }
    } else {
        // 添加一个全新的NPC
        const newNpc = {
            id: 'npc_' + Date.now(),
            name: name,
            persona: persona,
            avatar: avatar
        };
        chat.npcLibrary.push(newNpc);
    }

    await db.chats.put(chat);
    renderNpcList();
    closePersonaEditor(); // 复用关闭编辑器的函数
}
// ▲▲▲ 替换到这里结束 ▲▲▲


/**
 * 删除一个NPC
 * @param {string} npcId - 要删除的NPC的ID
 * @param {string} npcName - 要删除的NPC的名字，用于确认提示
 */
async function deleteNpc(npcId, npcName) {
    const confirmed = await showCustomConfirm(
        '删除NPC',
        `确定要从“${state.chats[state.activeChatId].name}”的NPC库中删除 “${npcName}” 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.npcLibrary = chat.npcLibrary.filter(n => n.id !== npcId);
        await db.chats.put(chat);
        renderNpcList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// --- ▼▼▼ 【全新】自定义头像框管理功能 ▼▼▼ ---

function openFrameManager() {
    renderFrameManager();
    document.getElementById('custom-frame-manager-modal').classList.add('visible');
}

// ▼▼▼ 操作2：用这块【支持选择模式】的全新代码，替换旧的 renderFrameManager 函数 ▼▼▼
/**
 * 【全新 | 支持选择模式】渲染头像框管理列表
 */
async function renderFrameManager() {
    const grid = document.getElementById('custom-frame-grid');
    grid.innerHTML = '';
    const customFrames = await db.customAvatarFrames.toArray();

    if (customFrames.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">你还没有上传过头像框哦~</p>';
        return;
    }

    customFrames.forEach(frame => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情面板的样式

        // 核心：创建一个专门用于显示图片的div，方便我们添加覆盖层
        const imageEl = document.createElement('div');
        imageEl.className = 'sticker-image';
        imageEl.style.backgroundImage = `url(${frame.url})`;
        imageEl.title = frame.name;

        // --- ★★★ 核心新增：选择模式的UI逻辑 ★★★ ---
        if (isFrameSelectionMode) {
            item.classList.add('in-selection-mode');
            
            // 检查是否已被选中
            if (selectedFrames.has(frame.id)) {
                item.classList.add('selected');
            }

            // 绑定点击选择事件
            item.addEventListener('click', () => {
                item.classList.toggle('selected');
                if (selectedFrames.has(frame.id)) {
                    selectedFrames.delete(frame.id);
                } else {
                    selectedFrames.add(frame.id);
                }
                // 更新导出按钮的计数
                const exportBtn = document.getElementById('export-selected-frames-btn');
                exportBtn.textContent = `导出已选 (${selectedFrames.size})`;
                exportBtn.disabled = selectedFrames.size === 0;
            });

        } else {
            // 非选择模式下，保留原来的删除按钮
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.display = 'block';
            deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm('删除头像框', `确定要删除“${frame.name}”吗？`, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.customAvatarFrames.delete(frame.id);
                    renderFrameManager();
                }
            };
            imageEl.appendChild(deleteBtn);
        }
        
        item.appendChild(imageEl);
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 操作3：将这【一整块新函数】，粘贴到 renderFrameManager 函数的下方 ▼▼▼

/**
 * 【全新】切换头像框的选择模式
 */
function toggleFrameSelectionMode() {
    isFrameSelectionMode = !isFrameSelectionMode;
    
    const editBtn = document.getElementById('edit-custom-frames-btn');
    const uploadBtn = document.getElementById('upload-custom-frame-btn');
    const footer = document.getElementById('custom-frame-footer');

    if (isFrameSelectionMode) {
        editBtn.textContent = '完成';
        uploadBtn.style.display = 'none'; // 编辑时隐藏上传按钮
        footer.style.display = 'flex';
        selectedFrames.clear(); // 进入时清空选择
    } else {
        editBtn.textContent = '编辑';
        uploadBtn.style.display = 'block'; // 退出时恢复上传按钮
        footer.style.display = 'none';
    }
    
    renderFrameManager(); // 重新渲染以应用UI变化
}

/**
 * 【全新 | 选择性导出】导出所有选中的自定义头像框
 */
async function exportSelectedFrames() {
    if (selectedFrames.size === 0) {
        alert("请先选择要导出的头像框。");
        return;
    }

    const idsToExport = Array.from(selectedFrames);
    const framesToExport = await db.customAvatarFrames.bulkGet(idsToExport);

    const exportData = {
        type: 'EPhoneAvatarFrames',
        version: 1,
        frames: framesToExport
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `EPhone-AvatarFrames-Selected-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 【旧函数重命名】这是您原来就有的导入函数，保持不变
 */
async function importCustomFrames(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.type !== 'EPhoneAvatarFrames' || !Array.isArray(data.frames)) {
                throw new Error("文件格式不正确，请选择正确的头像框备份文件。");
            }
            const newFrames = data.frames;
            if (newFrames.length === 0) {
                alert("这个备份文件中没有包含任何头像框。");
                return;
            }
            const existingUrls = new Set((await db.customAvatarFrames.toArray()).map(f => f.url));
            const framesToImport = newFrames.filter(frame => frame.url && !existingUrls.has(frame.url));
            if (framesToImport.length > 0) {
                await db.customAvatarFrames.bulkAdd(framesToImport);
            }
            await renderFrameManager();
            const message = `导入完成！\n\n成功导入 ${framesToImport.length} 个新头像框。\n跳过了 ${newFrames.length - framesToImport.length} 个已存在的重复项。`;
            await showCustomAlert("导入报告", message);
        } catch (error) {
            alert(`导入失败：${error.message}`);
        }
    };
    reader.readAsText(file);
}
// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 操作2：将这【一整块新函数】，粘贴到 handleUploadCustomFrame 函数的上方 ▼▼▼

/**
 * 【全新】导出所有自定义头像框为一个JSON文件
 */
async function exportCustomFrames() {
    const customFrames = await db.customAvatarFrames.toArray();
    if (customFrames.length === 0) {
        alert("你还没有任何自定义头像框可以导出。");
        return;
    }

    // 准备要导出的数据
    const exportData = {
        type: 'EPhoneAvatarFrames',
        version: 1,
        frames: customFrames
    };

    // 创建并触发下载
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `EPhone-AvatarFrames-Backup-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 【全新】处理导入的头像框备份文件
 * @param {File} file - 用户选择的.json文件
 */
async function importCustomFrames(file) {
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 验证文件内容是否是我们需要的格式
            if (data.type !== 'EPhoneAvatarFrames' || !Array.isArray(data.frames)) {
                throw new Error("文件格式不正确，请选择正确的头像框备份文件。");
            }

            const newFrames = data.frames;
            if (newFrames.length === 0) {
                alert("这个备份文件中没有包含任何头像框。");
                return;
            }

            // 为了防止重复导入，我们先获取所有已存在的URL
            const existingUrls = new Set((await db.customAvatarFrames.toArray()).map(f => f.url));
            
            // 筛选出那些URL还不存在的新头像框
            const framesToImport = newFrames.filter(frame => frame.url && !existingUrls.has(frame.url));

            if (framesToImport.length > 0) {
                await db.customAvatarFrames.bulkAdd(framesToImport);
            }
            
            // 刷新管理列表的UI
            await renderFrameManager();
            
            const message = `导入完成！\n\n成功导入 ${framesToImport.length} 个新头像框。\n跳过了 ${newFrames.length - framesToImport.length} 个已存在的重复项。`;
            await showCustomAlert("导入报告", message);

        } catch (error) {
            alert(`导入失败：${error.message}`);
        }
    };
    reader.readAsText(file);
}
// ▲▲▲ 新增函数结束 ▲▲▲
/**
 * 【V2多选版】处理用户上传自定义头像框的逻辑
 */
function handleUploadCustomFrame() {
    document.getElementById('custom-frame-upload-input').addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const newFrames = [];
        
        // 使用 for...of 循环来逐个处理选中的文件
        for (const file of files) {
            // 【核心修改】自动生成名字，而不是让用户输入
            // 我们用 "文件名 (前8位) + 时间戳" 来确保名字几乎不会重复
            const fileName = file.name.replace(/\.[^/.]+$/, "").substring(0, 8);
            const autoName = `${fileName}_${Date.now()}`;

            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newFrames.push({
                id: 'frame_' + (Date.now() + newFrames.length), // 确保ID唯一
                name: autoName,
                url: base64Url
            });
        }
        
        // 循环结束后，批量添加到数据库
        if (newFrames.length > 0) {
            await db.customAvatarFrames.bulkAdd(newFrames);
            renderFrameManager(); // 刷新管理列表
            await showCustomAlert("上传成功", `已成功添加 ${newFrames.length} 个新头像框！`);
        }

        // 清空文件选择器的值
        event.target.value = null;
    }, { once: true });

    document.getElementById('custom-frame-upload-input').click();
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这块【已添加新分支】的代码替换旧的 ▼▼▼
async function openFrameSelectorModal(type, targetId = null) {
    const grid = document.getElementById('avatar-frame-grid');
    grid.innerHTML = '';
    
    currentFrameSelection.type = type;
    currentFrameSelection.target = targetId;
    
    const chat = state.chats[state.activeChatId];
    let currentFrameUrl = '';
    let previewAvatarUrl = '';

    // --- ▼▼▼ 这就是新增的分支逻辑！▼▼▼ ---
    if (type === 'char-weibo') { 
        // 如果是为“角色微博”换框
        const charChat = state.chats[currentViewingWeiboProfileId];
        currentFrameUrl = charChat.settings.weiboAvatarFrame || '';
        previewAvatarUrl = charChat.settings.weiboAvatar || defaultAvatar;
    }
    // --- ▲▲▲ 新增结束 ▲▲▲ ---
    else if (type === 'home_profile') {
        currentFrameUrl = state.globalSettings.homeAvatarFrame || '';
        previewAvatarUrl = document.getElementById('profile-avatar-img').src;
    } 
    else if (type === 'weibo_profile') {
        currentFrameUrl = state.qzoneSettings.weiboAvatarFrame || '';
        previewAvatarUrl = state.qzoneSettings.weiboAvatar || defaultAvatar;
    } 
    else if (type === 'ai') {
        currentFrameUrl = chat.settings.aiAvatarFrame || '';
        previewAvatarUrl = chat.settings.aiAvatar || defaultAvatar;
    } else if (type === 'my') {
        currentFrameUrl = chat.settings.myAvatarFrame || '';
        previewAvatarUrl = chat.settings.myAvatar || defaultAvatar;
    } else if (type === 'member' && targetId) {
        const member = chat.members.find(m => m.id === targetId);
        if (member) {
            currentFrameUrl = member.avatarFrame || '';
            previewAvatarUrl = member.avatar || defaultGroupMemberAvatar;
        }
    }
    
    // 后续渲染逻辑保持不变
    const customFrames = await db.customAvatarFrames.toArray();
    const frameUrlSet = new Set();
    const allFrames = [...avatarFrames, ...customFrames].filter(frame => {
        if (!frame.url || !frameUrlSet.has(frame.url)) {
            frameUrlSet.add(frame.url);
            return true;
        }
        return false;
    });

    allFrames.forEach(frame => {
        const item = createFrameItem(frame, previewAvatarUrl);
        if (currentFrameUrl === frame.url) {
            item.classList.add('selected');
            currentFrameSelection.url = frame.url;
        }
        grid.appendChild(item);
    });

    document.getElementById('avatar-frame-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// 辅助函数：创建一个头像框选项
function createFrameItem(frame, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.title = frame.name;
    item.innerHTML = `
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame" style="pointer-events: none;">` : ''}
    `;
    item.addEventListener('click', () => {
        document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
        currentFrameSelection.url = frame.url;
    });
    return item;
}

// 保存选择
// ▼▼▼ 【最终修复版】请用这整块代码，完整替换掉你旧的 saveSelectedFrames 函数 ▼▼▼
async function saveSelectedFrames() {
    const { type, url, target } = currentFrameSelection;

    // 对于不属于“角色设置”的功能 (比如主屏幕、微博)，保持原有的立即保存逻辑
    if (type === 'char-weibo') { 
        const charChat = state.chats[currentViewingWeiboProfileId];
        if (charChat) {
            charChat.settings.weiboAvatarFrame = url;
            await db.chats.put(charChat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    } 
    else if (type === 'home_profile') {
        if (!state.globalSettings) state.globalSettings = {};
        state.globalSettings.homeAvatarFrame = url;
        await db.globalSettings.put(state.globalSettings);
        renderHomeScreenProfileFrame(); 
    } 
    else if (type === 'weibo_profile') {
        if (!state.qzoneSettings) state.qzoneSettings = {};
        state.qzoneSettings.weiboAvatarFrame = url;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
    // 【核心修改】对于“角色设置”里的头像框，我们不再立即保存，只在内存中更新
    else {
        const chat = state.chats[state.activeChatId];
        if (!chat) return; // 安全检查

        if (type === 'ai') {
            chat.settings.aiAvatarFrame = url;
        } else if (type === 'my') {
            chat.settings.myAvatarFrame = url;
        } else if (type === 'member' && target) {
            const member = chat.members.find(m => m.id === target);
            if (member) member.avatarFrame = url;
        }
        
        // ★★★ 修复关键 ★★★
        // 我们删除了这里所有的 await db.chats.put(chat);
        // 数据将在用户点击角色设置主面板的“保存”按钮时，与其他所有设置一起被保存。
        console.log(`头像框选择已暂存: type=${type}, url=${url}`);
    }
    
    // 只需关闭头像框选择弹窗即可，不做其他多余操作
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // ★★★ 修复关键 ★★★
    // 我们删除了下面这个会导致界面意外刷新并清空未保存内容的 if 代码块
    // if (type !== 'weibo_profile' && type !== 'home_profile' && type !== 'char-weibo') { ... }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 检查两个时间戳是否在不同的自然日
 * @param {number} timestamp1 - 新消息的时间戳
 * @param {number | null} timestamp2 - 上一条消息的时间戳
 * @returns {boolean} - 如果是新的一天，返回 true
 */
function isNewDay(timestamp1, timestamp2) {
    // 如果没有上一条消息的时间戳，说明这是第一条消息，肯定要显示日期
    if (!timestamp2) return true;

    const date1 = new Date(timestamp1);
    const date2 = new Date(timestamp2);

    // 比较年、月、日是否完全相同
    return date1.getFullYear() !== date2.getFullYear() ||
           date1.getMonth()    !== date2.getMonth()    ||
           date1.getDate()     !== date2.getDate();
}

/**
 * 将时间戳格式化为 "X月X日 HH:mm" 的形式
 * @param {number} timestamp - 时间戳
 * @returns {string} - 格式化后的日期字符串
 */
function formatDateStamp(timestamp) {
    const date = new Date(timestamp);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${month}月${day}日 ${hours}:${minutes}`;
}

/**
 * 【全新】根据时间戳，格式化聊天列表右侧的日期/时间显示
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的字符串 (例如 "14:30", "昨天", "08/03")
 */
function formatChatListTimestamp(timestamp) {
    if (!timestamp) return ''; // 如果没有时间戳，返回空字符串

    const now = new Date();
    const msgDate = new Date(timestamp);

    // 判断是否为今天
    const isToday = now.getFullYear() === msgDate.getFullYear() &&
                    now.getMonth() === msgDate.getMonth() &&
                    now.getDate() === msgDate.getDate();

    if (isToday) {
        // 如果是今天，只显示时间
        return msgDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    }

    // 判断是否为昨天
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    const isYesterday = yesterday.getFullYear() === msgDate.getFullYear() &&
                        yesterday.getMonth() === msgDate.getMonth() &&
                        yesterday.getDate() === msgDate.getDate();

    if (isYesterday) {
        return '昨天';
    }

    // 判断是否为今年
    if (now.getFullYear() === msgDate.getFullYear()) {
        // 如果是今年，显示 "月/日"
        const month = String(msgDate.getMonth() + 1).padStart(2, '0');
        const day = String(msgDate.getDate()).padStart(2, '0');
        return `${month}/${day}`;
    }

    // 如果是更早的年份，显示 "年/月/日"
    const year = msgDate.getFullYear();
    const month = String(msgDate.getMonth() + 1).padStart(2, '0');
    const day = String(msgDate.getDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
}

/**
 * 【全新】创建一个功能完整的日期戳“伪消息”元素
 * @param {number} timestamp - 该日期戳代表的时间
 * @returns {HTMLElement} - 创建好的 DOM 元素
 */
function createDateStampElement(timestamp) {
    // 1. 创建最外层的包裹 div，和真实消息一样
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper date-stamp-wrapper';
    // 【核心】把时间戳存起来，这是多选和删除的关键
    wrapper.dataset.timestamp = timestamp; 

    // 2. 创建气泡 div
    const bubble = document.createElement('div');
    // 【核心】同时加上 .message-bubble 类，让多选逻辑能找到它
    bubble.className = 'message-bubble date-stamp-bubble';
    bubble.dataset.timestamp = timestamp;
    bubble.textContent = formatDateStamp(timestamp);
    
    wrapper.appendChild(bubble);

    // 3. 【核心】为它绑定和真实消息完全一样的事件监听器
    addLongPressListener(wrapper, () => {
        // 日期戳不支持复杂操作，长按直接进入多选
        enterSelectionMode(timestamp);
    });
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(timestamp);
        }
    });

    return wrapper;
}
// ▼▼▼ 在你的JS功能函数定义区，粘贴下面这一整块新代码 ▼▼▼

// --- 美化功能的核心变量 ---
let activeThemeId = null; // 用于追踪当前正在编辑的主题ID

/**
 * 将CSS代码应用到页面上
 * @param {string} cssCode - 要应用的CSS代码字符串
 */
function applyThemeCss(cssCode) {
    const styleTag = document.getElementById('custom-theme-style');
    if (styleTag) {
        styleTag.innerHTML = cssCode || '';
    }
}

/**
 * 从数据库加载所有主题到下拉选择框
 */
async function loadThemesToDropdown() {
    const selector = document.getElementById('theme-selector');
    selector.innerHTML = '<option value="">-- 选择方案或新建 --</option>'; // 默认选项
    
    const themes = await db.themes.toArray();
    themes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme.id;
        option.textContent = theme.name;
        selector.appendChild(option);
    });
}

/**
 * 处理用户从下拉框选择一个主题的逻辑
 */
async function handleThemeSelection() {
    const selector = document.getElementById('theme-selector');
    const editor = document.getElementById('theme-css-editor');
    activeThemeId = selector.value ? parseInt(selector.value) : null;
    
    if (activeThemeId) {
        const theme = await db.themes.get(activeThemeId);
        editor.value = theme.css;
    } else {
        // 如果选择“--”，就加载模板
        editor.value = THEME_CSS_TEMPLATE;
    }
    // 立即应用选中的或模板代码，让用户看到效果
    applyThemeCss(editor.value);
}

/**
 * 保存当前编辑区的内容到当前选中的主题
 */
async function saveCurrentTheme() {
    if (!activeThemeId) {
        alert("请先选择一个方案，或使用“另存为”来创建新方案。");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    await db.themes.update(activeThemeId, { css: cssCode });
    alert("当前方案已保存！");
}

/**
 * 将当前编辑区的内容另存为一个新主题
 */
async function saveAsNewTheme() {
    const themeName = await showCustomPrompt("保存新方案", "请输入新方案的名称");
    if (!themeName || !themeName.trim()) {
        if(themeName !== null) alert("方案名称不能为空！");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    const newTheme = { name: themeName.trim(), css: cssCode };
    const newId = await db.themes.add(newTheme);
    
    // 刷新下拉框并自动选中新保存的方案
    await loadThemesToDropdown();
    document.getElementById('theme-selector').value = newId;
    activeThemeId = newId;
    
    alert(`方案 "${themeName}" 已成功保存！`);
}

/**
 * 重命名当前选中的主题
 */
async function renameSelectedTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要重命名的方案。");
        return;
    }
    const currentTheme = await db.themes.get(activeThemeId);
    const newName = await showCustomPrompt("重命名方案", "请输入新的名称", currentTheme.name);
    if (newName && newName.trim()) {
        await db.themes.update(activeThemeId, { name: newName.trim() });
        await loadThemesToDropdown();
        document.getElementById('theme-selector').value = activeThemeId;
        alert("重命名成功！");
    }
}

/**
 * 删除当前选中的主题
 */
async function deleteSelectedTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要删除的方案。");
        return;
    }
    const confirmed = await showCustomConfirm(
        "确认删除", 
        `确定要删除方案 "${document.getElementById('theme-selector').selectedOptions[0].textContent}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.themes.delete(activeThemeId);
        activeThemeId = null;
        await loadThemesToDropdown();
        // 恢复到模板状态
        document.getElementById('theme-css-editor').value = THEME_CSS_TEMPLATE;
        applyThemeCss(THEME_CSS_TEMPLATE);
        alert("方案已删除。");
    }
}

/**
 * 导出当前选中的主题为一个JSON文件
 */
async function exportTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要导出的方案。");
        return;
    }
    const theme = await db.themes.get(activeThemeId);
    const exportData = {
        themeName: theme.name,
        themeCss: theme.css
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${theme.name}-Theme.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 导入一个主题JSON或DOCX文件
 */
function importTheme(file) {
    if (!file) return;
    
    const fileName = file.name.toLowerCase();
    const isDocx = fileName.endsWith('.docx');
    const isJson = fileName.endsWith('.json');
    
    if (!isJson && !isDocx) {
        alert('仅支持 .json 或 .docx 文件格式');
        return;
    }
    
    if (isDocx) {
        // 处理DOCX文件
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const arrayBuffer = e.target.result;
                const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                const text = result.value;
                
                // 智能提取CSS代码和主题名称
                let themeName = '';
                let themeCss = '';
                
                // 1. 尝试从文件名提取主题名称（去掉扩展名）
                const baseFileName = file.name.replace(/\.docx$/i, '').trim();
                
                // 2. 清理文本内容
                let cleanedText = text.trim();
                
                // 3. 尝试多种方式提取CSS代码
                
                // 方式1: 查找CSS代码块标记（如 ```css 或 <style> 标签）
                const cssBlockMatch = cleanedText.match(/```css\s*([\s\S]*?)```/i) || 
                                      cleanedText.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
                
                if (cssBlockMatch) {
                    themeCss = cssBlockMatch[1].trim();
                    // 尝试提取代码块前的标题作为主题名
                    const beforeBlock = cleanedText.substring(0, cssBlockMatch.index);
                    const lines = beforeBlock.split('\n').filter(l => l.trim());
                    if (lines.length > 0) {
                        themeName = lines[lines.length - 1].trim();
                    }
                }
                
                // 方式2: 检测是否包含明显的CSS特征（选择器和花括号）
                if (!themeCss) {
                    const hasCssFeatures = /[.#\w\s-]+\s*\{[\s\S]*?\}/g.test(cleanedText);
                    
                    if (hasCssFeatures) {
                        // 分离标题和CSS代码
                        const lines = cleanedText.split('\n');
                        let cssStartIndex = 0;
                        
                        // 查找第一个看起来像CSS的行
                        for (let i = 0; i < lines.length; i++) {
                            if (lines[i].includes('{') || lines[i].match(/^[.#\w\s-]+\s*$/)) {
                                cssStartIndex = i;
                                break;
                            }
                        }
                        
                        // 前面的行作为标题（取最后一个非空行）
                        if (cssStartIndex > 0) {
                            const titleLines = lines.slice(0, cssStartIndex).filter(l => l.trim());
                            if (titleLines.length > 0) {
                                themeName = titleLines[titleLines.length - 1].trim();
                            }
                        }
                        
                        // CSS代码从检测到的位置开始
                        themeCss = lines.slice(cssStartIndex).join('\n').trim();
                    }
                }
                
                // 方式3: 如果前面的方法都没找到，尝试查找关键词分隔
                if (!themeCss) {
                    const keywords = ['css', '样式', '代码', 'style', '美化'];
                    const lines = cleanedText.split('\n');
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].toLowerCase();
                        if (keywords.some(kw => line.includes(kw))) {
                            // 关键词行之前的作为标题
                            if (i > 0) {
                                const titleLines = lines.slice(0, i).filter(l => l.trim());
                                if (titleLines.length > 0) {
                                    themeName = titleLines[titleLines.length - 1].trim();
                                }
                            }
                            // 关键词行之后的作为CSS
                            themeCss = lines.slice(i + 1).join('\n').trim();
                            break;
                        }
                    }
                }
                
                // 方式4: 如果还是没找到，将整个内容作为CSS
                if (!themeCss) {
                    // 检查是否第一行是标题（短且不含CSS特征）
                    const lines = cleanedText.split('\n');
                    const firstLine = lines[0].trim();
                    
                    if (firstLine.length < 50 && !firstLine.includes('{') && !firstLine.includes('}')) {
                        themeName = firstLine;
                        themeCss = lines.slice(1).join('\n').trim();
                    } else {
                        // 整个内容都是CSS
                        themeCss = cleanedText;
                    }
                }
                
                // 使用文件名作为默认主题名
                if (!themeName) {
                    themeName = baseFileName || '未命名主题';
                }
                
                // 清理主题名称（移除特殊字符，限制长度）
                themeName = themeName
                    .replace(/[#*\[\]]/g, '')
                    .replace(/主题名[称]?\s*[:：]?\s*/i, '')
                    .substring(0, 50)
                    .trim() || baseFileName || '未命名主题';
                
                // 验证CSS代码
                if (themeCss && themeCss.length > 10) {
                    const newTheme = {
                        name: `${themeName} (导入)`,
                        css: themeCss
                    };
                    const newId = await db.themes.add(newTheme);
                    await loadThemesToDropdown();
                    document.getElementById('theme-selector').value = newId;
                    handleThemeSelection();
                    alert(`方案 "${newTheme.name}" 导入成功！\n已提取 ${themeCss.length} 字符的CSS代码。`);
                } else {
                    alert('导入失败：DOCX文件中未找到有效的CSS代码。\n\n提示：请确保文档包含CSS样式代码。');
                }
            } catch (error) {
                alert(`导入DOCX失败：${error.message}`);
            }
        };
        reader.readAsArrayBuffer(file);
    } else {
        // 处理JSON文件（原有逻辑）
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.themeName && typeof data.themeCss !== 'undefined') {
                    const newTheme = {
                        name: `${data.themeName} (导入)`,
                        css: data.themeCss
                    };
                    const newId = await db.themes.add(newTheme);
                    await loadThemesToDropdown();
                    document.getElementById('theme-selector').value = newId;
                    handleThemeSelection();
                    alert(`方案 "${newTheme.name}" 导入成功！`);
                } else {
                    alert("导入失败：JSON文件格式不正确。");
                }
            } catch (error) {
                alert(`导入JSON失败：${error.message}`);
            }
        };
        reader.readAsText(file);
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】API预设功能核心函数 ▼▼▼

/**
 * 渲染并填充API预设的下拉选择框
 */
function renderApiPresetSelector() {
    const selectEl = document.getElementById('api-preset-select');
    if (!selectEl) return;

    selectEl.innerHTML = '<option value="">-- 自定义配置 --</option>';

    if (state.apiPresets) {
        state.apiPresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 检查当前配置是否匹配任何一个预设
    const { proxyUrl, apiKey } = state.apiConfig;
    const matchingPreset = state.apiPresets ? state.apiPresets.find(p => p.proxyUrl === proxyUrl && p.apiKey === apiKey) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何预设，则选中“自定义配置”
    }
}

/**
 * 当用户在下拉框中选择一个预设时触发
 */
function handleApiPresetSelectChange() {
    const selectEl = document.getElementById('api-preset-select');
    const proxyUrlInput = document.getElementById('proxy-url');
    const apiKeyInput = document.getElementById('api-key');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.apiPresets) {
        const selectedPreset = state.apiPresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            proxyUrlInput.value = selectedPreset.proxyUrl;
            apiKeyInput.value = selectedPreset.apiKey;
        }
    }
}

/**
 * 打开预设管理的操作菜单
 */
async function openApiPresetManager() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.apiPresets ? state.apiPresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal');
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存当前配置为新预设</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新当前配置</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>删除当前配置</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentApiConfigAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedApiPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedApiPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 将当前输入框的内容保存为一个新的预设
 */
async function saveCurrentApiConfigAsPreset() {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理地址和密钥都不能为空！');
        return;
    }

    const name = await showCustomPrompt('保存API预设', '请为这个配置起个名字：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), proxyUrl, apiKey };
        const newId = await db.apiPresets.add(newPreset);
        
        if (!state.apiPresets) state.apiPresets = [];
        state.apiPresets.push({ id: newId, ...newPreset });

        renderApiPresetSelector(); 
        document.getElementById('api-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `API预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedApiPreset(presetId) {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理地址和密钥都不能为空！');
        return;
    }

    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        preset.proxyUrl = proxyUrl;
        preset.apiKey = apiKey;
        await db.apiPresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${preset.name}" 已更新！`);
    }
}

/**
 * 删除当前选中的预设
 */
async function deleteSelectedApiPreset(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('确认删除', `确定要删除API预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.apiPresets.delete(presetId);
            state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);

            renderApiPresetSelector();
            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '预设已删除。');
        }
    }
}

// ▼▼▼ 【全新】气泡样式预设功能的核心函数 ▼▼▼

/**
 * 渲染并填充气泡样式预设的下拉选择框
 */
function renderBubblePresetSelector() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');

    selectEl.innerHTML = '<option value="">-- 无预设 --</option>';

    if (state.bubbleStylePresets) {
        state.bubbleStylePresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 检查当前聊天的CSS是否匹配任何一个预设
    const currentCss = customCssInput.value.trim();
    const matchingPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.css.trim() === currentCss) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何预设，则选中“无预设”
    }
}

/**
 * 当用户在下拉框中选择一个预设时触发
 */
function handlePresetSelectChange() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.bubbleStylePresets) {
        const selectedPreset = state.bubbleStylePresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            customCssInput.value = selectedPreset.css;
        }
    }
    updateSettingsPreview(); // 无论如何都更新预览
}

/**
 * 打开预设管理的操作菜单
 */
async function openBubblePresetManager() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal'); // 复用现有模态框
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>删除</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    // 重新绑定事件
    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentCssAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 将当前CSS文本框的内容保存为一个新的预设
 */
async function saveCurrentCssAsPreset() {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();
    if (!css) {
        alert('CSS内容不能为空！');
        return;
    }

    const name = await showCustomPrompt('保存预设', '请为这个气泡样式命名：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), css: css };
        const newId = await db.bubbleStylePresets.add(newPreset);
        
        if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
        state.bubbleStylePresets.push({ id: newId, ...newPreset });

        renderBubblePresetSelector(); 
        document.getElementById('bubble-style-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedPreset(presetId) {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();

    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        preset.css = css;
        await db.bubbleStylePresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${preset.name}" 已更新！`);
    }
}

/**
 * 删除当前选中的预设
 */
async function deleteSelectedPreset(presetId) {
    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('确认删除', `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.bubbleStylePresets.delete(presetId);
            state.bubbleStylePresets = state.bubbleStylePresets.filter(p => p.id !== presetId);

            renderBubblePresetSelector(); 
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();

            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '预设已删除。');
        }
    }
}

// ▼▼▼ 【全新】来电铃声控制函数 ▼▼▼

/**
 * 播放来电铃声
 */
function playRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 优先使用用户在设置中保存的URL，如果没设置，就用我们预设的URL
    const ringtoneUrl = state.globalSettings.ringtoneUrl || 'https://files.catbox.moe/3w7gla.mp3';
    
    if (ringtonePlayer && ringtoneUrl) {
        ringtonePlayer.src = ringtoneUrl;
        // play() 返回一个 Promise，我们最好用 try...catch 包裹以防止浏览器报错
        const playPromise = ringtonePlayer.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.error("铃声播放失败:", error);
                // 可以在这里给用户一个静音提示，如果需要的话
            });
        }
    }
}

/**
 * 停止并重置来电铃声
 */
function stopRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    if (ringtonePlayer) {
        ringtonePlayer.pause();
        ringtonePlayer.currentTime = 0; // 将播放进度重置到开头
    }
}


// ▼▼▼ 请用下面这段【优化后】的代码替换 ▼▼▼
/**
 * 【优化版】播放消息提示音，增加健壮性
 */
async function playNotificationSound() {
    const primaryUrl = state.globalSettings.notificationSoundUrl || 'https://files.catbox.moe/k369mf.mp3';
    const fallbackUrl = 'https://laddy-lulu.github.io/Ephone-stuffs/message.mp3';
    
    // 1. 增加安全检查：如果链接为空，直接返回，不执行任何操作
    if (!primaryUrl || !primaryUrl.trim()) return;

    // 尝试播放音频的函数
    const tryPlayAudio = (url) => {
        return new Promise((resolve, reject) => {
            try {
                const audio = new Audio(url);
                audio.volume = 0.7;
                
                // 监听加载错误
                audio.addEventListener('error', (e) => {
                    reject(new Error(`音频加载失败: ${e.type}`));
                }, { once: true });
                
                // 监听可以播放事件
                audio.addEventListener('canplay', () => {
                    audio.play()
                        .then(() => resolve())
                        .catch(error => reject(error));
                }, { once: true });
                
                audio.src = url;
            } catch (error) {
                reject(error);
            }
        });
    };

    // 先尝试主URL，失败则尝试备用URL
    try {
        await tryPlayAudio(primaryUrl);
    } catch (primaryError) {
        console.warn(`主提示音URL失败 (${primaryError.message})，尝试备用URL...`);
        
        try {
            await tryPlayAudio(fallbackUrl);
        } catch (fallbackError) {
            // 两个URL都失败
            if (fallbackError.name === 'NotAllowedError') {
                console.warn("播放消息提示音失败：用户需要先与页面进行一次交互（如点击）才能自动播放音频。");
            } else {
                console.error(`所有提示音URL都失败。主URL: ${primaryUrl}, 备用URL: ${fallbackUrl}`);
            }
        }
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】音频上下文解锁函数（修复铃声无法自动播放的问题） ▼▼▼
function unlockAudioContext() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 检查播放器是否处于暂停状态，并且我们之前没有成功播放过
    if (ringtonePlayer && ringtonePlayer.paused) {
        // 尝试播放，然后立刻暂停。
        // 这个操作对用户是无感知的，但能告诉浏览器用户已与音频交互。
        ringtonePlayer.play().catch(() => {}); // play() 会返回一个 Promise，我们忽略任何可能发生的错误
        ringtonePlayer.pause();
        console.log("Ringtone audio context unlocked.");
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('记录已删除。');
    }
}
// ▲▲▲ 删除功能结束 ▲▲▲
/**
 * 【全新】处理角色手机内单条聊天消息的删除
 * @param {string} contactName - 正在查看的联系人名称
 * @param {number} index - 要删除的消息在历史记录中的索引
 */
async function handleCharacterChatMessageDeletion(contactName, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    let historyArray;
    // 判断是和“我”的聊天还是和NPC的聊天
    if (contactName === (chat.characterPhoneData.chats['我']?.remarkName || '我')) {
        historyArray = chat.history;
    } else {
        historyArray = chat.characterPhoneData.chats[contactName]?.history;
    }

    if (!historyArray || !historyArray[index]) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条消息吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        historyArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 重新渲染当前聊天界面
        renderCharacterChatHistory(contactName);
        alert('消息已删除。');
    }
}

// ▼▼▼ 【全新】锁屏功能核心函数 ▼▼▼

/**
 * 应用锁屏壁纸到 #lock-screen 元素
 */
function applyLockscreenWallpaper() {
    const lockScreen = document.getElementById('lock-screen');
    const wallpaper = state.globalSettings.lockscreenWallpaper;
    if (wallpaper && wallpaper.startsWith('data:image')) {
        lockScreen.style.backgroundImage = `url(${wallpaper})`;
    } else if (wallpaper) {
        lockScreen.style.backgroundImage = wallpaper;
    }
}

/**
 * 显示锁屏界面
 */
function lockPhone() {
    console.log("正在锁定手机...");
    isLocked = true;
    document.getElementById('lock-screen').classList.add('active');
    document.querySelectorAll('.screen:not(#lock-screen)').forEach(s => s.classList.remove('active'));
}

/**
 * 解锁手机，显示主屏幕
 */
function unlockPhone() {
    console.log("手机已解锁！");
    isLocked = false;
        // 【核心修改】在这里彻底隐藏锁屏和毛玻璃背景
    document.getElementById('lock-screen').classList.remove('active');
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.display = 'none';
    blurBg.style.opacity = '0';

    // 确保主屏幕是唯一激活的顶层屏幕
    showScreen('home-screen'); 

    // 重置锁屏的样式，为下次锁定做准备
    setTimeout(() => {
        const lockScreen = document.getElementById('lock-screen');
        const unlockHint = document.getElementById('unlock-hint');
        lockScreen.style.transition = 'none'; 
        unlockHint.style.transition = 'none';
        lockScreen.style.transform = 'translateY(0)';
        lockScreen.offsetHeight; 
        lockScreen.style.transition = 'transform 0.3s ease-out';
        unlockHint.style.transition = 'opacity 0.3s ease-out';
    }, 500); 
}

/**
 * 显示密码输入弹窗
 */
function showPasswordModal() {
    const modal = document.getElementById('password-modal-overlay');
    const input = document.getElementById('password-input-field');
    input.value = ''; // 清空上次输入
    modal.classList.add('visible');
    setTimeout(() => input.focus(), 100); // 延迟聚焦，确保动画流畅
}

/**
 * 隐藏密码输入弹窗
 */
function hidePasswordModal() {

document.getElementById('password-modal-overlay').style.backgroundImage = 'none';

    const modal = document.getElementById('password-modal-overlay');
    modal.classList.remove('visible');
    // 移除可能存在的错误动画类
    modal.querySelector('.password-modal-content').classList.remove('error');
    // 【核心修改】当取消输入密码时...
    // 1. 隐藏毛玻璃背景
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.opacity = '0';
    setTimeout(() => { blurBg.style.display = 'none'; }, 300); // 动画结束后再隐藏

    // 2. 让锁屏界面滑回来
    const lockScreen = document.getElementById('lock-screen');
    const unlockHint = document.getElementById('unlock-hint');
    lockScreen.style.transform = 'translateY(0)';
    unlockHint.style.opacity = '1';
}

/**
 * 检查用户输入的密码是否正确
 */
function checkPassword() {
    const input = document.getElementById('password-input-field');
    const enteredPassword = input.value;
    const correctPassword = state.globalSettings.password;

    if (enteredPassword === correctPassword) {
        // --- 密码正确 ---

        // 1. 【核心魔术】提前把主屏幕在最底层激活并准备好！
        //    因为它 z-index 最低，所以你暂时还看不到它。
        showScreen('home-screen');

        // 2. 隐藏密码输入框 (它会自己播放淡出动画)
        document.getElementById('password-modal-overlay').classList.remove('visible');
        
        // 3. 让毛玻璃背景也开始淡出
        document.getElementById('lock-screen-background-blur').style.opacity = '0';
        
        // 4. 等待淡出动画播放完毕 (300毫秒)，再执行最终的清理工作
        setTimeout(unlockPhone, 300);

    } else {
        // --- 密码错误 (逻辑保持不变) ---
        const content = document.querySelector('.password-modal-content');
        content.classList.add('error');
        input.value = '';
        setTimeout(() => content.classList.remove('error'), 400);
    }
}

/**
 * 更新锁屏界面的时钟
 */
function updateLockClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('lock-main-time').textContent = timeString;
    document.getElementById('lock-main-date').textContent = dateString;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在你的JS功能函数定义区，粘贴下面这一整块新代码 ▼▼▼

async function openBulkAddStickersModal() {
    const placeholder = `在这里粘贴表情包，每行一个，格式如下：\n\n猫猫喝水：https://..../cat.gif\n狗狗摇头：https://..../dog.png\n\n(支持用中文冒号“：”、英文冒号“:”或空格分隔)`;

    const textInput = await showCustomPrompt(
        "批量添加表情(URL)",
        "一行一个，名称和链接用冒号或空格隔开",
        "",
        'textarea'
    );

    if (!textInput || !textInput.trim()) {
        return;
    }

    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;
    let errorLines = [];

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return;

        let name = '';
        let url = '';
        let splitIndex = -1;

        // --- 核心修复：使用更智能的分割逻辑 ---
        // 1. 查找 URL 的起始位置
        const httpIndex = line.indexOf('http');
        const dataIndex = line.indexOf('data:image');

        if (httpIndex > -1) {
            splitIndex = httpIndex;
        } else if (dataIndex > -1) {
            splitIndex = dataIndex;
        }

        // 2. 如果找到了 URL 的起始位置
        if (splitIndex > 0) {
            // URL 之前的所有内容都属于名称
            name = line.substring(0, splitIndex).trim();
            // 从 URL 起始位置到末尾的所有内容都属于 URL
            url = line.substring(splitIndex).trim();
            
            // 3. 清理名称末尾可能存在的分隔符
            if (name.endsWith(':') || name.endsWith('：')) {
                name = name.slice(0, -1).trim();
            }

        } else {
            // 如果找不到 URL，说明格式有问题
            errorLines.push(index + 1);
            return; // 跳过此行
        }
        // --- 修复结束 ---

        if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
            newStickers.push({
                id: 'sticker_' + (Date.now() + index),
                url: url,
                name: name
            });
            successCount++;
        } else {
            errorLines.push(index + 1);
        }
    });

    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
    }

    let reportMessage = `批量导入完成！\n\n成功导入：${successCount} 个表情。`;
    if (errorLines.length > 0) {
        reportMessage += `\n失败行号：${errorLines.join(', ')}。\n\n请检查这些行的格式是否正确。`;
    }
    await showCustomAlert("导入报告", reportMessage);
}

// ▼▼▼ 【全新】粘贴这两个新函数到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】根据距离文本，计算CSS宽度百分比
 * @param {string} distanceText - 距离描述，例如 "500m", "10km", "很近"
 * @returns {number} - 10到90之间的百分比
 */
function calculatePinDistancePercentage(distanceText) {
    if (!distanceText) return 50; // 默认值

    const text = distanceText.toLowerCase();
    // 提取数字部分
    const matches = text.match(/(\d+(\.\d+)?)/);
    const num = matches ? parseFloat(matches[1]) : 0;

    // 根据单位或关键词判断
    if (text.includes('km') || text.includes('公里')) {
        if (num > 1000) return 90;
        if (num > 100) return 80;
        if (num > 10) return 70;
        if (num > 1) return 60;
        return 50;
    } else if (text.includes('m') || text.includes('米')) {
        if (num > 500) return 40;
        if (num > 100) return 30;
        return 20;
    } else if (text.includes('远') || text.includes('不同城市')) {
        return 90;
    } else if (text.includes('附近') || text.includes('隔壁')) {
        return 20;
    } else if (text.includes('近')) {
        return 30;
    }
    
    return 15; // 如果无法识别，给一个最小的距离
}


// ▼▼▼ 用这整块【全新代码】，替换旧的 sendUserLocation 函数 ▼▼▼

/**
 * 【全新】在定位模态框中添加一个途经点输入框
 */
function addTrajectoryPointInput(name = '') {
    const container = document.getElementById('trajectory-points-container');
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.gap = '8px';
    div.innerHTML = `
        <input type="text" class="trajectory-point-input" placeholder="途经点${container.children.length + 1}" value="${name}" style="flex-grow: 1;">
        <button class="remove-option-btn">-</button>
    `;
    div.querySelector('.remove-option-btn').addEventListener('click', () => div.remove());
    container.appendChild(div);
}

// ▼▼▼ 请用这整块【已修复】的代码，替换你旧的 sendUserLocation 函数 ▼▼▼

async function sendUserLocation() {
    if (!state.activeChatId) return;

    const userLocation = document.getElementById('user-location-input').value.trim();
    const aiLocation = document.getElementById('ai-location-input').value.trim();
    const distance = document.getElementById('distance-input').value.trim();

    if (!distance || (!userLocation && !aiLocation)) {
        alert("“我的位置”和“Ta的位置”至少要填写一个，且“相距”为必填项！");
        return;
    }

    const trajectoryPoints = Array.from(document.querySelectorAll('.trajectory-point-input'))
        .map(input => ({ name: input.value.trim() }))
        .filter(point => point.name);

    const chat = state.chats[state.activeChatId];
    
    // --- ▼▼▼【核心修改从这里开始】▼▼▼ ---

    // 1. 根据用户输入，构建一条AI能看懂的文本内容
    //    这个格式和AI自己发定位时用的格式保持一致，非常完美！
    let contentString = '[SEND_LOCATION]';
    if (userLocation) contentString += ` 我的位置: ${userLocation}`;
    if (aiLocation) contentString += ` | 你的位置: ${aiLocation}`;
    contentString += ` | 相距: ${distance}`;
    if (trajectoryPoints.length > 0) {
        const trajectoryText = trajectoryPoints.map(p => p.name).join(', ');
        contentString += ` | 途经点: ${trajectoryText}`;
    }

    // 2. 创建消息对象，这次我们把刚刚创建的 contentString 也放了进去
    const locationMessage = {
        role: 'user',
        type: 'location',
        timestamp: Date.now(),
        userLocation: userLocation,
        aiLocation: aiLocation,
        distance: distance,
        trajectoryPoints: trajectoryPoints,
        content: contentString // <-- 这就是最关键的新增属性！
    };
    
    // --- ▲▲▲【核心修改结束】▲▲▲ ---

    // 后续的保存和渲染逻辑保持不变
    chat.history.push(locationMessage);
    await db.chats.put(chat);
    appendMessage(locationMessage, chat);
    renderChatList();

    document.getElementById('send-location-modal').classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】“一键重roll”功能核心代码 ▼▼▼

/**
 * 智能查找AI上一轮回复的所有消息
 * @param {Array} history - 完整的聊天历史记录
 * @returns {Array} - 一个包含了上一轮AI所有消息对象的数组
 */
function findLastAiTurnMessages(history) {
    const turnMessages = [];
    let lastMessageIndex = history.length - 1;

    // 从最后一条消息开始，向前查找
    for (let i = lastMessageIndex; i >= 0; i--) {
        const message = history[i];
        
        // 如果是AI的消息，就把它加入我们的“待删除列表”
        if (message.role === 'assistant') {
            turnMessages.unshift(message); // 使用 unshift 保持原始顺序
        } 
        // 一旦遇到非AI的消息（用户的或系统的），说明AI的这一轮回复已经结束了，立刻停止查找
        else {
            break;
        }
    }
    return turnMessages;
}

/**
 * “重roll”按钮被点击时的主处理函数
 */
async function handleRerollClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    // 1. 调用我们的智能查找函数，找出需要删除的消息
    const messagesToReroll = findLastAiTurnMessages(chat.history);

    // 2. 如果没找到（比如最后一条是用户发的），就提示并退出
    if (messagesToReroll.length === 0) {
        alert("请在AI回复后使用此功能。");
        return;
    }

    // 3. 从聊天记录中过滤掉这些旧消息
    const timestampsToReroll = new Set(messagesToReroll.map(m => m.timestamp));
    chat.history = chat.history.filter(msg => !timestampsToReroll.has(msg.timestamp));
    
    // 4. 保存更新后的聊天记录到数据库
    await db.chats.put(chat);

    // 5. 刷新聊天界面，让旧消息瞬间消失
    renderChatInterface(state.activeChatId);

    // 6. 触发一次新的AI响应，就像用户点击了“等待回复”一样
    triggerAiResponse();
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新简化版】粘贴这个完整的拖动功能函数 ▼▼▼
function initDraggableLyricsBar() {
    const bar = document.getElementById('floating-lyrics-bar');
    const phoneScreen = document.getElementById('phone-screen');
    
    let isDragging = false;
    let offsetX, offsetY;

    const onDragStart = (e) => {
        // 【问题2修复】检查点击的是否是按钮，如果是，则不开始拖动
        if (e.target.closest('#lyrics-settings-btn') || e.target.closest('.close-btn')) {
            return;
        }

        isDragging = true;
        bar.classList.add('dragging');
        
        const rect = bar.getBoundingClientRect();
        const coords = getEventCoords(e);

        offsetX = coords.x - rect.left;
        offsetY = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isDragging) return;
        
        e.preventDefault();

        const phoneRect = phoneScreen.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - offsetX - phoneRect.left;
        let newTop = coords.y - offsetY - phoneRect.top;

        const maxLeft = phoneScreen.clientWidth - bar.offsetWidth;
        const maxTop = phoneScreen.clientHeight - bar.offsetHeight;

        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        // 【问题1修复】在拖动时，同时设置left, top并清除transform
        bar.style.left = `${newLeft}px`;
        bar.style.top = `${newTop}px`;
        bar.style.transform = 'none';
    };

    const onDragEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        bar.classList.remove('dragging');

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    bar.addEventListener('mousedown', onDragStart);
    bar.addEventListener('touchstart', onDragStart, { passive: true });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】粘贴这个完整的函数 ▼▼▼
function applyLyricsSettings() {
    const bar = document.getElementById('floating-lyrics-bar');
    const toggleBtn = document.getElementById('toggle-lyrics-bar-btn');
    
    // 应用样式
    bar.style.fontSize = `${lyricsBarSettings.fontSize}px`;
    bar.style.color = lyricsBarSettings.fontColor;
    bar.style.backgroundColor = `rgba(0, 0, 0, ${lyricsBarSettings.bgOpacity / 100})`;

    // 更新设置模态框里的控件值
    document.getElementById('lyrics-font-size-slider').value = lyricsBarSettings.fontSize;
    document.getElementById('lyrics-font-size-value').textContent = `${lyricsBarSettings.fontSize}px`;
    document.getElementById('lyrics-bg-opacity-slider').value = lyricsBarSettings.bgOpacity;
    document.getElementById('lyrics-bg-opacity-value').textContent = `${lyricsBarSettings.bgOpacity}%`;
    document.getElementById('lyrics-font-color-picker').value = lyricsBarSettings.fontColor;
    
    // 【问题4需要】更新播放器里的开关按钮状态
    if (toggleBtn) {
        toggleBtn.textContent = lyricsBarSettings.showOnClose ? '悬浮' : '隐藏';
        toggleBtn.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用下面这块【已修复】的代码，替换旧的 getCountdownContext 函数 ▼▼▼
/**
 * 【全新】获取并格式化【与当前聊天相关】的约定，生成给AI看的上下文
 * @param {string} chatId - 当前正在聊天的角色ID
 * @returns {Promise<string>} 格式化后的约定信息字符串
 */
async function getCountdownContext(chatId) {
    // 1. 从数据库中找出所有“约定”类型，并且目标日期还没到的记录
    const activeCountdowns = await db.memories
        .where('type').equals('countdown')
        .filter(item => 
            item.targetDate > Date.now() &&
            // ★★★★★ 这就是我们这次修复的核心！ ★★★★★
            // 它现在只会查找两种约定：
            // 1. chatId 和当前聊天角色ID匹配的 (AI自己创建的)
            // 2. chatId 为空的 (你，也就是用户创建的全局约定)
            (item.chatId === chatId || item.chatId === null)
        )
        .toArray();

    // 如果没有与当前角色相关的约定，就告诉AI“目前没有”
    if (activeCountdowns.length === 0) {
        return "\n- **近期约定**: 目前没有特别的约定。";
    }

    // 2. 后续的整理报告逻辑保持不变
    let context = "\n# 近期约定与倒计时 (重要参考信息)\n";
    const now = Date.now();

    activeCountdowns.forEach(item => {
        const diff = item.targetDate - now;
        const diffDays = Math.floor(diff / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diff / (1000 * 60 * 60));

        let timeText;
        if (diffDays > 1) {
            timeText = `还有 ${diffDays} 天`;
        } else if (diffHours > 0) {
            timeText = `还有 ${diffHours} 小时`;
        } else {
            timeText = "就是现在！";
        }
        
        context += `- **${item.description}**: ${timeText} (目标: ${new Date(item.targetDate).toLocaleString()})\n`;
    });

    return context;
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 【全新】“查角色手机”功能的所有核心函数 ▼▼▼

/**
 * 入口：打开角色选择界面
 */
async function openCharacterSelectionScreen() {
    await renderCharacterSelectionScreen();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色选择列表
 */
async function renderCharacterSelectionScreen() {
    const listEl = document.getElementById('character-selection-list');
    listEl.innerHTML = '';
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有可以查看的角色</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.dataset.chatId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新】将指定的App内壁纸应用到角色手机屏幕
 */
function applyCharPhoneAppWallpaper() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    const innerScreen = document.querySelector('.character-phone-inner-screen');
    if (!innerScreen || !chat) return;

    const appWallpaperUrl = chat.characterPhoneData.appWallpaper;

    if (appWallpaperUrl) {
        innerScreen.style.backgroundImage = `url(${appWallpaperUrl})`;
        innerScreen.classList.add('has-app-wallpaper');
    } else {
        innerScreen.style.backgroundImage = 'none';
        innerScreen.classList.remove('has-app-wallpaper');
    }
}

/**
 * 【全新】处理角色手机App内壁纸的更换和移除
 * @param {string} newUrl - 新的壁纸URL，如果为空字符串则表示移除
 */
async function handleCharPhoneAppWallpaperChange(newUrl) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;
    
    chat.characterPhoneData.appWallpaper = newUrl;
    await db.chats.put(chat);
    
    // 立即应用壁纸
    applyCharPhoneAppWallpaper();
    
    // 刷新设置页面的预览
    renderCharPhoneAppearanceScreen();
    
    alert(newUrl ? 'App 内壁纸已更新！' : 'App 内壁纸已移除！');
}

// ▼▼▼ 用这块【已添加小组件渲染】的代码，完整替换你旧的 openCharacterPhone 函数 ▼▼▼
function openCharacterPhone(chatId) {
    activeCharacterPhoneId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    document.getElementById('character-phone-owner-name').textContent = `${chat.name}的手机`;
    
    const phoneHomeScreen = document.getElementById('character-phone-screen');
    const wallpaperUrl = chat.characterPhoneData.wallpaper;
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');

    if (wallpaperUrl) {
        phoneHomeScreen.style.backgroundImage = `url(${wallpaperUrl})`;
        phoneHomeScreen.style.backgroundColor = 'transparent';
        phoneHomeScreen.style.backgroundSize = 'cover';
        phoneHomeScreen.style.backgroundPosition = 'center';
    } else {
        phoneHomeScreen.style.backgroundImage = 'none';
        phoneHomeScreen.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';
    }
    
    // --- ▼▼▼ 【全新】在这里渲染小组件图片 ▼▼▼ ---
    const widgets = chat.characterPhoneData.widgets || {};
    document.getElementById('char-phone-widget-img-1').src = widgets.widget1_url || '';
    document.getElementById('char-phone-widget-img-2').src = widgets.widget2_url || '';
    // --- ▲▲▲ 新增代码结束 ▲▲▲

    renderCharacterAppGrid(); 

    showScreen('character-phone-container'); 
    showCharacterPhonePage('character-phone-screen');
    applyCharPhoneAppWallpaper();
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块【修复版】代码，替换你旧的 renderCharacterAppGrid 函数 ▼▼▼
function renderCharacterAppGrid() {
    const gridEl = document.getElementById('character-app-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterPhoneId) return;

    const chat = state.chats[activeCharacterPhoneId];
    const customIcons = chat.characterPhoneData.appIcons || {};

    CHAR_PHONE_APPS.forEach(app => {
        const iconEl = document.createElement('div');
        iconEl.className = 'app-icon';

        const customIconUrl = customIcons[app.id];
        
        // --- 核心修改从这里开始 ---
        
        let iconBgStyle = 'display: flex; justify-content: center; align-items: center; padding: 12px;';
        let iconHtml;

        if (customIconUrl) {
            // 如果有自定义图标URL...
            // 1. 覆盖掉 .icon-bg 的样式，移除内边距和背景色
            iconBgStyle = 'padding: 0; background-color: transparent;';
            // 2. iconHtml 直接变成一个带有圆角的图片
            iconHtml = `<img src="${customIconUrl}" style="width:100%; height:100%; object-fit:cover; border-radius: 18px;">`;
        } else {
            // 否则，使用默认的SVG
            iconHtml = app.svg;
        }

        // --- 修改结束 ---

        iconEl.innerHTML = `
            <div class="icon-bg" style="${iconBgStyle}">
                ${iconHtml}
            </div>
            <span class="label">${app.name}</span>
        `;
        
        // 后续的事件监听代码保持不变
        iconEl.addEventListener('click', () => {
            if (app.id === 'appearance') {
                openCharPhoneAppearanceSettings();
            } else {
                switch(app.id) {
                    case 'chat': renderCharacterChatList(); break;
                    case 'cart': renderCharacterShoppingCart(); break;
                    case 'memos': renderCharacterMemos(); break;
                    case 'browser': renderCharacterBrowser(); break;
                    case 'album': renderCharacterPhotoAlbum(); break;
                    case 'bank': renderCharacterBank(); break;
                    case 'trajectory': renderCharacterTrajectory(); break;
                    case 'app_usage': renderCharacterAppUsage(); break;
                    case 'diary': renderCharacterDiary(); break;
                }
                showCharacterPhonePage(app.screen); 
            }
        });
        gridEl.appendChild(iconEl);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这整块【数量增强版】代码，替换你旧的 generateCharacterPhoneDataSegment 函数 ▼▼▼

// ▼▼▼ 用下面这整块【终极社交版】代码，替换你旧的 generateCharacterPhoneDataSegment 函数 ▼▼▼

/**
 * 【AI核心 V4 - 智能余额版】为“查手机”功能单独生成某一项数据的通用函数
 * @param {string} dataType - 要生成的数据类型 (例如: 'diary', 'chats', 'shoppingCart')
 */
async function generateCharacterPhoneDataSegment(dataType) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 这个对象定义了每种数据类型的【默认】生成指令和JSON结构
    const dataTypeMap = {
        chats: {
            description: `2到5段你与【不同的】NPC朋友们的【全新的、接续上文的】聊天记录。`,
            jsonStructure: `"chats": [\n    {\n      "contactName": "【NPC朋友A的名字】",\n      "messages": [\n        {"sender": "【联系人名A】", "content": "消息内容1..."},\n        {"sender": "${chat.name}", "content": "你的回复1..."}\n      ]\n    },\n    {\n      "contactName": "【NPC朋友B的名字】",\n      "messages": [\n        {"sender": "【联系人名B】", "content": "消息内容1..."},\n        {"sender": "${chat.name}", "content": "你的回复1..."}\n      ]\n    }\n  ]`
        },
        shoppingCart: {
            description: "3到5件你最近加入购物车的新商品。",
            jsonStructure: `"shoppingCart": [\n    {"name": "商品名1", "price": 123.45, "store": "店铺名"},\n    {"name": "商品名2", "price": 67.89, "store": "店铺名"}\n  ]`
        },
        memos: {
            description: "2到3篇你新写的简短备忘录。",
            jsonStructure: `"memos": [\n    {"title": "备忘录标题1", "content": "备忘录详细内容1..."},\n    {"title": "备忘录标题2", "content": "备忘录详细内容2..."}\n  ]`
        },
        browserHistory: {
            description: "2到3条你最近的浏览器搜索记录或浏览的文章。",
            jsonStructure: `"browserHistory": [\n    {"query": "搜索标题1", "result": "模拟文章内容1..."},\n    {"query": "搜索标题2", "result": "模拟文章内容2..."}\n  ]`
        },
        photoAlbum: {
            description: "2到3张你“拍摄”的新照片的文字描述（用于文字生图）。",
            jsonStructure: `"photoAlbum": [\n    {"hiddenContent": "对新照片画面1的详细文字描述..."},\n    {"hiddenContent": "对新照片画面2的详细文字描述..."}\n  ]`
        },
        bank: {
            description: "3到5条你最近的银行交易记录（收入或支出）。",
            jsonStructure: `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"},\n      {"type": "收入或支出", "amount": 67.89, "description": "交易描述2"}\n    ]\n  }`
        },
        trajectory: {
            description: "2到3条你最近的行动轨迹记录。",
            jsonStructure: `"trajectory": [\n    {"time": "时间段1", "location": "地点1", "activity": "干了什么事1"},\n    {"time": "时间段2", "location": "地点2", "activity": "干了什么事2"}\n  ]`
        },
        appUsage: {
            description: "3到5条你最近的应用使用记录。",
            jsonStructure: `"appUsage": [\n    {"appName": "应用名1", "duration": "使用时长1"},\n    {"appName": "应用名2", "duration": "使用时长2"}\n  ]`
        },
        diary: {
            description: `一篇全新的日记。`,
            jsonStructure: `"diary": [\n    {"timestamp": ${Date.now()}, "content": "【用Markdown语法写一篇符合人设和情景的新日记】"}\n  ]`
        }
    };

    const dataTypeInfo = dataTypeMap[dataType];
    if (!dataTypeInfo) {
        console.error("请求了无效的数据生成类型:", dataType);
        return;
    }

    // ★★★★★ 这就是我们本次修改的核心逻辑！ ★★★★★
    // 动态修改dataTypeInfo，以适应不同情况
    let finalDataTypeInfo = { ...dataTypeInfo }; 

    if (dataType === 'bank') {
        const hasExistingTransactions = chat.characterPhoneData?.bank?.transactions?.length > 0;
        
        if (!hasExistingTransactions) {
            // 如果是第一次生成，就修改指令，要求AI提供初始余额
            finalDataTypeInfo.description = "一个符合你人设的【初始银行余额】，以及3到5条初始交易记录。";
            finalDataTypeInfo.jsonStructure = `"bank": {\n    "balance": 12345.67,\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
        } else {
            // 如果是后续生成，就告诉AI当前余额，只要求新交易
            const currentBalance = (chat.characterPhoneData.bank.balance || 0).toFixed(2);
            finalDataTypeInfo.description = `3到5条【全新的】银行交易记录（收入或支出）。【提示：你当前的余额是 ${currentBalance} 元，请在此基础上生成合理的交易】`;
            // 此时的JSON结构不需要balance字段
            finalDataTypeInfo.jsonStructure = `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
        }
    }
    // ★★★★★ 修改结束 ★★★★★

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        const persona = (chat.settings.aiPersona || '').substring(0, 4000);
        // updated by lrq 251028 修改最大记忆条数
        const maxMemory = chat.settings.maxMemory || 20;
        const recentHistory = chat.history.slice(-maxMemory).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        // added by lrq 251028 添加记忆互通的聊天记录作为参考
        let linkedMemoryContext = '';
        if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
            const contextPromises = chat.settings.linkedMemories.map(async (link) => {
                const linkedChat = state.chats[link.chatId];
                if (!linkedChat) return '';

                const freshLinkedChat = await db.chats.get(link.chatId);
                if (!freshLinkedChat) return '';

                const recentHistory = freshLinkedChat.history
                    .filter(msg => !msg.isHidden)
                    .slice(-link.depth); 

                if (recentHistory.length === 0) return '';

                const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

                return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
            });

            const allContexts = await Promise.all(contextPromises);
            linkedMemoryContext = allContexts.filter(Boolean).join('\n');
        }
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (必须严格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的专属NPC好友列表 (你必须从中随机选择2-3位朋友进行对话)\n' +
                '这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的专属NPC好友列表\n(你当前没有专属NPC，请虚构2-3个普通朋友并生成对话)';
        }

        let npcChatHistoryContext = '';
        const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);
        if (existingNpcChats.length > 0) {
            npcChatHistoryContext += '\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n';
            existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
                npcChatHistoryContext += `\n## 你和“${contactName}”的最近对话:\n${recentMessages}\n`;
            });
        }
        
        // 使用修改后的 finalDataTypeInfo 来构建Prompt
        const prompt = `
# 任务
你现在是角色 "${chat.name}"。请根据你的信息和最近的聊天记录，【只生成一项】你手机中的新数据。
具体任务是：生成${finalDataTypeInfo.description}

# 【【【情景一致性铁律】】】
你生成的所有数据（尤其是"trajectory"行动轨迹）**必须**与“最近聊天记录摘要”中提到的最新情景保持绝对一致。
当生成 "bank" 数据时，你的交易记录【绝对不能】包含与用户("${userNickname}")的转账或收款。所有交易都应是你与其他NPC或商家的。
# 【【【绝对禁止事项】】】
在生成 "chats" 数据时，**绝对不允许**让用户（${userNickname}）出现在你与其他NPC的对话中。

// ▼▼▼ 找到这部分代码 ▼▼▼

# 【【【重要指令：关于聊天记录生成】】】
- 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
- 如果“你的专属NPC好友列表”不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
- 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
- 你必须为每个联系人生成一段【至少包含5条消息】的对话。
- 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
- 不要只生成一问一答的机械式对话。
-   **【【【绝对禁止重复铁律】】】**: 你生成的 "messages" 数组中，【绝对不能】包含我提供给你的上下文里的任何一条消息。你的第一条消息必须是对话历史中最后一条消息的【下一条】。
# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}
# 和${userNickname}的最近聊天记录摘要
${recentHistory}
${npcContext}
${npcChatHistoryContext}

# JSON输出格式 (必须严格遵守，只包含你被要求的那个键)
{
  ${finalDataTypeInfo.jsonStructure}
}
`;
        
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            let errorMsg = `API请求失败: ${response.status} - ${await response.text()}`;
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const newData = JSON.parse(aiResponseContent);

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        let updateSuccess = false;

        if (newData && newData[dataType]) {
            if (dataType === 'bank' && newData.bank.transactions) {
                 if(!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
                 if (typeof phoneData.bank.balance !== 'number') phoneData.bank.balance = 0;
                (newData.bank.transactions || []).forEach(transaction => {
                    const amount = parseFloat(transaction.amount);
                    if (!isNaN(amount)) {
                        if (transaction.type === '收入') phoneData.bank.balance += amount;
                        else if (transaction.type === '支出') phoneData.bank.balance -= amount;
                    }
                });
                 phoneData.bank.transactions.push(...(newData.bank.transactions || []));
                 if (typeof newData.bank.balance === 'number') {
                     phoneData.bank.balance = newData.bank.balance;
                 }
                 updateSuccess = true;
            } else if (dataType === 'chats' && newData.chats) {
                 newData.chats.forEach(newChat => {
                    if (!newChat.messages) return;
                    const contactName = newChat.contactName;
                    if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                        phoneData.chats[contactName].history.push(...newChat.messages);
                    } else {
                        phoneData.chats[contactName] = { 
                            avatar: newChat.avatar, 
                            history: newChat.messages 
                        };
                    }
                 });
                 updateSuccess = true;
            } else if (dataType === 'appUsage' && Array.isArray(newData.appUsage)) {
                const usageMap = new Map();
                (phoneData.appUsage || []).forEach(item => {
                    usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
                });
                newData.appUsage.forEach(item => {
                    usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
                });
                const mergedUsage = [];
                for (const [appName, totalMinutes] of usageMap.entries()) {
                    mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
                }
                phoneData.appUsage = mergedUsage;
                updateSuccess = true;
            } else if (Array.isArray(phoneData[dataType])) {
                phoneData[dataType].push(...(newData[dataType] || []));
                updateSuccess = true;
            }
        }
        
        if (!updateSuccess) {
            throw new Error(`AI返回的JSON中缺少'${dataType}'字段或格式不正确。`);
        }

        await db.chats.put(chat);
        alert(`“${chat.name}”的${dataTypeMap[dataType].description.split('。')[0]}已更新！`);

        switch(dataType) {
            case 'chats': renderCharacterChatList(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'memos': renderCharacterMemos(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
            case 'bank': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'diary': renderCharacterDiary(); break;
        }

    } catch (error) {
        console.error(`生成角色手机数据(${dataType})失败:`, error);
        await showCustomAlert('生成失败', `发生了一个错误：\n\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】处理“查手机”各个APP页面“全部删除”功能的通用函数
 * @param {string} dataType - 要清空的数据类型，例如 'shoppingCart', 'memos', 'bank.transactions'
 */
async function handleClearCharacterDataSegment(dataType) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 为不同数据类型设置更人性化的提示文本
    const dataTypeMap = {
        chats: { name: 'NPC聊天记录', dataKey: 'chats' },
        shoppingCart: { name: '购物车', dataKey: 'shoppingCart' },
        memos: { name: '备忘录', dataKey: 'memos' },
        browserHistory: { name: '浏览器历史', dataKey: 'browserHistory' },
        photoAlbum: { name: '相册', dataKey: 'photoAlbum' },
        'bank.transactions': { name: '交易记录', dataKey: 'bank' },
        trajectory: { name: '足迹', dataKey: 'trajectory' },
        appUsage: { name: '使用记录', dataKey: 'appUsage' },
        diary: { name: '日记', dataKey: 'diary' }
    };

    const info = dataTypeMap[dataType];
    if (!info) {
        console.error("未知的清空数据类型:", dataType);
        return;
    }

    // 弹出确认框
    const confirmed = await showCustomConfirm(
        `确认清空`,
        `确定要清空“${chat.name}”手机里的所有【${info.name}】吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        // 【核心删除逻辑】
        if (dataType === 'chats') {
            // 特殊处理：清空所有NPC聊天（不包括和user的）
            chat.characterPhoneData.chats = {};
        } else if (dataType === 'bank.transactions') {
            // 特殊处理：清空银行交易记录，【同时将余额归零】
            if (chat.characterPhoneData.bank) {
                chat.characterPhoneData.bank.transactions = [];
                // ★★★ 核心修复：在这里将余额归零 ★★★
                chat.characterPhoneData.bank.balance = 0; 
            }
        } else if (chat.characterPhoneData[info.dataKey]) {
            // 通用处理：清空数组
            chat.characterPhoneData[info.dataKey] = [];
        }

        // 保存到数据库
        await db.chats.put(chat);

        // 刷新当前页面
        switch(dataType) {
            case 'chats': renderCharacterChatList(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'memos': renderCharacterMemos(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'diary': renderCharacterDiary(); break;
        }

        alert(`已成功清空所有${info.name}。`);
    } catch (error) {
        console.error(`清空 ${info.name} 时出错:`, error);
        await showCustomAlert('操作失败', `清空时发生错误: ${error.message}`);
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用下面这【一整块】增强版代码，替换掉你旧的 generateCharacterPhoneData 函数 ▼▼▼
/**
 * 【AI核心】生成角色手机数据 (已增加错误处理和优化)
 */
async function generateCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        
        // ▼▼▼ 核心修改1：【重要修复】限制人设长度，这是防止503错误的根本方法！▼▼▼
        // 我们只取人设的前4000个字符，避免整个人设过长导致请求失败。
        const persona = (chat.settings.aiPersona || '').substring(0, 4000); 
        // ▲▲▲ 修改结束 ▲▲▲

        // ▼▼▼ 核心修改2：按照您的要求，将参考历史记录调整为20条 ▼▼▼
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        // ▲▲▲ 修改结束 ▲▲▲
                // ▲▲▲ 修改结束 ▲▲▲
        console.log("用于生成手机数据的最近聊天记录:", recentHistory);
        // added by lrq 251028 添加记忆互通的聊天记录作为参考
        let linkedMemoryContext = '';
        if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
            const contextPromises = chat.settings.linkedMemories.map(async (link) => {
                const linkedChat = state.chats[link.chatId];
                if (!linkedChat) return '';

                const freshLinkedChat = await db.chats.get(link.chatId);
                if (!freshLinkedChat) return '';

                const recentHistory = freshLinkedChat.history
                    .filter(msg => !msg.isHidden)
                    .slice(-link.depth); 

                if (recentHistory.length === 0) return '';

                const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

                return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
            });

            const allContexts = await Promise.all(contextPromises);
            linkedMemoryContext = allContexts.filter(Boolean).join('\n');
        }
        console.log("用于生成手机数据的互通聊天记录上下文:", linkedMemoryContext);
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (必须严格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的专属NPC好友列表 (你必须在下方"chats"中为他们生成对话)\n' +
                '这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的专属NPC好友列表\n(你没有专属NPC，请虚构一些普通朋友)';
        }

        let npcChatHistoryContext = '';
        const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);

        if (existingNpcChats.length > 0) {
            npcChatHistoryContext += '\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n';
            existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
                npcChatHistoryContext += `\n## 你和“${contactName}”的最近对话:\n${recentMessages}\n`;
            });
        }

        // ▼▼▼ 核心修改3：优化提示词，让AI更好地理解任务，并强调情景一致性 ▼▼▼
        const prompt = `
# 任务
【【【情景一致性铁律】】】：你生成的所有数据（尤其是"trajectory"行动轨迹）**必须**与“最近聊天记录摘要”中提到的最新情景保持绝对一致。如果聊天记录显示你正在上课，你的行动轨迹就必须是在教室；如果聊天记录显示你在咖啡馆，你的行动轨迹就必须是咖啡馆。**绝对不能**仅凭你的人设就生成与聊天记录相矛盾的内容。
你现在是角色 "${chat.name}"。请根据你的人设、世界观、NPC好友列表以及和${userNickname}的最近聊天记录，模拟生成你手机中的各项数据。你需要一次性生成所有数据，并严格按照下面的JSON格式返回。

# 【【【绝对禁止事项：这是必须遵守的安全红线】】】
1.  在生成JSON数据，特别是chats字段时，**绝对不允许**创建另一个用户（${userNickname}）的虚拟形象或让他/她出现在你与其他NPC的对话中。
2.  "bank" 字段中的交易记录【绝对不能】涉及用户("${userNickname}")。所有交易都必须是你与其他NPC、商家或因某些事件（如购物、收到工资）产生的。
3.  chats字段中，与NPC或朋友的聊天记录，其sender或content**绝对不能**包含${userNickname}的名字或代称。
4.  所有你生成的聊天对话，都必须严格限制在【你(${chat.name})】和【另一位NPC/朋友】这**两个人之间**。**严禁**出现任何形式的第三者，尤其是${userNickname}。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}
# 和${userNickname}的最近聊天记录摘要
${recentHistory}

${npcContext}
${npcChatHistoryContext}
# JSON输出格式 (必须严格遵守，不要添加任何额外说明)
{
  "chats": [
    {
      "contactName": "【这里填写你给${userNickname}的备注名】"
    },
    {
      "contactName": "【这里必须填写上面NPC列表中的一个名字，或一个虚构朋友名】",
      "messages": [
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容1..."},
        {"sender": "${chat.name}", "content": "你的回复1..."},
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容2..."},
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容3..."},
        {"sender": "${chat.name}", "content": "你的回复2..."}
      ]
    }
  ],
  "shoppingCart": [
    {"name": "商品名", "price": 价格, "store": "店铺名"}
  ],
  "memos": [
    {"title": "备忘录标题", "content": "备忘录详细内容..."}
  ],
  "browserHistory": [
    {"query": "搜索或浏览的标题", "result": "【这里是AI生成的、关于这个搜索标题的模拟文章或网页内容】"}
  ],
  "photoAlbum": [
    {"hiddenContent": "对照片画面的详细文字描述"}
  ],
  "bank": {
    "balance": 银行卡余额(数字),
    "transactions": [
      {"type": "收入或支出", "amount": 金额, "description": "交易描述"}
    ]
  },
  "trajectory": [
    {"time": "时间段", "location": "地点", "activity": "干了什么事"}
  ],
  "appUsage": [
    {"appName": "应用名", "duration": "使用时长"}
  ],
  "diary": [
    {"timestamp": ${Date.now()}, "content": "【今天是${new Date().toLocaleString('zh-CN', { dateStyle: 'full' })}，用Markdown语法写一篇符合人设和今天情景的日记】"}
  ]
}

# 【【【重要指令：关于聊天记录生成】】】
- 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
- 你必须严格遵守本提示词最上方的【绝对禁止事项】。
- 如果“你的专属NPC好友列表”不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
- 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
- 你必须为每个联系人生成一段【至少包含5条消息】的对话。
- 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
- 不要只生成一问一答的机械式对话。
-   **【【【绝对禁止重复铁律】】】**: 你生成的 "messages" 数组中，【绝对不能】包含我提供给你的上下文里的任何一条消息。你的第一条消息必须是对话历史中最后一条消息的【下一条】。
`;
        // ▲▲▲ 提示词优化结束 ▲▲▲

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            let errorMsg = `API请求失败，状态码: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n错误信息: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n无法解析错误响应体。`;
            }
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        let newData;
        try {
            newData = JSON.parse(aiResponseContent);
        } catch (e) {
            throw new Error(`AI返回的不是有效的JSON格式，无法解析。\n原始返回内容:\n${aiResponseContent}`);
        }

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        
        if (newData.chats) {
            newData.chats.forEach(newChat => {
                if (!newChat.messages) {
                    const myNickname = userNickname || '我';
                    if (!phoneData.chats[myNickname]) {
                        phoneData.chats[myNickname] = { avatar: '', history: [] };
                    }
                    phoneData.chats[myNickname].remarkName = newChat.contactName;
                } else {
                    const contactName = newChat.contactName;
                    if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                        console.log(`合并聊天记录: 为 "${contactName}" 追加 ${newChat.messages.length} 条新消息。`);
                        phoneData.chats[contactName].history.push(...newChat.messages);
                    } else {
                        console.log(`创建新聊天: "${contactName}"`);
                        phoneData.chats[contactName] = { 
                            avatar: newChat.avatar, 
                            history: newChat.messages 
                        };
                    }
                }
            });
        }

        // 正确处理其他数组类型数据 (这些是没问题的，保持原样)
        if(!phoneData.shoppingCart) phoneData.shoppingCart = [];
        phoneData.shoppingCart.push(...(newData.shoppingCart || []));
        if(!phoneData.memos) phoneData.memos = [];
        phoneData.memos.push(...(newData.memos || []));
        if(!phoneData.browserHistory) phoneData.browserHistory = [];
        phoneData.browserHistory.push(...(newData.browserHistory || []));
        if(!phoneData.photoAlbum) phoneData.photoAlbum = [];
        phoneData.photoAlbum.push(...(newData.photoAlbum || []));
        if(!phoneData.trajectory) phoneData.trajectory = [];
        phoneData.trajectory.push(...(newData.trajectory || []));
        if (!phoneData.diary) phoneData.diary = [];
        phoneData.diary.push(...(newData.diary || []));

        // 【修复1：屏幕使用时间】
        if (newData.appUsage && Array.isArray(newData.appUsage)) {
            const usageMap = new Map();
            // 先加载已有的使用记录
            (phoneData.appUsage || []).forEach(item => {
                usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
            });
            // 再累加新生成的使用记录
            newData.appUsage.forEach(item => {
                usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
            });
            // 重新生成合并后的列表
            const mergedUsage = [];
            for (const [appName, totalMinutes] of usageMap.entries()) {
                mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
            }
            phoneData.appUsage = mergedUsage;
        }

        // 【修复2：钱包】
        if (newData.bank) {
            if (!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
            if (typeof phoneData.bank.balance !== 'number') phoneData.bank.balance = 0;

            // 如果AI返回了新的总余额 (通常是第一次生成时)，则以此为准
            if (typeof newData.bank.balance === 'number') {
                phoneData.bank.balance = newData.bank.balance;
            }

            // 遍历新生成的交易记录，并【累加/累减】到余额上
            if (newData.bank.transactions && Array.isArray(newData.bank.transactions)) {
                newData.bank.transactions.forEach(transaction => {
                    const amount = parseFloat(transaction.amount);
                    if (!isNaN(amount)) {
                        // 只有在AI没有直接提供新余额时，我们才根据交易记录自己计算
                        if (typeof newData.bank.balance !== 'number') {
                            if (transaction.type === '收入') {
                                phoneData.bank.balance += amount;
                            } else if (transaction.type === '支出') {
                                phoneData.bank.balance -= amount;
                            }
                        }
                    }
                });
                // 将新交易记录追加到历史记录中
                if(!phoneData.bank.transactions) phoneData.bank.transactions = [];
                phoneData.bank.transactions.push(...newData.bank.transactions);
            }
        }
        
        // --- ★★★ 核心修复到这里结束 ★★★ ---

        await db.chats.put(chat);
        alert('数据已刷新！');

    } catch (error) {
        console.error("生成角色手机数据失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}



/**
 * 清空角色手机数据
 */
async function clearCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    const confirmed = await showCustomConfirm('确认清空', `确定要清空“${chat.name}”的所有手机数据吗？此操作不可恢复。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 重置为初始状态
        chat.characterPhoneData = {
            lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
            browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
            trajectory: [],         appUsage: [],
        diary: [] // <--- 在这里新增
        };
        await db.chats.put(chat);
        // 重新渲染APP网格，因为点击APP会读取新数据
        renderCharacterAppGrid();
        alert('数据已清空。');
    }
}

/**
 * 【V13 - 已美化】渲染角色手机的聊天列表 (支持透明磨砂分组)
 */
function renderCharacterChatList() {
    const listEl = document.getElementById('character-chat-list');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const characterChatData = characterChat.characterPhoneData;
    const realChatHistory = characterChat.history;
    listEl.innerHTML = '';

    // ★★★ 核心修改：在这里创建NPC消息的容器 ★★★
    const npcContainer = document.createElement('div');
    npcContainer.className = 'npc-chat-group'; // 给它一个专属的class名

    // 获取 "我" 的备注名
    const userContactInData = characterChatData.chats
        ? Object.values(characterChatData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';

    // 渲染与 "我" 的聊天
    const lastMsg = realChatHistory.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    const myChatItem = document.createElement('div');
    myChatItem.className = 'chat-list-item'; // 这个是用户自己的消息，单独处理
    myChatItem.dataset.contactName = remarkNameForMe;
    myChatItem.dataset.isUserChat = 'true';
    const myAvatar = characterChat.settings.myAvatar || defaultMyGroupAvatar;
    myChatItem.innerHTML = `
        <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
        <div class="info">
            <span class="name">${remarkNameForMe}</span>
            <div class="last-msg">${stripHtmlAndCode(String(lastMsg.content)).substring(0, 30)}</div>
        </div>
    `;
    listEl.appendChild(myChatItem);

    // 渲染与其他NPC的聊天
    if (characterChatData.chats) {
        for (const contactName in characterChatData.chats) {
            if (contactName === remarkNameForMe) continue;
            const contact = characterChatData.chats[contactName];
            if (!contact.history || contact.history.length === 0) continue;

            const lastNpcMsg = contact.history.slice(-1)[0] || { content: '...' };
            const npcChatItem = document.createElement('div');
            npcChatItem.className = 'chat-list-item';
            npcChatItem.dataset.contactName = contactName;

            let npcAvatarHtml;
            const npcFromLibrary = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
            if (npcFromLibrary && npcFromLibrary.avatar) {
                npcAvatarHtml = `<img src="${npcFromLibrary.avatar}" class="avatar" style="border-radius: 6px;">`;
            } else {
                const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                const npcNameInitial = contactName.slice(-1);
                const colorIndex = contactName.length % avatarColors.length;
                const bgColor = avatarColors[colorIndex];
                npcAvatarHtml = `<div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
            }
            npcChatItem.innerHTML = `${npcAvatarHtml}<div class="info"><span class="name">${contactName}</span><div class="last-msg">${stripHtmlAndCode(String(lastNpcMsg.content)).substring(0, 30)}</div></div>`;
            
            // ★★★ 核心修改：将NPC消息添加到新的容器中 ★★★
            npcContainer.appendChild(npcChatItem);
        }
    }
    
    // ★★★ 核心修改：最后将包含所有NPC消息的容器一次性添加到列表中 ★★★
    if (npcContainer.hasChildNodes()) {
        listEl.appendChild(npcContainer);
    }
}

// ▼▼▼ 请用这整块代码，完整替换掉你旧的 renderCharacterChatHistory 函数 ▼▼▼
/**
 * 【V13 - 性能优化版】渲染角色手机的具体聊天记录 (分页加载)
 */
function renderCharacterChatHistory(contactName, isUserChat = false, loadOffset = 0) {
    const MESSAGES_PER_PAGE = 50; // 每次加载50条

    const messagesEl = document.getElementById('character-chat-history-messages');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) {
        console.error("【错误】: 找不到 characterChat 对象！");
        return;
    }

    // --- 准备工作：设置标题和头像 (仅在首次加载时执行) ---
    if (loadOffset === 0) {
        messagesEl.innerHTML = ''; // 首次加载才清空
        let finalContactName = contactName;
        if (isUserChat) {
            const myChatData = characterChat.characterPhoneData.chats['我'];
            // 尝试从手机数据里找AI给用户的备注名
            const userContactInData = characterChat.characterPhoneData.chats
                ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
                : null;
            finalContactName = userContactInData ? userContactInData.remarkName : '我';
        }
        document.getElementById('character-chat-with-name').textContent = finalContactName;
    }

    // --- 数据源选择 ---
    let fullHistory = [];
    if (isUserChat) {
        fullHistory = characterChat.history.filter(m => !m.isHidden);
    } else {
        const npcChat = characterChat.characterPhoneData.chats[contactName];
        if (npcChat && npcChat.history) {
            fullHistory = npcChat.history;
        }
    }

    // --- 核心分页逻辑 ---
    const totalMessages = fullHistory.length;
    const startIndex = Math.max(0, totalMessages - MESSAGES_PER_PAGE - loadOffset);
    const endIndex = totalMessages - loadOffset;
    const historyToShow = fullHistory.slice(startIndex, endIndex);

    // --- 移除旧的“加载更多”按钮 ---
    const existingLoader = document.getElementById('load-more-messages-btn');
    if (existingLoader) {
        existingLoader.remove();
    }

    // --- 渲染消息 ---
    const fragment = document.createDocumentFragment(); // 使用文档片段提升性能
    const characterName = characterChat.name;

    // (渲染逻辑与之前版本基本相同，只是添加到了 fragment 中)
    historyToShow.forEach((msg, index) => {
        if (msg.isHidden) return;
        const container = document.createElement('div');
        let sender;
        if (isUserChat) { sender = msg.role === 'user' ? '我' : characterName; } 
        else { sender = msg.sender; }

        const isSentByCharacter = sender === characterName;
        container.className = `character-chat-bubble-container ${isSentByCharacter ? 'sent' : 'received'}`;
        
        let avatarHtml = '';
        if(isSentByCharacter) {
             avatarHtml = `<img src="${characterChat.settings.aiAvatar || defaultAvatar}" class="character-chat-avatar">`;
        } else {
             if(isUserChat){
                avatarHtml = `<img src="${characterChat.settings.myAvatar || defaultMyGroupAvatar}" class="character-chat-avatar">`;
             } else {
                 const npcData = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
                 if (npcData && npcData.avatar) {
                    avatarHtml = `<img src="${npcData.avatar}" class="character-chat-avatar">`;
                 } else {
                    const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                    const npcNameInitial = contactName.slice(-1);
                    const colorIndex = contactName.length % avatarColors.length;
                    const bgColor = avatarColors[colorIndex];
                    avatarHtml = `<div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
                 }
             }
        }

        let contentHtml = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
        } else {
            contentHtml = msg.content;
        }
        const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;
        const originalIndex = startIndex + index; // 计算在完整历史记录中的真实索引
        container.innerHTML = `${avatarHtml}${bubbleHtml}<button class="item-delete-btn message-delete-btn" data-contact-name="${contactName}" data-index="${originalIndex}" data-is-user-chat="${isUserChat}">×</button>`;
        fragment.appendChild(container);
    });
    
    // --- 决定是否显示“加载更多”按钮 ---
    if (startIndex > 0) {
        const loadMoreBtn = document.createElement('div');
        loadMoreBtn.id = 'load-more-messages-btn';
        loadMoreBtn.textContent = '加载更早的消息';
        loadMoreBtn.style.textAlign = 'center';
        loadMoreBtn.style.padding = '10px';
        loadMoreBtn.style.color = '#888';
        loadMoreBtn.style.cursor = 'pointer';
        loadMoreBtn.style.fontSize = '12px';
        loadMoreBtn.onclick = () => {
            // 记录当前滚动条位置，以便加载后恢复
            const currentScrollHeight = messagesEl.scrollHeight;
            renderCharacterChatHistory(contactName, isUserChat, loadOffset + MESSAGES_PER_PAGE);
            // 加载后，将滚动条定位到之前的位置，避免跳动
            messagesEl.scrollTop = messagesEl.scrollHeight - currentScrollHeight;
        };
        messagesEl.prepend(loadMoreBtn); // 将按钮添加到顶部
    }
    
    messagesEl.prepend(fragment); // 将新消息一次性插入到DOM中

    // --- 滚动条定位 ---
    if (loadOffset === 0) {
        // 首次加载，滚动到底部
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
}
// ▲▲▲ 替换结束 ▲▲▲



function renderCharacterShoppingCart() {
    const listEl = document.getElementById('character-shopping-cart-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.shoppingCart;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">购物车是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-cart-item';
        itemEl.innerHTML = `
            <div class="cart-item-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
            </div>
            <div class="cart-item-info">
                <div class="title">${item.name}</div>
                <div class="store">${item.store}</div>
            </div>
            <div class="cart-item-price">¥ ${item.price.toFixed(2)}</div>
            <button class="item-delete-btn" data-type="shoppingCart" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}
function renderCharacterMemos() {
    const listEl = document.getElementById('character-memos-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.memos;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">备忘录是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        itemEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="content">${item.content}</div>
            <button class="item-delete-btn" data-type="memos" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▲▲▲ 新功能函数结束 ▲▲▲

/**
 * 【全新】在角色手机内部切换页面
 * @param {string} pageId - 要显示的角色手机页面的ID
 */
function showCharacterPhonePage(pageId) {
    // 1. 找到角色手机内部屏幕的所有页面
    const pages = document.querySelectorAll('.character-phone-page');
    // 2. 隐藏所有页面
    pages.forEach(p => p.classList.remove('active'));
    // 3. 显示目标页面
    const pageToShow = document.getElementById(pageId);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }
}

// ▼▼▼ 【全新】角色手机新增APP渲染函数 ▼▼▼

function renderCharacterBrowser() {
    const listEl = document.getElementById('character-browser-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.browserHistory;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">浏览器历史为空</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-browser-item';
        itemEl.innerHTML = `
            <span class="browser-item-icon">🌐</span>
            <div class="title">${item.query}</div>
            <button class="item-delete-btn" data-type="browserHistory" data-index="${index}">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            document.getElementById('character-browser-detail-title').textContent = item.query;
            document.getElementById('character-browser-detail-content').innerHTML = (item.result || "AI未生成详细内容。").replace(/\n/g, '<br>');
            showCharacterPhonePage('character-browser-detail-screen');
        });
        listEl.appendChild(itemEl);
    });
}


function renderCharacterPhotoAlbum() {
    const gridEl = document.getElementById('character-album-grid');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.photoAlbum;
// ▲▲▲ 修改结束 ▲▲▲
    gridEl.innerHTML = '';
    if (!items || items.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">相册里没有照片</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-album-item';
        itemEl.style.position = 'relative'; 
        itemEl.innerHTML = `
            <img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="文字图">
            <button class="item-delete-btn" data-type="photoAlbum" data-index="${index}" style="top: 10px; right: 10px; z-index: 1;">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            showCustomAlert("图片内容", item.hiddenContent);
        });
        gridEl.appendChild(itemEl);
    });
}



/**
 * 【V2美化版】渲染角色手机 - 银行
 */
function renderCharacterBank() {
    const detailsEl = document.getElementById('character-bank-details');
    // 【新增】获取当前角色对象，为后面找备注名做准备
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const bankData = characterChat.characterPhoneData?.bank;
    detailsEl.innerHTML = '';

    // 【新增】获取角色给用户的备注名
    const userContactInData = characterChat.characterPhoneData.chats
        ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';
    
    const balanceCard = document.createElement('div');
    balanceCard.className = 'character-bank-balance-card';
    balanceCard.innerHTML = `
        <div class="label">账户余额</div>
        <div class="amount">¥ ${(bankData?.balance || 0).toFixed(2)}</div>
    `;
    detailsEl.appendChild(balanceCard);
    
    if (!bankData?.transactions || bankData.transactions.length === 0) {
        detailsEl.innerHTML += '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">暂无交易明细</p>';
        return;
    }

    [...bankData.transactions].reverse().forEach((item, index) => {
        const originalIndex = bankData.transactions.length - 1 - index;
        const isIncome = item.type === '收入';
        const itemEl = document.createElement('div');
        itemEl.className = 'character-bank-transaction';
        const iconBg = isIncome ? '#4CAF50' : '#E91E63';
        const iconSvg = isIncome 
            ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>`
            : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

        // 【核心修改】在这里，我们用正则表达式 /我/g 全局替换所有“我”字
        const displayDescription = item.description.replace(/我/g, remarkNameForMe);

        itemEl.innerHTML = `
            <div class="transaction-details">
                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
                <div>
                    <div class="title">${displayDescription}</div>
                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <span class="transaction-amount ${isIncome ? 'income' : 'expense'}">
                    ${isIncome ? '+' : '-'} ${item.amount.toFixed(2)}
                </span>
                <button class="item-delete-btn" data-type="bank.transactions" data-index="${originalIndex}">×</button>
            </div>
        `;
        detailsEl.appendChild(itemEl);
    });
}


/**
 * 【V2美化版 | 已修复时间排序】渲染角色手机 - 行动轨迹
 */
function renderCharacterTrajectory() {
    const listEl = document.getElementById('character-trajectory-list');
    const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.trajectory;
    listEl.innerHTML = '';
    listEl.classList.add('character-trajectory-list');

    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无足迹</p>';
        return;
    }

    // ▼▼▼ 核心修复代码 ▼▼▼
    // 在渲染之前，使用我们新加的 parseTime 函数对轨迹数组进行排序
    items.sort((a, b) => parseTime(a.time) - parseTime(b.time));
    // ▲▲▲ 修复完成 ▲▲▲

    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-trajectory-item';
        itemEl.innerHTML = `
            <div class="trajectory-item-content">
                <div class="title">${item.activity}</div>
                <div class="meta">
                    <span>📍 ${item.location}</span>
                    <span style="margin-left: 10px;">🕒 ${item.time}</span>
                </div>
            </div>
            <button class="item-delete-btn" data-type="trajectory" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


/**
 * 【V2美化版】渲染角色手机 - APP使用记录
 */
function renderCharacterAppUsage() {
    const listEl = document.getElementById('character-app-usage-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.appUsage;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
     if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无使用记录</p>';
        return;
    }
    const durationsInMinutes = items.map(item => parseDurationToMinutes(item.duration));
    const maxDuration = Math.max(...durationsInMinutes);
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-app-usage-item';
        const durationInMinutes = durationsInMinutes[index];
        const barWidth = maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;
        itemEl.innerHTML = `
            <div class="app-usage-header">
                <span class="name">${item.appName}</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="duration">${item.duration}</span>
                    <button class="item-delete-btn" data-type="appUsage" data-index="${index}">×</button>
                </div>
            </div>
            <div class="app-usage-bar-container">
                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}


/**
 * 【日记 V4-最终修复版】渲染角色的日记列表
 */
function renderCharacterDiary() {
    const listEl = document.getElementById('character-diary-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.diary;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">日记本还是空的，点击右上角写下第一篇日记吧。</p>';
        return;
    }
    
    [...items].reverse().forEach((item, index) => {
        const originalIndex = items.length - 1 - index;
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        const contentHtml = renderMarkdown(item.content);
        itemEl.innerHTML = `
            <div class="content">${contentHtml}</div>
            <div class="meta">
                <span>${new Date(item.timestamp).toLocaleString()}</span>
            </div>
            <button class="item-delete-btn" data-type="diary" data-index="${originalIndex}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▼▼▼ 用下面这【一整块】增强版代码，替换掉你旧的 generateNewDiaryEntry 函数 ▼▼▼
/**
 * 【日记】独立刷新，生成新的日记条目 (已增加错误处理)
 */
async function generateNewDiaryEntry() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (这是你必须严格遵守的背景) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const diaryPrompt = `
# 任务
你现在是角色 "${chat.name}"。今天是 ${new Date().toLocaleString('zh-CN', { dateStyle: 'full' })}。请你回顾一下最近和我的聊天，以及你的人设，然后用你的口吻写一篇关于【今天或近期发生事情】的日记。
这篇日记是你内心的独白，可以记录你的感受、思考、计划或者秘密。
内容要丰富、有深度，长度在100到300字之间。

# 【【【重要：格式指令】】】
你【必须】使用以下Markdown语法来丰富日记的格式，使其更具表现力：
-   **标题**: 使用 \`#\` 或 \`##\` 来创建大标题和副标题。 (例如: \`# 今天的心情\`)
-   **粗体**: 使用 \`**文字**\` 来强调重点。 (例如: \`今天真的**非常**开心。\`)
-   **斜体**: 使用 \`*文字*\` 来表达情绪或内心想法。 (例如: \`*他到底是怎么想的呢...*\`)
-   **删除线**: 使用 \`~~文字~~\` 来表示划掉或否定的想法。 (例如: \`我决定明天去<s>逛街</s>学习。\`)
-   **遮挡/剧透**: 使用 \`||文字||\` 来隐藏秘密或悄悄话。 (例如: \`我偷偷准备了一个惊喜，||是一个手织的围巾||。\`)

你的输出【必须且只能】是日记的正文内容，不要包含任何其他说明或JSON格式。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}

# 最近聊天记录参考
${recentHistory}
`;

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, diaryPrompt, [{role: 'user', content: diaryPrompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: diaryPrompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
        
        // --- ★★★ 错误处理核心代码 ★★★ ---
        if (!response.ok) {
            let errorMsg = `API请求失败，状态码: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n错误信息: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n无法解析错误响应体。`;
            }
            throw new Error(errorMsg);
        }
        // --- ★★★ 错误处理结束 ★★★ ---
        
        const data = await response.json();
        const diaryContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

        const newEntry = {
            timestamp: Date.now(),
            content: diaryContent
        };
        
        chat.characterPhoneData.diary.push(newEntry);
        await db.chats.put(chat);
        
        renderCharacterDiary();
        alert('新日记已生成！');

    } catch (error) {
        console.error("生成日记失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 【全新】万能Markdown渲染函数 (带安全过滤和遮挡效果) ▼▼▼

/**
 * 将Markdown文本安全地渲染为HTML
 * @param {string} markdownText - 原始的Markdown文本
 * @returns {string} - 处理和净化后的安全HTML字符串
 */
function renderMarkdown(markdownText) {
    if (!markdownText) return '';

    // 1. 【预处理】支持自定义的“遮挡/剧透”语法 ||spoiler||
    // 我们在 marked.js 处理之前，手动把 ||text|| 替换成带特定class的HTML标签
    let processedText = markdownText.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');

    // 2. 【核心】使用 marked.js 将Markdown转换为HTML
    // gfm: true 开启GitHub风格的Markdown，支持删除线等
    // breaks: true 让回车符也能变成<br>，更符合聊天习惯
    let rawHtml = marked.parse(processedText, { gfm: true, breaks: true });

    // 3. 【安全】使用 DOMPurify 清洗HTML，防止XSS攻击
    let sanitizedHtml = DOMPurify.sanitize(rawHtml);

    return sanitizedHtml;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【辅助函数】将时长字符串（如“2.5小时”）转换为分钟数
 */
function parseDurationToMinutes(durationString) {
    if (!durationString) return 0;
    const num = parseFloat(durationString) || 0;
    if (durationString.includes('小时') || durationString.includes('h')) {
        return num * 60;
    }
    // 默认单位是分钟
    return num;
}
// ▼▼▼ 把这两个【新函数】粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】切换视频通话的大小窗口画面
 */
function switchVideoViews() {
    const mainView = document.getElementById('video-main-view');
    const pipView = document.getElementById('video-pip-view');
    
    // 交换两张图片的 src
    const mainImg = mainView.querySelector('img');
    const pipImg = pipView.querySelector('img');
    const tempSrc = mainImg.src;
    mainImg.src = pipImg.src;
    pipImg.src = tempSrc;
}

// ▼▼▼ 用这个【全新的、逻辑正确的函数】，完整替换掉你旧的 handleVideoCallReroll 函数 ▼▼▼
/**
 * 【全新】处理视频通话中的“重roll”请求
 */
async function handleVideoCallReroll() {
    if (!videoCallState.isActive) return;

    // 1. 找到用户最后一次说的话的索引
    const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(h => h.role === 'user');
    
    // 2. 从通话历史中，删除掉那之后的所有AI回复
    //    如果用户一句话没说（lastUserSpeechIndex 是 -1），就删除所有AI的回复
    if (lastUserSpeechIndex > -1) {
        videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
    } else {
        // 如果用户还没说过话，就清空所有历史，让AI重说第一句话
        videoCallState.callHistory = [];
    }
    
    // 3. 【核心】重新渲染通话界面，让旧的AI气泡从屏幕上消失
    //    我们需要根据当前是哪种模式，来清空对应的聊天容器
    const chat = state.chats[videoCallState.activeChatId];
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    const callFeed = isVisualMode 
        ? document.getElementById('video-call-messages-visual') 
        : document.getElementById('video-call-main');
    
    callFeed.innerHTML = ''; // 清空容器
    
    // 重新渲染删除后的历史记录
    videoCallState.callHistory.forEach(msg => {
        let bubble;
        if (isVisualMode) {
            bubble = document.createElement('div');
            bubble.className = `visual-call-bubble ${msg.role === 'user' ? 'user' : 'ai'}`;
        } else {
            bubble = document.createElement('div');
            bubble.className = `call-message-bubble ${msg.role === 'user' ? 'user-speech' : 'ai-speech'}`;
        }
        bubble.textContent = msg.content;
        callFeed.appendChild(bubble);
    });
    
    // 4. 重新触发AI响应，它会根据删减后的历史记录生成新内容
    await triggerAiInCallAction();
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：添加或移除 .dark-mode 类
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 将用户的选择保存到本地存储，以便下次打开时记住
    localStorage.setItem('ephone-theme', theme);

    // 【重要】因为聊天背景色依赖模式，切换后需要重新渲染
    if (state.activeChatId) {
        renderChatInterface(state.activeChatId);
    }
}

/**
 * 当用户点击开关时，切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
// ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
/**
 * 【全新】删除角色手机中的一个联系人及其所有聊天记录
 * @param {string} contactName - 要删除的联系人的名字
 */
async function deleteCharacterPhoneContact(contactName) {
    if (!activeCharacterPhoneId) return;

    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm(
        '删除联系人',
        `确定要从TA的手机中删除联系人“${contactName}”以及所有相关聊天记录吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat && chat.characterPhoneData && chat.characterPhoneData.chats) {
            // 从数据中删除这个联系人
            delete chat.characterPhoneData.chats[contactName];
            
            // 将更新后的数据保存回数据库
            await db.chats.put(chat);
            
            // 重新渲染聊天列表，让删除效果立刻显示
            renderCharacterChatList();
            
            alert(`联系人“${contactName}”已删除。`);
        }
    }
}
// ▼▼▼ 用这块【V5 - 已集成样式应用】的代码，替换旧的 openInnerVoiceModal 函数 ▼▼▼
/**
 * 【V5】打开心声面板，应用背景和所有自定义设置
 */
function openInnerVoiceModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // --- ★★★ 核心新增1：应用自定义样式 ★★★ ---
    applySavedInnerVoiceStyles();

    applyInnerVoiceBackground(chat.innerVoiceBackground || '');

    if (!chat.latestInnerVoice) {
        alert("还没有捕捉到Ta的心声哦，试着再聊一句吧！");
        return;
    }
    
    const modal = document.getElementById('inner-voice-modal');
    const data = chat.latestInnerVoice;
    
    // --- 角色信息填充 (不变) ---
    document.getElementById('inner-voice-avatar').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('inner-voice-char-name').textContent = chat.name;
    const frameImg = document.getElementById('inner-voice-avatar-frame');
    const avatarWrapper = document.getElementById('inner-voice-avatar-wrapper');
    const frameUrl = chat.settings.aiAvatarFrame || '';
    
    if (frameUrl) {
        frameImg.src = frameUrl;
        frameImg.style.display = 'block';
        avatarWrapper.classList.remove('has-border');
    } else {
        frameImg.src = '';
        frameImg.style.display = 'none';
        avatarWrapper.classList.add('has-border');
    }

    const labelFormat = chat.settings.innerVoiceAdopterLabelFormat || '领养人: {{user}}';
    const userNickname = chat.settings.myNickname || '你';
    const finalAdopterText = labelFormat.replace('{{user}}', userNickname);
    
    document.getElementById('inner-voice-adopter-avatar').src = chat.settings.myAvatar || defaultAvatar;
    document.getElementById('inner-voice-adopter-name').textContent = finalAdopterText;

    const header = document.querySelector('#inner-voice-main-panel .modal-header');
    if (header) {
        const shouldHideBorder = chat.settings.innerVoiceHideHeaderBorder || false;
        header.classList.toggle('no-border', shouldHideBorder);
    }

    // --- 心声内容填充 (不变) ---
    document.getElementById('inner-voice-clothing').textContent = data.clothing || '...';
    document.getElementById('inner-voice-behavior').textContent = data.behavior || '...';
    document.getElementById('inner-voice-thoughts').textContent = data.thoughts || '...';
    document.getElementById('inner-voice-naughty-thoughts').textContent = data.naughtyThoughts || '...';

    // --- 显示面板 (不变) ---
    modal.classList.add('visible');
    document.getElementById('inner-voice-history-panel').style.display = 'none';
    document.getElementById('inner-voice-main-panel').style.display = 'flex';
    isInnerVoiceHistoryOpen = false;
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 打开或关闭历史记录面板
 */
function toggleInnerVoiceHistory() {
    const mainPanel = document.getElementById('inner-voice-main-panel');
    const historyPanel = document.getElementById('inner-voice-history-panel');
    
    if (isInnerVoiceHistoryOpen) {
        // 如果是打开的，就关闭它，显示主面板
        mainPanel.style.display = 'flex';
        historyPanel.style.display = 'none';
    } else {
        // 如果是关闭的，就打开它，隐藏主面板
        renderInnerVoiceHistory(); // 渲染历史记录
        mainPanel.style.display = 'none';
        historyPanel.style.display = 'flex';
    }
    isInnerVoiceHistoryOpen = !isInnerVoiceHistoryOpen; // 切换状态
}

/**
 * 渲染心声的历史记录列表
 */
function renderInnerVoiceHistory() {
    const listEl = document.getElementById('inner-voice-history-list');
    listEl.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const history = chat.innerVoiceHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">还没有历史记录</p>';
        return;
    }

    // 从新到旧显示
    [...history].reverse().forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'inner-voice-history-item';
        
        const date = new Date(item.timestamp);
        const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        // 【核心修改】在HTML中加入了删除按钮
        itemEl.innerHTML = `
            <button class="history-item-delete-btn" data-timestamp="${item.timestamp}">×</button>
            <div class="history-item-timestamp">${dateString}</div>
            <div class="history-item-content">
                <p><strong>服装:</strong> ${item.clothing || '...'}</p>
                <p><strong>行为:</strong> ${item.behavior || '...'}</p>
                <p><strong>心声:</strong> ${item.thoughts || '...'}</p>
                <p><strong>坏心思:</strong> ${item.naughtyThoughts || '...'}</p>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
/**
 * 【全新】删除单条心声记录
 * @param {number} timestamp - 要删除的心声的时间戳
 */
async function deleteSingleInnerVoice(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.innerVoiceHistory) return;

    // 弹出确认框
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条心声记录吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 从数组中过滤掉匹配的项
        chat.innerVoiceHistory = chat.innerVoiceHistory.filter(item => item.timestamp !== timestamp);
        // 保存回数据库
        await db.chats.put(chat);
        // 重新渲染列表
        renderInnerVoiceHistory();
    }
}

/**
 * 【已修复】清空所有心声记录（包括当前心声）
 */
async function clearAllInnerVoiceHistory() {
    const chat = state.chats[state.activeChatId];
    // 优化了判断条件，确保只要有历史或当前心声，就可以执行清空
    if (!chat || (!chat.innerVoiceHistory || chat.innerVoiceHistory.length === 0) && !chat.latestInnerVoice) {
        alert("没有可以清空的心声记录。");
        return;
    }

    const confirmed = await showCustomConfirm('确认清空', '确定要清空所有心声历史记录吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // ★ 核心修复1：不仅清空历史数组，也要清空当前的心声对象
        chat.innerVoiceHistory = [];
        chat.latestInnerVoice = null; // 将当前心声设为null
        
        await db.chats.put(chat);
        
        // ★ 核心修复2：手动清空主面板的显示，防止返回时看到旧数据
        document.getElementById('inner-voice-clothing').textContent = '...';
        document.getElementById('inner-voice-behavior').textContent = '...';
        document.getElementById('inner-voice-thoughts').textContent = '...';
        document.getElementById('inner-voice-naughty-thoughts').textContent = '...';
        
        // 刷新历史记录列表（这行是原本就有的，会显示“还没有历史记录”）
        renderInnerVoiceHistory();
        
        // (可选但推荐) 给用户一个成功的提示
        alert('所有心声记录已清空！');
    }
}

/**
 * 【总入口】当用户点击“召唤NPC评论”按钮时触发
 * @param {number} postId - 动态的ID
 * @param {string} authorId - 动态作者的ID ('user' 或 'chat_...')
 */
async function handleNpcSummonClick(postId, authorId) {
    const post = await db.qzonePosts.get(postId);
    if (!post) {
        alert("找不到该动态！");
        return;
    }

    if (authorId === 'user') {
        // 如果是用户发的动态，弹出选择菜单
        await handleUserPostCommentTrigger(post);
    } else {
        // 如果是角色发的动态，直接触发他自己的NPC
        await handleCharPostCommentTrigger(post, authorId);
    }
}

// ▼▼▼ 用下面这块代码替换掉你旧的 handleCharPostCommentTrigger 函数 ▼▼▼
/**
 * 处理【角色】动态的NPC召唤
 * @param {object} post - 动态对象
 * @param {string} authorId - 动态作者的角色ID
 */
async function handleCharPostCommentTrigger(post, authorId) {
    const authorChar = state.chats[authorId];
    if (!authorChar || !authorChar.npcLibrary || authorChar.npcLibrary.length === 0) {
        alert(`角色“${authorChar.name}”还没有自己的NPC朋友哦！`);
        return;
    }

    // 只使用这个角色自己的NPC库
    // ▼▼▼ 核心修改：把作者本人(authorChar)作为“主人”传进去 ▼▼▼
    await generateNpcCommentsForPost(post, authorChar.npcLibrary, authorChar);
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这块代码替换掉你旧的 handleUserPostCommentTrigger 函数 ▼▼▼
/**
 * 处理【用户】动态的NPC召唤（弹出选择框）
 */
async function handleUserPostCommentTrigger(post) {
    const modal = document.getElementById('custom-modal-overlay');
    const modalTitle = document.getElementById('custom-modal-title');
    const modalBody = document.getElementById('custom-modal-body');
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    const modalCancelBtn = document.getElementById('custom-modal-cancel');
    
    modalTitle.textContent = '选择要召唤的NPC';
    
    // 筛选出所有拥有NPC库的角色
    const charsWithNpcs = Object.values(state.chats).filter(
        chat => !chat.isGroup && chat.npcLibrary && chat.npcLibrary.length > 0
    );

    if (charsWithNpcs.length === 0) {
        alert("当前没有任何角色拥有NPC库。");
        return;
    }

    // 构建选择列表的HTML
    let optionsHtml = '<div style="text-align: left;">';
    optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="all" checked> 召唤所有人</label>`;
    charsWithNpcs.forEach(char => {
        optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="${char.id}"> 只召唤 ${char.name} 的朋友</label>`;
    });
    optionsHtml += '</div>';
    
    modalBody.innerHTML = optionsHtml;
    modalConfirmBtn.textContent = '确认召唤';
    modalCancelBtn.style.display = 'block';

    modal.classList.add('visible');

    modalConfirmBtn.onclick = async () => {
        const selectedValue = document.querySelector('input[name="npc_summon_choice"]:checked').value;
        let npcsToSummon = [];
        let ownerChar = null; // ▼▼▼ 核心修改1：声明一个变量来存储主人 ▼▼▼

        if (selectedValue === 'all') {
            // 集合所有角色的所有NPC
            charsWithNpcs.forEach(char => {
                npcsToSummon.push(...char.npcLibrary);
            });
            // 召唤所有人时，我们不指定特定的主人
        } else {
            // 只获取被选中的那个角色的NPC
            const selectedChar = state.chats[selectedValue];
            if (selectedChar) {
                npcsToSummon = selectedChar.npcLibrary;
                ownerChar = selectedChar; // ▼▼▼ 核心修改2：把选中的角色存为主人 ▼▼▼
            }
        }
        
        modal.classList.remove('visible');
        if (npcsToSummon.length > 0) {
            // ▼▼▼ 核心修改3：把主人(ownerChar)作为第三个参数传进去 ▼▼▼
            await generateNpcCommentsForPost(post, npcsToSummon, ownerChar);
        }
    };
    
    modalCancelBtn.onclick = () => modal.classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这整块【召唤修复版】代码，替换掉你旧的 generateNpcCommentsForPost 函数 ▼▼▼
/**
 * 【AI核心 - V2.2 召唤修复版】生成NPC评论或回复，并更新到动态
 * @param {object} post - 动态对象
 * @param {Array<object>} npcsToComment - 将要发表评论的NPC对象数组
 * @param {object|null} ownerChar - (全新增) 这些NPC的“主人”角色对象
 */
async function generateNpcCommentsForPost(post, npcsToComment, ownerChar = null) {
    console.log("【NPC评论-诊断】: 1. 函数 generateNpcCommentsForPost 已触发", { post, npcsToComment, ownerChar });

    await showCustomAlert("请稍候...", "正在召唤NPC们前来围观评论...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    const postContent = (post.content || post.publicText || post.hiddenContent || "(图片动态)").substring(0, 150);
    const existingComments = (post.comments || []).slice(-3).map(c => `${c.commenterName}: ${c.text}`).join('\n');
    
    const shuffledNpcs = [...npcsToComment].sort(() => 0.5 - Math.random());
    const selectedNpcs = shuffledNpcs.slice(0, 5);
    const npcList = selectedNpcs.map(npc => `- ${npc.name} (人设: ${npc.persona})`).join('\n');
    
    const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');

    // ▼▼▼ 这就是我们新增的核心逻辑！▼▼▼
    let ownerContext = '';
    // 如果明确告诉了AI这些NPC的主人是谁
    if (ownerChar) {
        ownerContext = `
# NPC归属与关系 (重要背景)
- 你将要扮演的这些NPC都是角色“${ownerChar.name}”的朋友或关联人物。
- “${ownerChar.name}”的人设是: ${ownerChar.settings.aiPersona}
- 你在发表评论时，需要体现出你(作为NPC)与“${ownerChar.name}”的关系，并以此视角来看待动态作者“${authorName}”。
`;
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    const systemPrompt = `
# 任务
你是一个多角色扮演AI。现在有一条动态需要你扮演指定的NPC角色进行评论或回复。

${ownerContext}

# 动态信息
- 作者: ${authorName}
- 内容摘要: ${postContent}...
- 最近的评论 (你可以回复他们):
${existingComments || "(暂无评论)"}

# 你需要扮演的NPC列表 (及他们的人设)
${npcList}

# 核心规则
1.  你【必须】从上面的NPC列表中，选择1到3个最合适的角色进行评论或回复。
2.  评论/回复内容【必须】严格符合该NPC的人设和口吻，并与动态内容或已有评论相关。
3.  你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论或回复。
4.  格式: \`[{"commenterName": "NPC名字", "commentText": "评论内容", "replyTo": "(可选)被回复者名字"}]\`

现在，请开始生成评论或回复。
`;
    console.log("【NPC评论-诊断】: 2. 已构建完成，准备发送给AI的 System Prompt:", systemPrompt);

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi;
        if (isGemini) {
            messagesForApi = [{ role: 'user', content: systemPrompt }];
        } else {
            messagesForApi = [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: "请根据你在system prompt中读到的信息生成评论。" }
            ];
        }
        
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        console.log("【NPC评论-诊断】: 3. 即将发送API请求... 请求地址:", isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`);
        console.log("【NPC评论-诊断】: 3.1 请求体 (Body) 内容:", isGemini ? geminiConfig.data.body : JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } }));

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    response_format: { type: "json_object" }
                })
            });

        console.log("【NPC评论-诊断】: 4. 收到API响应", { ok: response.ok, status: response.status });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        console.log("【NPC评论-诊断】: 5. 从API获取到的原始回复内容:", aiResponseContent);
        
        let newComments;
        if (aiResponseContent.includes('"chatResponse"')) {
            newComments = JSON.parse(aiResponseContent).chatResponse;
        } else {
            newComments = JSON.parse(aiResponseContent);
        }

        console.log("【NPC评论-诊断】: 6. 成功解析后的评论对象数组:", newComments);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.qzonePosts.get(post.id); 
            if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
            if (!postToUpdate.comments) postToUpdate.comments = [];

            newComments.forEach(comment => {
                if(comment.commenterName && comment.commentText) {
                    const newCommentObject = {
                        commenterName: comment.commenterName,
                        text: comment.commentText,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) newCommentObject.replyTo = comment.replyTo;
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            await db.qzonePosts.put(postToUpdate);
            hideCustomModal();
            await renderQzonePosts(); 
            alert("NPC们评论成功！");
        } else {
             hideCustomModal();
             alert("NPC们似乎没什么想说的。");
        }

    } catch (error) {
        console.error("【NPC评论-错误】: 召唤NPC评论失败:", error);
        await showCustomAlert('召唤失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 把这一整块全新的微博功能函数，粘贴到 init() 函数的上方 ▼▼▼

let currentHotTopic = ''; // 用于存储当前正在查看的热搜话题
let hotTopicFeedCache = {}; // <-- 【新增】在这里创建一个缓存对象，像小本本一样记录生成过的内容
let weiboHotSearchCache = []; 
/**
 * 【总入口 V3 - 已支持多角色选择】生成微博热搜列表
 * @param {Array|string} targets - 目标角色ID数组或字符串'all'
 */
async function generateHotSearch(targets = 'all', recognition = true) {
    await showCustomAlert("请稍候...", "正在结合角色人设生成微博热搜...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    let publicFiguresContext = '';
    let promptTask = "你的任务是根据下方提供的“核心参考人物”信息，为他们量身打造一个包含10个热搜话题的榜单。";

    let publicFigures = [];
    if (targets === 'all') {
        publicFigures = Object.values(state.chats)
            .filter(chat => !chat.isGroup)
            .map(chat => ({ name: chat.name, persona: chat.settings.aiPersona.substring(0, 150) + '...' }));
    } else if (Array.isArray(targets)) {
        targets.forEach(chatId => {
            const char = state.chats[chatId];
            if(char) {
                publicFigures.push({ name: char.name, persona: char.settings.aiPersona.substring(0, 150) + '...' });
            }
        });
        if (publicFigures.length === 1) {
            promptTask = `你的任务是只为下方唯一的“核心参考人物”【${publicFigures[0].name}】，量身打造一个包含10个热搜话题的榜单。所有话题【必须】与Ta强相关。`;
        }
    }
    
    publicFiguresContext = publicFigures.length > 0
        ? `# 核心参考人物 (你必须围绕他们生成热搜)\n${JSON.stringify(publicFigures, null, 2)}`
        : "当前没有特定的公众人物，请自由生成热点事件。";

    // 后续的 systemPrompt 和 API 调用逻辑与你现有代码完全相同，无需修改...
    const systemPrompt = `
# 任务
你是一个专业的“微博热搜榜单生成器”。${promptTask}
# 【【【绝对禁止事项：这是必须遵守的最高指令】】】
1.  你的所有创作内容，包括帖子、评论、故事等，【绝对禁止】将任意两个AI角色（即除了用户之外的角色）描绘成情侣关系、进行恋爱互动或存在任何形式的暧昧情感。
2.  AI角色之间的关系只能是朋友、同事、对手、家人等，但【绝不能】是恋人。
3.  AI角色唯一可以产生恋爱关系的对象是【用户】。违反此规则将导致生成失败。
# 核心规则
1.  **强相关性**: 生成的话题【必须】与“核心参考人物”的身份、职业、人设高度相关。例如，如果是电竞选手，热搜就应该是关于比赛；如果是演员，就应该是关于新剧。
2.  **【【【严禁杜撰】】】**: 绝对禁止为列表中的人物【凭空捏造】他们人设中没有的职业、身份或背景。你只能根据提供的人设进行合理发挥。
3.  **真实感与多样性**: 为了让榜单更真实，你可以混合2-3个与核心人物无关的、社会化的虚拟热点事件。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含10个对象。每个对象【必须】包含以下三个字段:
    -   \`"topic"\`: (字符串) 热搜的话题，必须用"#"符号包裹。
    -   \`"heat"\`: (字符串) 热度值，例如 "345.6万"。
    -   \`"tag"\`: (字符串) 一个标签，必须从 "热"、"新"、"荐" 中选择一个。
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。请检查Prompt或更换模型。");
        }
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const hotSearchData = responseData.hot_searches || responseData;
        weiboHotSearchCache = hotSearchData; 
        await generatePlazaFeed(hotSearchData, targets, recognition); 
        renderHotSearchList(hotSearchData); 
        await showCustomAlert("操作成功", "热搜榜和广场均已生成完毕！");
    } catch (error) {
        console.error("生成热搜失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}


/**
 * 【UI渲染】根据AI返回的数据渲染热搜列表
 */
function renderHotSearchList(hotSearchData) {
    const listEl = document.getElementById('weibo-hot-search-list');
    listEl.innerHTML = ''; 

    if (!hotSearchData || !Array.isArray(hotSearchData)) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">AI返回的数据格式不正确，无法渲染。</p>';
        return;
    }

    hotSearchData.forEach((item, index) => {
        const rank = index + 1;
        const tagClass = { '热': 'hot', '新': 'new', '荐': 'rec' }[item.tag] || 'rec';

        const itemEl = document.createElement('div');
        itemEl.className = 'hot-search-item';
        itemEl.dataset.rank = rank;
        itemEl.innerHTML = `
            <span class="hot-search-rank">${rank}</span>
            <div class="hot-search-content">
                <span class="hot-search-topic">${item.topic}</span>
                <span class="hot-search-tag ${tagClass}">${item.tag}</span>
            </div>
            <span class="hot-search-heat" style="color: var(--text-secondary); font-size: 13px;">${item.heat}</span>
        `;
        itemEl.addEventListener('click', () => showHotTopicFeedScreen(item.topic));
        listEl.appendChild(itemEl);
    });
}

/**
 * 【总入口】显示并生成指定热搜话题的微博Feed (已增加缓存功能)
 */
async function showHotTopicFeedScreen(topic) {
    currentHotTopic = topic; 
    document.getElementById('weibo-hottopic-title').textContent = topic;
    switchToWeiboView('weibo-hottopic-feed-view'); 
    
    // 【核心修改】检查“小本本”里有没有记录
    if (hotTopicFeedCache[topic]) {
        // 如果有，就直接显示，不重新生成
        console.log(`从缓存加载话题: ${topic}`);
        const feedEl = document.getElementById('weibo-hottopic-feed-list');
        renderWeiboFeed(feedEl, hotTopicFeedCache[topic], true);
    } else {
        // 如果没有，才调用函数去生成新的内容
        await generateHotSearchFeed(topic); 
    }
}


/**
 * 【AI核心 V2 - 已修复拼写错误 & 增加缓存】调用API为指定话题生成微博Feed
 */
async function generateHotSearchFeed(topic) {
    const feedEl = document.getElementById('weibo-hottopic-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在生成内容，请稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    const allChars = Object.values(state.chats).filter(c => !c.isGroup).map(c => ({ name: c.name, persona: c.settings.aiPersona.substring(0,100) }));
    const allNpcs = Object.values(state.chats).flatMap(c => c.npcLibrary || []).map(npc => ({ name: npc.name, persona: npc.persona.substring(0,100) }));
    const allPeople = [...allChars, ...allNpcs];

    const systemPrompt = `
# 任务
你是一个“微博内容生成器”。你的任务是围绕一个给定的热搜话题，生成一批相关的微博帖子。

# 当前热搜话题
**${topic}**
# 【【【绝对禁止事项：这是必须遵守的最高指令】】】
1.  你的所有创作内容，包括帖子、评论、故事等，【绝对禁止】将任意两个AI角色（即除了用户之外的角色）描绘成情侣关系、进行恋爱互动或存在任何形式的暧昧情感。
2.  AI角色之间的关系只能是朋友、同事、对手、家人等，但【绝不能】是恋人。
3.  AI角色唯一可以产生恋爱关系的对象是【用户】。违反此规则将导致生成失败。

# 核心规则
1.  **数量**: 生成 5 到 10 条微博。
2.  **相关性**: 所有微博内容【必须】与话题 **"${topic}"** 强相关，并且【必须】在内容中包含 **${topic}** 这个话题标签。
3.  **高热度**: 生成的微博必须看起来像是热搜里的内容，所以它们的 "likes" (点赞数) 和 "comments" (评论数) 【必须】非常高。点赞数应在 10000 到 500000 之间，评论数应在 800 到 20000 之间。
4.  **评论生成**: 为每条微博生成 8 到 10 条真实感的路人评论。评论内容应与微博内容相关，风格多样。
5.  **作者多样性**: 微博的作者可以是下方“可用人物列表”中的角色，也可以是你虚构的路人、大V或官方媒体。如果让列表中的角色发言，内容必须符合他的人设。
6.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含多条微博对象。每个对象【必须】包含以下字段:
    -   \`"author"\`: (字符串) 作者昵称。
    -   \`"content"\`: (字符串) 微博正文，必须包含话题标签 ${topic}。
    -   \`"likes"\`: (数字) 10000到500000之间的随机高赞数。
    -   \`"comments"\`: (数字) 800到20000之间的随机高评论数。
    -   \`"comments_list"\`: (数组) 包含8-10个评论对象的数组，每个对象格式为 \`{"author": "评论者昵称", "text": "评论内容"}\`。

# 可用人物列表 (你可以让他们发言)
${JSON.stringify(allPeople, null, 2)}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。");
        }
        
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent); // <-- 这里的 responseData 是正确的
        const feedData = responseData.posts || responseData;

        // 【核心修改】将新生成的内容，记在“小本本”上
        hotTopicFeedCache[topic] = feedData; 

        renderWeiboFeed(feedEl, feedData, true);

    } catch (error) {
        console.error("生成热搜Feed失败:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失败: ${error.message}</p>`;
    }
}


/**
 * 【总入口 V3 - 已支持多角色选择】生成微博广场Feed
 * @param {Array} hotTopics - (可选) 从热搜生成函数传过来的话题数组
 * @param {Array|string} targets - (新增) 目标角色ID数组或字符串'all'
 */
async function generatePlazaFeed(hotTopics = null, targets = 'all', recognition = true) {
    if (!hotTopics) {
        await showCustomAlert("请稍候...", "正在生成广场动态...");
    }
    const feedEl = document.getElementById('weibo-plaza-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在加载内容，请稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    let publicFiguresContext = '';
    let taskInstruction = "你的任务是模拟一个真实的社交媒体广场，生成10条由不同路人发布的微博帖子。";

    let publicFigures = [];
    if (targets === 'all') {
        publicFigures = Object.values(state.chats)
            .filter(chat => !chat.isGroup)
            .map(chat => ({ 
                name: chat.realName || chat.name,  // 【修改】使用realName作为真实名字
                persona: chat.settings.aiPersona.substring(0, 150) + '...',
                weibo_profession: chat.settings.weiboProfession || '未设定',
                weibo_instruction: chat.settings.weiboInstruction || '无'
            }));
    } else if (Array.isArray(targets)) {
        targets.forEach(chatId => {
            const char = state.chats[chatId];
            if(char) {
                 publicFigures.push({ 
                    name: char.realName || char.name,  // 【修改】使用realName作为真实名字
                    persona: char.settings.aiPersona.substring(0, 150) + '...',
                    weibo_profession: char.settings.weiboProfession || '未设定',
                    weibo_instruction: char.settings.weiboInstruction || '无'
                });
            }
        });
        if (publicFigures.length === 1) {
            taskInstruction = `你的任务是模拟一个真实的社交媒体广场，生成10条与角色“${publicFigures[0].name}”相关的、由不同路人发布的微博帖子。`;
        } else {
            taskInstruction = `你的任务是模拟一个真实的社交媒体广场，生成10条与角色 ${publicFigures.map(p => `“${p.name}”`).join('、')} 相关的、由不同路人发布的微博帖子。`;
        }
    }
    
    publicFiguresContext = publicFigures.length > 0 
        ? `# 核心参考人物 (你生成的内容【必须】围绕他们展开)\n${JSON.stringify(publicFigures, null, 2)}` 
        : "";

    const topicsContext = (hotTopics && Array.isArray(hotTopics) && hotTopics.length > 0)
        ? `请围绕以下热门话题生成内容：${hotTopics.map(t => t.topic).join('、 ')}`
        : "请随机生成一些生活化的日常内容。";
    
    // 根据角色互识开关添加额外规则
    const recognitionRule = recognition 
        ? "" 
        : "\n6.  **【【【角色互识规则】】】**: 由于角色之间互不认识，每条微博帖子【有且仅能】提到上方\"核心参考人物\"列表中的【一个】角色。【绝对禁止】在同一条帖子中同时提到两个或更多角色。每个角色应该在不同的帖子中单独出现。";

    // 后续的 systemPrompt 和 API 调用逻辑与你现有代码完全相同，无需修改...
    const systemPrompt = `
# 任务
你是一个“微博广场内容生成器”。${taskInstruction}
# 【【【绝对禁止事项：这是必须遵守的最高指令】】】
1.  你的所有创作内容，包括帖子、评论、故事等，【绝对禁止】将任意两个AI角色（即除了用户之外的角色）描绘成情侣关系、进行恋爱互动或存在任何形式的暧昧情感。
2.  AI角色之间的关系只能是朋友、同事、对手、家人等，但【绝不能】是恋人。
3.  AI角色唯一可以产生恋爱关系的对象是【用户】。违反此规则将导致生成失败。
# 核心规则
1.  **身份**: 发帖者都是普通人，昵称要生活化。
2.  **内容**: 帖子内容应是生活化的日常。${topicsContext}
3.  **热度**: 赞和评论数可高可低，模拟真实世界的随机性。
4.  **【【【严禁杜撰】】】**: 如果你生成的内容提到了上方"核心参考人物"列表中的任何角色，你【绝对禁止】为他们【凭空捏造】人设中没有的职业、身份或背景。你只能根据提供的人设进行合理发挥。
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，包含10个微博对象。每个对象的格式与“热搜Feed”的格式完全相同（包含 author, content, likes, comments, comments_list 字段）。
    - \`"comments_list"\`: (数组) 包含2-5条评论对象的数组，每个对象格式为 \`{"author": "评论者昵称", "text": "评论内容"}\`.${recognitionRule}
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。");
        }
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const feedData = responseData.posts || responseData; 
        renderWeiboFeed(feedEl, feedData, false);
        if (!hotTopics) {
            await showCustomAlert("操作成功", "广场生成完毕！");
        }
    } catch (error) {
        console.error("生成广场Feed失败:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失败: ${error.message}</p>`;
    }
}





// ▼▼▼ 用这整块【V3修复版】代码，完整替换旧的 renderWeiboFeed 函数 ▼▼▼
/**
 * 【UI渲染 V3 - 修复评论和头像，并添加删除按钮】通用函数，用于渲染微博Feed列表
 */
function renderWeiboFeed(containerEl, feedData, isHotSearch) {
    containerEl.innerHTML = '';
    
    if (!feedData || !Array.isArray(feedData)) {
        containerEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">AI返回的数据格式不正确，无法渲染。</p>';
        return;
    }

    feedData.forEach((post, index) => { // <-- 新增了 index 参数
        const postEl = document.createElement('div');
        postEl.className = 'weibo-post-item';
        // ▼▼▼ 核心修改1：给帖子加上一个独一无二的ID，方便我们删除 ▼▼▼
        postEl.dataset.postId = `temp_${index}`;

        // 【核心修复1：头像查找逻辑】
        let finalAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默认路人头像
        const potentialChar = Object.values(state.chats).find(c => c.name === post.author);
        if (potentialChar) {
            finalAvatar = potentialChar.settings.aiAvatar; // 如果作者是你的char，就用他的头像！
        }

        // 【核心修复2：评论渲染逻辑】
        let commentsHtml = '';
        if (post.comments_list && post.comments_list.length > 0) {
            commentsHtml += '<div class="weibo-comments-container">';
            post.comments_list.forEach(comment => {
                // 确保我们能正确访问评论者昵称和内容
                const commenterName = comment.author || '匿名用户'; // 优先用 author，没有就用匿名
                const commentText = comment.text || ''; // 确保 text 存在
                commentsHtml += `
                    <div class="weibo-comment-item">
                        <span class="weibo-commenter-name">${commenterName}:</span>
                        <span class="weibo-comment-text">${commentText}</span>
                    </div>`;
            });
            commentsHtml += '</div>';
        }
        
        postEl.innerHTML = `
            <div class="weibo-post-header">
                <img src="${finalAvatar}" class="weibo-post-avatar">
                <div class="weibo-post-info">
                    <span class="weibo-post-nickname">${post.author}</span>
                    <span class="weibo-post-timestamp">${isHotSearch ? '热搜内容' : '刚刚'}</span>
                </div>
                <!-- ▼▼▼ 核心修改2：在这里加上我们设计好的删除按钮！ ▼▼▼ -->
                <button class="weibo-post-delete-btn" title="删除这条动态">×</button>
            </div>
            <div class="weibo-post-content">${(post.content || '').replace(/\n/g, '<br>')}</div>
            <div class="weibo-post-footer">
                <div class="weibo-post-actions">
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                        <span>${post.likes || 0}</span>
                    </span>
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                        <span>${post.comments || 0}</span>
                    </span>
                </div>
                ${commentsHtml}
            </div>
        `;
        containerEl.appendChild(postEl);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
        /* ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */
/**
 * 【全新】如果数据库中没有，则自动创建一个内置的夜间模式主题
 */
async function addDefaultDarkModeThemeIfNeeded() {
    const themeName = "内置夜间模式"; // 这是我们要内置的主题名字
    try {
        // 检查数据库里是否已经有了这个名字的主题
        const existingTheme = await db.themes.where('name').equals(themeName).first();
        
        // 如果没有找到 (existingTheme 是 undefined)，就创建它
        if (!existingTheme) {
            console.log("内置夜间模式不存在，正在创建...");

            // 这就是完整的夜间模式CSS代码
            const darkModeCss = `
/* 1. 全局重新定义颜色变量 */
:root {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
  --accent-color: #0A84FF; /* iOS风格的蓝色 */
}

/* 2. 为所有屏幕和主要容器设置基础深色背景 */
#phone-screen, .screen, #chat-list, #world-book-list, .list-container, .form-container, #chat-messages,
#wallpaper-screen, #font-settings-screen, #api-settings-screen, #character-selection-screen,
#world-book-screen, #world-book-editor-screen, #character-phone-inner-screen, #character-phone-page {
    background-color: #000000 !important;
}

/* 3. 主屏幕专属样式 */
#home-screen { background: #111827 !important; }
#desktop-dock { background-color: rgba(55, 65, 81, 0.5); }
.desktop-app-icon .label, .widget-subtext { color: #e5e7eb; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
#profile-widget .profile-info { background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); color: #f9fafb; }
#profile-username, #profile-bio, #profile-location span { color: #f9fafb; }
#profile-sub-username, #profile-location { color: #9ca3af; }
#profile-location { background-color: rgba(255,255,255,0.1); }
.widget-bubble { background-color: rgba(55, 65, 81, 0.9); color: #e5e7eb; }
.widget-bubble::after { border-top-color: rgba(55, 65, 81, 0.9); }

/* 4. 适配所有页面的头部Header */
.header, .qzone-header, .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 适配所有通用组件 */
#chat-input-area, #chat-list-bottom-nav { background-color: rgba(28, 28, 30, 0.85); border-top-color: var(--border-color); }
#chat-input { background-color: var(--secondary-bg); color: var(--text-primary); }
.modal-content, #custom-modal { background-color: #2c2c2e; }
.modal-header, .modal-footer, .custom-modal-footer, .custom-modal-footer button:first-child { border-color: var(--border-color); }
.form-group input, .form-group select, .form-group textarea { background-color: var(--secondary-bg); color: var(--text-primary); border-color: var(--border-color); }
.list-item, .chat-list-item-swipe-container:not(:last-child), .chat-group-container, .world-book-group-container { border-bottom-color: var(--border-color) !important; }
.chat-group-container:first-of-type { border-top-color: var(--border-color) !important; }
.list-item:hover, .chat-list-item:hover { background-color: #2c2c2e; }

/* 6. 特殊页面深度适配 */
.chat-group-header, .world-book-group-header { background-color: #1c1c1e; }
.chat-list-item-content.pinned { background-color: #3a3a3c; }
#font-preview, #wallpaper-preview, .font-preset-slot { background-color: #1c1c1e !important; border-color: #38383a !important; }

/* 7. 角色手机内部适配 & 全局文字颜色修复 */
#character-phone-container { background-color: #000000; }
.character-phone-frame { background-color: #111; }
#character-chat-history-messages { background-color: #0e0e0e !important; }
.character-chat-bubble.received { background-color: #2c2c2e !important; }
.character-data-item, .character-bank-transaction, .character-cart-item, .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}

/* ▼▼▼ 核心修复：把所有这些元素的文字颜色都改为低饱和度的浅灰色 ▼▼▼ */
.character-data-item .title,
.character-data-item .content,
.character-data-item .meta,
.cart-item-price,
.cart-item-info .title,
.character-browser-item .title,
.transaction-details .title,
.transaction-amount,
.character-select-item .name,  /* 修复角色选择列表的名字颜色 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2 {
    color: #E0E0E0 !important; /* 使用一个柔和的、不刺眼的白色 */
}

.character-data-item .meta span,
#character-diary-list .character-data-item .meta {
    color: #9E9E9E !important; /* 次要信息使用更暗的灰色 */
}

#character-diary-list .character-data-item {
    background-color: #26211a; /* 夜间模式下的信纸背景色 */
    border-color: #524a3d;
    border-left-color: #9e8a70;
}

`;

            // 把这个新主题添加到数据库的 'themes' 表里
            await db.themes.add({ name: themeName, css: darkModeCss });
            console.log("内置夜间模式已成功创建！");
        } else {
            console.log("内置夜间模式已存在，跳过创建。");
        }
    } catch (error) {
        console.error("检查或创建内置夜间模式时出错:", error);
    }
}
// ▼▼▼ 【全新】聊天记录搜索功能核心函数 ▼▼▼

/**
 * 打开并准备聊天记录搜索界面
 */
function openChatSearchScreen() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 清空旧的搜索条件和结果
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('sender-search-select').innerHTML = '';
    document.getElementById('date-search-input').value = '';
    document.getElementById('chat-search-results-list').innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">输入条件开始搜索</p>';

    // 动态填充“人物”下拉菜单
    const senderSelect = document.getElementById('sender-search-select');
    senderSelect.innerHTML = '<option value="">所有人</option>'; // 默认选项

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const myOption = document.createElement('option');
    myOption.value = myNickname;
    myOption.textContent = myNickname;
    senderSelect.appendChild(myOption);

    if (chat.isGroup) {
        chat.members.forEach(member => {
            const memberOption = document.createElement('option');
            memberOption.value = member.originalName; // 使用本名进行精确匹配
            memberOption.textContent = member.groupNickname; // 显示群昵称给用户看
            senderSelect.appendChild(memberOption);
        });
    } else {
        const aiOption = document.createElement('option');
        aiOption.value = chat.name;
        aiOption.textContent = chat.name;
        senderSelect.appendChild(aiOption);
    }
    
    // 关闭聊天设置弹窗，并显示搜索界面
    document.getElementById('chat-settings-modal').classList.remove('visible');
    showScreen('chat-search-screen');
}

/**
 * 执行搜索操作
 */
/**
 * 【功能完整版】执行搜索操作
 */
function performChatSearch() {
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        // 如果找不到聊天对象，给用户一个明确的提示
        alert('无法执行搜索，因为没有找到当前聊天。');
        return;
    }

    // 1. 获取所有搜索条件
    const keyword = document.getElementById('keyword-search-input').value.trim();
    const senderValue = document.getElementById('sender-search-select').value;
    const dateValue = document.getElementById('date-search-input').value;
    const typeValue = document.getElementById('type-search-select').value;

    // 将关键词保存到全局变量，以便在渲染结果时用于高亮
    currentSearchKeyword = keyword;

    if (!keyword && !senderValue && !dateValue && !typeValue) {
        alert('请至少输入一个搜索条件！');
        return;
    }

    // 2. 筛选聊天记录
    console.log(`开始搜索: 关键词='${keyword}', 发言人='${senderValue}', 日期='${dateValue}', 类型='${typeValue}'`);
    
    const results = chat.history.filter(msg => {
        // 过滤掉系统消息和对用户隐藏的消息
        if (msg.isHidden || msg.role === 'system' || msg.type === 'recalled_message') {
            return false;
        }

        // a. 筛选日期
        if (dateValue) {
            const msgDate = new Date(msg.timestamp).toISOString().split('T')[0];
            if (msgDate !== dateValue) {
                return false;
            }
        }

        // b. 筛选发言人
        if (senderValue) {
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            let msgSenderName = '';
            
            if (msg.role === 'user') {
                msgSenderName = myNickname;
            } else { // AI或群成员的消息
                // 这里我们使用 originalName 来精确匹配，因为群昵称可能会变
                msgSenderName = chat.isGroup ? msg.senderName : chat.name;
            }
            if (msgSenderName !== senderValue) {
                return false;
            }
        }

        // c. 筛选关键词
        if (keyword) {
            let contentText = '';
            // 将所有可能包含文本的内容都转换成字符串进行搜索
            if (typeof msg.content === 'string') {
                contentText = msg.content;
            } else if (typeof msg.content === 'object' && msg.content !== null) {
                // 对于复杂对象，我们可以简单地将它们转为JSON字符串来搜索
                contentText = JSON.stringify(msg.content);
            }
            
            if (!contentText.toLowerCase().includes(keyword.toLowerCase())) {
                return false;
            }
        }

        // d. 筛选消息类型
        if (typeValue) {
            // 获取消息的实际类型
            const msgType = msg.type || 'text'; // 如果没有type属性，默认为普通文本
            
            // 特殊处理：如果选择的是 'text'，匹配所有没有type或type为undefined的消息
            if (typeValue === 'text') {
                // 普通文本消息通常没有type属性，或者type为空
                if (msgType && msgType !== 'text' && msgType !== '') {
                    return false;
                }
            } else {
                // 其他类型需要精确匹配
                if (msgType !== typeValue) {
                    return false;
                }
            }
        }

        return true; // 所有条件都满足
    });
    
    console.log(`搜索到 ${results.length} 条结果`);

    // 3. 渲染结果
    renderSearchResults(results);
}


/**
 * 渲染搜索结果列表
 * @param {Array} results - 筛选出的消息数组
 */
function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list')
;
    listEl.innerHTML = '';
listEl.scrollTop = 0; // 每次渲染前，都将滚动条重置到顶部

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">未找到相关记录</p>';
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    // 为了性能，只渲染最新的100条结果
    results.slice(-100).reverse().forEach(msg => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.timestamp = msg.timestamp; // 关键！用于跳转

        let senderName, senderAvatar;
        if (msg.role === 'user') {
            senderName = myNickname;
            senderAvatar = chat.settings.myAvatar;
        } else {
            if (chat.isGroup) {
                senderName = msg.senderName;
                const member = chat.members.find(m => m.originalName === senderName);
                senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
            } else {
                senderName = chat.name;
                senderAvatar = chat.settings.aiAvatar;
            }
        }

        let contentText = '';
        if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
            contentText = '[表情]';
        } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || Array.isArray(msg.content)) {
            contentText = '[图片]';
        } else {
            contentText = String(msg.content);
        }

        item.innerHTML = `
            <img src="${senderAvatar || defaultAvatar}" class="avatar">
            <div class="search-result-info">
                <div class="search-result-meta">
                    <span class="name">${senderName}</span>
                    <span class="timestamp">${formatDateStamp(msg.timestamp)}</span>
                </div>
                <div class="search-result-content">
                    ${highlightText(contentText, currentSearchKeyword)}
                </div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 辅助函数：高亮文本中的关键词
 * @param {string} text - 原始文本
 * @param {string} keyword - 要高亮的关键词
 * @returns {string} - 处理后的HTML字符串
 */
function highlightText(text, keyword) {
    if (!keyword || !text) {
        return text;
    }
    const regex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
    return text.replace(regex, `<span class="highlight">$&</span>`);
}

// ▼▼▼ 请用这块【最终修复版】的代码，完整替换旧的 jumpToMessage 函数 ▼▼▼
/**
 * 【最终修复版】点击搜索结果，跳转到对应的消息位置
 * @param {number} timestamp - 目标消息的时间戳
 */
async function jumpToMessage(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const targetIndex = chat.history.findIndex(msg => msg.timestamp === timestamp);
    if (targetIndex === -1) {
        await showCustomAlert('错误', '找不到该条消息，可能已被删除。');
        return;
    }

    // 1. 切换回聊天界面
    showScreen('chat-interface-screen');
    await new Promise(resolve => setTimeout(resolve, 50));

    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = ''; // 清空当前内容

    // 2. 计算要渲染的消息窗口（以目标消息为中心）
    const windowSize = 50; // 和 MESSAGE_RENDER_WINDOW 保持一致
    const startIndex = Math.max(0, targetIndex - Math.floor(windowSize / 2));
    const messagesToRender = chat.history.slice(startIndex);

    // 3. 更新 currentRenderedCount 以同步加载状态
    //    这一步至关重要，它告诉“加载更多”功能下次应该从哪里开始加载
    currentRenderedCount = messagesToRender.length;

    // 4. 如果计算出的起始位置大于0，说明前面还有更早的记录，需要显示“加载更多”按钮
    if (startIndex > 0) {
        prependLoadMoreButton(messagesContainer);
    }

    // 5. 渲染消息窗口和日期戳
    let lastMessageTimestamp = startIndex > 0 ? chat.history[startIndex - 1].timestamp : null;
    messagesToRender.forEach(msg => {
        if (msg.isHidden) return;
        if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
            const dateStampEl = createDateStampElement(msg.timestamp);
            messagesContainer.appendChild(dateStampEl);
        }
        // 使用 true 作为第三个参数，表示这是初始加载，不应播放动画
        appendMessage(msg, chat, true); 
        lastMessageTimestamp = msg.timestamp;
    });

    // 6. 滚动到目标消息并高亮它
    //    使用 setTimeout 确保 DOM 元素已经完全渲染到页面上
    setTimeout(() => {
        const targetMessage = messagesContainer.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
        if (targetMessage) {
            // 使用 'auto' 滚动，比 'smooth' 更快速直接
            targetMessage.scrollIntoView({ behavior: 'auto', block: 'center' });
            
            // 添加闪烁高亮效果，让用户能注意到
            targetMessage.classList.add('flash');
            setTimeout(() => {
                targetMessage.classList.remove('flash');
            }, 1500);
        }
    }, 100);

    // 7. 【最关键】我们已经移除了导致页面跳回的 setTimeout(renderChatInterface, ...)
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把下面这【两段】全新的函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】显示微博主页并渲染数据
 */
async function showWeiboScreen() {
    // 1. 计算关注数
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    const followingCount = allSingleChats.length + totalNpcCount;

    // 2. 更新页面上的元素
    // 从你的“动态(QZone)”设置里获取头像和昵称，保持统一
    document.getElementById('weibo-avatar-img').src = state.qzoneSettings.avatar || defaultAvatar;
    document.getElementById('weibo-nickname').textContent = state.qzoneSettings.nickname || '你的昵称';
    document.getElementById('weibo-following-count').textContent = followingCount;

    // 3. 显示微博页面
    showScreen('weibo-screen');
}

// ▼▼▼ 用这块【已添加主页按钮】的代码，替换旧的 showFollowingList 函数 ▼▼▼
function showFollowingList() {
    console.log("【诊断日志 2】: showFollowingList 函数已成功触发！");

    const modal = document.getElementById('weibo-following-modal');
    console.log("【诊断日志 3】: 正在尝试获取弹窗元素 #weibo-following-modal:", modal);
    if (!modal) {
        alert("诊断错误：在HTML中找不到ID为 'weibo-following-modal' 的弹窗元素！请检查HTML代码。");
        return;
    }

    const listContainer = document.getElementById('weibo-following-list-container');
    listContainer.innerHTML = '';
    
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (allSingleChats.length === 0) {
        listContainer.innerHTML = '<p style="text-align:center; color:grey; padding: 20px;">还没有关注任何人哦</p>';
    } else {
        allSingleChats.forEach(chat => {
            // --- 渲染角色本人 ---
            const charItem = document.createElement('div');
            charItem.className = 'weibo-following-item';
            // 【核心修改】在这里加入了“查看主页”和“AI操作”按钮
            charItem.innerHTML = `
                <img src="${chat.settings.aiAvatar || defaultAvatar}" class="weibo-following-avatar">
                <span class="weibo-following-name">${chat.name}</span>
                <!-- 这是我们新增的“查看主页”按钮 -->
                <button class="view-profile-btn" data-char-id="${chat.id}">主页</button>
                <span class="weibo-action-trigger-btn" data-target-id="${chat.id}" data-target-name="${chat.name}" data-is-npc="false" title="为Ta执行操作">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                </span>
            `;
            listContainer.appendChild(charItem);
            
            // --- 渲染该角色下的NPC ---
            if (chat.npcLibrary && chat.npcLibrary.length > 0) {
                chat.npcLibrary.forEach(npc => {
                    const npcItem = document.createElement('div');
                    npcItem.className = 'weibo-following-item';
                    npcItem.style.paddingLeft = '30px';
                    // NPC暂时没有独立主页，所以不加“主页”按钮
                    npcItem.innerHTML = `
                         <img src="${npc.avatar || defaultGroupMemberAvatar}" class="weibo-following-avatar">
                         <span class="weibo-following-name">${npc.name} (NPC)</span>
                         <span class="weibo-action-trigger-btn" data-target-id="${npc.id}" data-target-name="${npc.name}" data-is-npc="true" data-owner-id="${chat.id}" title="为Ta执行操作">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                         </span>
                    `;
                    listContainer.appendChild(npcItem);
                });
            }
        });
    }
    
    modal.classList.add('visible');
    console.log("【诊断日志 4】: 已成功为弹窗添加 .visible 类，弹窗现在应该显示了。");
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】微博页面功能函数 ▼▼▼

// ▼▼▼ 用这块【已添加头像框渲染逻辑】的代码替换旧的 ▼▼▼
/**
 * 【微博专属】渲染微博个人主页的所有数据
 */
async function renderWeiboProfile() {
    const settings = state.qzoneSettings || {};
    // 【核心】所有数据都从 weibo... 字段读取！
    document.getElementById('weibo-avatar-img').src = settings.weiboAvatar;
    document.getElementById('weibo-nickname').textContent = settings.weiboNickname;
    document.getElementById('weibo-fans-count').textContent = settings.weiboFansCount;
    document.getElementById('weibo-background-img').src = settings.weiboBackground;
    
    // 动态计算关注数 (这部分不变)
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    document.getElementById('weibo-following-count').textContent = allSingleChats.length + totalNpcCount;
    
    // 动态计算微博数
    const postsCount = await db.weiboPosts.where('authorId').equals('user').count();
    document.getElementById('weibo-posts-count').textContent = postsCount;
    
    const professionEl = document.getElementById('weibo-user-profession-display');
    if (professionEl) {
        professionEl.textContent = settings.weiboUserProfession || '点击设置职业';
    }

    // --- ▼▼▼ 以下是本次新增的核心代码 ▼▼▼ ---
    // 1. 获取保存的头像框URL
    const frameUrl = settings.weiboAvatarFrame || '';
    // 2. 找到头像框的img元素
    const frameImg = document.getElementById('weibo-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就显示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL为空（即选择了“无”），就隐藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
    // --- ▲▲▲ 新增代码结束 ▲▲▲
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【微博专属】编辑微博头像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更换微博头像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl; // 只修改微博头像
        await saveQzoneSettings();
        await renderWeiboProfile(); // 用专属函数刷新
    }
}

/**
 * 【微博专属】编辑微博背景图
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更换微博背景", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl; // 只修改微博背景
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博专属】编辑微博昵称
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("编辑微博昵称", "请输入新的昵称", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵称'; // 只修改微博昵称
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博专属】编辑微博粉丝数
 */
async function editWeiboFansCount() {
    const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数", state.qzoneSettings.weiboFansCount, "number");
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉丝数
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 通用的图片编辑函数 (本地上传或URL)
 * @param {string} title - 弹窗标题
 * @param {string} currentUrl - 当前的图片URL
 * @returns {Promise<string|null>} - 新的图片URL或null
 */
async function getNewImageUrl(title, currentUrl) {
    const choice = await showChoiceModal(title, [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    if (choice === 'local') {
        return await uploadImageLocally();
    } else if (choice === 'url') {
        const url = await showCustomPrompt(title, "请输入新的图片URL", currentUrl, "url");
        if (url && url.trim().startsWith('http')) {
            return url.trim();
        } else if (url !== null) {
            alert("请输入一个有效的URL！");
        }
    }
    return null;
}

/**
 * 编辑微博头像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更换头像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博背景图
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更换背景图", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博昵称
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("编辑昵称", "请输入新的微博昵称", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵称';
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▼▼▼ 请【再次确认】并用下面这【整块函数】替换掉旧的 editWeiboFansCount 函数 ▼▼▼
/**
 * 【微博专属】编辑微博粉丝数 (已修复，支持汉字)
 */
async function editWeiboFansCount() {
    // 核心修改：确保这里的第四个参数是 "text"，而不是 "number"
    const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数", state.qzoneSettings.weiboFansCount, "text");
    
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉丝数
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲


// ▼▼▼ 请用这块【修复后】的代码，完整替换掉你旧的 switchToWeiboView 函数 ▼▼▼
/**
 * 【全新】切换微博主界面中的不同页面视图
 * @param {string} viewId - 要切换到的视图的ID
 */
async function switchToWeiboView(viewId) {
    // 1. 隐藏所有微博页面
    document.querySelectorAll('.weibo-view').forEach(view => {
        view.style.display = 'none'; // 使用 style.display 确保隐藏
    });
    
    // 2. 显示目标页面
    const targetView = document.getElementById(viewId);
    if (targetView) {
        targetView.style.display = 'flex'; // 使用 flex 显示
    }

    // 3. 更新底部导航栏的高亮状态
    document.querySelectorAll('.weibo-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    const targetNavItem = document.querySelector(`.weibo-nav-item[data-view="${viewId}"]`);
    if (targetNavItem) {
        targetNavItem.classList.add('active');
    }

    // --- ▼▼▼【核心修复】▼▼▼ ---
    // 4. 根据你点击的页签，去加载并显示对应的微博内容
    if (viewId === 'weibo-following-view') {
        // 如果是“关注的人”页，就调用渲染关注列表的函数
        await renderFollowingWeiboFeed();
    } else if (viewId === 'weibo-my-profile-view') {
        // 如果是“我的微博”页，就调用渲染“我”的微博的函数
        await renderMyWeiboFeed();
    }
    // --- ▲▲▲【修复结束】▲▲▲ ---
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 在这里开始复制 ▼▼▼

// ▼▼▼ 用这块【功能增强版】代码，替换旧的 openQZonePublisher 函数 ▼▼▼
async function openQZonePublisher(mode) {
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = mode;
    document.getElementById('create-post-modal-title').textContent = '发布动态';

    if (mode === 'shuoshuo') {
        modal.querySelector('.post-mode-switcher').style.display = 'none';
        modal.querySelector('#image-mode-content').style.display = 'none';
        modal.querySelector('#text-image-mode-content').style.display = 'none';
        modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
    } else {
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        modal.querySelector('#image-mode-content').classList.add('active');
        modal.querySelector('#text-image-mode-content').classList.remove('active');
        modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';
    }

    document.getElementById('post-comments-toggle-group').style.display = 'block';
    
    // --- ▼▼▼ 以下是本次新增的核心代码 ▼▼▼ ---
    const visibilityGroup = document.getElementById('post-visibility-group');
    const groupsContainer = document.getElementById('post-visibility-groups');
    const visibilityRadios = document.querySelectorAll('input[name="visibility"]');

    visibilityGroup.style.display = 'block';
    groupsContainer.innerHTML = ''; // 清空旧的分组列表
    
    // 从数据库读取你的好友分组
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="${group.id}"> ${group.name}`;
            groupsContainer.appendChild(label);
        });
    } else {
        groupsContainer.innerHTML = '<p style="color: #8a8a8a; font-size: 13px;">还没有创建任何好友分组哦。</p>';
    }

    // 默认选中“所有人可见”并隐藏分组选择
    visibilityRadios[0].checked = true;
    groupsContainer.style.display = 'none';

    // 监听单选按钮的变化
    visibilityRadios.forEach(radio => {
        radio.onchange = function() {
            groupsContainer.style.display = this.value === 'groups' ? 'block' : 'none';
        };
    });
    // --- ▲▲▲ 新增代码结束 ▲▲▲ ---

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【最终修复版】代码，完整替换掉你旧的 generateWeiboComments 函数 ▼▼▼
/**
 * 【评论优化版 V3 - 禁止回复用户】AI生成微博评论的核心函数
 * @param {number} postId - 需要生成评论的微博ID
 */
async function generateWeiboComments(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) {
        alert("错误：找不到这条微博！");
        return;
    }

    await showCustomAlert("请稍候...", "正在召唤高质量网友...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    // ★★★ 核心修复1：在这里获取用户的微博昵称 ★★★
    const userNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

    let authorPersona = "一个普通用户。";
    let authorProfession = "未设定"; 
    const authorName = post.authorId === 'user' ? userNickname : post.authorNickname;
    
    if (post.authorId === 'user') {
        authorPersona = state.qzoneSettings.weiboUserPersona || '一个普通的微博用户。';
        authorProfession = state.qzoneSettings.weiboUserProfession || '未设定';
    } else {
        const authorChat = state.chats[post.authorId];
        if (authorChat) {
            authorPersona = authorChat.settings.aiPersona || '无';
            authorProfession = authorChat.settings.weiboProfession || '未设定';
        }
    }
    const truncatedPersona = authorPersona.substring(0, 400);
    const postContent = (post.content || "").substring(0, 200);
    const existingComments = (post.comments || []).slice(-5).map(c => `${c.authorNickname}: ${c.commentText}`).join('\n');

    let imageContext = '';
    if (post.imageUrl && post.imageDescription) {
        imageContext = `
- **图片内容**: 这条微博配有一张图片，描述为：“${post.imageDescription}”`;
    } else if (post.postType === 'text_image' && post.hiddenContent) {
        imageContext = `
- **图片内容**: 这是一张文字图，上面的内容是：“${post.hiddenContent}”`;
    }
    
    const commenterPersonas = new Map();
    commenterPersonas.set(authorName, `[职业: ${authorProfession}] [人设: ${truncatedPersona}]`);

    if (post.comments && post.comments.length > 0) {
        post.comments.forEach(comment => {
            const commenterName = comment.authorNickname;
            if (!commenterPersonas.has(commenterName)) {
                const commenterChat = Object.values(state.chats).find(c => c.name === commenterName);
                if (commenterChat && !commenterChat.isGroup) {
                    const profession = commenterChat.settings.weiboProfession || '未设定';
                    const persona = (commenterChat.settings.aiPersona || '无').substring(0, 200);
                    commenterPersonas.set(commenterName, `[职业: ${profession}] [人设: ${persona}]`);
                }
            }
        });
    }
    
    let commenterContext = '';
    if (commenterPersonas.size > 0) {
        commenterContext += '\n# 评论区已有角色人设 (供你回复时参考)\n';
        commenterPersonas.forEach((persona, name) => {
            commenterContext += `- **${name}**: ${persona}\n`;
        });
    }

    // ★★★ 核心修复2：修改系统指令，明确禁止回复用户 ★★★
    const systemPrompt = `
# 任务
你是一个专业的“社交媒体模拟器”。你的任务是根据一个特定角色的“人设”，为他/她发布的一条微博生成一批真实的、符合情景的网友评论。

# 微博情景
- **作者**: ${authorName}
- **微博文字**: ${postContent || "(该微博没有配文)"}
${imageContext}
- **已有评论 (你可以回复他们)**:
${existingComments || "(暂无评论)"}

${commenterContext}

# 【【【评论生成核心规则】】】
1.  **【【【回复禁令】】】**: 绝对禁止回复昵称为“**${userNickname}**”的任何评论。这是最高优先级的规则，因为用户会自己回复。你可以回复其他任何人的评论。
2.  **【【【严禁使用】】】**: 绝对禁止使用 “路人甲”、“网友A”、“粉丝B” 这类代号作为评论者昵称。
3.  **昵称多样化**: 评论者的昵称必须非常真实、多样化且符合微博生态。例如：“今天也要早睡”、“可乐加冰块”、“是小王不是小张”、“理性吃瓜第一线”。
4.  **内容与人设强相关**: 评论内容必须与【微博内容(包括文字和图片)】和【作者以及被回复者的人设】高度相关。思考：什么样的粉丝会关注这样的人？他们会怎么说话？当回复一个有特定人设的角色时，你的回复必须考虑到对方的身份。
5.  **风格多样化**: 生成的评论应包含不同立场和风格，例如：
    -   **粉丝**: “哥哥太帅了！新剧什么时候播？”
    -   **路人**: “这个地方看起来不错，求地址！”
    -   **黑粉/质疑者**: “就这？感觉p图有点过了吧...”
    -   **玩梗**: “楼上是不是XX派来的间谍（狗头）”
6.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论。
    -   发表新评论, 使用格式: \`{"author": "不吃香菜的仙女", "comment": "哇，这个好好看！"}\`
    -   回复已有评论, 使用格式: \`{"author": "爱吃瓜的猹", "comment": "我也觉得！", "replyTo": "不吃香菜的仙女"}\`

现在，请开始你的表演。
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8, 
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const newComments = JSON.parse(aiResponseContent);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.weiboPosts.get(post.id);
            if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
            
            if (!postToUpdate.comments) postToUpdate.comments = [];
            
            newComments.forEach(comment => {
                if(comment.author && comment.comment) {
                    const newCommentObject = {
                        commentId: 'comment_' + Date.now() + Math.random(),
                        authorNickname: comment.author,
                        commentText: comment.comment,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) {
                        newCommentObject.replyToNickname = comment.replyTo;
                    }
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            postToUpdate.baseLikesCount = (postToUpdate.baseLikesCount || 0) + Math.floor(Math.random() * newComments.length * 3 + 5);

            await db.weiboPosts.put(postToUpdate);
            
            await renderMyWeiboFeed();
            await renderFollowingWeiboFeed();
            
            alert(`成功生成了 ${newComments.length} 条新评论！`);
        } else {
             alert("AI没有生成有效的评论。");
        }

    } catch (error) {
        console.error("生成微博评论失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 把这个新函数粘贴到 renderWeiboProfile 函数的上方 ▼▼▼
/**
 * 【全新】删除一条微博评论
 * @param {number} postId - 评论所在的微博ID
 * @param {string} commentId - 要删除的评论的ID
 */
async function deleteWeiboComment(postId, commentId) {
    const post = await db.weiboPosts.get(postId);
    if (!post || !post.comments) return;

    const commentIndex = post.comments.findIndex(c => c.commentId === commentId);
    if (commentIndex === -1) return;
    
    const commentText = post.comments[commentIndex].commentText;

    const confirmed = await showCustomConfirm(
        '删除评论', 
        `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        post.comments.splice(commentIndex, 1);
        await db.weiboPosts.put(post);
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        alert("评论已删除。");
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的【正上方】，粘贴下面这一整块新代码 ▼▼▼
/**
 * 【全新】一键清空所有单人聊天背景
 */
async function clearAllSingleChatBackgrounds() {
    // 弹出确认框，防止误操作
    const confirmed = await showCustomConfirm(
        '确认操作', 
        '此操作将移除所有角色单独设置的聊天背景，统一使用全局背景。确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        let updatedCount = 0;
        const chatsToUpdate = [];

        // 遍历所有聊天
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            // 如果这个聊天设置了单人背景
            if (chat.settings && chat.settings.background) {
                chat.settings.background = ''; // 清空它
                chatsToUpdate.push(chat);
                updatedCount++;
            }
        }

        // 如果有需要更新的聊天，就批量写入数据库
        if (chatsToUpdate.length > 0) {
            await db.chats.bulkPut(chatsToUpdate);
        }
        
        await showCustomAlert('操作成功', `已成功清空 ${updatedCount} 个角色的单人聊天背景！`);
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲
/* ▼▼▼ 【V2修正版】主屏幕美化预设核心功能函数 ▼▼▼ */

let activeHomePresetId = null; // 用于追踪当前选中的预设ID

/**
 * 启用或禁用预设管理按钮
 */
function toggleHomePresetButtons(isEnabled) {
    document.getElementById('apply-home-preset-btn').disabled = !isEnabled;
    document.getElementById('update-home-preset-btn').disabled = !isEnabled; // <-- 新增这一行
    document.getElementById('rename-home-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-home-preset-btn').disabled = !isEnabled;
    document.getElementById('export-home-preset-btn').disabled = !isEnabled;
}


/**
 * 加载预设到下拉框
 */
async function loadHomeScreenPresetsToDropdown() {
    const selector = document.getElementById('home-preset-selector');
    selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
    const presets = await db.homeScreenPresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    activeHomePresetId = null; // 重置选择
    toggleHomePresetButtons(false); // 默认禁用按钮
}

/**
 * 【新】当用户从下拉框选择一个预设时
 */
function handleHomePresetSelection() {
    const selector = document.getElementById('home-preset-selector');
    activeHomePresetId = selector.value ? parseInt(selector.value) : null;
    // 只有当用户确实选择了一个预设时，才启用相关按钮
    toggleHomePresetButtons(!!activeHomePresetId);
}

// ▼▼▼ 请用这整块【修复版】代码，完整替换你旧的 applySelectedHomeScreenPreset 函数 ▼▼▼
async function applySelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("请先从下拉框中选择一个要应用的预设。");
        return;
    }
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    if (preset && preset.data) {
        // 将预设数据加载到全局状态
        state.globalSettings.widgetData = preset.data;

        if (preset.data.wallpaper) {
            state.globalSettings.wallpaper = preset.data.wallpaper;
        }
        if (preset.data.appIcons) {
            state.globalSettings.appIcons = { ...preset.data.appIcons };
        }

        // 检查预设中是否有appLabels数据，如果有，就加载它
        if (preset.data.appLabels) {
            state.globalSettings.appLabels = { ...preset.data.appLabels };
        } else {
            // 如果这个旧的预设里没有保存App名字，就清空当前的自定义名字，以恢复默认
            state.globalSettings.appLabels = {};
        }
        // ★★★★★ 修复结束 ★★★★★

        // 保存所有更新到数据库
        await db.globalSettings.put(state.globalSettings);
        
        // 依次应用所有设置 (现在 applyAppLabels() 就能获取到正确的名称了)
        applyGlobalWallpaper();
        applyAppIcons();
        applyAppLabels(); 
        applyWidgetData(); 

        alert(`已成功应用预设: "${preset.name}"！`);
        showScreen('home-screen');
    }
}


/**
 * 【全新】渲染主屏幕个人资料卡的头像框
 */
function renderHomeScreenProfileFrame() {
    // 1. 获取保存的头像框URL
    const frameUrl = state.globalSettings.homeAvatarFrame || '';
    // 2. 找到头像框的img元素
    const frameImg = document.getElementById('profile-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就显示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL为空（即选择了“无”），就隐藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
}


/**
 * 【V2 修复版】保存当前的主屏幕设置为一个新的预设
 */
async function saveCurrentHomeScreenAsPreset() {
   saveAppLabels(); 
    const presetName = await showCustomPrompt("保存预设", "请为这个主屏幕美化方案起个名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能为空！");
        return;
    }

    // 核心：构建一个包含所有主屏幕元素的完整数据对象
    const presetData = {
        // --- 个人资料卡片 ---
        'profile-banner-img': document.getElementById('profile-banner-img').src,
        'profile-avatar-img': document.getElementById('profile-avatar-img').src,
        'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, // ★★★ 新增：保存头像框 ★★★
        'profile-username': document.getElementById('profile-username').textContent,
        'profile-sub-username': document.getElementById('profile-sub-username').textContent,
        'profile-bio': document.getElementById('profile-bio').textContent,
        'profile-location': document.getElementById('profile-location').innerHTML,

        // --- 第一页小组件 ---
        'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
        'widget-image-1': document.getElementById('widget-image-1').src,
        'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
        'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
        'widget-image-2': document.getElementById('widget-image-2').src,
        'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
        
        // --- 第二页小组件 ---
        'widget-image-3': document.getElementById('widget-image-3').src,
        'second-page-bubble': document.getElementById('second-page-bubble').textContent,
        'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
        'circular-bubble': document.getElementById('circular-bubble').textContent,
        'widget-image-4': document.getElementById('widget-image-4').src,
        'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
        'bubble-top-left': document.getElementById('bubble-top-left').textContent,
        'bubble-top-right': document.getElementById('bubble-top-right').textContent,
        'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
        'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
        'new-widget-avatar': document.getElementById('new-widget-avatar').src,
        'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
        'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
        'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
        'widget-month-display': document.getElementById('widget-month-display').textContent,
        
        // --- App图标和壁纸 ---
        'appIcons': { ...state.globalSettings.appIcons },
        'appLabels': { ...state.globalSettings.appLabels },
        'wallpaper': state.globalSettings.wallpaper
    };

    // 保存到数据库
    await db.homeScreenPresets.add({ name: presetName.trim(), data: presetData });
    await loadHomeScreenPresetsToDropdown(); // 刷新下拉列表
    alert(`预设 "${presetName.trim()}" 已保存！`);
}

async function updateSelectedHomeScreenPreset() {
  saveAppLabels(); 
    if (!activeHomePresetId) {
        alert("请先选择一个要更新的预设。");
        return;
    }

    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "确认更新",
        `确定要用当前的主屏幕布局覆盖预设 "${currentPreset.name}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 构建与保存时完全相同的完整数据对象
        const presetData = {
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'homeAvatarFrame': document.getElementById('profile-avatar-frame').src,
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML,
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src,
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'appLabels': { ...state.globalSettings.appLabels }, 
            'wallpaper': state.globalSettings.wallpaper
        };

        await db.homeScreenPresets.update(activeHomePresetId, { data: presetData });
        await showCustomAlert('成功', `预设 "${currentPreset.name}" 已更新！`);
    }
}

/**
 * 重命名选中的预设
 */
async function renameSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.homeScreenPresets.update(activeHomePresetId, { name: newName.trim() });
        await loadHomeScreenPresetsToDropdown();
        document.getElementById('home-preset-selector').value = activeHomePresetId;
        alert("重命名成功！");
    }
}

/**
 * 删除选中的预设
 */
async function deleteSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.homeScreenPresets.delete(activeHomePresetId);
        await loadHomeScreenPresetsToDropdown(); // 这会自动重置选择并禁用按钮
        alert("预设已删除。");
    }
}

/**
 * 【全新】导出选中的预设
 */
async function exportHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${preset.name}-HomeScreen.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 【全新】导入预设文件
 */
function importHomeScreenPreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 简单验证一下文件内容是不是我们需要的格式
            if (data.name && data.data) {
                await db.homeScreenPresets.add({ name: `${data.name} (导入)`, data: data.data });
                await loadHomeScreenPresetsToDropdown();
                alert(`预设 "${data.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。${error.message}`);
        }
    };
    reader.readAsText(file);
}
/* ▲▲▲ 新功能函数粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */

let currentWeiboActionTarget = {}; // 用于存储被操作的目标信息

// ▼▼▼ 用这块【全新逻辑】的代码，完整替换你旧的 openWeiboActionModal 函数 ▼▼▼

/**
 * 【V2 - AI自主版】打开微博操作模态框
 * @param {object} targetInfo - 包含被操作角色信息的对象
 */
function openWeiboActionModal(targetInfo) {
    currentWeiboActionTarget = targetInfo; // 保存目标信息
    const modal = document.getElementById('weibo-action-modal');
    
    // 核心修改：标题直接显示为谁行动，不再有“操作者”
    document.getElementById('weibo-action-modal-title').textContent = `为 "${targetInfo.name}" 触发行动`;

    // 核心修改：彻底移除并隐藏“选择操作者”的下拉框
    const actorSelectGroup = document.getElementById('weibo-action-actor-select').parentElement;
    if (actorSelectGroup) {
        actorSelectGroup.style.display = 'none';
    }
    
    // 清空上次的输入并重置选项
    document.getElementById('weibo-action-prompt-input').value = '';
    document.querySelector('input[name="weibo_action_type"][value="post"]').checked = true;

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【AI核心 V2.2 - 评论用户微博版 + 500错误最终修复】执行AI操作（发微博/评论）
 */
async function handleWeiboAiAction() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    document.getElementById('weibo-action-modal').classList.remove('visible');
    document.getElementById('weibo-following-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", "正在请求AI生成内容，请耐心等待...");

    const actionType = document.querySelector('input[name="weibo_action_type"]:checked').value;
    const userInputPrompt = document.getElementById('weibo-action-prompt-input').value.trim();

    let target = { 
        id: currentWeiboActionTarget.id,
        name: currentWeiboActionTarget.name, 
        persona: '一个普通的微博用户。',
        profession: '',
        instruction: ''
    };

    if (currentWeiboActionTarget.isNpc) {
        const owner = state.chats[currentWeiboActionTarget.ownerId];
        const npc = owner.npcLibrary.find(n => n.id === currentWeiboActionTarget.id);
        if (npc) {
            target.persona = npc.persona;
            target.profession = owner.settings.weiboProfession || '';
            target.instruction = owner.settings.weiboInstruction || '';
        }
    } else {
        const char = state.chats[currentWeiboActionTarget.id];
        if (char) {
            target.persona = char.settings.aiPersona;
            target.profession = char.settings.weiboProfession || '';
            target.instruction = char.settings.weiboInstruction || '';
        }
    }
    
    let systemPrompt = '';
    let messagesForApi = [];

    try {
        if (actionType === 'post') {
            systemPrompt = `
# 任务: 角色扮演与微博创作
你现在【就是】角色“${target.name}”。
你的任务是根据你的身份信息，创作一条全新的微博。
# 你的身份信息
- **你的名字**: ${target.name}
- **你的职业**: ${target.profession || '未设定'}
- **你的人设**: ${target.persona}
- **你的微博指令 (必须遵守)**: ${target.instruction || '无'}
- **用户给你的提示 (可选参考)**: ${userInputPrompt || '无'}
# 【【【评论生成核心规则】】】
1.  **【【【严禁使用】】】**: 绝对禁止使用 “路人甲”、“网友A”、“粉丝B” 这类代号作为评论者昵称。
2.  **昵称多样化**: 评论者的昵称必须非常真实、多样化且符合微博生态。例如：“今天也要早睡”、“可乐加冰块”、“是小王不是小张”、“理性吃瓜第一线”。
3.  **内容与人设强相关**: 评论内容必须与【你即将创作的微博内容】和【你自己的人设】高度相关。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
   \`{"content": "微博正文内容...", "baseLikesCount": 随机生成的点赞数, "baseCommentsCount": 随机生成的评论数, "comments": "今天也要早睡: 评论1...\\n可乐加冰块: 评论2..."}\`
   - 点赞和评论数要符合你的身份地位。
   - "comments"字段是一个【字符串】，里面包含5-10条真实感的路人评论，每条评论用换行符'\\n'分隔。
`;
            messagesForApi.push({ role: 'user', content: systemPrompt });

        } else {
            let targetPost;
            let taskDescription;
            let extraContext = ''; 

            if (actionType === 'comment_plaza') {
                targetPost = await db.weiboPosts.orderBy('timestamp').last();
                if (!targetPost) throw new Error("广场上还没有任何微博可以评论！");
                taskDescription = `你的任务是根据你的身份信息，去评论下面这条最新的【广场微博】。`;
            } else if (actionType === 'comment_user') {
                targetPost = await db.weiboPosts.where('authorId').equals('user').reverse().first();
                if (!targetPost) throw new Error("用户还没有发布任何微博，无法评论！");
                taskDescription = `你的任务是根据你的身份信息，去评论下面这条由【用户】发布的最新微博。`;
            }

            let postAuthorName = targetPost.authorNickname;
            if (postAuthorName === '{{user}}') {
                postAuthorName = '我';
            }
            
            systemPrompt = `
# 任务: 角色扮演与微博评论
你现在【就是】角色“${target.name}”。
${taskDescription}
# 你的身份信息
- **你的名字**: ${target.name}
- **你的职业**: ${target.profession || '未设定'}
- **你的人设**: ${target.persona}
- **你的微博指令 (必须遵守)**: ${target.instruction || '无'}
- **用户给你的提示 (可选参考)**: ${userInputPrompt || '无'}
# 被评论的微博
- 作者: ${postAuthorName}
- 内容: ${targetPost.content}
${extraContext}
# 核心规则
1. **深度扮演**: 你的评论【必须】完全符合你的职业、人设和微博指令。
2. **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
   \`{"commentText": "你的评论内容..."}\`
`;
            messagesForApi.push({ role: 'user', content: systemPrompt });
        }

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);


        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: messagesForApi,
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                // ▼▼▼ 核心修复：我们把下面这行导致错误的 `response_format` 彻底删掉了！▼▼▼
            })
        });

        if (!response.ok) {
            let errorBody = '';
            try {
                errorBody = await response.text();
            } catch (e) {
                errorBody = '无法读取错误响应体。';
            }
            throw new Error(`API请求失败: ${response.status} - ${errorBody}`);
        }

        const data = await response.json();
        // ▼▼▼ 在这里添加下面的安全检查代码 ▼▼▼
if (data.error) {
    // 如果API返回的数据中直接包含了 error 对象，说明请求出错了
    // 我们主动抛出一个包含详细错误信息的Error
    throw new Error(`API返回错误: ${data.error.message || JSON.stringify(data.error)}`);
}
// ▲▲▲ 添加结束 ▲▲▲
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const result = JSON.parse(aiResponseContent);

        if (actionType === 'post') {
            const newPost = {
                authorId: target.id,
                authorType: currentWeiboActionTarget.isNpc ? 'npc' : 'char',
                authorNickname: target.name,
                authorAvatar: currentWeiboActionTarget.isNpc 
                    ? (state.chats[currentWeiboActionTarget.ownerId].npcLibrary.find(n => n.id === target.id).avatar || defaultGroupMemberAvatar)
                    : (state.chats[target.id].settings.aiAvatar || defaultAvatar),
                content: result.content,
                timestamp: Date.now(),
                likes: [], comments: [],
                baseLikesCount: result.baseLikesCount || 0,
                baseCommentsCount: result.baseCommentsCount || 0
            };
            if(result.comments) {
                newPost.comments = result.comments.split('\n').map(c => {
                    const parts = c.split(/[:：]/);
                    const commenter = parts.shift() || '路人';
                    const commentText = parts.join(':').trim();
                    return { commentId: 'comment_' + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
                }).filter(c => c.commentText);
            }
            await db.weiboPosts.add(newPost);
        } else {
            let postToUpdate;
            if (actionType === 'comment_plaza') {
                postToUpdate = await db.weiboPosts.orderBy('timestamp').last();
            } else {
                postToUpdate = await db.weiboPosts.where('authorId').equals('user').reverse().first();
            }

            if (postToUpdate) {
                if (!postToUpdate.comments) postToUpdate.comments = [];
                postToUpdate.comments.push({
                    commentId: 'comment_' + Date.now(),
                    authorId: target.id,
                    authorNickname: target.name,
                    commentText: result.commentText,
                    timestamp: Date.now()
                });
                await db.weiboPosts.put(postToUpdate);
            }
        }
        
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        await showCustomAlert("操作成功", `“${target.name}”已成功执行操作！`);

    } catch (error) {
        console.error("微博AI操作失败:", error);
        await showCustomAlert('操作失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▼▼▼ 第2步 第4处修改（新增JS功能函数） ▼▼▼

/**
 * 【全新】角色表情包管理核心功能
 */
async function openCharStickerManager() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
        // 【修改】根据聊天类型显示不同的标题
    if (chat.isGroup) {
        document.getElementById('sticker-manager-title').textContent = `“${chat.name}”的群表情`;
    } else {
        document.getElementById('sticker-manager-title').textContent = `“${chat.name}”的表情包`;
    }


    // 默认显示专属表情
    document.getElementById('sticker-tab-exclusive').click();
    
    await renderCharStickers('exclusive');
    await renderCharStickers('common');
    
    showScreen('char-sticker-manager-screen');
}

// ▼▼▼ 用这块【增强版】代码，完整替换旧的 renderCharStickers 函数 ▼▼▼
async function renderCharStickers(type) {
    const isExclusive = type === 'exclusive';
    const gridId = isExclusive ? 'exclusive-sticker-grid' : 'common-sticker-grid';
    const grid = document.getElementById(gridId);
    grid.innerHTML = '';

    let stickers = [];
    if (isExclusive) {
        const chat = state.chats[state.activeChatId];
        stickers = chat.settings.stickerLibrary || [];
    } else {
        state.charStickers = await db.charStickers.toArray();
        stickers = state.charStickers || [];
    }

    if (stickers.length === 0) {
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">这里还是空的哦~</p>`;
        return;
    }

    // 为了正确删除，我们需要原始索引
    const stickersWithIndex = stickers.map((sticker, index) => ({ ...sticker, originalIndex: index }));

    stickersWithIndex.forEach((sticker) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.style.backgroundImage = `url(${sticker.url})`;
        item.title = sticker.name;
        
        // 我们使用 URL 作为唯一标识符，因为它在两种库中都是唯一的
        const uniqueId = sticker.url;

        if (isCharStickerSelectionMode) {
            // 【选择模式】下的逻辑
            item.classList.add('in-selection-mode');
            if (selectedCharStickers.has(uniqueId)) {
                item.classList.add('selected');
            }
            
            item.addEventListener('click', () => {
                item.classList.toggle('selected');
                if (selectedCharStickers.has(uniqueId)) {
                    selectedCharStickers.delete(uniqueId);
                } else {
                    selectedCharStickers.add(uniqueId);
                }
                const deleteBtn = document.getElementById('delete-selected-char-stickers-btn');
                deleteBtn.textContent = `删除已选 (${selectedCharStickers.size})`;
                deleteBtn.disabled = selectedCharStickers.size === 0;
            });

        } else {
            // 【正常模式】下的逻辑（只有删除按钮）
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.display = 'block'; // 默认就显示
            deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    if (isExclusive) {
                        const chat = state.chats[state.activeChatId];
                        chat.settings.stickerLibrary.splice(sticker.originalIndex, 1);
                        await db.chats.put(chat);
                    } else {
                        await db.charStickers.delete(sticker.id);
                    }
                    await renderCharStickers(type); // 刷新
                }
            };
            item.appendChild(deleteBtn);
        }
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 renderCharStickers 函数后，粘贴这个新函数 ▼▼▼
/**
 * 处理批量删除选中的角色表情
 */
async function handleBulkDeleteCharStickers() {
    if (selectedCharStickers.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除选中的 ${selectedCharStickers.size} 个表情吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const activeTab = document.querySelector('#char-sticker-manager-screen .frame-tab.active');
        const type = activeTab.id === 'sticker-tab-exclusive' ? 'exclusive' : 'common';
        
        if (type === 'exclusive') {
            const chat = state.chats[state.activeChatId];
            chat.settings.stickerLibrary = chat.settings.stickerLibrary.filter(
                s => !selectedCharStickers.has(s.url)
            );
            await db.chats.put(chat);
        } else { // common
            const stickersToDelete = await db.charStickers.where('url').anyOf(Array.from(selectedCharStickers)).toArray();
            const idsToDelete = stickersToDelete.map(s => s.id);
            if (idsToDelete.length > 0) {
                await db.charStickers.bulkDelete(idsToDelete);
            }
        }
        
        // 退出编辑模式
        toggleCharStickerSelectionMode();
        
        alert('选中的表情已删除。');
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲


/**
 * 【已修复+优化】批量添加表情包到指定库
 */
async function bulkAddCharStickers(type) {
    const textInput = await showCustomPrompt(
        `批量添加${type === 'exclusive' ? '专属' : '通用'}表情`,
        "一行一个，格式：\n猫猫喝水 https://..../cat.gif",
        "", 'textarea'
    );
    if (!textInput || !textInput.trim()) return;

    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return;

        // 【优化】使用更智能、更健壮的分割逻辑
        let name = '';
        let url = '';
        let splitIndex = -1;
        const httpIndex = line.indexOf('http');
        const dataIndex = line.indexOf('data:image');
        if (httpIndex > -1) { splitIndex = httpIndex; }
        else if (dataIndex > -1) { splitIndex = dataIndex; }

        if (splitIndex > 0) {
            name = line.substring(0, splitIndex).trim();
            url = line.substring(splitIndex).trim();
            if (name.endsWith(':') || name.endsWith('：')) {
                name = name.slice(0, -1).trim();
            }
        }

        if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
            const stickerData = { url, name };
            if (type !== 'exclusive') {
                stickerData.id = 'char_sticker_' + (Date.now() + index);
            }
            newStickers.push(stickerData);
            successCount++;
        }
    });

    if (newStickers.length > 0) {
        if (type === 'exclusive') {
            const chat = state.chats[state.activeChatId];
            chat.settings.stickerLibrary.push(...newStickers);
            await db.chats.put(chat);
        } else {
            await db.charStickers.bulkAdd(newStickers);
        }
        await renderCharStickers(type); // 【核心修复】在数据库操作后，统一重新渲染
    }
    await showCustomAlert("导入报告", `成功导入：${successCount} 个表情。`);
}

/**
 * 【已修复】从本地上传表情到指定库
 */
async function uploadCharStickersLocal(type) {
    const input = document.getElementById('char-sticker-upload-input'); // 应该长这样
    input.onchange = async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const stickersToAdd = []; // 先收集所有要添加的表情

        for (const file of files) {
            const name = await showCustomPrompt("为表情命名", "请输入表情名称", file.name.replace(/\.[^/.]+$/, ""));
            if (name && name.trim()) {
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                
                const stickerData = { name: name.trim(), url: base64Url };
                if (type !== 'exclusive') {
                    stickerData.id = 'char_sticker_' + Date.now() + Math.random();
                }
                stickersToAdd.push(stickerData);
            }
        }

        if (stickersToAdd.length > 0) {
            if (type === 'exclusive') {
                const chat = state.chats[state.activeChatId];
                chat.settings.stickerLibrary.push(...stickersToAdd);
                await db.chats.put(chat);
            } else {
                await db.charStickers.bulkAdd(stickersToAdd);
            }
            await renderCharStickers(type); // 【核心修复】在数据库操作后，统一重新渲染
            alert(`已成功上传 ${stickersToAdd.length} 个表情！`);
        }
        
        event.target.value = null;
    };
    input.click();
}

// ▲▲▲ 修复代码块结束 ▲▲▲
// ▼▼▼ 第1步：在这里粘贴下面这个【新函数】 ▼▼▼

/**
 * 【新增】显示指定的角色表情包标签页
 * 这是之前缺失的核心功能，用于控制显示哪个标签页（专属或通用）。
 * @param {'exclusive' | 'common'} type - 要显示的标签页类型
 */
function showCharStickerTab(type) {
    // 1. 切换标签按钮的 'active' 状态
    document.querySelectorAll('.char-sticker-tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
    });

    // 2. 切换内容区域的显示
    document.querySelectorAll('.sticker-tab-content').forEach(content => {
        content.classList.toggle('active', content.id === `${type}-sticker-content`);
    });

    // 3. 渲染对应标签页的表情
    // (这一步确保每次切换标签时，表情都会刷新)
    renderCharStickers(type);
}

// ▲▲▲ JavaScript新函数粘贴结束 ▲▲▲

// 这里应该是你已有的其他函数，比如 renderCharStickers, bulkAddCharStickers 等...

// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的正上方 ▼▼▼

/**
 * 塔罗牌占卜功能核心
 */
let activeTarotReading = null; // 用于暂存当前占卜的结果

// 牌阵信息
const TAROT_SPREADS = {
    single: { name: '单张牌 - 快速指引', count: 1, positions: ['核心指引'] },
    three_past_present_future: { name: '三张牌 - 过去/现在/未来', count: 3, positions: ['过去', '现在', '未来'] },
    three_situation_challenge_advice: { name: '三张牌 - 情境/挑战/建议', count: 3, positions: ['情境', '挑战', '建议'] },
    celtic_cross: { name: '凯尔特十字 - 深度分析', count: 10, positions: ['现状', '挑战', '根基', '过去', '目标', '未来', '自我认知', '外部影响', '希望与恐惧', '最终结果'] }
};

// 打开塔罗牌占卜主模态框
function openTarotModal() {
    document.getElementById('tarot-divination-modal').classList.add('visible');
    // 默认显示设置界面
    document.getElementById('tarot-setup-view').style.display = 'block';
    document.getElementById('tarot-result-view').style.display = 'none';
    document.getElementById('tarot-history-view').style.display = 'none';
    // 清空输入框
    document.getElementById('tarot-question-input').value = '';
}

// 执行抽牌逻辑
function handleDrawCards() {
    const question = document.getElementById('tarot-question-input').value.trim();
    const spreadType = document.getElementById('tarot-spread-select').value;
    const orientation = document.querySelector('input[name="tarot-orientation"]:checked').value;
    
    if (!question) {
        alert('请输入您的问题或关注点。');
        return;
    }

    const spreadInfo = TAROT_SPREADS[spreadType];
    const deck = [...TAROT_DECK];

    // 洗牌
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }

    // 抽牌
    const drawnCardsRaw = deck.slice(0, spreadInfo.count);
    const drawnCards = drawnCardsRaw.map((card, index) => {
        const isReversed = orientation === 'reversed' && Math.random() < 0.5;
        return {
            ...card,
            isReversed: isReversed,
            position: spreadInfo.positions[index]
        };
    });

    activeTarotReading = {
        question: question,
        spread: spreadInfo,
        cards: drawnCards,
        timestamp: Date.now()
    };
    
    displayTarotResults(activeTarotReading);
}

// ▼▼▼ 用这个【新版本】替换旧的 displayTarotResults 函数 ▼▼▼
// 显示占卜结果 (纯文字版)
function displayTarotResults(reading) {
    const displayEl = document.getElementById('tarot-result-display');
    displayEl.innerHTML = ''; // 清空

    // 显示问题
    const questionEl = document.createElement('div');
    questionEl.className = 'tarot-result-question';
    questionEl.textContent = `您的问题是：“${reading.question}”`;
    displayEl.appendChild(questionEl);
    
    const container = document.createElement('div');
    container.className = 'tarot-spread-container';

    reading.cards.forEach(card => {
        const cardWrapper = document.createElement('div');
        cardWrapper.className = 'tarot-card-wrapper';
        
        cardWrapper.innerHTML = `
            <div class="tarot-card-position">[${card.position}]</div>
            <div class="tarot-card-name">${card.name} ${card.isReversed ? '(逆位)' : '(正位)'}</div>
        `;
        container.appendChild(cardWrapper);
    });
    
    displayEl.appendChild(container);

    // 切换视图
    document.getElementById('tarot-setup-view').style.display = 'none';
    document.getElementById('tarot-result-view').style.display = 'flex';
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这整块【AI智能解读最终版】代码，完整替换旧的 sendTarotReadingToChat 函数 ▼▼▼
async function sendTarotReadingToChat() {
    if (!activeTarotReading || !state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能触发AI解读哦！');
        return;
    }

    // 1. 关闭弹窗，并显示“正在解读”的提示
    document.getElementById('tarot-divination-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", "塔罗师正在为你连接星辰，解读牌面...");

    try {
        const reading = activeTarotReading;
        
        // 2. 【全新优化】给“塔罗师AI”一个更专业、更结构化的指令 (Prompt)
        const cardDetails = reading.cards.map(card => {
            const orientation = card.isReversed ? '逆位' : '正位';
            const meaning = card.isReversed ? card.reversed : card.upright;
            return `- ${card.position}: ${card.name} (${orientation})，象征: ${meaning}`;
        }).join('\n');

        const tarotMasterPrompt = `
# 角色
你是一位世界级的塔罗牌解读大师，以深刻的洞察力、清晰的表达和富有同情心的指引而闻名。

# 核心任务
为用户提供一次全面、结构化且易于理解的塔罗牌解读。你的解读必须严格遵循下面的输出结构。

# 输出结构 (必须严格遵守)
你的回答必须包含以下三个部分，并使用Markdown加粗标题来分隔：

1.  **✨ 综合解读 (Overall Interpretation):**
    首先，根据所有牌面的整体感觉，给出一个高度概括的、1-2句话的核心结论或氛围描述。

2.  **🃏 牌面详解 (Card Details):**
    然后，逐一分析每一张牌。对于每一张牌，你必须：
    -   使用格式 \`**[牌位名称] - [牌名] ([正位/逆位])**\` 作为小标题。
    -   详细解释这张牌在这个特定牌位上，是如何回应用户的问题的。
    -   将牌的象征意义与用户的具体情境（问题）紧密结合起来进行分析。

3.  **💡 核心建议 (Key Advice):**
    最后，综合所有牌的信息，为用户提供一个明确、具体、可操作的行动建议或心态指引。

# 指导原则
- **故事性**: 将所有牌的含义编织成一个连贯的叙事，而不是简单地罗列关键词。
- **相关性**: 始终将解读直接与用户提出的具体问题联系起来。
- **清晰易懂**: 避免使用过于神秘或专业的术语。用平实的语言解释复杂的概念。
- **深度而非罗列**: 绝对不要只是重复我提供给你的“象征”关键词。你必须在这些关键词的基础上进行综合、提炼和深化，给出你作为大师的独特见解。

# 占卜信息
- **用户的问题**: "${reading.question}"
- **使用的牌阵**: ${reading.spread.name}
- **抽到的牌及基础含义**:
${cardDetails}

# 最终指令
你的最终输出【只能是】完整的、格式化后的解读文本。不要添加任何“好的，这是你的解读：”之类的对话性开场白。
`;

        // 3. 发起API调用，让AI扮演塔罗师
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: tarotMasterPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, tarotMasterPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, })
            });

        if (!response.ok) {
            throw new Error(`API请求失败: ${await response.text()}`);
        }
        
        const data = await response.json();
        const interpretation = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();

        // 4. 创建对用户可见的“系统解读”消息
        const systemMessageVisible = {
            role: 'system',
            type: 'pat_message', // 复用居中灰色气泡样式
            content: `🔮 **塔罗牌解读** 🔮\n\n**您的问题**：“${reading.question}”\n\n${interpretation}`,
            timestamp: Date.now()
        };
        chat.history.push(systemMessageVisible);
        appendMessage(systemMessageVisible, chat);

        // 5. 创建给角色Char看的隐藏指令
        const hiddenInstruction = {
            role: 'system',
            content: `[系统指令：刚刚系统为用户进行了一次塔罗牌占卜，解读结果是：“${interpretation}”。现在，请你以角色的身份，和用户一起讨论这个结果。]`,
            timestamp: Date.now() + 1, // 确保时间戳在后
            isHidden: true
        };
        chat.history.push(hiddenInstruction);

        // 6. 保存所有数据
        await saveTarotReading(activeTarotReading);
        await db.chats.put(chat);
        renderChatList();
        
        // 7. 【核心修改】我们在这里删除了 triggerAiResponse()，不再自动触发Char！
        
        activeTarotReading = null;

    } catch (error) {
        console.error("塔罗牌AI解读失败:", error);
        await showCustomAlert('解读失败', `抱歉，连接塔罗师时出现了一点问题：\n\n${error.message}`);
        activeTarotReading = null;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// 保存占卜记录到数据库
async function saveTarotReading(reading) {
    // 为了节省空间，我们只保存解读文本，而不是整个牌组对象
    const interpretationText = `牌阵: ${reading.spread.name}\n` + reading.cards.map((card, index) => {
        const orientationText = card.isReversed ? '逆位' : '正位';
        const meaning = card.isReversed ? card.reversed : card.upright;
        return `[${card.position}]: ${card.name} (${orientationText}) - ${meaning}`;
    }).join('\n');
    
    await db.tarotReadings.add({
        question: reading.question,
        interpretation: interpretationText,
        timestamp: reading.timestamp
    });
}

// 打开历史记录界面
async function openTarotHistory() {
    const readings = await db.tarotReadings.orderBy('timestamp').reverse().toArray();
    renderTarotHistory(readings);
    document.getElementById('tarot-setup-view').style.display = 'none';
    document.getElementById('tarot-history-view').style.display = 'flex';
}

// 渲染历史记录列表
function renderTarotHistory(readings) {
    const listEl = document.getElementById('tarot-history-list');
    listEl.innerHTML = '';
    if (readings.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有占卜历史哦</p>';
        return;
    }
    readings.forEach(reading => {
        const item = document.createElement('div');
        item.className = 'tarot-history-item';
        item.innerHTML = `
            <div class="question">${reading.question}</div>
            <div class="details">${new Date(reading.timestamp).toLocaleString()}</div>
            <button class="tarot-history-delete-btn" data-id="${reading.id}">×</button>
        `;
        listEl.appendChild(item);
    });
}

// 删除一条历史记录
async function deleteTarotReading(readingId) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条占卜历史吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.tarotReadings.delete(readingId);
        openTarotHistory(); // 重新加载历史记录
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲

// ▼▼▼ 八卦六爻占卜功能 ▼▼▼
/**
 * 八卦六爻占卜功能核心
 */
let activeBaguaReading = null; // 用于暂存当前占卜的结果

// 64卦基本信息
const BAGUA_64 = {
    1: { name: '乾为天', trigrams: ['乾', '乾'], meaning: '刚健中正，自强不息' },
    2: { name: '坤为地', trigrams: ['坤', '坤'], meaning: '柔顺载物，厚德载福' },
    3: { name: '水雷屯', trigrams: ['坎', '震'], meaning: '始生之难，万物初萌' },
    4: { name: '山水蒙', trigrams: ['艮', '坎'], meaning: '启蒙教化，循序渐进' },
    5: { name: '水天需', trigrams: ['坎', '乾'], meaning: '等待时机，养精蓄锐' },
    6: { name: '天水讼', trigrams: ['乾', '坎'], meaning: '争讼之象，宜和不宜争' },
    7: { name: '地水师', trigrams: ['坤', '坎'], meaning: '统率之道，纪律严明' },
    8: { name: '水地比', trigrams: ['坎', '坤'], meaning: '亲比辅佐，团结协作' },
    9: { name: '风天小畜', trigrams: ['巽', '乾'], meaning: '小有积蓄，循序渐进' },
    10: { name: '天泽履', trigrams: ['乾', '兑'], meaning: '如履薄冰，谨慎前行' },
    11: { name: '地天泰', trigrams: ['坤', '乾'], meaning: '天地交泰，诸事亨通' },
    12: { name: '天地否', trigrams: ['乾', '坤'], meaning: '阻塞不通，守正待时' },
    13: { name: '天火同人', trigrams: ['乾', '离'], meaning: '和同志合，众志成城' },
    14: { name: '火天大有', trigrams: ['离', '乾'], meaning: '大有收获，丰盛富足' },
    15: { name: '地山谦', trigrams: ['坤', '艮'], meaning: '谦逊退让，德配天地' },
    16: { name: '雷地豫', trigrams: ['震', '坤'], meaning: '顺应天时，喜悦和乐' },
    17: { name: '泽雷随', trigrams: ['兑', '震'], meaning: '随顺时势，因时制宜' },
    18: { name: '山风蛊', trigrams: ['艮', '巽'], meaning: '整治祸乱，拨乱反正' },
    19: { name: '地泽临', trigrams: ['坤', '兑'], meaning: '居高临下，教导关怀' },
    20: { name: '风地观', trigrams: ['巽', '坤'], meaning: '观察省思，见贤思齐' },
    21: { name: '火雷噬嗑', trigrams: ['离', '震'], meaning: '刚柔相济，决断明快' },
    22: { name: '山火贲', trigrams: ['艮', '离'], meaning: '文饰之美，内外兼修' },
    23: { name: '山地剥', trigrams: ['艮', '坤'], meaning: '剥落消退，以守为进' },
    24: { name: '地雷复', trigrams: ['坤', '震'], meaning: '复苏回归，否极泰来' },
    25: { name: '天雷无妄', trigrams: ['乾', '震'], meaning: '正道而行，顺应自然' },
    26: { name: '山天大畜', trigrams: ['艮', '乾'], meaning: '大有积蓄，厚积薄发' },
    27: { name: '山雷颐', trigrams: ['艮', '震'], meaning: '养生之道，慎言节食' },
    28: { name: '泽风大过', trigrams: ['兑', '巽'], meaning: '大有过越，栋梁之才' },
    29: { name: '坎为水', trigrams: ['坎', '坎'], meaning: '险中求进，信守正道' },
    30: { name: '离为火', trigrams: ['离', '离'], meaning: '光明磊落，依附正道' },
    31: { name: '泽山咸', trigrams: ['兑', '艮'], meaning: '感应相通，彼此吸引' },
    32: { name: '雷风恒', trigrams: ['震', '巽'], meaning: '恒久不变，持之以恒' },
    33: { name: '天山遁', trigrams: ['乾', '艮'], meaning: '退避隐遁，以退为进' },
    34: { name: '雷天大壮', trigrams: ['震', '乾'], meaning: '刚强壮盛，光明正大' },
    35: { name: '火地晋', trigrams: ['离', '坤'], meaning: '晋升发展，日出大地' },
    36: { name: '地火明夷', trigrams: ['坤', '离'], meaning: '明珠暗投，韬光养晦' },
    37: { name: '风火家人', trigrams: ['巽', '离'], meaning: '家道兴旺，和睦相处' },
    38: { name: '火泽睽', trigrams: ['离', '兑'], meaning: '违背乖离，求同存异' },
    39: { name: '水山蹇', trigrams: ['坎', '艮'], meaning: '艰难险阻，谨慎前行' },
    40: { name: '雷水解', trigrams: ['震', '坎'], meaning: '解除困难，雨过天晴' },
    41: { name: '山泽损', trigrams: ['艮', '兑'], meaning: '损己益人，惩忿窒欲' },
    42: { name: '风雷益', trigrams: ['巽', '震'], meaning: '增益积极，见善则迁' },
    43: { name: '泽天夬', trigrams: ['兑', '乾'], meaning: '刚决果断，以正除邪' },
    44: { name: '天风姤', trigrams: ['乾', '巽'], meaning: '不期而遇，防微杜渐' },
    45: { name: '泽地萃', trigrams: ['兑', '坤'], meaning: '聚集汇合，众志成城' },
    46: { name: '地风升', trigrams: ['坤', '巽'], meaning: '上升进取，循序渐进' },
    47: { name: '泽水困', trigrams: ['兑', '坎'], meaning: '困顿窘迫，坚守正道' },
    48: { name: '水风井', trigrams: ['坎', '巽'], meaning: '养人济世，源源不断' },
    49: { name: '泽火革', trigrams: ['兑', '离'], meaning: '革故鼎新，顺天应人' },
    50: { name: '火风鼎', trigrams: ['离', '巽'], meaning: '稳重图新，去旧立新' },
    51: { name: '震为雷', trigrams: ['震', '震'], meaning: '震动奋起，反省警醒' },
    52: { name: '艮为山', trigrams: ['艮', '艮'], meaning: '止于至善，沉稳镇定' },
    53: { name: '风山渐', trigrams: ['巽', '艮'], meaning: '循序渐进，水到渠成' },
    54: { name: '雷泽归妹', trigrams: ['震', '兑'], meaning: '归顺从属，以柔克刚' },
    55: { name: '雷火丰', trigrams: ['震', '离'], meaning: '丰盛美满，盛极必衰' },
    56: { name: '火山旅', trigrams: ['离', '艮'], meaning: '羁旅他乡，谦恭谨慎' },
    57: { name: '巽为风', trigrams: ['巽', '巽'], meaning: '谦逊顺从，随风而动' },
    58: { name: '兑为泽', trigrams: ['兑', '兑'], meaning: '喜悦交流，和悦相处' },
    59: { name: '风水涣', trigrams: ['巽', '坎'], meaning: '涣散消融，聚散有时' },
    60: { name: '水泽节', trigrams: ['坎', '兑'], meaning: '节制有度，不可过分' },
    61: { name: '风泽中孚', trigrams: ['巽', '兑'], meaning: '诚信至诚，内外一致' },
    62: { name: '雷山小过', trigrams: ['震', '艮'], meaning: '小有过越，大事不宜' },
    63: { name: '水火既济', trigrams: ['坎', '离'], meaning: '功德圆满，持盈保泰' },
    64: { name: '火水未济', trigrams: ['离', '坎'], meaning: '尚未完成，继续努力' }
};

// 打开八卦六爻占卜弹窗
function openBaguaModal() {
    document.getElementById('bagua-divination-modal').classList.add('visible');
    document.getElementById('bagua-setup-view').style.display = 'block';
    document.getElementById('bagua-result-view').style.display = 'none';
    document.getElementById('bagua-history-view').style.display = 'none';
    document.getElementById('bagua-question-input').value = '';
}

// 监听起卦方式的变化
document.getElementById('bagua-method-select')?.addEventListener('change', (e) => {
    const numberInputGroup = document.getElementById('bagua-number-input-group');
    if (e.target.value === 'number') {
        numberInputGroup.style.display = 'block';
    } else {
        numberInputGroup.style.display = 'none';
    }
});

// 执行起卦逻辑
function startBaguaDivination() {
    const question = document.getElementById('bagua-question-input').value.trim();
    const method = document.getElementById('bagua-method-select').value;
    
    if (!question) {
        alert('请输入您的问题或关注点。');
        return;
    }
    
    let lines = [];
    
    if (method === 'coin') {
        // 铜钱摇卦法：摇6次，每次3枚铜钱
        for (let i = 0; i < 6; i++) {
            let sum = 0;
            for (let j = 0; j < 3; j++) {
                sum += Math.random() < 0.5 ? 2 : 3; // 2为背，3为字
            }
            // 6为老阴（变爻），7为少阳，8为少阴，9为老阳（变爻）
            lines.push(sum);
        }
    } else if (method === 'time') {
        // 时间起卦法：根据当前时间
        const now = new Date();
        const year = now.getFullYear();
        const month = now.getMonth() + 1;
        const day = now.getDate();
        const hour = now.getHours();
        
        const upper = (year + month + day) % 8 || 8;
        const lower = (year + month + day + hour) % 8 || 8;
        const changing = (year + month + day + hour) % 6 || 6;
        
        lines = generateLinesFromTrigrams(upper, lower, changing);
    } else if (method === 'number') {
        // 数字起卦法
        const number = parseInt(document.getElementById('bagua-number-input').value);
        if (!number || number <= 0) {
            alert('请输入一个正整数。');
            return;
        }
        
        const upper = number % 8 || 8;
        const lower = Math.floor(number / 8) % 8 || 8;
        const changing = number % 6 || 6;
        
        lines = generateLinesFromTrigrams(upper, lower, changing);
    }
    
    // 根据六爻生成本卦和变卦
    const originalHex = getHexagramFromLines(lines);
    const changingLines = lines.map((line, index) => line === 6 || line === 9 ? index + 1 : 0).filter(l => l > 0);
    
    // 生成变卦
    const changedLines = lines.map(line => {
        if (line === 6) return 8; // 老阴变少阳
        if (line === 9) return 7; // 老阳变少阴
        return line;
    });
    const changedHex = getHexagramFromLines(changedLines);
    
    activeBaguaReading = {
        question: question,
        method: method,
        lines: lines,
        originalHexagram: originalHex,
        changedHexagram: changedHex,
        changingLines: changingLines,
        timestamp: Date.now()
    };
    
    displayBaguaResults(activeBaguaReading);
}

// 根据卦数生成六爻（辅助函数）
function generateLinesFromTrigrams(upper, lower, changing) {
    const trigramToLines = {
        1: [9, 9, 9], // 乾 ☰
        2: [6, 6, 6], // 坤 ☷
        3: [7, 6, 9], // 震 ☳
        4: [6, 9, 7], // 坎 ☵
        5: [9, 7, 6], // 艮 ☶
        6: [9, 9, 7], // 巽 ☴
        7: [6, 9, 9], // 离 ☲
        8: [7, 9, 9]  // 兑 ☱
    };
    
    const lowerLines = trigramToLines[lower] || [7, 7, 7];
    const upperLines = trigramToLines[upper] || [7, 7, 7];
    const lines = [...lowerLines, ...upperLines];
    
    // 设置动爻
    if (changing >= 1 && changing <= 6) {
        const currentLine = lines[changing - 1];
        if (currentLine === 7) lines[changing - 1] = 9; // 少阳变老阳
        else if (currentLine === 8) lines[changing - 1] = 6; // 少阴变老阴
    }
    
    return lines;
}

// 根据六爻获取卦象
function getHexagramFromLines(lines) {
    // 将六爻转换为64卦索引（简化版本）
    const binary = lines.map(line => (line === 7 || line === 9) ? 1 : 0).join('');
    const decimal = parseInt(binary, 2) + 1;
    const hexIndex = ((decimal - 1) % 64) + 1;
    return BAGUA_64[hexIndex] || BAGUA_64[1];
}

// 显示占卜结果
function displayBaguaResults(reading) {
    const displayEl = document.getElementById('bagua-result-display');
    displayEl.innerHTML = '';
    
    // 显示问题
    const questionEl = document.createElement('div');
    questionEl.className = 'bagua-result-question';
    questionEl.textContent = `您的问题是："${reading.question}"`;
    displayEl.appendChild(questionEl);
    
    const container = document.createElement('div');
    container.className = 'bagua-hexagram-container';
    
    // 本卦
    const originalBox = document.createElement('div');
    originalBox.className = 'bagua-hexagram-box';
    originalBox.innerHTML = `
        <div class="bagua-hexagram-title">本卦</div>
        <div class="bagua-hexagram-name">${reading.originalHexagram.name}</div>
        ${renderBaguaLines(reading.lines, reading.changingLines)}
        <div class="bagua-details">${reading.originalHexagram.meaning}</div>
    `;
    container.appendChild(originalBox);
    
    // 如果有动爻，显示变卦
    if (reading.changingLines.length > 0) {
        const changedBox = document.createElement('div');
        changedBox.className = 'bagua-hexagram-box';
        const changedLines = reading.lines.map(line => {
            if (line === 6) return 8;
            if (line === 9) return 7;
            return line;
        });
        changedBox.innerHTML = `
            <div class="bagua-hexagram-title">变卦</div>
            <div class="bagua-hexagram-name">${reading.changedHexagram.name}</div>
            ${renderBaguaLines(changedLines, [])}
            <div class="bagua-details">${reading.changedHexagram.meaning}</div>
            <div class="bagua-details" style="margin-top: 10px; color: #ff6b6b;">动爻：第${reading.changingLines.join('、')}爻</div>
        `;
        container.appendChild(changedBox);
    }
    
    displayEl.appendChild(container);
    
    // 切换视图
    document.getElementById('bagua-setup-view').style.display = 'none';
    document.getElementById('bagua-result-view').style.display = 'flex';
}

// 渲染卦象的六爻
function renderBaguaLines(lines, changingLines) {
    let html = '<div class="bagua-lines">';
    lines.forEach((line, index) => {
        const isYang = line === 7 || line === 9;
        const isChanging = changingLines.includes(index + 1);
        const classes = `bagua-line ${!isYang ? 'yin' : ''} ${isChanging ? 'changing' : ''}`;
        html += `<div class="${classes}"><span class="bagua-line-number">${index + 1}</span></div>`;
    });
    html += '</div>';
    return html;
}

// 发送给AI解读
async function sendBaguaReadingToChat() {
    if (!activeBaguaReading) return;
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能触发AI解读哦！');
        return;
    }
    
    document.getElementById('bagua-divination-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", "易经大师正在为你解读卦象...");
    
    try {
        const reading = activeBaguaReading;
        
        const hexInfo = `本卦：${reading.originalHexagram.name}（${reading.originalHexagram.meaning}）` +
            (reading.changingLines.length > 0 ? `\n变卦：${reading.changedHexagram.name}（${reading.changedHexagram.meaning}）\n动爻：第${reading.changingLines.join('、')}爻` : '');
        
        const yijingMasterPrompt = `
# 角色
你是一位精通易经的占卜大师，对八卦六爻有深刻的理解和丰富的实践经验。

# 核心任务
为用户提供一次专业、结构化且易于理解的八卦六爻解读。你的解读必须严格遵循下面的输出结构。

# 输出结构 (必须严格遵守)
你的回答必须包含以下部分，并使用Markdown加粗标题来分隔：

1. **🌟 卦象综述 (Overall Interpretation):**
   首先，根据本卦和变卦的整体象征，给出一个高度概括的、1-2句话的核心结论。

2. **📊 卦象详解 (Hexagram Details):**
   详细分析本卦的含义，如果有变卦，也要分析变卦的意义和动爻的影响。
   将卦象的象征意义与用户的具体问题紧密结合起来进行分析。

3. **💡 指引建议 (Guidance):**
   综合所有信息，为用户提供一个明确、具体、可操作的建议或心态指引。

# 指导原则
- **贴合实际**: 将卦象的抽象含义转化为与用户问题相关的具体指引。
- **清晰易懂**: 用平实的语言解释复杂的卦象，避免过于玄奥的术语。
- **深度分析**: 不要只是罗列卦辞，而是要深入分析其背后的智慧和启示。

# 占卜信息
- **用户的问题**: "${reading.question}"
- **卦象信息**:
${hexInfo}

# 最终指令
你的最终输出【只能是】完整的、格式化后的解读文本。不要添加任何对话性开场白。
`;
        
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: yijingMasterPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, yijingMasterPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8 })
            });
        
        if (!response.ok) {
            throw new Error(`API请求失败: ${await response.text()}`);
        }
        
        const data = await response.json();
        const interpretation = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
        
        // 保存解读结果到数据库（包含AI解读）
        await db.baguaReadings.add({
            question: reading.question,
            interpretation: hexInfo + '\n\n' + interpretation,
            timestamp: reading.timestamp
        });
        
        // 用弹窗显示解读结果
        await showCustomAlert(
            '☯️ 八卦六爻解读', 
            `**您的问题**："${reading.question}"\n\n**卦象信息**：\n${hexInfo}\n\n${interpretation}`,
            { confirmButtonText: '知道了' }
        );
        
        activeBaguaReading = null;
        
    } catch (error) {
        console.error("八卦六爻AI解读失败:", error);
        await showCustomAlert('解读失败', `抱歉，连接易经大师时出现了一点问题：\n\n${error.message}`);
        activeBaguaReading = null;
    }
}

// 打开历史记录界面
async function openBaguaHistory() {
    const readings = await db.baguaReadings.orderBy('timestamp').reverse().toArray();
    renderBaguaHistory(readings);
    document.getElementById('bagua-setup-view').style.display = 'none';
    document.getElementById('bagua-history-view').style.display = 'flex';
}

// 渲染历史记录列表
function renderBaguaHistory(readings) {
    const listEl = document.getElementById('bagua-history-list');
    listEl.innerHTML = '';
    if (readings.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有占卜历史哦</p>';
        return;
    }
    readings.forEach(reading => {
        const item = document.createElement('div');
        item.className = 'bagua-history-item';
        item.innerHTML = `
            <div class="question">${reading.question}</div>
            <div class="details">${new Date(reading.timestamp).toLocaleString()}</div>
            <button class="bagua-history-delete-btn" data-id="${reading.id}">×</button>
        `;
        // 添加点击事件查看详情
        item.addEventListener('click', (e) => {
            if (!e.target.classList.contains('bagua-history-delete-btn')) {
                showBaguaReadingDetail(reading);
            }
        });
        listEl.appendChild(item);
    });
}

// 显示历史记录详情
function showBaguaReadingDetail(reading) {
    showCustomAlert(
        '☯️ 八卦六爻解读', 
        reading.interpretation,
        { confirmButtonText: '知道了' }
    );
}

// 删除一条历史记录
async function deleteBaguaReading(readingId) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条占卜历史吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.baguaReadings.delete(readingId);
        openBaguaHistory();
    }
}
// ▲▲▲ 八卦六爻占卜功能结束 ▲▲▲

// ▼▼▼ 把这个新函数粘贴到 renderLSLetters 函数的下方 ▼▼▼




/**
 * 【全新】应用主屏幕图标和小组件的文字颜色
 * @param {string} color - 颜色代码, e.g., '#FFFFFF'
 */
function applyHomeIconWidgetTextColor(color) {
    const phoneScreen = document.getElementById('phone-screen');
    if (phoneScreen && color) {
        // 使用新的CSS变量名
        phoneScreen.style.setProperty('--home-icon-widget-text-color', color);
    }
}
/**
 * 【新增辅助函数1】将时长字符串（如“2.5小时”, "30m"）解析为分钟数
 * @param {string} durationString - 时长描述文本
 * @returns {number} - 对应的分钟数
 */
function parseDurationToMinutes(durationString) {
    if (!durationString || typeof durationString !== 'string') return 0;
    
    const text = durationString.toLowerCase();
    const num = parseFloat(text.match(/(\d+(\.\d+)?)/)?.[0]) || 0;

    if (text.includes('小时') || text.includes('h')) {
        return num * 60;
    }
    if (text.includes('分钟') || text.includes('m')) {
        return num;
    }
    // 如果没有单位，但数值大于等于10，我们猜测是分钟
    if (num >= 10) {
        return num;
    }
    // 其他情况（如数值很小且无单位），猜测是小时
    return num * 60;
}

/**
 * 【新增辅助函数2】将总分钟数格式化为 "X小时Y分钟" 的字符串
 * @param {number} totalMinutes - 总分钟数
 * @returns {string} - 格式化后的时长字符串
 */
function formatMinutesToDuration(totalMinutes) {
    if (totalMinutes < 1) return '不到1分钟';
    
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.round(totalMinutes % 60);

    if (hours > 0 && minutes > 0) {
        return `${hours}小时${minutes}分钟`;
    } else if (hours > 0) {
        return `${hours}小时`;
    } else {
        return `${minutes}分钟`;
    }
}

// ▼▼▼ 【全新】宠物功能核心函数 ▼▼▼

let currentPetData = null; // 用于暂存正在编辑的宠物数据
let isPetDragging = false; // 标记是否正在拖动宠物
let petDragOffset = { x: 0, y: 0 };

/**
 * 【领养系统改造版】打开宠物主面板（设置与互动）
 */
async function openPetModal() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        alert("只有在单人聊天中才能养宠物哦！");
        return;
    }
    const chat = state.chats[state.activeChatId];

    // 核心判断：检查是否已领养
    if (!chat.settings.petAdopted) {
        // 如果未领养，弹出确认框
        const confirmed = await showCustomConfirm(
            '领养新宠物',
            `你还没有为“${chat.name}”领养宠物，要现在开启宠物系统吗？`,
            { confirmText: '现在领养' }
        );

        if (confirmed) {
            // 用户同意领养
            chat.settings.petAdopted = true;
            // 创建一个全新的默认宠物对象
            chat.settings.pet = {
                type: '无', name: '', image: '🥚', persona: '一只可爱的小宠物，对世界充满好奇。',
                petChatHistory: [], isCustomImage: false,
                display: { show: false, size: 100, top: '80%', left: '50%' },
                status: {
                    hunger: 100, happiness: 100, intimacyToUser: 50,
                    intimacyToChar: 50, lastUpdated: Date.now()
                }
            };
            await db.chats.put(chat);
            alert(`恭喜！你已成功为“${chat.name}”开启宠物系统！现在来为它设置一下吧。`);
            // 领养成功后，再次调用本函数，这次会直接进入设置界面
            openPetModal(); 
        }
        // 如果用户取消，则什么也不做
        return;
    }

    // --- 如果已经领养，则执行原来的显示逻辑 ---
    currentPetData = JSON.parse(JSON.stringify(chat.settings.pet)); 

    document.getElementById('pet-type-input').value = currentPetData.type === '无' ? '' : currentPetData.type;
    document.getElementById('pet-name-input').value = currentPetData.name;
    document.getElementById('pet-image-input').value = currentPetData.image;
    document.getElementById('pet-display-toggle').checked = currentPetData.display.show;
    document.getElementById('pet-size-slider').value = currentPetData.display.size;
    document.getElementById('pet-size-value').textContent = `${currentPetData.display.size}px`;
    document.getElementById('pet-persona-input').value = currentPetData.persona || '';
    
    updatePetPreview();

    if (currentPetData.type !== '无') {
        document.getElementById('pet-stats-area').style.display = 'flex';
        updatePetStatusUI(currentPetData);
    } else {
        document.getElementById('pet-stats-area').style.display = 'none';
    }

    const positionControls = document.getElementById('pet-position-controls');
    positionControls.style.display = currentPetData.display.show ? 'block' : 'none';
    
    document.getElementById('pet-modal').classList.add('visible');
}


/**
 * 计算并应用宠物的数值衰减
 * @param {object} pet - 宠物对象
 * @returns {boolean} - 如果数值发生了变化，返回 true
 */
function applyPetDecay(pet) {
    if (!pet || !pet.status) return false;

    const now = Date.now();
    const lastUpdated = pet.status.lastUpdated || now;
    const timeElapsed = now - lastUpdated;

    // 计算过去了多少个衰减周期
    const intervalsPassed = Math.floor(timeElapsed / PET_DECAY_INTERVAL);

    if (intervalsPassed > 0) {
        // 计算总共要衰减多少
        const totalHungerDecay = intervalsPassed * PET_DECAY_AMOUNT.hunger;
        const totalHappinessDecay = intervalsPassed * PET_DECAY_AMOUNT.happiness;

        // 应用衰减，确保不低于0
        pet.status.hunger = Math.max(0, pet.status.hunger - totalHungerDecay);
        pet.status.happiness = Math.max(0, pet.status.happiness - totalHappinessDecay);

        // 更新最后更新时间，只加上已经计算过的周期的时间，避免丢失零头时间
        pet.status.lastUpdated = lastUpdated + intervalsPassed * PET_DECAY_INTERVAL;
        
        console.log(`宠物"${pet.name}"数值衰减: ${intervalsPassed}个周期, 饱食度-${totalHungerDecay}, 心情-${totalHappinessDecay}`);
        return true; // 数值已改变
    }

    return false; // 数值未改变
}

/**
 * 停止当前的宠物衰减计时器
 */
function stopPetDecayTimer() {
    if (petDecayTimer) {
        clearInterval(petDecayTimer);
        petDecayTimer = null;
        // console.log("宠物衰减计时器已停止。");
    }
}

/**
 * 为当前聊天中的宠物启动衰减计时器
 */
function startPetDecayTimer() {
    stopPetDecayTimer(); // 先确保停止任何旧的计时器

    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.pet || chat.settings.pet.type === '无') {
        return; // 如果当前聊天没有宠物，则不启动
    }
    
    // console.log(`为宠物"${chat.settings.pet.name}"启动衰减计时器。`);
    
    // 使用 setInterval 定期检查并应用衰减
    petDecayTimer = setInterval(async () => {
        const currentChat = state.chats[state.activeChatId];
        if (!currentChat) { // 安全检查，如果聊天已关闭则停止计时器
            stopPetDecayTimer();
            return;
        }
        const pet = currentChat.settings.pet;
        
        if (applyPetDecay(pet)) {
            // 如果数值变化了，更新UI并保存到数据库
            // 只有当宠物面板打开时才需要更新UI
            if (document.getElementById('pet-modal').classList.contains('visible')) {
                 updatePetStatusUI(pet);
            }
            await db.chats.put(currentChat);
        }
    }, 60 * 1000); // 每分钟检查一次，是否到达了衰减周期
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲


// ▼▼▼ 用这块【已更新】的代码，替换旧的 updatePetStatusUI 函数 ▼▼▼
/**
 * 【全新】更新宠物数值面板的UI显示
 * @param {object} petData - 宠物的数据对象
 */
function updatePetStatusUI(petData) {
    const hunger = petData.status.hunger || 0;
    const happiness = petData.status.happiness || 0;
    // ★★★ 新增：获取亲密度数值 ★★★
    const intimacyToUser = petData.status.intimacyToUser || 0;
    const intimacyToChar = petData.status.intimacyToChar || 0;

    const hungerFill = document.querySelector('#pet-hunger-bar .stat-bar-fill');
    const happinessFill = document.querySelector('#pet-happiness-bar .stat-bar-fill');
    // ★★★ 新增：获取亲密度进度条元素 ★★★
    const intimacyUserFill = document.querySelector('#pet-intimacy-user-bar .stat-bar-fill');
    const intimacyCharFill = document.querySelector('#pet-intimacy-char-bar .stat-bar-fill');

    if (hungerFill) {
        hungerFill.style.width = `${hunger}%`;
        hungerFill.textContent = `${hunger}%`;
    }
    if (happinessFill) {
        happinessFill.style.width = `${happiness}%`;
        happinessFill.textContent = `${happiness}%`;
    }
    // ★★★ 新增：渲染亲密度进度条 ★★★
    if (intimacyUserFill) {
        intimacyUserFill.style.width = `${intimacyToUser}%`;
        intimacyUserFill.textContent = `${intimacyToUser}%`;
    }
    if (intimacyCharFill) {
        intimacyCharFill.style.width = `${intimacyToChar}%`;
        intimacyCharFill.textContent = `${intimacyToChar}%`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 在弹窗中更新宠物的预览
 */
function updatePetPreview() {
    const previewDisplay = document.getElementById('pet-preview-display');
    const nameEl = document.getElementById('pet-preview-name');
    const typeEl = document.getElementById('pet-preview-type');
    
    const imageInput = document.getElementById('pet-image-input').value.trim();

    if (imageInput.startsWith('http') || imageInput.startsWith('data:image')) {
        previewDisplay.innerHTML = `<img src="${imageInput}" style="width: 60px; height: 60px; object-fit: contain;">`;
    } else {
        previewDisplay.textContent = imageInput || '🥚';
    }
    
    nameEl.textContent = document.getElementById('pet-name-input').value.trim() || '(未命名)';
    typeEl.textContent = document.getElementById('pet-type-input').value.trim() || '物种';
}


/**
 * 保存宠物设置
 */
async function savePetSettings() {
    const chat = state.chats[state.activeChatId];
    
    // 从UI读取数据
    const type = document.getElementById('pet-type-input').value.trim() || '无';
    const name = document.getElementById('pet-name-input').value.trim();
    const image = document.getElementById('pet-image-input').value.trim() || '🥚';
    
    const newPetSettings = {
        ...currentPetData, // 保留如位置等未在主面板修改的属性
        type: type,
        name: name,
        image: image,
        persona: document.getElementById('pet-persona-input').value.trim(),
        isCustomImage: image.startsWith('http') || image.startsWith('data:image'),
        display: {
            ...currentPetData.display,
            show: document.getElementById('pet-display-toggle').checked,
            size: parseInt(document.getElementById('pet-size-slider').value)
        }
    };

    // 更新到 state 和数据库
    chat.settings.pet = newPetSettings;
    await db.chats.put(chat);
    
    // 刷新聊天界面上的宠物
    renderChatPet();
    
    document.getElementById('pet-modal').classList.remove('visible');
    currentPetData = null; // 清理临时数据
    alert('宠物信息已保存！');
}

/**
 * 在聊天界面上渲染宠物
 */
function renderChatPet() {
    const chat = state.chats[state.activeChatId];
    const petContainer = document.getElementById('chat-pet-container');
    const petEl = document.getElementById('chat-pet');

    if (!chat || chat.isGroup || !chat.settings.petAdopted || !chat.settings.pet || !chat.settings.pet.display.show) {
        petEl.style.display = 'none';
        return;
    }

    const pet = chat.settings.pet;
    petEl.style.display = 'block';
    
    if (pet.isCustomImage) {
        petEl.innerHTML = `<img src="${pet.image}" alt="${pet.name}">`;
    } else {
        petEl.innerHTML = pet.image;
    }
    
    // 应用样式
    petEl.style.fontSize = `${pet.display.size}px`;
    petEl.style.width = `${pet.display.size}px`;
    petEl.style.height = `${pet.display.size}px`;
    petEl.style.top = pet.display.top;
    petEl.style.left = pet.display.left;
}

// ▼▼▼ 用这块【新代码】替换旧的 handlePetInteraction 函数 ▼▼▼
/**
 * 处理用户与宠物的互动 (V2 - 增强互动记录)
 * @param {string} action - 互动类型, e.g., 'feed', 'play'
 */
async function handlePetInteraction(action) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.petAdopted || !chat.settings.pet || chat.settings.pet.type === '无') {
        alert("你还没有宠物，或者还没有给它设定种类哦！");
        return;
    }

    const pet = chat.settings.pet;
    let actionText = '';
    const myNickname = chat.settings.myNickname || '我';

    switch(action) {
        case 'feed':
            pet.status.hunger = Math.min(100, pet.status.hunger + 20);
            pet.status.happiness = Math.min(100, pet.status.happiness + 5);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 10);
            actionText = `${myNickname} 喂了 ${pet.name} 一些食物。`;
            break;
        case 'play':
            pet.status.hunger = Math.max(0, pet.status.hunger - 10);
            pet.status.happiness = Math.min(100, pet.status.happiness + 15);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 15);
            actionText = `${myNickname} 陪 ${pet.name} 玩了一会儿。`;
            break;
        case 'touch':
            pet.status.happiness = Math.min(100, pet.status.happiness + 10);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 5);
            actionText = `${myNickname} 轻轻地抚摸了 ${pet.name}。`;
            break;
        case 'chat':
            openPetChat();
            return; 
    }
    
    updatePetStatusUI(pet);
    chat.settings.pet = pet; 

    // ★★★ 核心修改1：创建对用户【可见】的系统消息 ★★★
    const visibleMessage = {
        role: 'system',
        type: 'pat_message',
        content: `[系统：${actionText}]`,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);
    
    // ★★★ 核心修改2：创建给AI看的【隐藏】指令 ★★★
    const hiddenMessageForAI = {
        role: 'system',
        content: `[系统提示：用户刚刚和宠物“${pet.name}”进行了互动：${actionText}。]`,
        timestamp: Date.now() + 1, // 确保时间戳在后
        isHidden: true
    };
    chat.history.push(hiddenMessageForAI);

    await db.chats.put(chat);
    
    if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(visibleMessage, chat);
    }
    
    document.getElementById('pet-modal').classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】宠物对话功能核心函数 ▼▼▼

/**
 * 打开宠物聊天模态框
 */
function openPetChat() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.pet || chat.settings.pet.type === '无') {
        alert("先给你的宠物起个名字和种类吧！");
        return;
    }
    
    // 关闭主设置面板，打开聊天面板
    document.getElementById('pet-modal').classList.remove('visible');
    const chatModal = document.getElementById('pet-chat-modal');
    document.getElementById('pet-chat-title').textContent = `和“${chat.settings.pet.name}”的对话`;
    document.getElementById('pet-chat-input').value = '';
    
    renderPetChatHistory(); // 渲染历史记录
    chatModal.classList.add('visible');
}

/**
 * 渲染宠物的聊天记录
 */
function renderPetChatHistory() {
    const chat = state.chats[state.activeChatId];
    const pet = chat.settings.pet;
    const messagesEl = document.getElementById('pet-chat-messages');
    messagesEl.innerHTML = '';

    if (!pet.petChatHistory || pet.petChatHistory.length === 0) {
        messagesEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">试着和它打个招呼吧！</p>`;
        return;
    }
    
    // 获取用户头像
    const myAvatar = chat.settings.myAvatar || defaultAvatar;

    pet.petChatHistory.forEach(msg => {
        const wrapper = document.createElement('div');
        // 【核心】这里的 msg.sender 会是 'user', 'pet', 或 'char'
        wrapper.className = `message-wrapper ${msg.sender}`; 
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        let avatarSrc = '';
        let avatarHtml = '';

        // ▼▼▼ 问题就在下面这段逻辑，我们来修复它 ▼▼▼
        if (msg.sender === 'user') {
            // 如果是用户发的，使用用户头像
            avatarSrc = myAvatar;
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
        } else if (msg.sender === 'char') {
            // 【【【这就是新增的修复逻辑！】】】
            // 如果是角色(char)发的，就使用角色的头像
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
        } else { // 剩下的情况就是宠物(pet)自己发的
            avatarSrc = pet.isCustomImage ? pet.image : null;
            if (avatarSrc) {
                // 如果是图片，显示图片
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            } else {
                // 如果是Emoji，直接显示Emoji
                avatarHtml = `<div class="avatar" style="font-size: 28px; text-align: center;">${pet.image}</div>`;
            }
        }
        // ▲▲▲ 修复结束 ▲▲▲
        
        bubble.innerHTML = `
            ${avatarHtml}
            <div class="content">${msg.content.replace(/\n/g, '<br>')}</div>
        `;
        wrapper.appendChild(bubble);
        messagesEl.appendChild(wrapper);
    });

    messagesEl.scrollTop = messagesEl.scrollHeight;
}

// ▼▼▼ 用这块【新代码】替换旧的 handleSendToPet 函数 ▼▼▼
/**
 * 处理用户在宠物聊天框中发送消息
 */
async function handleSendToPet() {
    const chat = state.chats[state.activeChatId];
    const pet = chat.settings.pet;
    const input = document.getElementById('pet-chat-input');
    const userInput = input.value.trim();
    if (!userInput) return;

    input.value = '';
    input.style.height = 'auto';

    pet.petChatHistory.push({ sender: 'user', content: userInput });
    renderPetChatHistory();

    const petResponse = await getPetApiResponse(pet);
    if (petResponse) {
        pet.petChatHistory.push({ sender: 'pet', content: petResponse });
        renderPetChatHistory();
    }
    
    // ★★★ 核心修改：创建对用户【可见】的系统消息，记录这次对话 ★★★
    const visibleLog = `[系统：你和宠物“${pet.name}”进行了对话。你说：“${userInput}”，它回应：“${petResponse}”。]`;
    const visibleMessage = {
        role: 'system',
        type: 'pat_message', // 使用这个类型来显示居中灰色气泡
        content: visibleLog,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 只有当用户正在查看当前聊天时，才实时追加到界面上
    if (document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chat.id) {
        appendMessage(visibleMessage, chat);
    }
    
    // 创建给AI看的【隐藏】指令，这部分保持不变
    const hiddenMessageForAI = `[系统提示：用户刚刚和宠物“${pet.name}”进行了一次对话。用户说：“${userInput}”，宠物回应：“${petResponse}”。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageForAI,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【已修复】的代码替换旧的 getPetApiResponse 函数 ▼▼▼
/**
 * 【AI核心】为宠物获取API回复
 * @param {object} pet - 宠物对象
 * @returns {Promise<string|null>} - AI生成的宠物回复文本
 */
async function getPetApiResponse(pet) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("请先配置API！");
        return "（我好像断线了...）";
    }

    // ★★★ 核心修复2：重构对话历史的生成逻辑 ★★★
    const historyForPet = pet.petChatHistory.slice(-6).map(msg => {
        let senderName;
        if (msg.sender === 'user') {
            senderName = '主人';
        } else if (msg.sender === 'char') {
            senderName = msg.senderName; // 正确获取Char的名字
        } else { // 'pet'
            senderName = pet.name;
        }
        return `${senderName}: ${msg.content}`;
    }).join('\n');

    const systemPrompt = `你现在正在扮演一只宠物。
# 你的核心设定
- 你的种类: ${pet.type}
- 你的名字: ${pet.name}
- 你的性格和背景故事: ${pet.persona}

# 核心规则
1. 你【必须】完全代入你的角色设定进行回复。
2. 你的回复应该是简短、可爱的，符合一只宠物的说话方式（例如，使用拟声词、简单的词汇）。
3. 你的回复【只能是纯文本】，不要包含任何JSON或特殊格式。

# 最近的对话
${historyForPet}

现在，请根据上面的对话，继续你的回应。`;

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你在系统指令中读到的规则，立即开始你的行动。" }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
    } catch (error) {
        console.error("获取宠物回复失败:", error);
        return "（呜...我好像说不出话了...）";
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 初始化宠物的拖拽功能
 */
function initPetDragging() {
    const petEl = document.getElementById('chat-pet');
    const container = document.getElementById('chat-pet-container');

    const onDragStart = (e) => {
        if (!petEl.style.display || petEl.style.display === 'none') return;
        e.preventDefault();
        isPetDragging = true;
        
        const rect = petEl.getBoundingClientRect();
        const coords = getEventCoords(e);

        petDragOffset.x = coords.x - rect.left;
        petDragOffset.y = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isPetDragging) return;
        e.preventDefault();
        
        const containerRect = container.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - petDragOffset.x - containerRect.left;
        let newTop = coords.y - petDragOffset.y - containerRect.top;

        // 边界检测
        newLeft = Math.max(0, Math.min(newLeft, container.clientWidth - petEl.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, container.clientHeight - petEl.offsetHeight));
        
        // 用百分比存储，以适应不同屏幕尺寸
        petEl.style.left = `${(newLeft / container.clientWidth) * 100}%`;
        petEl.style.top = `${(newTop / container.clientHeight) * 100}%`;
    };

    const onDragEnd = async () => {
        if (!isPetDragging) return;
        isPetDragging = false;
        
        // 拖动结束后，保存新的位置
        const chat = state.chats[state.activeChatId];
        if (chat && chat.settings.pet) {
            chat.settings.pet.display.top = petEl.style.top;
            chat.settings.pet.display.left = petEl.style.left;
            await db.chats.put(chat);
        }

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    petEl.addEventListener('mousedown', onDragStart);
    petEl.addEventListener('touchstart', onDragStart, { passive: true });
}

// ▲▲▲ 宠物功能核心函数结束 ▲▲▲
/**
 * 【全新】显示微博内容生成的目标角色选择器
 * @returns {Promise<object|string|null>} - 返回选中的角色对象, 'all', 或 null (如果用户取消)
 */
async function showCharacterSelectorForWeibo() {
    // 1. 找出所有单聊角色
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        alert("还没有任何角色可以生成内容哦。");
        return null;
    }

    // 2. 准备弹窗的选项
    const options = [
        // 添加一个“随机”选项，保留原来的功能
        { text: '✨ 随机 (所有角色)', value: 'all' }, 
        // 遍历所有角色，为每个角色创建一个选项
        ...singleChats.map(chat => ({
            text: `👤 ${chat.name}`, // 选项显示的名字
            value: chat.id         // 选项的值是角色的唯一ID
        }))
    ];

    // 3. 调用你现有的操作菜单弹窗，并等待用户选择
    const selectedId = await showChoiceModal("请选择本次生成的主角", options);

    // 4. 根据用户的选择，返回不同的结果
    if (selectedId === null) {
        return null; // 用户点击了“取消”
    }
    if (selectedId === 'all') {
        return 'all'; // 用户选择了“随机”
    }

    // 如果用户选择了某个角色，就返回那个角色的完整数据对象
    return state.chats[selectedId];
}
/**
 * 【全新 | V2多选版】显示微博内容生成的目标角色选择器
 * @returns {Promise<Array|string|null>} - 返回选中的角色ID数组, 'all', 或 null
 */
async function showMultiCharacterSelectorForWeibo() {
    return new Promise(resolve => {
        const modal = document.getElementById('weibo-char-selector-modal');
        const listEl = document.getElementById('weibo-char-selector-list');
        const confirmBtn = document.getElementById('weibo-confirm-char-select-btn');
        const cancelBtn = document.getElementById('weibo-cancel-char-select-btn');
        const selectAllBtn = document.getElementById('weibo-select-all-btn');
        const deselectAllBtn = document.getElementById('weibo-deselect-all-btn');
        const recognitionToggle = document.getElementById('char-mutual-recognition-toggle');

        // 从state中恢复角色互识开关的状态
        recognitionToggle.checked = state.weiboCharRecognition !== false;

        listEl.innerHTML = '';
        const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

        if (singleChats.length === 0) {
            alert("还没有任何角色可以生成内容哦。");
            resolve(null);
            return;
        }

        // 添加一个“随机”选项
        const randomOption = document.createElement('div');
        randomOption.className = 'player-selection-item';
        randomOption.innerHTML = `
            <input type="radio" name="weibo-char-choice" value="all" id="weibo-char-random" checked style="margin-right: 15px;">
            <label for="weibo-char-random" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <span class="name">✨ 随机选择 (所有角色)</span>
            </label>
        `;
        listEl.appendChild(randomOption);
        
        // 添加一个“指定”选项的标题
        const specificOptionHeader = document.createElement('div');
        specificOptionHeader.className = 'player-selection-item';
        specificOptionHeader.innerHTML = `
            <input type="radio" name="weibo-char-choice" value="specific" id="weibo-char-specific" style="margin-right: 15px;">
            <label for="weibo-char-specific" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <span class="name">👤 指定以下角色</span>
            </label>
        `;
        listEl.appendChild(specificOptionHeader);

        // 渲染所有可选的角色
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'player-selection-item';
            item.style.paddingLeft = '50px'; // 向内缩进，表示是"指定"的子选项
            item.innerHTML = `
                <input type="checkbox" class="weibo-char-checkbox" value="${chat.id}" id="weibo-char-${chat.id}">
                <label for="weibo-char-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" alt="${chat.name}">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        // 使用克隆节点技巧来确保事件只被绑定一次
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        const onConfirm = () => {
            const choice = document.querySelector('input[name="weibo-char-choice"]:checked').value;
            
            // 保存角色互识开关的状态到 state（内存中）
            state.weiboCharRecognition = recognitionToggle.checked;
            
            if (choice === 'all') {
                cleanup();
                resolve({ targets: 'all', recognition: state.weiboCharRecognition });
            } else {
                const selectedIds = Array.from(document.querySelectorAll('.weibo-char-checkbox:checked')).map(cb => cb.value);
                if (selectedIds.length === 0) {
                    alert("请至少选择一个指定的角色！");
                    return;
                }
                cleanup();
                resolve({ targets: selectedIds, recognition: state.weiboCharRecognition });
            }
        };

        const onCancel = () => { cleanup(); resolve(null); };
        const onSelectAll = () => document.querySelectorAll('.weibo-char-checkbox').forEach(cb => cb.checked = true);
        const onDeselectAll = () => document.querySelectorAll('.weibo-char-checkbox').forEach(cb => cb.checked = false);

        const cleanup = () => {
            modal.classList.remove('visible');
            // 清除事件监听器，防止内存泄漏
            newConfirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
            selectAllBtn.removeEventListener('click', onSelectAll);
            deselectAllBtn.removeEventListener('click', onDeselectAll);
        };

        newConfirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
        selectAllBtn.addEventListener('click', onSelectAll);
        deselectAllBtn.addEventListener('click', onDeselectAll);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 使用这【一整块】全新的代码，完整替换掉你旧的、所有与线下模式预设相关的函数 ▼▼▼

/**
 * 【全局版】渲染线下模式预设的下拉框
 */
function renderOfflinePresetsSelector() {
    const select = document.getElementById('offline-preset-select');
    // 直接从全局 state 读取预设
    const presets = state.offlinePresets || []; 
    select.innerHTML = '<option value="">-- 使用自定义输入 --</option>';
    
    presets.forEach(preset => {
        const option = document.createElement('option');
        // 使用数据库的 ID 作为 option 的 value，这更可靠
        option.value = preset.id; 
        option.textContent = preset.name;
        select.appendChild(option);
    });
}

/**
 * 【全局版】当用户选择一个预设时，自动填充输入框
 */
function handleOfflinePresetSelection() {
    const select = document.getElementById('offline-preset-select');
    const selectedId = parseInt(select.value);

    // 如果选择的不是“自定义输入”
    if (selectedId) {
        // 从全局 state 中根据 ID 查找预设
        const preset = state.offlinePresets.find(p => p.id === selectedId);
        if (preset) {
            document.getElementById('offline-prompt-input').value = preset.prompt;
            document.getElementById('offline-style-input').value = preset.style;
        }
    }
}

/**
 * 【全局版】打开预设管理的操作菜单
 */
async function openOfflinePresetManager() {
    const select = document.getElementById('offline-preset-select');
    // 获取当前选中的预设ID
    const selectedId = select.value ? parseInt(select.value) : null;

    const choice = await showChoiceModal("管理线下模式预设", [
        { text: '💾 保存当前为新预设', value: 'save_new' },
        { text: '✏️ 更新选中预设', value: 'update_selected', disabled: !selectedId },
        { text: '🗑️ 删除选中预设', value: 'delete_selected', disabled: !selectedId }
    ]);
    
    // 根据选择执行相应的全局操作函数
    switch (choice) {
        case 'save_new':
            await saveCurrentAsOfflinePreset();
            break;
        case 'update_selected':
            if (selectedId) await updateSelectedOfflinePreset(selectedId);
            break;
        case 'delete_selected':
            if (selectedId) await deleteSelectedOfflinePreset(selectedId);
            break;
    }
}

/**
 * 【全局版】将当前输入框的内容保存为一个新预设
 */
async function saveCurrentAsOfflinePreset() {
    const name = await showCustomPrompt("保存新预设", "请输入预设名称：");
    
    if (name && name.trim()) {
        const newPreset = {
            name: name.trim(),
            prompt: document.getElementById('offline-prompt-input').value.trim(),
            style: document.getElementById('offline-style-input').value.trim()
        };
        // 直接添加到全局的 offlinePresets 表中
        const newId = await db.offlinePresets.add(newPreset);
        
        // 更新内存中的 state
        if (!state.offlinePresets) state.offlinePresets = [];
        state.offlinePresets.push({ id: newId, ...newPreset });

        renderOfflinePresetsSelector(); // 刷新下拉框
        document.getElementById('offline-preset-select').value = newId; // 自动选中新保存的
        alert(`预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 【全局版】用当前输入框的内容更新选中的预设
 */
async function updateSelectedOfflinePreset(presetId) {
    const preset = state.offlinePresets.find(p => p.id === presetId);
    if (!preset) return;

    const confirmed = await showCustomConfirm("确认更新", `确定要用当前内容覆盖预设 "${preset.name}" 吗？`);
    if (confirmed) {
        const updatedData = {
            prompt: document.getElementById('offline-prompt-input').value.trim(),
            style: document.getElementById('offline-style-input').value.trim()
        };
        // 更新数据库
        await db.offlinePresets.update(presetId, updatedData);
        // 更新内存
        preset.prompt = updatedData.prompt;
        preset.style = updatedData.style;
        alert("预设已更新！");
    }
}

/**
 * 【全局版】删除选中的预设
 */
async function deleteSelectedOfflinePreset(presetId) {
    const preset = state.offlinePresets.find(p => p.id === presetId);
    if (!preset) return;

    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 从数据库删除
        await db.offlinePresets.delete(presetId);
        // 从内存中删除
        state.offlinePresets = state.offlinePresets.filter(p => p.id !== presetId);
        
        renderOfflinePresetsSelector(); // 刷新下拉框
        // 清空输入框
        document.getElementById('offline-prompt-input').value = '';
        document.getElementById('offline-style-input').value = '';
        alert("预设已删除。");
    }
}

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】微博私信功能核心函数 ▼▼▼

/**
 * 【总入口】当用户点击关注列表时，打开私信界面
 * @param {object} targetInfo - 包含被点击角色/NPC信息的对象
 */
async function openWeiboDms(targetInfo) {
    currentViewingDmsFor = targetInfo;
    const charId = targetInfo.isNpc ? targetInfo.ownerId : targetInfo.id;
    const chat = state.chats[charId];
    if (!chat) return;

    // 检查并生成粉丝私信数据
    const dmsData = await generateAndCacheFanDms(chat);
    
    // 渲染私信列表
    renderDmList(dmsData, targetInfo.name);

    // 显示私信列表屏幕
    showScreen('weibo-dm-list-screen');
}

/**
 * 【AI核心】检查或生成角色的粉丝私信数据
 * @param {object} characterChat - 角色/NPC的 "主人" 的聊天对象
 * @returns {Promise<Array>} - 粉丝私信对话数组
 */
async function generateAndCacheFanDms(characterChat, addMore = false) {
    // 如果不是“继续生成”，且缓存已存在，则直接返回
    if (!addMore && characterChat.weiboDms && characterChat.weiboDms.length > 0) {
        console.log(`从缓存加载 "${characterChat.name}" 的粉丝私信。`);
        return characterChat.weiboDms;
    }

    const alertMessage = addMore ? "正在生成更多私信内容..." : `正在为“${characterChat.name}”生成粉丝私信内容...`;
    await showCustomAlert("请稍候...", alertMessage);
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return [];
    }

    const truncatedMainPersona = (characterChat.settings.aiPersona || '一个普通的角色').substring(0, 500);
    const truncatedWeiboInstruction = (characterChat.settings.weiboInstruction || '无特殊指令').substring(0, 400);
    
    // 如果是继续生成，把现有对话作为上下文
    const existingDmsContext = addMore ? `
# 已有私信记录 (供你参考，你可以选择延续对话或开启新对话):
${JSON.stringify(characterChat.weiboDms, null, 2)}
` : '';

        // 【优化后】的AI指令
        const systemPrompt = `
# 任务
你现在是角色“${characterChat.name}”的社交媒体运营助理。
你的任务是根据该角色的【所有信息】，虚构一个包含${addMore ? '2-3' : '3-5'}位不同粉丝的私信列表，并为每位粉丝创作一段生动、真实的对话历史。
${existingDmsContext}

# 角色信息 (你必须综合参考以下所有信息)
- 角色名: ${characterChat.name}
- 公开职业: ${characterChat.settings.weiboProfession || '未设定'}
- 核心人设 (最高优先级): ${truncatedMainPersona}
- 微博互动准则 (处理私信时需遵守): ${truncatedWeiboInstruction}

# 核心规则
1.  **粉丝多样性**: 创作${addMore ? '2-3' : '3-5'}位不同类型的粉丝（例如：狂热粉、事业粉、CP粉、黑粉、路人粉、广告商等）。
2.  **【【【对话鲜活度铁律】】】**: 为了让对话更真实，你必须：
    -   **避免机械问答**：不要生成“你好”-“你好”之类的无意义对话。让对话像一个正在进行的真实互动片段。
    -   **注入情绪和语气**：粉丝的语气可以是兴奋的、担忧的、质疑的、开玩笑的。角色的回应也要符合人设，可能是冷淡的、温柔的、官方的，或者干脆已读不回。
    -   **使用网络语言**: 适当加入符合粉丝圈文化的网络用语、emoji或颜文字，让对话更接地气。
    -   **内容多样化**: 私信内容不应只局限于工作，也可以是粉丝分享自己的日常、表达关心、提出一些私人问题等。
3.  **角色回应**: 根据角色的【微博互动准则】和【核心人设】，决定角色是否会回复私信以及如何回复。例如，一个高冷的角色可能只会回复重要信息，或者干脆不回复。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以 '[' 开头，以 ']' 结尾。

# JSON对象结构 (注意：你不再需要提供头像URL)
{
  "fanName": "粉丝的微博昵称",
  "fanPersona": "对这位粉丝的简单描述 (例如: '一个担心哥哥事业的妈妈粉')",
  "messages": [
    { "sender": "fan", "text": "粉丝发的第一条消息..." },
    { "sender": "char", "text": "角色回复的消息..." }
  ]
}

现在，请开始生成私信列表。`;


    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });
        
        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        }
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newDmsData = JSON.parse(cleanedContent);
        // 【已修复】在这里为AI生成的数据手动添加随机头像
        if (Array.isArray(newDmsData)) {
            // 这是你提供的两个头像URL
            const fanAvatars = [
                'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg',
                'https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png'
            ];

            // 遍历AI生成的每一段对话，这次我们加入了 index 参数
            newDmsData.forEach((convo, index) => {
                // 【核心修改】使用索引和取余运算符(%)来交替分配头像
                convo.fanAvatarUrl = fanAvatars[index % fanAvatars.length];
            });
        }


        if (Array.isArray(newDmsData)) {
            if (addMore) {
                // 合并新旧数据
                characterChat.weiboDms.push(...newDmsData);
            } else {
                characterChat.weiboDms = newDmsData;
            }
            await db.chats.put(characterChat);
            return characterChat.weiboDms;
        }
        throw new Error("AI返回的数据不是一个有效的数组。");
    } catch (error) {
        console.error("生成粉丝私信失败:", error);
        await showCustomAlert('生成失败', `抱歉，生成私信时发生了一个错误。\n\n详细信息:\n${error.message}`);
        return characterChat.weiboDms || []; // 失败时返回旧数据或空数组
    }
}

/**
 * 渲染粉丝私信列表
 * @param {Array} dmsData - 私信对话数组
 * @param {string} charName - 角色名
 */
function renderDmList(dmsData, charName) {
    const listEl = document.getElementById('weibo-dm-list');
    const titleEl = document.getElementById('weibo-dm-list-title');
    listEl.innerHTML = '';
    titleEl.textContent = `${charName}的私信`;

    if (!dmsData || dmsData.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有收到任何私信哦</p>';
        return;
    }

    dmsData.forEach((convo, index) => {
        const lastMsg = convo.messages[convo.messages.length - 1];
        const item = document.createElement('div');
        item.className = 'dm-list-item';
        item.dataset.fanIndex = index; // 用索引来标识
        item.innerHTML = `
            <img src="${convo.fanAvatarUrl}" class="dm-avatar">
            <div class="dm-info">
                <div class="dm-name">${convo.fanName}</div>
                <div class="dm-last-msg">${lastMsg.text}</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 打开私信详情页
 * @param {number} fanIndex - 粉丝在私信数组中的索引
 */
function openDmDetail(fanIndex) {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    const conversation = chat.weiboDms[fanIndex];
    
    if (conversation) {
        renderDmDetail(conversation, chat);
        showScreen('weibo-dm-detail-screen');
    }
}

/**
 * 渲染私信详情页的聊天气泡
 * @param {object} conversation - 单个粉丝的对话对象
 * @param {object} characterChat - 角色的聊天对象
 */
function renderDmDetail(conversation, characterChat) {
    const messagesEl = document.getElementById('weibo-dm-messages');
    const titleEl = document.getElementById('weibo-dm-detail-title');
    messagesEl.innerHTML = '';
    titleEl.textContent = conversation.fanName;
    
    const charAvatar = characterChat.settings.aiAvatar || defaultAvatar;

    conversation.messages.forEach((msg, index) => {
        const isFan = msg.sender === 'fan';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isFan ? 'fan' : 'char'}`;

        const bubble = document.createElement('div');
        bubble.className = `message-bubble`;

        const avatarHtml = `<img src="${isFan ? conversation.fanAvatarUrl : charAvatar}" class="avatar">`;
        const contentHtml = `<div class="content">${msg.text.replace(/\n/g, '<br>')}</div>`;
        
        // ★★★ 只有粉丝的消息才添加删除按钮 ★★★
        const deleteBtnHtml = isFan 
            ? `<button class="dm-message-delete-btn" data-message-index="${index}">×</button>` 
            : '';

        bubble.innerHTML = `${avatarHtml}${contentHtml}`;
        // 将删除按钮添加到wrapper，而不是bubble内部，以方便定位
        wrapper.innerHTML = deleteBtnHtml; 
        wrapper.appendChild(bubble);

        messagesEl.appendChild(wrapper);
    });
    
    messagesEl.scrollTop = messagesEl.scrollHeight;
}
/**
 * 【全新】清空当前角色的所有粉丝私信
 */
async function handleClearAllDms() {
    if (!currentViewingDmsFor) return;

    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat || !chat.weiboDms || chat.weiboDms.length === 0) {
        alert("没有可以清空的私信。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认清空',
        `确定要清空“${currentViewingDmsFor.name}”收到的所有粉丝私信吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.weiboDms = []; // 清空数组
        await db.chats.put(chat); // 保存到数据库
        renderDmList(chat.weiboDms, currentViewingDmsFor.name); // 重新渲染列表
        alert('所有私信已清空。');
    }
}

/**
 * ★★★ 处理删除单条私信的逻辑 ★★★
 * @param {number} fanIndex - 粉丝对话的索引
 * @param {number} messageIndex - 要删除的消息的索引
 */
async function handleDeleteWeiboDm(fanIndex, messageIndex) {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat || !chat.weiboDms[fanIndex]) return;

    const conversation = chat.weiboDms[fanIndex];
    const messageText = conversation.messages[messageIndex].text.substring(0, 30);
    
    const confirmed = await showCustomConfirm(
        '删除私信',
        `确定要删除这条私信吗？\n\n“${messageText}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 从消息数组中移除
        conversation.messages.splice(messageIndex, 1);
        
        // 如果一个对话的所有消息都被删除了，可以选择是否删除整个对话
        if (conversation.messages.length === 0) {
            chat.weiboDms.splice(fanIndex, 1);
            await db.chats.put(chat);
            // 返回私信列表
            renderDmList(chat.weiboDms, currentViewingDmsFor.name);
            showScreen('weibo-dm-list-screen');
        } else {
            await db.chats.put(chat);
            // 重新渲染当前对话
            renderDmDetail(conversation, chat);
        }
        alert('私信已删除。');
    }
}

/**
 * ★★★ 处理点击“继续生成”按钮的逻辑 ★★★
 */
async function handleGenerateMoreDms() {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat) return;

    // 调用核心AI函数，并传入 addMore=true 参数
    const newDmsData = await generateAndCacheFanDms(chat, true);
    
    // 渲染更新后的私信列表
    renderDmList(newDmsData, currentViewingDmsFor.name);
}






let isSummarizing = false; // 全局锁，防止重复触发总结

// ▼▼▼ 【V2 - 流程分离版】用这整块代码替换旧的 checkAndTriggerSummary 函数 ▼▼▼
/**
 * 【总入口 V2】检查是否需要触发总结或提醒
 * @param {string} chatId - 当前聊天的ID
 */
async function checkAndTriggerSummary(chatId) {
    if (isSummarizing) return; 

    const chat = state.chats[chatId];
    if (!chat || !chat.settings.summary || !chat.settings.summary.enabled) return;

    const summarySettings = chat.settings.summary;
    // 核心修改：我们不再从0开始，而是从上次总结的位置开始计算
    const lastSummaryIndex = summarySettings.lastSummaryIndex;
    const messagesSinceLastSummary = chat.history.slice(lastSummaryIndex + 1);

    if (messagesSinceLastSummary.length >= summarySettings.count) {
        isSummarizing = true; 
        if (summarySettings.mode === 'auto') {
            await performAutomaticSummary(chatId);
        } else {
            // 对于手动模式，现在只弹提醒
            await notifyForManualSummary(chatId);
        }
        isSummarizing = false;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【V2 - 范围精确版】用这整块代码替换旧的 performAutomaticSummary 函数 ▼▼▼
/**
 * 自动在后台执行总结，只总结触发条件的N条消息
 */
async function performAutomaticSummary(chatId) {
    console.log(`自动总结触发 for chat: ${chatId}`);
    const chat = state.chats[chatId];
    const summarySettings = chat.settings.summary;

    // 【核心修改】精确截取最后N条消息作为总结范围
    const messagesToSummarize = chat.history.slice(-summarySettings.count);
    
    try {
        const summaryText = await generateSummary(chatId, messagesToSummarize);
        if (summaryText) {
            await saveSummaryAsMemory(chatId, summaryText);
        }
    } catch (e) {
        // generateSummary 内部已经处理了错误弹窗，这里我们只需要记录日志即可
        console.error("自动总结过程中发生未捕获的错误:", e);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V2 - 仅提醒版】用这整块新代码替换旧的 promptForManualSummary 函数 ▼▼▼
/**
 * 弹出提示框，【提醒】用户可以进行手动总结了
 */
async function notifyForManualSummary(chatId) {
    console.log(`手动总结提醒触发 for chat: ${chatId}`);
    
    // 只弹出一个简单的通知
    await showCustomAlert(
        '总结提醒',
        '对话已达到设定长度，你可以随时在“聊天设置”中点击“立即手动总结”来生成对话记忆。'
    );

    // 【重要】提醒过后，更新“上次总结位置”，以防止每条新消息都弹窗。
    // 这意味着计时器会从现在重新开始计算。
    const chat = state.chats[chatId];
    chat.settings.summary.lastSummaryIndex = chat.history.length - 1;
    await db.chats.put(chat);
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V2 - 时间戳增强版】用这整块代码替换旧的 generateSummary 函数 ▼▼▼
/**
 * 【AI核心 V2 - 时间戳增强版】调用API生成总结内容
 * @param {string} chatId - 聊天的ID
 * @param {Array | null} specificMessages - 如果提供，则只总结这个数组里的消息；如果为null，则总结自上次以来的所有消息。
 * @returns {Promise<string|null>} - AI生成的总结文本
 */
async function generateSummary(chatId, specificMessages = null) {
    const chat = state.chats[chatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成总结。');
    }

    const summarySettings = chat.settings.summary;
    let messagesToSummarize;

    if (specificMessages && specificMessages.length > 0) {
        messagesToSummarize = specificMessages;
    } else {
        const lastSummaryIndex = summarySettings.lastSummaryIndex > -1 ? summarySettings.lastSummaryIndex : 0;
        messagesToSummarize = chat.history.slice(lastSummaryIndex + 1);
    }
    
    const filteredMessagesForSummary = messagesToSummarize.filter(msg => msg.type !== 'summary');

    if (filteredMessagesForSummary.length === 0) {
        if (!specificMessages) {
             await showCustomAlert("无需总结", "自上次总结以来没有新的对话内容。");
        }
        return null;
    }

    // --- ★★★ 核心修改1：在构建对话文本时，加入时间戳！ ★★★ ---
    const conversationText = filteredMessagesForSummary.map(msg => {
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        let content = '';
        if (typeof msg.content === 'string') {
            content = msg.content;
        } else if (Array.isArray(msg.content)) {
            content = '[图片]';
        } else if (msg.type) {
            content = `[${msg.type}]`;
        }
        // 将毫秒时间戳转换为人类可读的日期时间字符串
        const readableTime = new Date(msg.timestamp).toLocaleString('zh-CN', { hour12: false });
        return `[${readableTime}] ${sender}: ${content}`;
    }).join('\n');

    // --- ★★★ 核心修改2：更新系统指令，要求AI使用时间戳！ ★★★ ---
    const systemPrompt = summarySettings.prompt + `\n\n重要提示：每条消息开头都有一个 [时间] 标记。你在总结时，【必须】参考这些时间，在总结关键事件时附上对应的时间范围或具体时间点，让总结包含时间线索。\n\n--- 对话开始 ---\n${conversationText}\n--- 对话结束 ---`;
    
    try {
        if (!specificMessages) {
             await showCustomAlert("正在生成...", "AI正在努力总结你们的对话，请稍候...");
        }
        
        const isGemini = proxyUrl === GEMINI_API_URL;
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        const geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.3,
                })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const aiContent = isGemini 
            ? data?.candidates?.[0]?.content?.parts?.[0]?.text 
            : data?.choices?.[0]?.message?.content;

        if (!aiContent) {
            throw new Error("AI返回了空内容。");
        }
        
        return aiContent;

    } catch (error) {
        console.error("生成总结失败:", error);
        await showCustomAlert('总结失败', `发生错误: ${error.message}`);
        return null;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 将生成的总结作为一条特殊的记忆消息保存起来
 */
async function saveSummaryAsMemory(chatId, summaryText) {
    const chat = state.chats[chatId];
    
    // 记录下总结操作发生时的最后一条消息的索引
    const newLastSummaryIndex = chat.history.length - 1;

    const summaryMessage = {
        role: 'system',
        type: 'summary', // 特殊类型
        content: summaryText,
        timestamp: Date.now(),
        isHidden: true // 这条消息对AI可见，但对用户隐藏
    };

    chat.history.push(summaryMessage);
    chat.settings.summary.lastSummaryIndex = newLastSummaryIndex; // 更新索引
    
    await db.chats.put(chat);
    console.log(`新的总结已作为记忆保存 for chat: ${chatId}`);
}

// --- 以下是总结管理界面的函数 ---

let editingSummaryTimestamp = null;

// ▼▼▼ 用这块【V2 - 美化版】代码替换旧的 openSummaryViewer 函数 ▼▼▼
async function openSummaryViewer() {
    const chat = state.chats[state.activeChatId];
    document.getElementById('summary-viewer-title').textContent = `“${chat.name}”的对话记忆`;
    
    const listEl = document.getElementById('summary-list');
    listEl.innerHTML = '';
    
    const summaries = chat.history.filter(msg => msg.type === 'summary');

    if (summaries.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">还没有生成过任何总结。</p>';
    } else {
        [...summaries].reverse().forEach(summary => {
            const card = document.createElement('div');
            card.className = 'summary-item-card';
            
            // --- ★★★ 核心修改：让生成时间显示得更简短好看！ ★★★ ---
            card.innerHTML = `
                <div class="summary-actions">
                    <button class="concise-summary-btn" data-timestamp="${summary.timestamp}" title="精简总结">✨</button>
                    <button class="edit-summary-btn" data-timestamp="${summary.timestamp}" title="编辑">✏️</button>
                    <button class="delete-summary-btn" data-timestamp="${summary.timestamp}" title="删除">🗑️</button>
                </div>
                <div class="summary-content">${summary.content.replace(/\n/g, '<br>')}</div>
                <div class="summary-meta">
                    <span>生成于: ${new Date(summary.timestamp).toLocaleString('zh-CN', { dateStyle: 'short', timeStyle: 'short'})}</span>
                </div>
            `;
            listEl.appendChild(card);
        });
    }
    
    document.getElementById('chat-settings-modal').classList.remove('visible');
    document.getElementById('summary-viewer-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 编辑一条总结
 */
async function editSummary(timestamp) {
    const chat = state.chats[state.activeChatId];
    const summary = chat.history.find(msg => msg.timestamp === timestamp);
    if (!summary) return;

    const newContent = await showCustomPrompt(
        '编辑总结',
        '修改总结内容:',
        summary.content,
        'textarea'
    );

    if (newContent !== null) {
        summary.content = newContent.trim();
        await db.chats.put(chat);
        openSummaryViewer(); // 重新渲染列表
    }
}

/**
 * 【已修复】删除一条总结，并智能更新总结索引
 */
async function deleteSummary(timestamp) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条总结记忆吗？这可能会影响AI的长期记忆。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 从历史记录中过滤掉被删除的总结
        chat.history = chat.history.filter(msg => msg.timestamp !== timestamp);

        // 2. --- 核心修复：重新计算 lastSummaryIndex ---
        // 找到剩下的总结中，最新的那一条
        const lastRemainingSummary = chat.history.filter(m => m.type === 'summary').pop();
        
        let newLastSummaryIndex;

        if (lastRemainingSummary) {
            // 3. 如果还有其他总结，就找到它在历史记录中的位置
            const lastSummaryMessageIndexInHistory = chat.history.findIndex(m => m.timestamp === lastRemainingSummary.timestamp);
            // 4. 新的索引就是它前面那条普通消息的索引
            newLastSummaryIndex = lastSummaryMessageIndexInHistory > 0 ? (lastSummaryMessageIndexInHistory - 1) : -1;
        } else {
            // 5. 如果一条总结都不剩了，就彻底重置索引
            newLastSummaryIndex = -1;
        }
        
        // 6. 更新设置
        if (chat.settings.summary) {
            chat.settings.summary.lastSummaryIndex = newLastSummaryIndex;
        }

        // 保存更改并刷新UI
        await db.chats.put(chat);
        openSummaryViewer();
        await showCustomAlert('操作成功', '总结已删除！');
    }
}

// ▼▼▼ 把这一整块全新的功能函数，粘贴到你的JS代码中 ▼▼▼

/**
 * 【AI核心】调用API将指定文本精简为摘要
 * @param {string} originalText - 原始的、较长的总结文本
 * @returns {Promise<string|null>} - AI生成的精简摘要，如果失败则返回null
 */
async function generateConciseSummary(originalText) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成精简摘要。');
    }

    // 核心Prompt：指示AI将内容精简为一句话
    const systemPrompt = `请你将以下内容精简为一句话的核心摘要，保留最关键的人物、事件和结论，字数控制在20字以内：\n\n--- 内容开始 ---\n${originalText}\n--- 内容结束 ---`;

    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: systemPrompt }],
                temperature: parseFloat(state.apiConfig.temperature) || 0.5,
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return data.choices[0].message.content;

    } catch (error) {
        console.error("生成精简摘要失败:", error);
        await showCustomAlert('精简失败', `发生错误: ${error.message}`);
        return null;
    }
}

/**
 * 处理单条总结的精简
 * @param {number} timestamp - 要精简的总结消息的时间戳
 */
async function handleConciseSummary(timestamp) {
    const chat = state.chats[state.activeChatId];
    const summary = chat.history.find(msg => msg.timestamp === timestamp);
    if (!summary) return;

    await showCustomAlert("请稍候...", "AI正在努力为您精简内容...");

    const conciseText = await generateConciseSummary(summary.content);

    if (conciseText) {
        summary.content = conciseText.trim(); // 用精简后的文本替换原文
        await db.chats.put(chat); // 保存到数据库
        await openSummaryViewer(); // 重新渲染列表
        await showCustomAlert('成功', '本条总结已精简！');
    }
}

/**
 * 处理全部总结的精简
 */
async function handleConciseAllSummaries() {
    const chat = state.chats[state.activeChatId];
    const summaries = chat.history.filter(msg => msg.type === 'summary');

    if (summaries.length === 0) {
        alert("没有可以精简的总结。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认全部精简',
        `确定要精简全部 ${summaries.length} 条总结吗？此操作会覆盖原始内容且不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在批量精简 ${summaries.length} 条总结，这可能需要一些时间...`);

    try {
        // 使用 for...of 循环来逐条处理，避免同时发送太多API请求导致被限制
        for (const summary of summaries) {
            const conciseText = await generateConciseSummary(summary.content);
            if (conciseText) {
                summary.content = conciseText.trim();
            }
            // 每处理完一条，稍微等待一下，给API一点喘息时间
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        await db.chats.put(chat);
        await openSummaryViewer();
        await showCustomAlert('成功', '所有总结都已精简完毕！');
    } catch (error) {
        // generateConciseSummary 内部已经处理了错误弹窗，这里我们只需要确保流程正常结束
        console.error("批量精简时出错:", error);
    }
}

// ▼▼▼ 第2步：用这块【已改造】的代码，完整替换旧的 triggerManualSummaryNow 函数 ▼▼▼

/**
 * 【手动总结 V2】用户点击“立即手动总结”按钮时触发的函数 (支持不同模式)
 * @param {'latest' | 'range'} mode - 总结模式
 * @param {{start: number, end: number} | null} range - 如果是范围模式，则为起始和结束序号
 */
async function triggerManualSummaryNow(mode = 'latest', range = null) {
    if (isSummarizing) {
        alert("正在处理上一个总结任务，请稍候...");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) {
        alert("错误：找不到当前聊天，无法总结。");
        return;
    }
    
    isSummarizing = true; // 上锁

    try {
        let messagesToSummarize = [];

        // --- ▼▼▼ 这就是我们本次修改的核心逻辑 ▼▼▼ ---

        // 1. 根据传入的模式，决定要截取哪些消息
        if (mode === 'latest') {
            const summarySettings = chat.settings.summary;
            const count = (summarySettings && summarySettings.count > 0) ? summarySettings.count : 20;
            messagesToSummarize = chat.history.slice(-count);
            console.log(`手动总结最新 ${count} 条消息...`);
        } else if (mode === 'range' && range) {
            // 注意：数组索引从0开始，而用户输入从1开始，所以需要-1
            messagesToSummarize = chat.history.slice(range.start - 1, range.end);
            console.log(`手动总结从 ${range.start} 到 ${range.end} 的消息...`);
        } else {
            throw new Error("无效的总结模式或范围。");
        }

        // --- ▲▲▲ 修改结束 ▲▲▲ ---

        // 后续的逻辑保持不变
        if (messagesToSummarize.length === 0) {
            alert("选定的范围内没有可总结的聊天记录。");
            isSummarizing = false; // 解锁
            return;
        }
        
        const summaryText = await generateSummary(state.activeChatId, messagesToSummarize);
        
        if (summaryText) {
            await saveSummaryAsMemory(state.activeChatId, summaryText);
            await showCustomAlert('总结完成', '新的对话记忆已生成！');
            if (document.getElementById('summary-viewer-modal').classList.contains('visible')) {
                openSummaryViewer();
            }
        }
    } catch (e) {
        console.error("手动总结过程中发生未捕获的错误:", e);
        await showCustomAlert('错误', '手动总结时发生错误，详情请查看控制台。');
    } finally {
        isSummarizing = false; // 别忘了无论成功失败都要解锁
    }
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】更新角色手机钱包的余额和交易记录
 * @param {string} charId - 要更新钱包的角色ID
 * @param {number} amount - 交易金额 (正数为收入, 负数为支出)
 * @param {string} description - 交易描述 (例如: "转账给 XX", "收到 XX 的红包")
 */
async function updateCharacterBankBalance(charId, amount, description) {
    // 安全检查：如果缺少关键信息，则直接返回
    if (!charId || !amount || isNaN(amount)) {
        console.warn("updateCharacterBankBalance 调用失败：缺少charId或有效的amount。");
        return;
    }

    // 从全局状态中获取角色对象
    const chat = state.chats[charId];
    // 安全检查：确保角色存在且不是群聊
    if (!chat || chat.isGroup) {
        console.warn(`updateCharacterBankBalance 跳过：找不到ID为 ${charId} 的角色或该ID为群聊。`);
        return;
    }

    // --- 确保数据结构完整，兼容旧数据 ---
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {};
    }
    if (!chat.characterPhoneData.bank) {
        chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    }
    // 如果旧数据的余额不是数字，则强制设为0
    if (typeof chat.characterPhoneData.bank.balance !== 'number') {
        chat.characterPhoneData.bank.balance = 0;
    }
    // 如果旧数据的交易记录不是数组，则创建一个空数组
    if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
        chat.characterPhoneData.bank.transactions = [];
    }

    // --- 核心逻辑 ---
    // 1. 创建一条新的交易记录
    const newTransaction = {
        type: amount > 0 ? '收入' : '支出',
        amount: Math.abs(amount), // 交易记录里的金额总是正数
        description: description,
        timestamp: Date.now() // 记录交易发生的时间
    };

    // 2. 更新余额
    chat.characterPhoneData.bank.balance += amount;

    // 3. 将新交易记录添加到列表的开头（让最新的显示在最前面）
    chat.characterPhoneData.bank.transactions.unshift(newTransaction);

    // 4. 将更新后的角色数据保存回数据库
    await db.chats.put(chat);
    
    console.log(`✅ 钱包同步成功: 角色[${chat.name}], 交易[${description}], 金额[${amount.toFixed(2)}], 新余额[${chat.characterPhoneData.bank.balance.toFixed(2)}]`);
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的正上方 ▼▼▼


// ▼▼▼ 【全新】这是角色手机外观设置的所有核心函数，请粘贴到JS功能区 ▼▼▼

/**
 * 【总入口】打开角色手机的外观设置页面
 */
function openCharPhoneAppearanceSettings() {
    renderCharPhoneAppearanceScreen(); // 渲染页面内容
    showCharacterPhonePage('character-phone-appearance-screen'); // 显示页面
    loadCharPhonePresetsToDropdown();
}

/**
 * 【全新 | 已修复】渲染角色手机的外观设置页面
 */
function renderCharPhoneAppearanceScreen() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // --- 渲染壁纸预览 (逻辑不变) ---
    const wallpaperPreview = document.getElementById('char-phone-wallpaper-preview');
    const wallpaperUrl = chat.characterPhoneData.wallpaper || '';
    if (wallpaperUrl) {
        wallpaperPreview.style.backgroundImage = `url(${wallpaperUrl})`;
        wallpaperPreview.textContent = '';
    } else {
        wallpaperPreview.style.backgroundImage = 'none';
        wallpaperPreview.textContent = '暂无壁纸';
    }
// --- 渲染App内壁纸预览 ---
const appWallpaperPreview = document.getElementById('char-phone-app-wallpaper-preview');
const appWallpaperUrl = newAppWallpaperBase64 || chat.characterPhoneData.appWallpaper || '';
if (appWallpaperUrl) {
    appWallpaperPreview.style.backgroundImage = `url(${appWallpaperUrl})`;
    appWallpaperPreview.textContent = '';
} else {
    appWallpaperPreview.style.backgroundImage = 'none';
    appWallpaperPreview.textContent = '点击下方上传';
}
// --- App内壁纸预览渲染结束 ---
    // --- 渲染App图标设置列表 (核心修复) ---
    const iconGrid = document.getElementById('char-phone-icon-settings-grid');
    iconGrid.innerHTML = '';
    const customIcons = chat.characterPhoneData.appIcons || {};

    // ★★★ 我们已经把那行碍事的 `if (app.id === 'appearance') continue;` 删掉了！★★★
    CHAR_PHONE_APPS.forEach(app => {
        const customIconUrl = customIcons[app.id];
        // 使用默认图标作为备用
        const currentIconUrl = customIconUrl || (DEFAULT_APP_ICONS[app.id] || '');
        const currentIconHtml = currentIconUrl ? `<img src="${currentIconUrl}" style="width:100%; height:100%; object-fit:cover;">` : app.svg;
        
        const itemEl = document.createElement('div');
        itemEl.className = 'icon-setting-item'; 
        itemEl.dataset.iconId = app.id; 
        itemEl.innerHTML = `
            <div class="icon-preview" style="width: 50px; height: 50px; border-radius: 12px; display: flex; justify-content: center; align-items: center; padding: 8px; background: #f0f2f5;">
                ${currentIconHtml}
            </div>
            <span style="font-size: 13px;">${app.name}</span>
            <button class="change-icon-btn" data-icon-id="${app.id}" style="padding: 4px 10px; font-size: 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer;">更换</button>
        `;
        iconGrid.appendChild(itemEl);
    });
    
    // --- 渲染小组件预览 (逻辑不变) ---
    const widgets = chat.characterPhoneData.widgets || {};
    const widgetPreview1 = document.getElementById('char-phone-widget-preview-1');
    const widgetPreview2 = document.getElementById('char-phone-widget-preview-2');

    if (widgets.widget1_url) {
        widgetPreview1.style.backgroundImage = `url(${widgets.widget1_url})`;
        widgetPreview1.textContent = '';
    } else {
        widgetPreview1.style.backgroundImage = 'none';
        widgetPreview1.textContent = '点击上传';
    }
    
    if (widgets.widget2_url) {
        widgetPreview2.style.backgroundImage = `url(${widgets.widget2_url})`;
        widgetPreview2.textContent = '';
    } else {
        widgetPreview2.style.backgroundImage = 'none';
        widgetPreview2.textContent = '点击上传';
    }
}



/**
 * 处理角色手机壁纸的更换和移除
 * @param {string} newUrl - 新的壁纸URL，如果为空字符串则表示移除
 */
async function handleCharPhoneWallpaperChange(newUrl) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    chat.characterPhoneData.wallpaper = newUrl;
    await db.chats.put(chat);
    
    // 立即应用壁纸到角色手机主屏幕
    const phoneScreen = document.getElementById('character-phone-screen');
    if (newUrl) {
        phoneScreen.style.backgroundImage = `url(${newUrl})`;
        phoneScreen.style.backgroundColor = 'transparent';
    } else {
        phoneScreen.style.backgroundImage = 'none';
        const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
        phoneScreen.style.backgroundColor = isDarkMode ? '#000' : '#f0f2f5';
    }
    
    // 刷新设置页面的预览
    renderCharPhoneAppearanceScreen();
    alert(newUrl ? '壁纸已更新！' : '壁纸已移除！');
}

/**
 * 处理角色手机App图标的更换
 * @param {string} iconId - 要更换的App的ID
 */
async function handleChangeCharPhoneIcon(iconId) {
    if (!activeCharacterPhoneId) return;
    
    const choice = await showChoiceModal("更换图标", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' },
        { text: '🔄 恢复默认', value: 'reset' }
    ]);

    let newIconUrl = null;

    if (choice === 'local') {
        newIconUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newIconUrl = await showCustomPrompt("图标URL", "请输入图片链接");
    } else if (choice === 'reset') {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat.characterPhoneData.appIcons && chat.characterPhoneData.appIcons[iconId]) {
            delete chat.characterPhoneData.appIcons[iconId];
            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen();
            renderCharacterAppGrid();
            alert('图标已恢复默认。');
        }
        return;
    }

    if (newIconUrl && newIconUrl.trim()) {
        const chat = state.chats[activeCharacterPhoneId];
        if (!chat.characterPhoneData.appIcons) {
            chat.characterPhoneData.appIcons = {};
        }
        chat.characterPhoneData.appIcons[iconId] = newIconUrl.trim();
        await db.chats.put(chat);
        
        renderCharPhoneAppearanceScreen(); // 刷新设置页面
        renderCharacterAppGrid(); // 刷新主屏幕
        alert('图标已更新！');
    }
}

// ▲▲▲ 新增函数粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼

let currentViewingWeiboProfileId = null; // 全局变量，记录正在查看哪个角色的主页

/**
 * 【全新】打开指定角色的微博主页
 * @param {string} charId - 要查看的角色的ID
 */
async function openWeiboCharProfile(charId) {
    currentViewingWeiboProfileId = charId;
    const chat = state.chats[charId];
    if (!chat) return;

    // 渲染角色主页内容
    await renderWeiboCharProfile(charId);
    
    // 渲染该角色的微博Feed
    await renderCharSpecificFeed(charId);

    // 切换到角色主页屏幕
    showScreen('weibo-char-profile-screen');
    
    // 隐藏关注列表弹窗（如果它还开着）
    document.getElementById('weibo-following-modal').classList.remove('visible');
}

/**
 * 【全新】渲染角色微博主页的个人资料部分 (V2 - 支持粉丝/关注数)
 * @param {string} charId - 角色的ID
 */
async function renderWeiboCharProfile(charId) {
    const chat = state.chats[charId];
    if (!chat) return;

    // 渲染基础信息（这部分不变）
    document.getElementById('weibo-char-profile-title').textContent = `${chat.name}的主页`;
    document.getElementById('weibo-char-avatar-img').src = chat.settings.weiboAvatar || chat.settings.aiAvatar;
    document.getElementById('weibo-char-nickname').textContent = chat.settings.weiboNickname || chat.name;
    document.getElementById('weibo-char-background-img').src = chat.settings.weiboBackground;
    document.getElementById('weibo-char-profession-display').textContent = chat.settings.weiboProfession || '职业未设定';
    
    // --- ▼▼▼ 这就是我们新增的核心逻辑 ▼▼▼ ---

    // 1. 从设置中读取关注数和粉丝数
    document.getElementById('weibo-char-following-count').textContent = chat.settings.weiboFollowingCount || '0';
    document.getElementById('weibo-char-fans-count').textContent = chat.settings.weiboFansCount || '0';

    // 2. 动态计算并显示微博数
    const postCount = await db.weiboPosts.where('authorId').equals(charId).count();
    document.getElementById('weibo-char-posts-count').textContent = postCount;
    
    // --- ▲▲▲ 新增逻辑结束 ▲▲▲ ---

    // 渲染头像框 (这部分不变)
    const frameImg = document.getElementById('weibo-char-avatar-frame');
    const frameUrl = chat.settings.weiboAvatarFrame || '';
    if (frameUrl) {
        frameImg.src = frameUrl;
        frameImg.style.display = 'block';
    } else {
        frameImg.style.display = 'none';
    }
}


/**
 * 【全新】渲染指定角色的微博Feed
 * @param {string} charId - 角色的ID
 */
async function renderCharSpecificFeed(charId) {
    const feedEl = document.getElementById('char-weibo-feed-list');
    feedEl.innerHTML = '';
    
    const posts = await db.weiboPosts.where('authorId').equals(charId).reverse().sortBy('timestamp');
    
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">Ta 还没有发过微博哦。</p>';
        return;
    }

    posts.forEach(post => {
        // 复用我们强大的微博帖子创建函数
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

/**
 * 【全新】打开角色微博资料的编辑器
 */
async function openCharWeiboEditor() {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 填充当前数据到编辑器
    document.getElementById('char-weibo-editor-avatar-preview').src = chat.settings.weiboAvatar || chat.settings.aiAvatar;
    document.getElementById('char-weibo-editor-nickname-input').value = chat.settings.weiboNickname || chat.name;
    document.getElementById('char-weibo-editor-bg-preview').src = chat.settings.weiboBackground;

    // 显示弹窗
    document.getElementById('char-weibo-editor-modal').classList.add('visible');
}

/**
 * 【全新】保存对角色微博资料的修改
 */
async function saveCharWeiboProfile() {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 从编辑器获取新数据
    chat.settings.weiboAvatar = document.getElementById('char-weibo-editor-avatar-preview').src;
    chat.settings.weiboNickname = document.getElementById('char-weibo-editor-nickname-input').value.trim();
    chat.settings.weiboBackground = document.getElementById('char-weibo-editor-bg-preview').src;

    // 保存到数据库
    await db.chats.put(chat);
    
    // 刷新主页显示
    await renderWeiboCharProfile(currentViewingWeiboProfileId);
    
    document.getElementById('char-weibo-editor-modal').classList.remove('visible');
    alert('角色微博资料已保存！');
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲
// ▼▼▼ 在 const db = ... 的正上方，粘贴下面这一整块新代码 ▼▼▼

/**
 * 【全新】根据角色人设和职业，生成初始的微博关注数和粉丝数
 * @param {object} chat - 角色的聊天对象
 * @returns {{following: string, fans: string}}
 */
function getInitialWeiboStats(chat) {
    const persona = (chat.settings.aiPersona || '') + (chat.settings.weiboProfession || '');
    const keywords = ["偶像", "明星", "演员", "歌手", "博主", "网红", "UP主", "主播", "选手", "画家", "作家"];
    const isPublicFigure = keywords.some(keyword => persona.includes(keyword));

    let fansCount, followingCount;

    if (isPublicFigure) {
        fansCount = Math.floor(100000 + Math.random() * 9900000); // 10万 - 1000万
        followingCount = Math.floor(50 + Math.random() * 450); // 50 - 500
    } else {
        fansCount = Math.floor(100 + Math.random() * 4900); // 100 - 5000
        followingCount = Math.floor(50 + Math.random() * 250); // 50 - 300
    }

    return {
        fans: formatNumberToChinese(fansCount),
        following: formatNumberToChinese(followingCount)
    };
}

/**
 * 【全新】将数字格式化为带“万”或“亿”的字符串
 * @param {number} num - 原始数字
 * @returns {string} - 格式化后的字符串
 */
function formatNumberToChinese(num) {
    if (num >= 100000000) {
        return (num / 100000000).toFixed(1).replace(/\.0$/, '') + '亿';
    }
    if (num >= 10000) {
        return (num / 10000).toFixed(1).replace(/\.0$/, '') + '万';
    }
    return String(num);
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【最终修复版】用这整块代码，完整替换你旧的 playMinimaxAudio 函数 ▼▼▼
let isIntentionalStop = false;
// ▼▼▼ 步骤 1：添加或替换这两行代码 ▼▼▼
let isTtsPlaying = false; // 全局锁，true表示有语音正在播放或加载
let currentTtsAudioBubble = null; // 记录当前正在播放动画或音频的气泡元素
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 第1步：在这里粘贴下面这个【全新的】辅助函数 ▼▼▼
/**
 * 【全新】查找从指定位置开始的所有连续AI语音消息
 * @param {Array} history - 完整的聊天历史记录数组
 * @param {number} startIndex - 开始查找的索引位置
 * @returns {Array} - 一个包含所有连续AI语音消息对象的数组
 */
function findConsecutiveAiVoiceMessages(history, startIndex) {
    const messagesToPlay = [];
    if (startIndex < 0 || startIndex >= history.length) {
        return messagesToPlay;
    }

    // 从点击的那条消息开始，向后遍历
    for (let i = startIndex; i < history.length; i++) {
        const msg = history[i];
        // 检查这条消息是否是AI发送的，并且类型是语音
        if (msg.role === 'assistant' && msg.type === 'voice_message') {
            messagesToPlay.push(msg); // 如果是，就把它加入待播放列表
        } else {
            // 一旦遇到不是AI语音的消息（比如用户的回复，或AI的图片/文字消息），就立刻停止查找
            break;
        }
    }
    return messagesToPlay;
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 第1步：在这里粘贴这个【全新的】停止函数 ▼▼▼

// ▼▼▼ 第2步：用这整块【V2 - 精准停止版】代码，完整替换旧的 stopMinimaxAudio 函数 ▼▼▼

/**
 * 【V2 - 精准停止版】停止当前正在播放的Minimax TTS语音
 */
function stopMinimaxAudio() {
    if (!isTtsPlaying) return;

    // 核心修改1：在执行停止操作前，先设置“故意停止”的标志为 true
    isIntentionalStop = true;

    const ttsPlayer = document.getElementById('tts-audio-player');
    ttsPlayer.pause();
    ttsPlayer.src = ''; // 这行代码会触发 onerror 事件

    if (window.currentAnimatingBubbles) {
        window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
    }

    isTtsPlaying = false;
    currentTtsAudioBubble = null;
    window.currentAnimatingBubbles = null;
    console.log('Minimax TTS: Playback stopped by user.');

    // 核心修改2：用一个微小的延迟来重置标志位
    // 这能确保 onerror 事件有足够的时间检查到标志位，然后再将其重置
    setTimeout(() => {
        isIntentionalStop = false;
    }, 100);
}

// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 第3步：用这整块【V8 - 错误处理终极版】代码，完整替换旧的 playMinimaxAudio 函数 ▼▼▼

// ▼▼▼ 用这块【新代码】替换旧的 playMinimaxAudio 函数 ▼▼▼
/**
 * 【V9 - 全局模型版】调用 Minimax TTS API 生成语音并播放
 * @param {string} text - 要转换为语音的合并后的文本
 * @param {string} voiceId - Minimax 的语音 ID
 * @param {Array<HTMLElement>} bubblesToAnimate - 需要播放动画的所有语音气泡元素的数组
 */
async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
    stopMinimaxAudio();
    await new Promise(resolve => setTimeout(resolve, 50));

    const ttsPlayer = document.getElementById('tts-audio-player');
    const firstBubble = bubblesToAnimate[0];

    isTtsPlaying = true;
    currentTtsAudioBubble = firstBubble;
    window.currentAnimatingBubbles = bubblesToAnimate;
    bubblesToAnimate.forEach(b => b.classList.add('playing'));

    const mainAudioPlayer = document.getElementById('audio-player');
    if (mainAudioPlayer && !mainAudioPlayer.paused) {
        mainAudioPlayer.pause();
        musicState.isPlaying = false;
        updatePlayerUI();
    }

    const groupId = state.apiConfig.minimaxGroupId;
    const apiKey = state.apiConfig.minimaxApiKey;
    if (!groupId || !apiKey) {
        await showCustomAlert('语音播放失败', '尚未配置Minimax的Group ID和API Key。');
        stopMinimaxAudio();
        return;
    }

    // ★★★ 核心修改：从全局 apiConfig 获取语音模型 ★★★
    const speechModel = state.apiConfig.minimaxSpeechModel || 'speech-01';
    console.log(`正在使用 Minimax 语音模型: ${speechModel}`);

    try {
        const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                text: text, 
                voice_id: voiceId, 
                model: speechModel, // ★★★ 使用我们获取到的模型变量 ★★★
                speed: 1.0, 
                pitch: 0, 
                timber_list: [] 
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Minimax API 错误: ${errorData.base_resp?.status_msg || response.statusText}`);
        }
        const contentType = response.headers.get('Content-Type');
        if (!contentType || !contentType.startsWith('audio/')) {
            const errorData = await response.json().catch(() => response.text());
            throw new Error(`Minimax API 未返回有效的音频文件，而是返回了: ${JSON.stringify(errorData)}`);
        }
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;
        
        const cleanupAndReset = () => {
            if (isTtsPlaying) {
                isTtsPlaying = false;
                URL.revokeObjectURL(audioUrl); 
                if (window.currentAnimatingBubbles) {
                    window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
                }
                currentTtsAudioBubble = null;
                window.currentAnimatingBubbles = null;
            }
        };

       ttsPlayer.onended = cleanupAndReset;
        
        ttsPlayer.onerror = (e) => {
             if (!isIntentionalStop) {
                 console.error("TTS音频播放时发生错误，已自动切换为文本显示:", e);
             } else {
                 console.log("Intentional stop triggered error event, alert skipped.");
             }
             cleanupAndReset();
        };

        await ttsPlayer.play();

    } catch (error) {
        console.error("Minimax TTS 调用失败:", error);
        await showCustomAlert('语音合成失败', `错误信息: ${error.message}`);
        stopMinimaxAudio();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】角色手机外观预设功能核心函数 ▼▼▼

/**
 * 启用或禁用角色手机预设管理按钮
 * @param {boolean} isEnabled - 是否启用
 */
function toggleCharPhonePresetButtons(isEnabled) {
    document.getElementById('apply-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('update-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('rename-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('export-char-phone-preset-btn').disabled = !isEnabled;
}

/**
 * 加载角色手机外观预设到下拉框
 */
async function loadCharPhonePresetsToDropdown() {
    const selector = document.getElementById('char-phone-preset-selector');
    if (!selector) return;
    selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
    const presets = await db.charPhonePresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    activeCharPhonePresetId = null;
    toggleCharPhonePresetButtons(false);
}

/**
 * 当用户从下拉框选择一个预设时触发
 */
function handleCharPhonePresetSelection() {
    const selector = document.getElementById('char-phone-preset-selector');
    activeCharPhonePresetId = selector.value ? parseInt(selector.value) : null;
    toggleCharPhonePresetButtons(!!activeCharPhonePresetId);
}

// ▼▼▼ 用这块【修复后】的代码，完整替换你旧的 applySelectedCharPhonePreset 函数 ▼▼▼
async function applySelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) {
        alert("请先从下拉框中选择一个要应用的预设。");
        return;
    }
    if (!activeCharacterPhoneId) {
        alert("错误：没有找到当前正在操作的角色手机。");
        return;
    }
    const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const chat = state.chats[activeCharacterPhoneId];

    if (preset && preset.data && chat) {
        // 将预设数据深拷贝一份，应用到角色的手机数据上
        chat.characterPhoneData.wallpaper = preset.data.wallpaper || '';
        chat.characterPhoneData.appIcons = { ...DEFAULT_APP_ICONS, ...(preset.data.appIcons || {}) };
        chat.characterPhoneData.widgets = { ...(preset.data.widgets || {}) };
        
        // ★★★ 这就是我们新增的一行！★★★
        chat.characterPhoneData.appWallpaper = preset.data.appWallpaper || '';

        await db.chats.put(chat);
        
        // 刷新手机界面以显示新外观
        openCharacterPhone(activeCharacterPhoneId);
        
        // 刷新外观设置页面，以便预览和数据同步
        renderCharPhoneAppearanceScreen();

        alert(`已成功为“${chat.name}”应用预设: "${preset.name}"！`);
    } else {
        alert("应用预设失败，找不到预设或角色数据。");
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 保存当前角色手机的外观设置为一个新的预设
 */
async function saveCurrentCharPhonePreset() {
    if (!activeCharacterPhoneId) return;

    const presetName = await showCustomPrompt("保存预设", "请为这个外观方案起个名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能为空！");
        return;
    }

    const chat = state.chats[activeCharacterPhoneId];
    // 从当前角色的数据中提取外观设置
    const presetData = {
        wallpaper: chat.characterPhoneData.wallpaper || '',
        appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
        widgets: { ...(chat.characterPhoneData.widgets || {}) },
        appWallpaper: chat.characterPhoneData.appWallpaper || '',
    };

    await db.charPhonePresets.add({ name: presetName.trim(), data: presetData });
    await loadCharPhonePresetsToDropdown();
    alert(`外观预设 "${presetName.trim()}" 已保存！`);
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId || !activeCharacterPhoneId) return;

    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "确认更新",
        `确定要用当前手机的外观覆盖预设 "${currentPreset.name}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        const presetData = {
            wallpaper: chat.characterPhoneData.wallpaper || '',
            appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
            widgets: { ...(chat.characterPhoneData.widgets || {}) },
            appWallpaper: chat.characterPhoneData.appWallpaper || '',
        };
        await db.charPhonePresets.update(activeCharPhonePresetId, { data: presetData });
        await showCustomAlert('成功', `预设 "${currentPreset.name}" 已更新！`);
    }
}

/**
 * 重命名选中的预设
 */
async function renameSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.charPhonePresets.update(activeCharPhonePresetId, { name: newName.trim() });
        await loadCharPhonePresetsToDropdown();
        document.getElementById('char-phone-preset-selector').value = activeCharPhonePresetId;
        alert("重命名成功！");
    }
}

/**
 * 删除选中的预设
 */
async function deleteSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.charPhonePresets.delete(activeCharPhonePresetId);
        await loadCharPhonePresetsToDropdown();
        alert("预设已删除。");
    }
}

/**
 * 导出选中的预设
 */
async function exportCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[CharPhone]${preset.name}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 导入预设文件
 */
function importCharPhonePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.name && data.data) {
                await db.charPhonePresets.add({ name: `${data.name} (导入)`, data: data.data });
                await loadCharPhonePresetsToDropdown();
                alert(`预设 "${data.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 角色手机外观预设功能函数结束 ▲▲▲
// ▼▼▼ 把下面这一整块全新的代码，粘贴到 init() 函数的上方 ▼▼▼

/**
 * [全新] 在外观设置页面渲染出所有App的名称设置项
 */
function renderAppNameSettings() {
    const grid = document.getElementById('icon-rename-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = state.globalSettings.appLabels || {};

    // 遍历默认标签对象，以确保所有app都有设置项
    for (const appId in DEFAULT_APP_LABELS) {
        if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
            const defaultName = DEFAULT_APP_LABELS[appId];
            const currentName = appLabels[appId] || defaultName;

            const item = document.createElement('div');
            item.className = 'form-group';
            item.style.marginBottom = '0'; // 让布局更紧凑
            item.innerHTML = `
                <label for="rename-input-${appId}">${defaultName}</label>
                <input type="text" id="rename-input-${appId}" class="app-rename-input" data-appid="${appId}" value="${currentName}">
            `;
            grid.appendChild(item);
        }
    }
}

/**
 * [全新] 将保存的App名称应用到主屏幕的图标上
 */
function applyAppLabels() {
    const appLabels = state.globalSettings.appLabels || {};
    
    for (const appId in DEFAULT_APP_LABELS) {
        if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
            const defaultName = DEFAULT_APP_LABELS[appId];
            const customName = appLabels[appId] || defaultName;

            // 这个选择器会同时找到主屏幕和Dock栏上的所有图标
            const icons = document.querySelectorAll(`.desktop-app-icon [id="icon-img-${appId}"]`);
            
            icons.forEach(iconImg => {
                const appIconContainer = iconImg.closest('.desktop-app-icon');
                if (appIconContainer) {
                    const labelElement = appIconContainer.querySelector('.label');
                    if (labelElement) {
                        labelElement.textContent = customName;
                    }
                }
            });
        }
    }
}

/**
 * [全新] 从输入框读取并保存用户修改的App名称
 */
function saveAppLabels() {
    const appNameInputs = document.querySelectorAll('.app-rename-input');
    if (!state.globalSettings.appLabels) {
        state.globalSettings.appLabels = {};
    }

    appNameInputs.forEach(input => {
        const appId = input.dataset.appid;
        const newName = input.value.trim();
        const defaultName = DEFAULT_APP_LABELS[appId];

        // 如果用户输入了新名字，且和默认名字不一样，就保存
        if (newName && newName !== defaultName) {
            state.globalSettings.appLabels[appId] = newName;
        } else {
            // 如果用户清空了输入框，或者改回了默认名字，就删除保存记录，以恢复默认
            delete state.globalSettings.appLabels[appId];
        }
    });
}


// ▼▼▼ 请用这整块【全新修复版】代码，替换掉你旧的 handleImportSillyTavernWorldBook 函数 ▼▼▼
/**
 * 【全新 | 已修复】处理导入的SillyTavern世界书文件
 * @param {File} file - 用户选择的JSON文件
 */
async function handleImportSillyTavernWorldBook(file) {
    // 使用FileReader来读取文件内容
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            const data = JSON.parse(text);

            // 验证文件格式是否正确，确保包含'entries'对象
            if (!data.entries || typeof data.entries !== 'object') {
                throw new Error("文件格式无效。SillyTavern世界书应包含'entries'对象。");
            }

            // 从文件名提取名称，作为新的分类名
            let categoryName = file.name.replace(/\.(json|jsonl)$/i, '').trim();
            if (!categoryName) categoryName = '导入的世界书';

            // 检查该分类是否已存在，如果不存在则创建
            let category = await db.worldBookCategories.where('name').equals(categoryName).first();
            if (!category) {
                const newCategoryId = await db.worldBookCategories.add({ name: categoryName });
                category = { id: newCategoryId, name: categoryName };
                console.log(`创建了新的世界书分类: ${categoryName} (ID: ${newCategoryId})`);
            } else {
                console.log(`将条目添加到已存在的分类: ${categoryName} (ID: ${category.id})`);
            }

            const newBooks = [];
            // 遍历SillyTavern worldbook中的所有条目
            for (const key in data.entries) {
                const entry = data.entries[key];
                
                // ★★★ 核心修改：移除了 !entry.disable 的检查，现在会导入所有条目 ★★★
                if (entry) { 
                    // 使用entry.comment作为书名，如果为空则使用"条目 key"作为备用
                    const entryName = (entry.comment || `条目 ${key}`).trim();
                    const entryContent = (entry.content || '').trim();
                    // 确保书名和内容都不为空
                    if (entryName && entryContent) {
                        newBooks.push({
                            id: 'wb_' + Date.now() + Math.random(), // 创建唯一ID
                            name: entryName,
                            content: entryContent,
                            categoryId: category.id // 归属到新的分类
                        });
                    }
                }
            }

            if (newBooks.length === 0) {
                alert('没有找到任何可导入的有效条目。');
                return;
            }
            
            // 批量将新书添加到数据库，效率更高
            await db.worldBooks.bulkAdd(newBooks);
            // 更新内存中的state，以便UI能立即刷新
            state.worldBooks.push(...newBooks); 

            // 重新渲染世界书列表，显示新内容
            await renderWorldBookScreen();
            await showCustomAlert('导入成功', `成功将《${categoryName}》中的 ${newBooks.length} 个条目导入到世界书！`);

        } catch (error) {
            console.error("导入世界书失败:", error);
            await showCustomAlert('导入失败', `无法解析文件，请确保它是有效的SillyTavern世界书JSON文件。\n\n错误: ${error.message}`);
        }
    };
    // 以UTF-8编码读取文件内容
    reader.readAsText(file, 'UTF-8');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】心声背景更换功能的核心函数 ▼▼▼

/**
 * 【总入口】当用户点击“更换背景”按钮时，弹出操作菜单
 */
async function handleInnerVoiceBgChange() {
    const choice = await showChoiceModal("更换心声背景", [
        { text: '上传新背景', value: 'upload' },
        { text: '恢复默认', value: 'reset' }
    ]);

    if (choice === 'upload') {
        // 触发隐藏的文件选择器
        document.getElementById('inner-voice-bg-input').click();
    } else if (choice === 'reset') {
        // 调用保存函数并传入空字符串，表示恢复默认
        await saveInnerVoiceBackground('');
    }
}

// ▼▼▼ 用这块【V2 - 角色独立版】代码，完整替换旧的 saveInnerVoiceBackground 函数 ▼▼▼
/**
 * 【V2】保存新的背景图片URL到【当前角色】
 * @param {string} url - 图片的URL (可以是网络链接或Base64)
 */
async function saveInnerVoiceBackground(url) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 【核心修改】将背景URL保存在当前角色的数据中
    chat.innerVoiceBackground = url;

    // 2. 将更新后的整个 chat 对象保存回数据库
    await db.chats.put(chat);

    // 3. 立即应用新的背景
    applyInnerVoiceBackground(url);

    // 4. 给用户一个反馈
    alert(url ? '当前角色背景已更新！' : '当前角色背景已恢复默认。');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 将指定的背景图应用到心声面板上
 * @param {string} url - 图片的URL
 */
function applyInnerVoiceBackground(url) {
    const panel = document.getElementById('inner-voice-main-panel');
    if (!panel) return;

    if (url) {
        panel.style.backgroundImage = `url(${url})`;
    } else {
        // 如果URL为空，就移除背景图，恢复CSS中定义的默认样式
        panel.style.backgroundImage = 'none';
    }
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

/**
 * [全新] 估算文本的Token数 (按字符数计算)
 * @param {string} text - 要计算的文本
 * @returns {number} - 估算的token数
 */
function calculateTokenCount(text) {
    if (!text) return 0;
    // 这是一个非常简化的估算，直接返回字符数。
    // 对于中文，一个字约等于1-2个token。对于英文，一个词约等于1.3个token。
    // 直接用字符数作为一个简单直观的参考值。
    return text.length;
}
/**
 * [全新] 为Token计算准备完整的上下文和提示词
 * @param {string} chatId - 目标聊天的ID
 * @returns {Promise<string>} - 拼接好的、将要发送给AI的完整文本
 */
async function getContextForTokenCalculation(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return '';

    let combinedText = '';
    const settings = chat.settings;

    // 1. 添加核心提示词 (人设)
    if(chat.isGroup) {
        const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
        const myNickname = chat.settings.myNickname || '我';
        combinedText += `你是一个群聊AI... # 群成员列表及人设\n${membersList}\n# 用户的角色\n- **${myNickname}**: ${chat.settings.myPersona}`;
    } else {
        combinedText += chat.settings.aiPersona || '';
        combinedText += chat.settings.myPersona || '';
    }

    // 2. 添加世界书内容
    if (settings.linkedWorldBookIds && settings.linkedWorldBookIds.length > 0) {
        const linkedContents = settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook ? worldBook.content : '';
        }).join('\n');
        combinedText += linkedContents;
    }
    
    // 3. 添加所有总结作为长期记忆
    const summaryContext = chat.history.filter(msg => msg.type === 'summary').map(s => s.content).join('\n');
    combinedText += summaryContext;

    // 4. 添加最近的对话记录 (上下文记忆)
    const history = chat.history.filter(msg => !msg.isHidden);
    const memoryDepth = settings.maxMemory || 10;
    const contextMessages = history.slice(-memoryDepth);

    const messageText = contextMessages.map(msg => {
        let content = '';
        if (typeof msg.content === 'string') {
            content = msg.content;
        } else if (Array.isArray(msg.content)) {
            content = '[图片]'; // 将图片简化为占位符
        } else if (msg.type) {
            content = `[${msg.type}]`;
        }
        const sender = msg.role === 'user' ? '用户' : (msg.senderName || chat.name);
        return `${sender}: ${content}`;
    }).join('\n');

    combinedText += '\n' + messageText;
    
    return combinedText;
}
/**
 * 【全新】清理所有与已删除角色关联的失效数据
 */
async function clearOrphanedData() {
    // 1. 在执行敏感操作前，先弹窗向用户确认
    const confirmed = await showCustomConfirm(
        '确认清理',
        '此操作将扫描并删除所有与【已不存在的角色】关联的数据（如动态、微博、回忆、通话记录等），释放存储空间。\n\n此操作不可撤销，确定要继续吗？',
        { confirmButtonClass: 'btn-danger' } // 使用醒目的红色按钮
    );

    // 如果用户点了“取消”，则直接退出
    if (!confirmed) return;

    // 显示一个“处理中”的提示，避免用户以为程序卡死
    await showCustomAlert("请稍候...", "正在扫描并清理失效数据...");

    try {
        let totalDeletedCount = 0;

        // 2. 获取所有仍然存在的、有效的角色ID列表
        const validChatIds = new Set((await db.chats.toArray()).map(c => c.id));
        validChatIds.add('user'); // 'user' (即“我”) 永远是有效的作者

        // 3. 定义我们需要检查的数据库表和它们用来关联角色ID的字段名
        const tablesToCheck = [
            { name: 'qzonePosts', idField: 'authorId', typeName: '动态' },
            { name: 'weiboPosts', idField: 'authorId', typeName: '微博' },
            { name: 'memories', idField: 'chatId', typeName: '回忆/约定' },
            { name: 'callRecords', idField: 'chatId', typeName: '通话记录' }
        ];

        // 4. 遍历每一个需要检查的表
        for (const tableInfo of tablesToCheck) {
            const table = db[tableInfo.name];
            const allItems = await table.toArray();
            
            // 找出所有作者ID已经不存在的“孤儿”数据
            const idsToDelete = allItems
                .filter(item => !validChatIds.has(item[tableInfo.idField]))
                .map(item => item.id);

            // 如果找到了需要删除的数据
            if (idsToDelete.length > 0) {
                await table.bulkDelete(idsToDelete); // 批量删除，效率更高
                console.log(`从 ${tableInfo.name} 表中清除了 ${idsToDelete.length} 条失效数据。`);
                totalDeletedCount += idsToDelete.length;
            }
        }

        // 5. 根据清理结果，给用户最终的反馈
        if (totalDeletedCount > 0) {
            await showCustomAlert('清理完成', `已成功清理 ${totalDeletedCount} 条失效数据！`);
        } else {
            await showCustomAlert('扫描完成', '未发现任何可清理的失效数据。');
        }

    } catch (error) {
        console.error("清理失效数据时出错:", error);
        await showCustomAlert('操作失败', `清理过程中发生错误: ${error.message}`);
    }
}

// ▼▼▼ 定时导出提醒功能 ▼▼▼
/**
 * 定时导出提醒配置键
 */
const EXPORT_REMINDER_CONFIG_KEY = 'exportReminderConfig';

/**
 * 定时器ID
 */
let exportReminderIntervalId = null;

/**
 * 加载定时导出提醒配置
 */
function loadExportReminderConfig() {
    const configStr = localStorage.getItem(EXPORT_REMINDER_CONFIG_KEY);
    if (configStr) {
        try {
            return JSON.parse(configStr);
        } catch (e) {
            console.error('加载定时导出提醒配置失败:', e);
        }
    }
    return {
        enabled: false,
        time: '20:00'
    };
}

/**
 * 保存定时导出提醒配置
 */
function saveExportReminderSettings() {
    const enabled = document.getElementById('export-reminder-toggle').checked;
    const time = document.getElementById('export-reminder-time').value || '20:00';
    
    // 获取旧配置，检查时间是否改变
    const oldConfig = loadExportReminderConfig();
    const timeChanged = oldConfig.time !== time;
    
    const config = {
        enabled: enabled,
        time: time
    };
    
    localStorage.setItem(EXPORT_REMINDER_CONFIG_KEY, JSON.stringify(config));
    
    // 如果时间改变了，清除今天已提醒的记录，让新时间可以立即生效
    if (timeChanged) {
        localStorage.removeItem('exportReminderLastDate');
        console.log(`[定时导出提醒] 时间已更改为 ${time}，清除今天的提醒记录`);
    }
    
    // 重新启动定时器
    if (enabled) {
        startExportReminderTimer();
    }
}

/**
 * 处理开关切换
 */
function handleExportReminderToggle(e) {
    const enabled = e.target.checked;
    const settingsDiv = document.getElementById('export-reminder-settings');
    
    if (enabled) {
        settingsDiv.style.display = 'block';
        // 启用时清除今天的提醒记录，允许立即测试
        localStorage.removeItem('exportReminderLastDate');
        console.log('[定时导出提醒] 功能已启用，清除今天的提醒记录');
        startExportReminderTimer();
    } else {
        settingsDiv.style.display = 'none';
        stopExportReminderTimer();
    }
    
    saveExportReminderSettings();
}

/**
 * 启动定时导出提醒定时器
 */
function startExportReminderTimer() {
    // 先停止现有定时器
    stopExportReminderTimer();
    
    // 每分钟检查一次是否到了提醒时间
    exportReminderIntervalId = setInterval(async () => {
        try {
            await checkExportReminder();
        } catch (error) {
            console.error('[定时导出提醒] 检查时出错:', error);
        }
    }, 60000); // 每60秒检查一次
    
    // 立即检查一次
    checkExportReminder().catch(error => {
        console.error('[定时导出提醒] 初始检查时出错:', error);
    });
    
    console.log('[定时导出提醒] 定时器已启动，每60秒检查一次');
}

/**
 * 停止定时导出提醒定时器
 */
function stopExportReminderTimer() {
    if (exportReminderIntervalId) {
        clearInterval(exportReminderIntervalId);
        exportReminderIntervalId = null;
    }
}

/**
 * 检查是否到了提醒时间
 */
async function checkExportReminder() {
    const config = loadExportReminderConfig();
    
    if (!config.enabled) {
        return;
    }
    
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentTime = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
    
    // 解析配置的时间
    const [targetHour, targetMinute] = config.time.split(':').map(Number);
    
    // 检查今天是否已经提醒过
    const lastReminderDate = localStorage.getItem('exportReminderLastDate');
    const todayDate = now.toDateString();
    
    // 时间匹配：当前时间与目标时间相同
    const timeMatches = currentHour === targetHour && currentMinute === targetMinute;
    
    console.log(`[定时导出提醒] 检查中... 当前时间: ${currentTime}, 目标时间: ${config.time}, 匹配: ${timeMatches}, 今天已提醒: ${lastReminderDate === todayDate}`);
    
    if (timeMatches && lastReminderDate !== todayDate) {
        // 记录今天已提醒
        localStorage.setItem('exportReminderLastDate', todayDate);
        
        console.log('[定时导出提醒] 触发提醒！');
        
        // 弹出提醒
        const userConfirmed = await showCustomConfirm(
            '⏰ 导出数据提醒',
            '是否现在导出数据备份？\n定期备份数据可以避免数据丢失。',
            { confirmButtonText: '立即导出', cancelButtonText: '稍后再说' }
        );
        
        if (userConfirmed) {
            // 用户点击了"立即导出"，触发导出功能
            exportBackup();
        }
    }
}

/**
 * 初始化定时导出提醒功能
 */
function initExportReminder() {
    const config = loadExportReminderConfig();
    
    // 设置UI状态
    const toggle = document.getElementById('export-reminder-toggle');
    const timeInput = document.getElementById('export-reminder-time');
    const settingsDiv = document.getElementById('export-reminder-settings');
    
    if (toggle && timeInput && settingsDiv) {
        // 恢复保存的设置
        toggle.checked = config.enabled;
        timeInput.value = config.time;
        
        // 显示/隐藏设置面板
        if (config.enabled) {
            settingsDiv.style.display = 'block';
            startExportReminderTimer();
        } else {
            settingsDiv.style.display = 'none';
        }
        
        // 绑定事件监听器
        toggle.addEventListener('change', handleExportReminderToggle);
        timeInput.addEventListener('change', saveExportReminderSettings);
        
        // 绑定重置按钮
        const resetBtn = document.getElementById('reset-reminder-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                localStorage.removeItem('exportReminderLastDate');
                console.log('[定时导出提醒] 已手动清除今天的提醒记录');
                showCustomAlert('重置成功', '已清除今天的提醒记录，现在可以再次测试提醒功能了。');
            });
        }
        
        console.log(`[定时导出提醒] 功能已${config.enabled ? '启用' : '禁用'}，提醒时间: ${config.time}`);
    } else {
        console.error('[定时导出提醒] 初始化失败：找不到必需的DOM元素');
    }
}
// ▲▲▲ 定时导出提醒功能结束 ▲▲▲

// ▼▼▼ 定时自动导出功能 ▼▼▼
/**
 * 定时自动导出配置键
 */
const AUTO_EXPORT_CONFIG_KEY = 'autoExportConfig';

/**
 * 定时器ID
 */
let autoExportIntervalId = null;

/**
 * 加载定时自动导出配置
 */
function loadAutoExportConfig() {
    const configStr = localStorage.getItem(AUTO_EXPORT_CONFIG_KEY);
    if (configStr) {
        try {
            return JSON.parse(configStr);
        } catch (e) {
            console.error('加载定时自动导出配置失败:', e);
        }
    }
    return {
        enabled: false,
        time: '22:00',
        path: ''
    };
}

/**
 * 保存定时自动导出配置
 */
function saveAutoExportSettings() {
    const enabled = document.getElementById('auto-export-toggle').checked;
    const time = document.getElementById('auto-export-time').value || '22:00';
    const path = document.getElementById('auto-export-path').value || '';
    
    // 获取旧配置，检查时间是否改变
    const oldConfig = loadAutoExportConfig();
    const timeChanged = oldConfig.time !== time;
    
    const config = {
        enabled: enabled,
        time: time,
        path: path
    };
    
    localStorage.setItem(AUTO_EXPORT_CONFIG_KEY, JSON.stringify(config));
    
    // 如果时间改变了，清除今天已导出的记录
    if (timeChanged) {
        localStorage.removeItem('autoExportLastDate');
        console.log(`[定时自动导出] 时间已更改为 ${time}，清除今天的导出记录`);
    }
    
    // 重新启动定时器
    if (enabled) {
        startAutoExportTimer();
    }
}

/**
 * 处理开关切换
 */
function handleAutoExportToggle(e) {
    const enabled = e.target.checked;
    const settingsDiv = document.getElementById('auto-export-settings');
    
    if (enabled) {
        settingsDiv.style.display = 'block';
        // 启用时清除今天的导出记录
        localStorage.removeItem('autoExportLastDate');
        console.log('[定时自动导出] 功能已启用，清除今天的导出记录');
        startAutoExportTimer();
    } else {
        settingsDiv.style.display = 'none';
        stopAutoExportTimer();
    }
    
    saveAutoExportSettings();
}

/**
 * 启动定时自动导出定时器
 */
function startAutoExportTimer() {
    // 先停止现有定时器
    stopAutoExportTimer();
    
    // 每分钟检查一次是否到了导出时间
    autoExportIntervalId = setInterval(async () => {
        try {
            await checkAutoExport();
        } catch (error) {
            console.error('[定时自动导出] 检查时出错:', error);
        }
    }, 60000); // 每60秒检查一次
    
    // 立即检查一次
    checkAutoExport().catch(error => {
        console.error('[定时自动导出] 初始检查时出错:', error);
    });
    
    console.log('[定时自动导出] 定时器已启动，每60秒检查一次');
}

/**
 * 停止定时自动导出定时器
 */
function stopAutoExportTimer() {
    if (autoExportIntervalId) {
        clearInterval(autoExportIntervalId);
        autoExportIntervalId = null;
    }
}

/**
 * 检查是否到了自动导出时间
 */
async function checkAutoExport() {
    const config = loadAutoExportConfig();
    
    if (!config.enabled) {
        return;
    }
    
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentTime = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
    
    // 解析配置的时间
    const [targetHour, targetMinute] = config.time.split(':').map(Number);
    
    // 检查今天是否已经导出过
    const lastExportDate = localStorage.getItem('autoExportLastDate');
    const todayDate = now.toDateString();
    
    // 时间匹配：当前时间与目标时间相同
    const timeMatches = currentHour === targetHour && currentMinute === targetMinute;
    
    console.log(`[定时自动导出] 检查中... 当前时间: ${currentTime}, 目标时间: ${config.time}, 匹配: ${timeMatches}, 今天已导出: ${lastExportDate === todayDate}`);
    
    if (timeMatches && lastExportDate !== todayDate) {
        // 记录今天已导出
        localStorage.setItem('autoExportLastDate', todayDate);
        
        console.log('[定时自动导出] 触发自动导出！');
        
        // 执行自动导出
        await performAutoExport(config.path);
    }
}

/**
 * 执行自动导出
 */
async function performAutoExport(customPath) {
    try {
        console.log('[定时自动导出] 开始执行自动导出...');
        
        // 获取备份数据
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        const [
            chats, worldBooks, userStickers, charStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets, datingScenes,
            datingPresets, datingSpriteGroups, datingSprites, datingHistory, pomodoroSessions,
            ludoQuestionBanks, ludoQuestions, scriptKillScripts, taobaoProducts,
            taobaoOrders, taobaoCart, userWalletTransactions, userStickerCategories
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.charStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.customAvatarFrames.toArray(),
            db.themes.toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray(),
            db.fontPresets.toArray(),
            db.homeScreenPresets.toArray(),
            db.datingScenes.toArray(),
            db.datingPresets.toArray(),
            db.datingSpriteGroups.toArray(),
            db.datingSprites.toArray(),
            db.datingHistory.toArray(),
            db.pomodoroSessions.toArray(),
            db.ludoQuestionBanks.toArray(),
            db.ludoQuestions.toArray(),
            db.scriptKillScripts.toArray(),
            db.taobaoProducts.toArray(),
            db.taobaoOrders.toArray(),
            db.taobaoCart.toArray(),
            db.userWalletTransactions.toArray(),
            db.userStickerCategories.toArray()
        ]);
        
        Object.assign(backupData, {
            chats, worldBooks, userStickers, charStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets, datingScenes,
            datingPresets, datingSpriteGroups, datingSprites, datingHistory, pomodoroSessions,
            ludoQuestionBanks, ludoQuestions, scriptKillScripts, taobaoProducts,
            taobaoOrders, taobaoCart, userWalletTransactions, userStickerCategories
        });
        
        // 添加主屏状态
        backupData.homeScreenState = {
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, 
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML,
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src,
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'appLabels': { ...state.globalSettings.appLabels },
            'wallpaper': state.globalSettings.wallpaper
        };

        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        
        // 生成文件名
        let fileName;
        if (customPath && customPath.trim() !== '') {
            // 如果用户指定了路径/文件名，使用它
            fileName = customPath.trim();
            // 如果路径不以.json结尾，自动添加
            if (!fileName.toLowerCase().endsWith('.json')) {
                fileName += '.json';
            }
        } else {
            // 使用默认文件名
            fileName = `EPhone-Auto-Backup-${new Date().toISOString().split('T')[0]}.json`;
        }
        
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: fileName
        });
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log(`[定时自动导出] 导出成功！文件名: ${fileName}`);
        
        // 可选：显示一个不干扰的通知（如果有通知功能的话）
        // 这里不使用showCustomAlert避免打断用户
        
    } catch (error) {
        console.error("[定时自动导出] 导出数据时出错:", error);
    }
}

/**
 * 测试自动导出功能
 */
async function testAutoExport() {
    const config = loadAutoExportConfig();
    console.log('[定时自动导出] 开始测试导出...');
    
    const confirmed = await showCustomConfirm(
        '测试自动导出',
        '确定要立即执行一次自动导出吗？这将下载一个备份文件。',
        { confirmButtonText: '确定', cancelButtonText: '取消' }
    );
    
    if (confirmed) {
        await performAutoExport(config.path);
        await showCustomAlert('测试完成', '已成功执行自动导出！请检查您的下载文件夹。');
    }
}

/**
 * 初始化定时自动导出功能
 */
function initAutoExport() {
    const config = loadAutoExportConfig();
    
    // 设置UI状态
    const toggle = document.getElementById('auto-export-toggle');
    const timeInput = document.getElementById('auto-export-time');
    const pathInput = document.getElementById('auto-export-path');
    const settingsDiv = document.getElementById('auto-export-settings');
    
    if (toggle && timeInput && pathInput && settingsDiv) {
        // 恢复保存的设置
        toggle.checked = config.enabled;
        timeInput.value = config.time;
        pathInput.value = config.path;
        
        // 显示/隐藏设置面板
        if (config.enabled) {
            settingsDiv.style.display = 'block';
            startAutoExportTimer();
        } else {
            settingsDiv.style.display = 'none';
        }
        
        // 绑定事件监听器
        toggle.addEventListener('change', handleAutoExportToggle);
        timeInput.addEventListener('change', saveAutoExportSettings);
        pathInput.addEventListener('change', saveAutoExportSettings);
        
        // 绑定测试按钮
        const testBtn = document.getElementById('test-auto-export-btn');
        if (testBtn) {
            testBtn.addEventListener('click', testAutoExport);
        }
        
        console.log(`[定时自动导出] 功能已${config.enabled ? '启用' : '禁用'}，导出时间: ${config.time}, 路径: ${config.path || '默认'}`);
    } else {
        console.error('[定时自动导出] 初始化失败：找不到必需的DOM元素');
    }
}
// ▲▲▲ 定时自动导出功能结束 ▲▲▲

// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】处理取消情侣空间
 */
async function handleCancelLoversSpace() {
    if (!activeLoversSpaceCharId) return;
    const confirmed = await showCustomConfirm(
        '取消情侣空间',
        '确定要取消情侣空间吗？这会使空间变为未启用状态，但所有数据（说说、照片等）都会被保留。此操作不会通知对方。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeLoversSpaceCharId];
        if (chat && chat.loversSpaceData) {
            // 将情侣空间数据设置为null，即可禁用它
            chat.loversSpaceData = null;
            await db.chats.put(chat);
            document.getElementById('ls-settings-modal').classList.remove('visible');
            alert('情侣空间已取消。');
            // 返回到聊天列表主屏幕
            showScreen('chat-list-screen');
        }
    }
}

// ▼▼▼ 【最终版】请用这整块代码，完整替换旧的 handleDisconnectLoversSpace 函数 ▼▼▼

// ▼▼▼ 第1步：用这块【最终双消息版】的代码，完整替换旧的 handleDisconnectLoversSpace 函数 ▼▼▼
/**
 * 【最终版 | 解除卡片+系统通知】处理解除情侣关系
 */
async function handleDisconnectLoversSpace() {
    if (!activeLoversSpaceCharId) return;
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    const confirmed = await showCustomConfirm(
        '解除关系',
        `确定要与“${chat.name}”解除关系吗？情侣空间将被取消，并且对方会收到通知并对此发表意见。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 1. 禁用空间
        chat.loversSpaceData = null;

        // 2. 【核心新增1】创建您发出的、在右侧的“解除卡片”
        const userDisconnectCardMessage = {
            role: 'user',                       
            type: 'lovers_space_disconnect',    // 一个新类型，用于渲染卡片
            content: `情侣空间已解除`,           // 卡片底层可编辑的文字
            timestamp: Date.now()
        };
        chat.history.push(userDisconnectCardMessage);

        // 3. 【核心新增2】创建居中的、灰色的“系统通知”
        const systemNotification = {
            role: 'system',
            type: 'pat_message', // 复用“拍一拍”的居中灰色气泡样式
            content: `你和 ${chat.name} 的情侣空间已解除`,
            timestamp: Date.now() + 1 // 时间戳+1确保在卡片之后
        };
        chat.history.push(systemNotification);

        // 4. 【保留】给AI看的隐藏指令，完全不变
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统指令：用户刚刚解除了与你的情侣关系。]`,
            timestamp: Date.now() + 2, // 时间戳再+1
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);

        // 5. 保存、关闭弹窗、跳转、触发回应
        await db.chats.put(chat);
        document.getElementById('ls-settings-modal').classList.remove('visible');
        document.getElementById('lovers-space-screen').classList.remove('visible');
        
        openChat(activeLoversSpaceCharId);
        
        alert('关系已解除，对方已知晓。');
        triggerAiResponse();
    }
}
// ▲▲▲ 第1步替换结束 ▲▲▲
// ▼▼▼ 第1步：在这里粘贴下面这整块新代码 ▼▼▼

/**
 * 【全新】打开手动总结的模式选择弹窗
 */
async function openManualSummaryOptions() {
    const choice = await showChoiceModal(
        '手动总结',
        [
            { text: '总结最新内容', value: 'latest' },
            { text: '总结指定范围', value: 'range' }
        ]
    );

    if (choice === 'latest') {
        // 用户选择总结最新，调用主函数并传入'latest'模式
        await triggerManualSummaryNow('latest');
    } else if (choice === 'range') {
        // 用户选择总结范围，调用范围输入函数
        await promptForSummaryRange();
    }
}

/**
 * 【全新】提示用户输入要总结的消息范围
 */
async function promptForSummaryRange() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const totalMessages = chat.history.length;
    if (totalMessages === 0) {
        alert("聊天记录为空，无法进行总结。");
        return;
    }

    // 弹出输入框，让用户输入开始序号
    const startStr = await showCustomPrompt('指定范围', `请输入开始的消息序号 (1 - ${totalMessages})`, '1', 'number');
    if (startStr === null) return; // 用户点击了取消

    const startNum = parseInt(startStr);
    if (isNaN(startNum) || startNum < 1 || startNum > totalMessages) {
        alert("请输入有效的开始序号。");
        return;
    }

    // 弹出输入框，让用户输入结束序号
    const endStr = await showCustomPrompt('指定范围', `请输入结束的消息序号 (${startNum} - ${totalMessages})`, totalMessages, 'number');
    if (endStr === null) return; // 用户点击了取消

    const endNum = parseInt(endStr);
    if (isNaN(endNum) || endNum < startNum || endNum > totalMessages) {
        alert("请输入有效的结束序号。");
        return;
    }

    // 调用主函数并传入'range'模式和具体的范围
    await triggerManualSummaryNow('range', { start: startNum, end: endNum });
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
/* ▼▼▼ 【全新】这是User自己的私信功能的所有核心函数 ▼▼▼ */

/**
 * 【总入口】打开User的私信列表
 */
async function openUserDmListScreen() {
    const settings = state.qzoneSettings || {};
    // 如果还没有生成过私信，就先让AI生成
    if (!settings.userDms || settings.userDms.length === 0) {
        await generateUserDms();
    } else {
        // 如果已经有了，就直接渲染
        renderUserDmList(settings.userDms);
    }
    showScreen('user-dm-list-screen');
}

/**
 * 【AI核心 V4 - 已增加初始粉丝数量】调用AI为User生成一批粉丝私信
 */
async function generateUserDms(isAddingMore = false) {
    const settings = state.qzoneSettings;
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    if (!isAddingMore && settings.userDms && settings.userDms.length > 0) {
        const confirmed = await showCustomConfirm(
            '重新生成',
            '已有私信记录。重新生成将覆盖现有所有私信，确定吗？',
            { confirmButtonClass: 'btn-danger' }
        );
        if (!confirmed) return;
    }

    const alertMessage = isAddingMore ? "正在召唤新粉丝..." : "AI正在为你模拟粉丝私信...";
    await showCustomAlert("请稍候...", alertMessage);

    const userPersona = `
# 用户信息 (这是你私信的对象，请仔细阅读)
- 你的微博昵称: ${settings.weiboNickname || settings.nickname}
- 你的微博职业: ${settings.weiboUserProfession || '未设定'}
- 你的隐藏人设 (粉丝看不到，但会影响他们对你的态度): ${settings.weiboUserPersona || '一个普通的微博用户。'}
`;

    const existingDmsContext = (isAddingMore && settings.userDms)
        ? `# 已有私信 (供你参考，请生成全新的对话)\n${JSON.stringify(settings.userDms.slice(-5))}`
        : '';

    // --- ▼▼▼ 修改点1：增加粉丝数量 ▼▼▼ ---
    const systemPrompt = `
# 任务
你是一个专业的“微博生态模拟器”。你的任务是根据用户的微博人设，虚构一个包含${isAddingMore ? '3-4' : '5-8'}位不同粉丝/路人的私信列表，并为每位粉丝创作一段【他们单方面发送给用户的】私信内容。
${userPersona}
${existingDmsContext}

# 核心规则
1.  **粉丝多样性**: 创作${isAddingMore ? '3-4' : '5-8'}位不同类型的粉丝。他们的私信内容和语气【必须】与他们的身份以及【用户的微博人设】高度相关。
2.  **【【【对话单向性铁律】】】**: 你生成的对话【只能包含粉丝发送给用户的消息】。绝对不要模拟用户的回复。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以 '[' 开头，以 ']' 结尾。
4.  **随机头像**: 为每位粉丝从下方头像池中随机挑选一个URL。

# JSON对象结构 (重要：messages数组里只能有sender为"fan"的对象！)
{
  "fanName": "粉丝的微博昵称",
  "fanPersona": "对这位粉丝的简单描述 (例如: '一个担心哥哥事业的妈妈粉')",
  "fanAvatarUrl": "从头像池中选择的URL",
  "messages": [
    { "sender": "fan", "text": "这是粉丝发来的第一条消息..." },
    { "sender": "fan", "text": "这是粉丝紧接着发的第二条消息，因为还没收到回复..." }
  ]
}

# 头像池 (fanAvatarUrl 必须从以下链接中选择一个)
- https://i.postimg.cc/PxZrFFFL/o-o-1.jpg
- https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png
现在，请开始生成【只有粉丝发言】的私信列表。`;
    // --- ▲▲▲ 修改结束 ▲▲▲ ---
    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newDmsData = JSON.parse(cleanedContent);

        if (Array.isArray(newDmsData)) {
            newDmsData.forEach((convo, index) => {
                if (!convo.fanAvatarUrl) {
                    const fanAvatars = ['https://i.postimg.cc/PxZrFFFL/o-o-1.jpg', 'https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png'];
                    convo.fanAvatarUrl = fanAvatars[index % fanAvatars.length];
                }
            });

            if (isAddingMore) {
                settings.userDms.push(...newDmsData);
            } else {
                settings.userDms = newDmsData;
            }
            await saveQzoneSettings();
            renderUserDmList(settings.userDms);
            
            await showCustomAlert('生成成功', `${isAddingMore ? '新的私信已添加！' : '粉丝私信已生成！'}`);
        } else {
            throw new Error("AI返回的数据不是一个有效的数组。");
        }
    } catch (error) {
        console.error("生成User私信失败:", error);
        await showCustomAlert('生成失败', `发生错误: ${error.message}`);
    }
}


/**
 * 【已增强】处理用户点击“触发AI回应”按钮
 */
async function handleTriggerUserDmAiReply() {
    if (currentUserDmFanIndex === null) return;
    
    const convo = state.qzoneSettings.userDms[currentUserDmFanIndex];
    if (!convo) return;
    
    const inputEl = document.getElementById('user-dm-input');
    inputEl.placeholder = "等待对方回复中...";
    inputEl.disabled = true;

    const aiResponse = await triggerUserDmAiReply(convo);
    if (aiResponse && aiResponse.length > 0) {
        // ▼▼▼ 修改点4：使用 ... 展开数组 ▼▼▼
        convo.messages.push(...aiResponse);
        await saveQzoneSettings();
        renderUserDmDetail(convo);
        renderUserDmList(state.qzoneSettings.userDms);
    }
    
    inputEl.placeholder = "和粉丝聊点什么...";
    inputEl.disabled = false;
    inputEl.focus();
}


/**
 * 【已增强】处理用户点击“重Roll”按钮
 */
async function handleUserDmReroll() {
    if (currentUserDmFanIndex === null) return;
    
    const convo = state.qzoneSettings.userDms[currentUserDmFanIndex];
    if (!convo || convo.messages.length === 0) return;

    let lastMessageIndex = convo.messages.length - 1;
    
    // 循环向前查找，直到找到第一个不是自己发的消息
    while (lastMessageIndex >= 0 && convo.messages[lastMessageIndex].sender === 'char') {
        lastMessageIndex--;
    }
    
    // 如果没找到粉丝的消息，或者全是自己的消息，则提示
    if (lastMessageIndex < 0 || convo.messages[lastMessageIndex].sender !== 'fan') {
        alert("只能对粉丝的最新回复使用重Roll功能哦。");
        return;
    }

    // 从找到的第一个粉丝消息开始，删除之后的所有消息
    convo.messages.splice(lastMessageIndex);
    
    renderUserDmDetail(convo);
    
    const inputEl = document.getElementById('user-dm-input');
    inputEl.placeholder = "正在重新生成回复...";
    inputEl.disabled = true;
    
    const aiResponse = await triggerUserDmAiReply(convo);
    if (aiResponse && aiResponse.length > 0) {
         // ▼▼▼ 修改点5：使用 ... 展开数组 ▼▼▼
        convo.messages.push(...aiResponse);
        renderUserDmDetail(convo);
    }

    await saveQzoneSettings();
    renderUserDmList(state.qzoneSettings.userDms);

    inputEl.placeholder = "和粉丝聊点什么...";
    inputEl.disabled = false;
    inputEl.focus();
}


/**
 * 【V2-已添加左滑删除】渲染User的私信列表
 */
function renderUserDmList(dmsData) {
    const listEl = document.getElementById('user-dm-list-container');
    listEl.innerHTML = '';

    if (!dmsData || dmsData.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有收到任何私信哦</p>';
        return;
    }

    dmsData.forEach((convo, index) => {
        const lastMsg = convo.messages[convo.messages.length - 1];
        
        // ★★★ 核心修改：创建滑动容器和操作按钮 ★★★
        const swipeContainer = document.createElement('div');
        swipeContainer.className = 'user-dm-list-item-swipe-container';

        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'user-dm-list-item-content';
        contentWrapper.innerHTML = `
            <div class="dm-list-item" data-fan-index="${index}">
                <img src="${convo.fanAvatarUrl}" class="dm-avatar">
                <div class="dm-info">
                    <div class="dm-name-line">
                        <span class="dm-name">${convo.fanName}</span>
                        <span class="dm-persona-tag">${convo.fanPersona}</span>
                    </div>
                    <div class="dm-last-msg">${lastMsg.sender === 'char' ? '你: ' : ''}${lastMsg.text}</div>
                </div>
            </div>
        `;
        
        const actionsWrapper = document.createElement('div');
        actionsWrapper.className = 'user-dm-swipe-actions';
        actionsWrapper.innerHTML = `<button class="swipe-action-btn delete" data-fan-index="${index}">删除</button>`;

        swipeContainer.appendChild(contentWrapper);
        swipeContainer.appendChild(actionsWrapper);
        listEl.appendChild(swipeContainer);
    });
}
/**
 * 【全新】处理删除单条用户私信的逻辑
 */
async function handleDeleteUserDmMessage(fanIndex, messageIndex) {
    if (fanIndex === null || messageIndex === null) return;
    
    const settings = state.qzoneSettings;
    const conversation = settings.userDms[fanIndex];
    if (!conversation) return;

    const messageText = conversation.messages[messageIndex].text.substring(0, 30);
    const confirmed = await showCustomConfirm('删除私信', `确定要删除这条私信吗？\n\n“${messageText}...”`, { confirmButtonClass: 'btn-danger' });

    if (confirmed) {
        conversation.messages.splice(messageIndex, 1);

        if (conversation.messages.length === 0) {
            // 如果这是最后一条消息，则删除整个对话
            settings.userDms.splice(fanIndex, 1);
            await saveQzoneSettings();
            renderUserDmList(settings.userDms);
            showScreen('user-dm-list-screen'); // 返回到列表页
        } else {
            // 否则只更新当前对话
            await saveQzoneSettings();
            renderUserDmDetail(conversation);
        }
        alert('私信已删除。');
    }
}

/**
 * 【全新】处理删除整个用户私信对话的逻辑
 */
async function handleDeleteUserDmConversation(fanIndex) {
    const settings = state.qzoneSettings;
    const conversation = settings.userDms[fanIndex];
    if (!conversation) return;

    const confirmed = await showCustomConfirm('删除对话', `确定要删除与“${conversation.fanName}”的全部对话吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        settings.userDms.splice(fanIndex, 1);
        await saveQzoneSettings();
        renderUserDmList(settings.userDms);
        alert('对话已删除。');
    } else {
        // 如果取消，则把滑块收回去
        const swipedContent = document.querySelector(`.user-dm-list-item-content.swiped`);
        if (swipedContent) swipedContent.classList.remove('swiped');
    }
}


/**
 * 打开与某个粉丝的私信详情页
 */
function openUserDmDetail(fanIndex) {
    currentUserDmFanIndex = fanIndex;
    const convo = state.qzoneSettings.userDms[fanIndex];
    if (!convo) return;
    
    renderUserDmDetail(convo);
    showScreen('user-dm-detail-screen');
}

/**
 * 【V2-已添加删除按钮】渲染私信详情页的具体内容
 */
function renderUserDmDetail(conversation) {
    const messagesEl = document.getElementById('user-dm-messages-container');
    const titleEl = document.getElementById('user-dm-detail-title');
    messagesEl.innerHTML = '';
    titleEl.textContent = conversation.fanName;
    
    const userAvatar = state.qzoneSettings.avatar || defaultAvatar;

    conversation.messages.forEach((msg, index) => {
        const isFan = msg.sender === 'fan';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isFan ? 'fan' : 'user-self'}`;
        
        const bubble = document.createElement('div');
        bubble.className = `message-bubble`;

        const avatarHtml = `<img src="${isFan ? conversation.fanAvatarUrl : userAvatar}" class="avatar">`;
        const contentHtml = `<div class="content">${msg.text.replace(/\n/g, '<br>')}</div>`;
        
        // ★★★ 核心修改：在这里创建删除按钮的HTML ★★★
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'user-dm-message-delete-btn';
        deleteBtn.dataset.messageIndex = index; // 用索引来标识是哪条消息
        deleteBtn.title = "删除";
        deleteBtn.innerHTML = '×';
        
        bubble.innerHTML = `${avatarHtml}${contentHtml}`;
        
        // ★★★ 将气泡和删除按钮都添加到容器中 ★★★
        wrapper.appendChild(bubble);
        wrapper.appendChild(deleteBtn);
        
        messagesEl.appendChild(wrapper);
    });

    messagesEl.scrollTop = messagesEl.scrollHeight;
}


/**
 * 【已修复】处理用户在私信详情页发送消息 (仅发送，不触发AI)
 */
async function handleSendUserDm() {
    const inputEl = document.getElementById('user-dm-input');
    const messageText = inputEl.value.trim();
    if (!messageText || currentUserDmFanIndex === null) return;

    const convo = state.qzoneSettings.userDms[currentUserDmFanIndex];
    
    // 1. 创建你的消息对象
    const newMessage = { sender: 'char', text: messageText };

    // 2. 将你的消息添加到对话历史中
    convo.messages.push(newMessage);
    
    // 3. 清空输入框并重置样式
    inputEl.value = '';
    inputEl.style.height = 'auto';

    // 4. 重新渲染对话详情和左侧列表，以显示你的新消息
    renderUserDmDetail(convo);
    renderUserDmList(state.qzoneSettings.userDms);

    // 5. 保存状态
    await saveQzoneSettings();
    
    // 6. 重新聚焦输入框，方便你继续输入或等待操作
    inputEl.focus();
    
    // 注意：此处已移除所有自动触发AI回复的代码
}



/**
 * 【AI回复核心 V2 - 已增强回复丰富度】调用AI生成粉丝的回复 (可以生成多条)
 */
async function triggerUserDmAiReply(conversation) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.error("API配置不完整");
        return null;
    }
    
    const settings = state.qzoneSettings;

    // --- ▼▼▼ 修改点2：全新的、更丰富的AI指令 ▼▼▼ ---
    const systemPrompt = `
# 角色扮演任务
你将扮演一个正在和偶像或博主私信的粉丝。

# 你的粉丝人设
- 你的昵称: "${conversation.fanName}"
- 你的性格和背景: "${conversation.fanPersona}"

# 博主信息 (你正在和他/她聊天)
- 微博昵称: ${settings.weiboNickname || settings.nickname}
- 微博职业: ${settings.weiboUserProfession || '未设定'}
- 博主的隐藏人设: ${settings.weiboUserPersona || '一个普通的微博用户。'}

# 对话历史 (最近的5条)
${conversation.messages.slice(-5).map(m => `- ${m.sender === 'fan' ? conversation.fanName : '我'}: ${m.text}`).join('\n')}

# 你的任务
根据以上人设和对话历史，生成你接下来的回复。

# 回复规则
1.  **深度扮演**: 你的回复必须【极度符合】你的粉丝人设。语气、用词、情绪都要到位。
2.  **内容丰富**: 不要只回复一句话。你的回复应该包含情绪(激动、失望、好奇等)、思考，或者向博主提出新的问题来推动对话。
3.  **【【【格式铁律】】】**: 你的回复必须是一个【JSON数组】，即使只有一条消息。这个数组可以包含3到8条消息对象，模拟真实聊天中连续发消息的场景。
4.  **对象结构**: 数组中的每个对象都必须是 {"sender": "fan", "text": "你的单条回复内容"}。

现在，请以JSON数组的格式，生成你接下来要发送的1-3条消息。`;
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);


        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        
        // AI现在返回的是一个数组，我们直接解析并返回它
        const newMessages = JSON.parse(cleanedContent);

        // 做一个兼容性检查，如果AI意外返回了单个对象，我们把它包装成数组
        return Array.isArray(newMessages) ? newMessages : [newMessages];

    } catch (error) {
        console.error('触发粉丝回复失败:', error);
        await showCustomAlert('回复生成失败', `发生错误: ${error.message}`);
        // 返回一个包含错误信息的数组，以便界面能显示出来
        return [{ sender: 'fan', text: `(AI生成回复时出错了: ${error.message})` }];
    }
}

/**
 * 清空所有User的私信
 */
async function handleClearAllUserDms() {
    const confirmed = await showCustomConfirm(
        '确认清空', 
        '确定要清空所有粉丝私信吗？此操作不可恢复。',
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        state.qzoneSettings.userDms = [];
        await saveQzoneSettings();
        renderUserDmList([]);
        alert('所有私信已清空。');
    }
}

/* ▲▲▲ 全新的 User 私信功能核心函数结束 ▲▲▲ */
/**
 * 【全新】将时间字符串（如 "20:00", "早上9点"）解析为分钟数
 * @param {string} timeStr - 时间字符串
 * @returns {number} - 从午夜0点开始的分钟数
 */
function parseTime(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return -1; // 错误或无效输入返回-1

    let hours = 0;
    let minutes = 0;

    // 匹配 "HH:mm" 或 "H:mm" 格式
    const match = timeStr.match(/(\d{1,2}):(\d{2})/);
    if (match) {
        hours = parseInt(match[1], 10);
        minutes = parseInt(match[2], 10);
    } else {
        // 如果不是标准格式，尝试匹配中文描述
        const numMatch = timeStr.match(/(\d+)/);
        const num = numMatch ? parseInt(numMatch[0], 10) : -1;

        if (num !== -1) {
            if (timeStr.includes('下午') || timeStr.includes('晚上')) {
                // 下午1点(13点)到晚上11点(23点)
                if (num < 12) {
                    hours = num + 12;
                } else {
                    hours = num; // 如果已经是24小时制如“晚上20点”，直接使用
                }
            } else {
                // 早上或上午
                hours = num;
            }
        } else {
            return -1; // 无法解析
        }
    }

    // 处理特殊情况，如晚上12点应为0点
    if ((timeStr.includes('晚上') || timeStr.includes('凌晨')) && hours === 12) {
        hours = 0;
    }
    // 处理下午12点应为12点
    if ((timeStr.includes('下午') || timeStr.includes('中午')) && hours === 24) {
        hours = 12;
    }

    return hours * 60 + minutes;
}
/**
 * 【火花 V2.2】检查并更新火花天数 (已修复熄灭后从1开始的问题)
 * @param {string} chatId - 要更新火花的聊天ID
 * @returns {Promise<boolean>} - 如果火花天数有变化，则返回true
 */
async function updateStreak(chatId) {
    const chat = state.chats[chatId];
    // 如果不是单聊，或者功能未开启，直接返回
    if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
        return false;
    }

    const streak = chat.settings.streak;
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD格式

    // 如果今天已经互动过了，就什么都不做
    if (streak.lastInteractionDate === today) {
        return false;
    }

    let changed = false;

    // 检查火花是否已熄灭
    if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
        const lastDate = new Date(streak.lastInteractionDate);
        const todayDate = new Date(today);
        // 为了精确计算天数差异，我们将两个日期都设置为UTC时间的午夜
        const lastDateUTC = Date.UTC(lastDate.getFullYear(), lastDate.getMonth(), lastDate.getDate());
        const todayDateUTC = Date.UTC(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());
        
        const daysDiff = (todayDateUTC - lastDateUTC) / (1000 * 60 * 60 * 24);

        if (daysDiff >= streak.extinguishThreshold) {
            // 如果断联天数达到了你设置的阈值，就将当前火花天数归零。
            streak.currentDays = 0; 
            console.log(`🔥 与 ${chat.name} 的火花因超过 ${streak.extinguishThreshold} 天未联系而熄灭，将重新从 1 开始计算。`);
            changed = true;
        }
    }
    
    // 今天是新的互动日，天数+1
    // 如果是永不熄灭模式，currentDays 为 -1, 不应该增加
    if (streak.currentDays >= 0) {
        streak.currentDays++;
        changed = true;
    }
    
    // 无论火花是否熄灭，只要今天互动了，就把“最后互动日期”更新为今天。
    streak.lastInteractionDate = today;

    await db.chats.put(chat);
    
    if(changed) {
        console.log(`🔥 与 ${chat.name} 的火花天数更新为: ${streak.currentDays}`);
    }
    
    return changed; // 返回是否发生了变化
}



// ▼▼▼ 用这块【修复后】的代码替换旧的 handleToggleAdmin 函数 ▼▼▼
/**
 * 【全新 | 权限修复版】处理设置/取消管理员
 */
async function handleToggleAdmin(memberId) {
    const chat = state.chats[state.activeChatId];
    // 权限检查：确保操作者是群主
    if (!chat || chat.ownerId !== 'user') {
        alert("你不是群主，没有权限执行此操作！");
        return;
    }

    let targetNickname;
    let isAdminNow;

    // --- ★★★ 核心修改在这里 ★★★ ---
    // 1. 判断操作目标是不是用户自己
    if (memberId === 'user') {
        // 如果是用户，就修改 chat.settings 里的专属标志
        // 我们使用 isUserAdmin 属性来记录用户是否是管理员
        chat.settings.isUserAdmin = !chat.settings.isUserAdmin;
        targetNickname = chat.settings.myNickname || '我';
        isAdminNow = chat.settings.isUserAdmin;
    } else {
        // 如果是其他成员，保持原有逻辑不变
        const member = chat.members.find(m => m.id === memberId);
        if (!member) return;

        // 【重要】不能将群主设为管理员或取消其管理员身份
        if (member.id === chat.ownerId) {
            alert("不能对群主进行此操作。");
            return;
        }
        
        member.isAdmin = !member.isAdmin;
        targetNickname = member.groupNickname;
        isAdminNow = member.isAdmin;
    }
    // --- ▲▲▲ 修改结束 ▲▲▲

    await db.chats.put(chat);
    
    // 准备并发送系统通知消息
    const actionText = isAdminNow ? '设为管理员' : '取消了管理员身份';
    const myNickname = chat.settings.myNickname || '我';
    // 这里我们用 logSystemMessage 函数来发送通知，它会自动刷新UI
    await logSystemMessage(chat.id, `“${myNickname}”将“${targetNickname}”${actionText}。`);

    // 刷新成员管理列表的显示
    renderMemberManagementList(); 
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【修复后】的代码替换旧的 handleSetMemberTitle 函数 ▼▼▼
/**
 * 【全新 | 权限修复版】处理设置群成员头衔
 */
async function handleSetMemberTitle(memberId) {
    const chat = state.chats[state.activeChatId];
    // 权限检查：群主或管理员才能设置
    const isOwner = chat.ownerId === 'user';
    const isAdmin = chat.settings.isUserAdmin;

    if (!chat || (!isOwner && !isAdmin)) {
        alert("你不是群主或管理员，没有权限执行此操作！");
        return;
    }
    
    let targetNickname;
    let oldTitle;
    
    // --- ★★★ 核心修改在这里 ★★★ ---
    if (memberId === 'user') {
        targetNickname = chat.settings.myNickname || '我';
        oldTitle = chat.settings.myGroupTitle || '';
    } else {
        const member = chat.members.find(m => m.id === memberId);
        if (!member) return;
        targetNickname = member.groupNickname;
        oldTitle = member.groupTitle || '';
    }
    // --- ▲▲▲ 修改结束 ▲▲▲

    const newTitle = await showCustomPrompt(`为“${targetNickname}”设置头衔`, '留空则为取消头衔', oldTitle);
    
    if (newTitle !== null) {
        const trimmedTitle = newTitle.trim();
        // --- ★★★ 核心修改在这里 ★★★ ---
        if (memberId === 'user') {
            chat.settings.myGroupTitle = trimmedTitle;
        } else {
            const member = chat.members.find(m => m.id === memberId);
            if (member) member.groupTitle = trimmedTitle;
        }
        // --- ▲▲▲ 修改结束 ▲▲▲

        await db.chats.put(chat);
        
        const myNickname = chat.settings.myNickname || '我';
        await logTitleChange(chat.id, myNickname, targetNickname, trimmedTitle);

        renderMemberManagementList();
    }
}
// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 请用这块【功能增强版】的代码，完整替换你旧的 handleTransferOwnership 函数 ▼▼▼
/**
 * 【全新】处理转让群主 (已添加系统消息通知)
 */
async function handleTransferOwnership(memberId) {
    const chat = state.chats[state.activeChatId];
    const newOwner = chat.members.find(m => m.id === memberId);
    if (!newOwner) return;

    // 【新增】获取旧群主的昵称，也就是你自己的昵称
    const oldOwnerNickname = chat.settings.myNickname || '我';

    const confirmed = await showCustomConfirm(
        '转让群主',
        `你确定要将群主身份转让给“${newOwner.groupNickname}”吗？\n此操作不可撤销，你将失去群主权限。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 更新群主ID
        chat.ownerId = newOwner.id;
        
        // 将新群主设为管理员（如果他之前不是）
        newOwner.isAdmin = true;

        // ★★★★★ 这就是我们本次唯一需要添加的核心代码！ ★★★★★
        // 1. 构建系统消息的内容
        const message = `“${oldOwnerNickname}”已将群主转让给“${newOwner.groupNickname}”`;
        
        // 2. 调用你已有的函数来发送这条系统消息
        //    这个函数会自动保存数据并刷新聊天列表，非常方便！
        await logSystemMessage(chat.id, message);
        // ★★★★★ 添加结束 ★★★★★

        // 刷新成员管理列表的显示
        renderMemberManagementList(); 
        
        // 给出成功提示
        await showCustomAlert('操作成功', `群主已成功转让给“${newOwner.groupNickname}”。`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】发送一条居中显示的系统消息到当前聊天
 * @param {string} chatId - 目标聊天的ID
 * @param {string} messageContent - 要显示的消息内容
 */
async function logSystemMessage(chatId, messageContent) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 创建系统消息对象
    const systemMessage = {
        role: 'system',       // 这是一个系统角色的消息
        type: 'pat_message',  // 复用“拍一拍”的居中灰色气泡样式
        content: messageContent,
        timestamp: Date.now()
    };

    // 2. 将消息添加到聊天记录并保存
    chat.history.push(systemMessage);
    await db.chats.put(chat);

    // 3. 如果用户正在查看此聊天，则立即显示新消息
    if (state.activeChatId === chatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(systemMessage, chat);
    }
    
    // 4. 刷新聊天列表以更新预览
    await renderChatList();

    console.log(`系统消息已记录: ${messageContent}`);
}


/**
 * 【V2 - 重构版】记录并发送群头衔变更的系统消息
 * @param {string} chatId - 发生变更的群聊ID
 * @param {string} actorName - 执行操作的人的昵称
 * @param {string} targetName - 被修改头衔的人的昵称
 * @param {string} newTitle - 新的头衔
 */
async function logTitleChange(chatId, actorName, targetName, newTitle) {
    // 1. 构造消息内容
    const messageContent = newTitle 
        ? `${actorName} 将“${targetName}”的群头衔修改为“${newTitle}”`
        : `${actorName} 取消了“${targetName}”的群头衔`;
        
    // 2. 调用通用的系统消息函数
    await logSystemMessage(chatId, messageContent);
}
/* ▼▼▼ 【全新】群公告功能核心函数 ▼▼▼ */

/* ▼▼▼ 【全新 | 已修复】群公告功能核心函数 ▼▼▼ */

/**
 * 打开群公告弹窗并渲染内容
 */
function openGroupAnnouncementModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const modal = document.getElementById('group-announcement-modal');
    const contentArea = document.getElementById('announcement-content-area');
    const footer = document.getElementById('announcement-footer');

    const announcement = chat.settings.groupAnnouncement || '暂无公告';
    contentArea.innerHTML = announcement.replace(/\n/g, '<br>');
    
    const canEdit = chat.ownerId === 'user' || chat.settings.isUserAdmin;
    
    footer.innerHTML = ''; 
    if (canEdit) {
        const editBtn = document.createElement('button');
        editBtn.className = 'cancel';
        editBtn.textContent = '编辑';
        // 【核心修复1】改用 addEventListener 来绑定事件，更安全可靠
        editBtn.addEventListener('click', editGroupAnnouncement); 
        footer.appendChild(editBtn);
    }
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'save'; 
    closeBtn.textContent = '关闭';
    // 【核心修复2】同样改用 addEventListener
    closeBtn.addEventListener('click', closeGroupAnnouncementModal); 
    footer.appendChild(closeBtn);

    modal.classList.add('visible');
}

/**
 * 进入公告编辑模式
 */
function editGroupAnnouncement() {
    const chat = state.chats[state.activeChatId];
    const contentArea = document.getElementById('announcement-content-area');
    const footer = document.getElementById('announcement-footer');

    const currentContent = chat.settings.groupAnnouncement || '';
    contentArea.innerHTML = `<textarea id="announcement-editor">${currentContent}</textarea>`;
    
    // 【核心修复3】这里也全部改用 addEventListener 的方式绑定
    footer.innerHTML = ''; // 先清空

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'cancel';
    cancelBtn.textContent = '取消';
    cancelBtn.addEventListener('click', closeGroupAnnouncementModal); // 直接调用函数
    
    const saveBtn = document.createElement('button');
    saveBtn.className = 'save';
    saveBtn.textContent = '保存';
    saveBtn.addEventListener('click', saveGroupAnnouncement); // 直接调用函数

    footer.appendChild(cancelBtn);
    footer.appendChild(saveBtn);
    
    document.getElementById('announcement-editor').focus();
}

/**
 * 保存新的群公告
 */
async function saveGroupAnnouncement() {
    const chat = state.chats[state.activeChatId];
    const newContent = document.getElementById('announcement-editor').value.trim();

    chat.settings.groupAnnouncement = newContent;
    await db.chats.put(chat);
    
    const myNickname = chat.settings.myNickname || '我';
    await logSystemMessage(chat.id, `“${myNickname}”修改了群公告。`);

    closeGroupAnnouncementModal();
    alert('群公告已更新！');
}

/**
 * 关闭群公告弹窗
 */
function closeGroupAnnouncementModal() {
    // 关闭后，重新渲染一次查看状态，以防用户取消了编辑
    const modal = document.getElementById('group-announcement-modal');
    modal.classList.remove('visible');
    // 延迟一点点再打开，可以避免视觉上的冲突
    setTimeout(() => {
        if(modal.classList.contains('visible')) { // 做个检查，万一用户快速操作
           openGroupAnnouncementModal();
        }
    }, 10);
    // 直接关闭，不再重新打开
    document.getElementById('group-announcement-modal').classList.remove('visible');
}

/* ▲▲▲ 新功能函数结束 ▲▲▲ */
/**
 * 【全新】获取并格式化当前聊天的续火花状态，生成给AI看的上下文
 * @param {object} chat - 当前的聊天对象
 * @returns {string} - 格式化后的火花状态文本，或空字符串
 */
async function getStreakContext(chat) {
    // 1. 安全检查：如果不是单聊，或者功能未开启，则直接返回空内容
    if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
        return "";
    }

    const streak = chat.settings.streak;
    const currentDays = streak.currentDays || 0;
    const extinguishThreshold = streak.extinguishThreshold || 1;
    const lastInteractionDate = streak.lastInteractionDate;
    let isExtinguished = false;

    // 2. 判断火花是否已熄灭
    if (lastInteractionDate && extinguishThreshold !== -1) {
        const lastDate = new Date(lastInteractionDate);
        const todayDate = new Date();
        todayDate.setHours(0, 0, 0, 0); // 将时间设为当日零点，以精确计算天数

        // 计算最后一次互动到今天过了多少天
        const daysDiff = (todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24);

        if (daysDiff >= extinguishThreshold) {
            isExtinguished = true;
        }
    }

    let statusText = "";

    // 3. 根据不同状态，生成给AI看的不同文本
    if (isExtinguished && currentDays > 0) {
        // 这种状态表示“曾经有过火花，但现在断了”
        statusText = `你们的聊天火花【已熄灭】。之前曾连续聊了 ${currentDays} 天，但现在中断了。`;
    } else if (currentDays > 10) {
        statusText = `你们的聊天火花正在热烈燃烧，已经持续了【${currentDays}】天了！这是一个值得纪念的数字。`;
    } else if (currentDays > 0) {
        statusText = `你们的聊天火花正在延续，已经持续了【${currentDays}】天。`;
    } else {
        // 天数为0，说明是刚开启或刚重置
        statusText = "你们刚刚点燃了聊天火花，要继续保持哦！";
    }
    
    // 4. 拼接成最终的上下文格式
    return `\n- **聊天火花状态**: ${statusText}`;
}

// === 攻略模式上下文函数 ===
/**
 * 生成攻略模式的上下文信息
 * @param {object} chat - 当前的聊天对象
 * @returns {string} - 格式化后的攻略模式状态文本，或空字符串
 */
function getConquestModeContext(chat) {
    // 检查：如果不是单聊，或者攻略模式未开启，返回空
    if (!chat || chat.isGroup || !chat.settings.conquestMode?.enabled) {
        return "";
    }

    const conquest = chat.settings.conquestMode;
    const currentAffection = conquest.currentAffection || 50;
    const successAffection = conquest.successAffection || 90;
    const previousAffection = conquest.previousAffection || currentAffection;
    
    // 计算好感度变化
    const affectionChange = currentAffection - previousAffection;
    let changeIndicator = "";
    if (affectionChange > 0) {
        changeIndicator = ` (↑${affectionChange})`;
    } else if (affectionChange < 0) {
        changeIndicator = ` (↓${Math.abs(affectionChange)})`;
    }
    
    // 根据好感度等级给出不同的状态描述
    let statusText = "";
    let behaviorGuide = "";
    
    if (currentAffection < 20) {
        statusText = "【极度冷淡】";
        behaviorGuide = "你对用户非常冷淡，甚至带有敌意。你会用简短、冷漠的语气回应，不主动关心用户。";
    } else if (currentAffection < 40) {
        statusText = "【疏远陌生】";
        behaviorGuide = "你对用户保持距离，态度礼貌但疏离。你不会分享私人话题，也不会主动发起深入对话。";
    } else if (currentAffection < 60) {
        statusText = "【普通朋友】";
        behaviorGuide = "你把用户当作普通朋友，会礼貌友好地交流，但还没有特别亲密的感觉。";
    } else if (currentAffection < 80) {
        statusText = "【好感增加】";
        behaviorGuide = "你对用户产生了明显的好感，会更主动地分享想法，偶尔表现出关心和在意。";
    } else if (currentAffection < successAffection) {
        statusText = "【暧昧心动】";
        behaviorGuide = "你对用户产生了爱慕之情，会表现出明显的喜欢和在意，但还没有表白。你会更加主动，更关注对方的一切。";
    } else {
        statusText = "【攻略成功！】";
        behaviorGuide = "你已经深深爱上用户，会毫不掩饰地表达爱意。你们的关系已经非常亲密，可以随时表现出恋人的亲昵和甜蜜。";
    }
    
    return `\n- **【攻略模式】当前好感度**: ${currentAffection}/${successAffection} ${statusText}${changeIndicator}
- **行为指导**: ${behaviorGuide}
- **重要规则**: 
  * 你的态度和行为必须严格符合当前好感度等级
  * 好感度会根据用户的行为动态变化（系统会在后台自动调整）
  * 在低好感度时，不要表现得过于热情或亲密
  * 随着好感度提升，逐渐展现更多的关心、信任和爱意`;
}
// === 攻略模式上下文函数结束 ===

// ▼▼▼ 【全新】这是用户表情包批量删除的JS核心函数 ▼▼▼

// ▼▼▼ 使用这块【新代码】替换旧的 toggleUserStickerSelectionMode 函数 ▼▼▼
function toggleUserStickerSelectionMode() {
    isUserStickerSelectionMode = !isUserStickerSelectionMode;
    const stickerPanel = document.getElementById('sticker-panel');
    
    selectedUserStickers.clear();
    // 核心修改：在这里给父容器添加/移除一个class
    stickerPanel.classList.toggle('selection-mode', isUserStickerSelectionMode);
    
    document.getElementById('edit-user-stickers-btn').style.display = isUserStickerSelectionMode ? 'none' : 'block';
    document.getElementById('done-user-stickers-btn').style.display = isUserStickerSelectionMode ? 'block' : 'none';
    document.getElementById('sticker-panel-footer').style.display = isUserStickerSelectionMode ? 'flex' : 'none';
    
    const deleteBtn = document.getElementById('delete-selected-user-stickers-btn');
    deleteBtn.textContent = `删除已选 (0)`;
    deleteBtn.disabled = true;

    const moveBtn = document.getElementById('move-selected-stickers-btn');
    moveBtn.disabled = true;
    
    renderStickerPanel(); // 这一步会调用 renderStickerCategories，并根据新的模式重新渲染
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 退出用户表情包的选择模式
 */
function exitUserStickerSelectionMode() {
    if (isUserStickerSelectionMode) {
        toggleUserStickerSelectionMode();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是角色表情包批量删除的JS核心函数 ▼▼▼

/**
 * 切换角色表情包的选择模式
 */
function toggleCharStickerSelectionMode() {
    isCharStickerSelectionMode = !isCharStickerSelectionMode;
    const screen = document.getElementById('char-sticker-manager-screen');
    
    // 清空选择集并更新UI
    selectedCharStickers.clear();
    screen.classList.toggle('selection-mode', isCharStickerSelectionMode);
    
    document.getElementById('edit-char-stickers-btn').style.display = isCharStickerSelectionMode ? 'none' : 'block';
    document.getElementById('done-char-stickers-btn').style.display = isCharStickerSelectionMode ? 'block' : 'none';
    document.getElementById('char-sticker-footer').style.display = isCharStickerSelectionMode ? 'block' : 'none';
    document.getElementById('delete-selected-char-stickers-btn').textContent = `删除已选 (0)`;
    document.getElementById('delete-selected-char-stickers-btn').disabled = true;

    // 重新渲染当前激活的页签
    const activeTab = document.querySelector('#char-sticker-manager-screen .frame-tab.active');
    if (activeTab) {
        renderCharStickers(activeTab.id === 'sticker-tab-exclusive' ? 'exclusive' : 'common');
    }
}

/**
 * 退出角色表情包的选择模式
 */
function exitCharStickerSelectionMode() {
    if (isCharStickerSelectionMode) {
        toggleCharStickerSelectionMode();
    }
}

// ▼▼▼ 用这块【新代码】替换旧的 showInnerVoiceEditOptions 函数 ▼▼▼
/**
 * 【总入口】当用户点击心声面板的编辑按钮时，打开操作菜单
 */
async function showInnerVoiceEditOptions() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const borderHidden = chat.settings.innerVoiceHideHeaderBorder || false;
    const borderOptionText = borderHidden ? '显示分割线' : '隐藏分割线';
    
    // 【核心修改】在选项数组里新增了 'editStyles'
    const choice = await showChoiceModal("编辑心声面板", [
        { text: '🎨 编辑面板样式', value: 'editStyles' },
        { text: borderOptionText, value: 'toggleBorder' },
        { text: '修改领养人', value: 'editAdopter' }
    ]);

    if (choice === 'editStyles') {
        openInnerVoiceStyleEditor(); // 调用我们新写的函数来打开样式编辑器
    } else if (choice === 'toggleBorder') {
        await toggleInnerVoiceHeaderBorder();
    } else if (choice === 'editAdopter') {
        await editInnerVoiceAdopterName();
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 切换心声面板头部分割线的显示/隐藏
 */
async function toggleInnerVoiceHeaderBorder() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 确保 chat.settings 存在
    if (!chat.settings) chat.settings = {};

    // 切换布尔值
    chat.settings.innerVoiceHideHeaderBorder = !(chat.settings.innerVoiceHideHeaderBorder || false);

    // 保存到数据库
    await db.chats.put(chat);

    // 更新UI
    const header = document.querySelector('#inner-voice-main-panel .modal-header');
    if (header) {
        header.classList.toggle('no-border', chat.settings.innerVoiceHideHeaderBorder);
    }

    await showCustomAlert('操作成功', `分割线已${chat.settings.innerVoiceHideHeaderBorder ? '隐藏' : '显示'}。`);
}

// ▼▼▼ 用这块【模板编辑版】的代码，替换旧的 editInnerVoiceAdopterName 函数 ▼▼▼
/**
 * 修改“领养人”的标签模板
 */
async function editInnerVoiceAdopterName() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 获取当前的标签模板，如果没有设置过，就使用默认值
    const currentFormat = chat.settings.innerVoiceAdopterLabelFormat || '领养人: {{user}}';
    
    // 弹出输入框，让用户编辑整个模板字符串
    const newFormat = await showCustomPrompt(
        '修改领养人标签', 
        '你可以修改整个标签，其中 {{user}} 会被自动替换为你的昵称。', 
        currentFormat
    );

    // 如果用户输入了新内容（不是取消）
    if (newFormat !== null) {
        // 保存新模板，如果输入为空则恢复默认
        chat.settings.innerVoiceAdopterLabelFormat = newFormat.trim() || '领养人: {{user}}';
        await db.chats.put(chat);
        
        // 重新渲染心声面板以显示新标签
        openInnerVoiceModal(); 
        await showCustomAlert('修改成功', '领养人标签已更新！');
    }
}
// ▲▲▲ 替换结束 ▲▲▲
/* ▼▼▼ 【全新】心声面板样式编辑功能的核心函数 ▼▼▼ */

/**
 * 将十六进制颜色(#FFFFFF)转换为 "R, G, B" 字符串 (255, 255, 255)
 * @param {string} hex - 十六进制颜色代码
 * @returns {string} - RGB字符串
 */
function hexToRgb(hex) {
    if (!hex || hex.length < 4) return '255, 255, 255';
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 255, 255';
}

// ▼▼▼ 用这块新代码替换旧的 applySavedInnerVoiceStyles 函数 ▼▼▼
/**
 * 将保存的样式应用到心声面板
 */
function applySavedInnerVoiceStyles() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.innerVoiceStyles) return;

    const styles = chat.settings.innerVoiceStyles;
    const panel = document.getElementById('inner-voice-main-panel');

    panel.style.setProperty('--iv-color-clothing', styles.clothingColor);
    panel.style.setProperty('--iv-color-behavior', styles.behaviorColor);
    panel.style.setProperty('--iv-color-thoughts', styles.thoughtsColor);
    panel.style.setProperty('--iv-color-naughty', styles.naughtyColor);
    panel.style.setProperty('--iv-card-bg-rgb', hexToRgb(styles.cardBgColor));
    panel.style.setProperty('--iv-card-opacity', styles.cardOpacity);
    
    // ★★★ 核心新增：在这里应用我们保存的图标颜色！ ★★★
    panel.style.setProperty('--iv-icon-color', styles.iconColor || '#ff8a80');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块新代码替换旧的 openInnerVoiceStyleEditor 函数 ▼▼▼
/**
 * 打开心声面板样式编辑器
 */
function openInnerVoiceStyleEditor() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.innerVoiceStyles) return;

    document.getElementById('inner-voice-edit-options-modal')?.classList.remove('visible');
    
    const styles = chat.settings.innerVoiceStyles;
    const modal = document.getElementById('inner-voice-editor-modal');
    
    // 加载当前样式到编辑器
    document.getElementById('iv-color-clothing').value = styles.clothingColor;
    document.getElementById('iv-color-behavior').value = styles.behaviorColor;
    document.getElementById('iv-color-thoughts').value = styles.thoughtsColor;
    document.getElementById('iv-color-naughty').value = styles.naughtyColor;
    document.getElementById('iv-card-bg-color').value = styles.cardBgColor;
    document.getElementById('iv-opacity-slider').value = styles.cardOpacity;
    document.getElementById('iv-opacity-value').textContent = `${Math.round(styles.cardOpacity * 100)}%`;
    
    // ★★★ 核心新增：在这里加载我们保存的图标颜色！ ★★★
    document.getElementById('iv-icon-color').value = styles.iconColor || '#ff8a80';

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 保存用户修改的样式
 */
async function saveInnerVoiceStyles() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 从编辑器读取新值
    const newStyles = {
        clothingColor: document.getElementById('iv-color-clothing').value,
        behaviorColor: document.getElementById('iv-color-behavior').value,
        thoughtsColor: document.getElementById('iv-color-thoughts').value,
        naughtyColor: document.getElementById('iv-color-naughty').value,
        cardBgColor: document.getElementById('iv-card-bg-color').value,
        cardOpacity: parseFloat(document.getElementById('iv-opacity-slider').value),
        iconColor: document.getElementById('iv-icon-color').value
    };

    // 更新到state和数据库
    chat.settings.innerVoiceStyles = newStyles;
    await db.chats.put(chat);
    
    // 关闭弹窗
    document.getElementById('inner-voice-editor-modal').classList.remove('visible');
    
    // 重新应用一下最终保存的样式，以防万一
    applySavedInnerVoiceStyles();
    
    await showCustomAlert('保存成功', '心声面板的样式已更新！');
}

/* ▲▲▲ 新功能函数结束 ▲▲▲ */
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】打开AI生成群成员的模态框
 */
function openAiGenerateMembersModal() {
    // 清空上次的输入
    document.getElementById('ai-member-count-input').value = '3';
    document.getElementById('ai-member-prompt-input').value = '';
    // 显示弹窗
    document.getElementById('ai-generate-members-modal').classList.add('visible');
}

// ▼▼▼ 用这整块【已修复】的代码，完整替换你旧的 handleGenerateMembers 函数 ▼▼▼
/**
 * 【全新 | AI核心】处理用户点击“开始生成”按钮的逻辑 (已修复)
 */
async function handleGenerateMembers() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const count = parseInt(document.getElementById('ai-member-count-input').value);
    const requirements = document.getElementById('ai-member-prompt-input').value.trim();

    if (isNaN(count) || count < 1 || count > 20) {
        alert('请输入1到20之间的有效人数！');
        return;
    }

    document.getElementById('ai-generate-members-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", `AI正在为“${chat.name}”创造 ${count} 位新朋友...`);

    const systemPrompt = `
# 任务
你是一个群聊成员生成器。请根据用户的要求，为群聊“${chat.name}”创建${count}个新成员。

# 用户要求:
${requirements || '无特殊要求，请自由发挥。'}

# 核心规则
1.  你生成的每个成员都必须有独特的名字(name)和鲜明的性格人设(persona)。
2.  人设描述要生动、具体，能体现出角色的特点。
3.  【格式铁律】: 你的回复【必须且只能】是一个严格的JSON数组，直接以'['开头, 以']'结尾。数组中的每个元素都是一个代表成员的JSON对象。

# JSON输出格式示例:
[
  {
    "name": "林风",
    "persona": "一个阳光开朗的运动系少年，热爱篮球，性格直爽，是团队里的气氛担当。"
  },
  {
    "name": "陈雪",
    "persona": "文静内向的学霸少女，喜欢读书和画画，心思细腻，不善言辞但观察力敏锐。"
  }
]
`;

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        const newMembersData = JSON.parse(rawContent);

        if (Array.isArray(newMembersData) && newMembersData.length > 0) {
            const addedNames = [];
            newMembersData.forEach((memberData, index) => {
                if (memberData.name && memberData.persona) {
                    const newMember = {
                        id: 'npc_' + (Date.now() + index),
                        originalName: memberData.name.trim(),
                        groupNickname: memberData.name.trim(),
                        avatar: defaultGroupMemberAvatar,
                        persona: memberData.persona.trim(),
                        avatarFrame: '',
                        isAdmin: false,
                        groupTitle: ''
                    };
                    chat.members.push(newMember);
                    addedNames.push(`“${newMember.groupNickname}”`);
                }
            });

            if (addedNames.length > 0) {
                await db.chats.put(chat);
                await logSystemMessage(chat.id, `邀请了 ${addedNames.length} 位新成员: ${addedNames.join('、')}加入了群聊。`);
                await showCustomAlert("生成成功！", `${addedNames.length} 位新成员已加入群聊！`);
                renderMemberManagementList(); // 刷新成员管理列表

                // ★★★★★ 核心修复：就是删除了下面这一行！ ★★★★★
                // renderGroupMemberSettings(chat.members); 

            } else {
                throw new Error("AI返回的数据格式不正确，缺少name或persona字段。");
            }
        } else {
            throw new Error("AI返回的数据不是有效的数组。");
        }
    } catch (error) {
        console.error("AI生成群成员失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新 | 彻底重构】约会大作战 - 邀请与支付核心功能函数 ▼▼▼

/**
 * 【总入口 V2】当用户点击约会卡片时，打开角色选择器
 * @param {object} scene - 被选中的约会场景对象
 */
async function openDatingCharacterSelector(scene) {
    const modal = document.getElementById('dating-char-selector-modal');
    const listEl = document.getElementById('dating-char-selector-list');
    listEl.innerHTML = '';

    // 1. 找出所有可约会的单聊角色
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        alert("你还没有任何可以约会的角色哦，先去创建一个吧！");
        return;
    }

    // 2. 为每个角色创建列表项
    singleChats.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'character-select-item'; // 复用现有的样式
        item.dataset.charId = chat.id; // 将角色ID存起来
        item.innerHTML = `
            <img src="${chat.settings.aiAvatar || defaultAvatar}" alt="${chat.name}">
            <span class="name">${chat.name}</span>
        `;
        // 3. 【核心】为每个角色项绑定点击事件
        item.addEventListener('click', () => {
            modal.classList.remove('visible'); // 点击后先关闭选择器
            openDatingInvitationModal(scene, chat.id); // 然后带着场景和角色ID，打开支付弹窗
        });
        listEl.appendChild(item);
    });

    // 绑定取消按钮
    document.getElementById('dating-cancel-char-select-btn').onclick = () => modal.classList.remove('visible');
    
    // 4. 显示角色选择弹窗
    modal.classList.add('visible');
}


/**
 * 【V3 | 最终支付修复版】打开支付方式选择的模态框
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function openDatingInvitationModal(scene, targetCharId) {
    const modal = document.getElementById('dating-payment-modal');
    document.getElementById('dating-modal-scene-name').textContent = scene.name;
    document.getElementById('dating-modal-scene-cost').textContent = `预计花费: ${scene.cost}金币`;

    const optionsContainer = document.getElementById('dating-payment-options');
    optionsContainer.innerHTML = ''; // 清空旧按钮

    const chat = state.chats[targetCharId];
    if (!chat) return;

    // --- 按钮1：我来付全款 ---
    const userPayBtn = document.createElement('button');
    userPayBtn.className = 'form-button';
    userPayBtn.textContent = '我来付全款';
    userPayBtn.onclick = async () => {
        const userBalance = state.globalSettings.userBalance || 0;
        if (userBalance < scene.cost) {
            await showCustomAlert("余额不足", "你的钱包空空如也，无法支付这次约会的花费！");
            return;
        }
        await updateUserBalanceAndLogTransaction(-scene.cost, `约会支出: ${scene.name}`);
        await showCustomAlert("支付成功", `已成功支付 ${scene.cost}金币！`);
        modal.classList.remove('visible');
        startDatingScene(scene, targetCharId, 'user'); // 记录由user支付
    };
    optionsContainer.appendChild(userPayBtn);

    // --- 按钮2：让对方付全款 ---
    const charPayBtn = document.createElement('button');
    charPayBtn.className = 'form-button';
    charPayBtn.textContent = `让 ${chat.name} 付全款`;
    charPayBtn.onclick = async () => {
        const charBalance = chat.characterPhoneData?.bank?.balance || 0;
        if (charBalance < scene.cost) {
            await showCustomAlert("对方余额不足", `“${chat.name}”的钱包好像不够支付这次约会的费用哦。`);
            return;
        }
        // 【核心修复】调用函数，扣除角色的余额
        await updateCharacterPhoneBankBalance(targetCharId, -scene.cost, `约会支出: ${scene.name}`);
        await showCustomAlert("支付成功", `“${chat.name}”爽快地买单了！`);
        modal.classList.remove('visible');
        startDatingScene(scene, targetCharId, 'char'); // 记录由char支付
    };
    optionsContainer.appendChild(charPayBtn);

    // --- 按钮3：AA制 ---
    const aaPayBtn = document.createElement('button');
    aaPayBtn.className = 'form-button';
    aaPayBtn.textContent = '我们AA制吧';
    aaPayBtn.onclick = async () => {
        const splitCost = scene.cost / 2;
        const userBalance = state.globalSettings.userBalance || 0;
        const charBalance = chat.characterPhoneData?.bank?.balance || 0;

        if (userBalance < splitCost) {
            await showCustomAlert("余额不足", "你的钱包不够支付AA的费用哦！");
            return;
        }
        if (charBalance < splitCost) {
            await showCustomAlert("对方余额不足", `“${chat.name}”的钱包不够支付AA的费用哦。`);
            return;
        }
        
        // 【核心修复】同时扣除双方的余额
        await updateUserBalanceAndLogTransaction(-splitCost, `约会AA支出: ${scene.name}`);
        await updateCharacterPhoneBankBalance(targetCharId, -splitCost, `约会AA支出: ${scene.name}`);

        await showCustomAlert("支付成功", `你们愉快地决定AA制！`);
        modal.classList.remove('visible');
        startDatingScene(scene, targetCharId, 'aa'); // 记录为AA制
    };
    optionsContainer.appendChild(aaPayBtn);
    
    // --- 按钮4：找人借钱 (保持不变) ---
    const otherChars = Object.values(state.chats).filter(c => !c.isGroup && c.id !== targetCharId);
    if (otherChars.length > 0) {
        const borrowBtn = document.createElement('button');
        borrowBtn.className = 'form-button';
        borrowBtn.textContent = '我钱不够，找别人借点...';
        borrowBtn.onclick = () => {
            modal.classList.remove('visible');
            openBorrowMoneyModal(scene, targetCharId);
        };
        optionsContainer.appendChild(borrowBtn);
    }
    
    // 绑定取消按钮
    document.getElementById('dating-cancel-btn').onclick = () => modal.classList.remove('visible');
    // 显示弹窗
    modal.classList.add('visible');
}

/**
 * 【重构版】处理用户付全款的逻辑
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function handleUserPaysForDate(scene, targetCharId) {
    const cost = scene.cost;
    const userBalance = state.globalSettings.userBalance || 0;

    if (userBalance < cost) {
        await showCustomAlert("余额不足", "你的钱包空空如也，无法支付这次约会的花费！");
        return;
    }

    await updateUserBalanceAndLogTransaction(-cost, `约会支出: ${scene.name}`);
    await showCustomAlert("支付成功", `已成功支付 ${cost}金币！现在可以开始你们的约会了。`);

    const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户已为约会“${scene.name}”付款，花费${cost}金币。现在约会正式开始，请根据场景和人设，开启一段浪漫的约会对话。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    
    // 【核心修改】将消息添加到【目标角色】的聊天记录中
    const chat = state.chats[targetCharId];
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
    
    // 打开与该角色的聊天并触发回应
    openChat(targetCharId);
    triggerAiResponse();
}

/**
 * 【重构版】向AI请求让它付全款
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function requestCharToPay(scene, targetCharId) {
    const chat = state.chats[targetCharId];
    const cost = scene.cost;

    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户邀请你进行约会“${scene.name}”，并希望由你来支付全部费用（${cost}金币）。你的钱包余额是 ${chat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设、你与用户的关系以及你的钱包余额，决定是否同意。你【必须】使用 'dating_payment_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true
    };

    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
    
    await showCustomAlert("请求已发送", `已向 ${chat.name} 发出请求，请到聊天中查看Ta的回应吧。`);
    openChat(targetCharId);
    triggerAiResponse();
}

/**
 * 【重构版】向AI请求AA制
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function requestAAsplit(scene, targetCharId) {
    const chat = state.chats[targetCharId];
    const splitCost = scene.cost / 2;

    if ((state.globalSettings.userBalance || 0) < splitCost) {
        await showCustomAlert("余额不足", `你的余额不足以支付AA制的费用（${splitCost.toFixed(2)}金币）！`);
        return;
    }
    
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户邀请你进行约会“${scene.name}”，并提议AA制，即各自支付 ${splitCost.toFixed(2)} 金币。你的钱包余额是 ${chat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设和你与用户的关系，决定是否同意。你【必须】使用 'dating_aa_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);

    await showCustomAlert("请求已发送", `已向 ${chat.name} 发出AA制的提议，请到聊天中查看Ta的回应吧。`);
    openChat(targetCharId);
    triggerAiResponse();
}


// ▼▼▼ 【全新 | V2版】约会借钱功能核心函数 ▼▼▼

/**
 * 【V2 | 带头像、可滑动】打开“找人借钱”的选择列表
 * @param {object} scene - 约会场景对象
 * @param {string} dateTargetCharId - 你的约会对象ID
 */
async function openBorrowMoneyModal(scene, dateTargetCharId) {
    const modal = document.getElementById('borrow-money-modal');
    const listEl = document.getElementById('borrow-money-char-list');
    listEl.innerHTML = '';

    const otherChars = Object.values(state.chats).filter(c => !c.isGroup && c.id !== dateTargetCharId);

    if (otherChars.length === 0) {
        alert("没有其他可以借钱的朋友了。");
        return;
    }

    otherChars.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item'; // 复用样式
        item.dataset.charId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        item.addEventListener('click', async () => {
            modal.classList.remove('visible');
            const borrowAmountStr = await showCustomPrompt("借多少？", "请输入你想借的金额", "", "number");
            const borrowAmount = parseFloat(borrowAmountStr);
            if (borrowAmount > 0) {
                await requestToBorrowMoney(scene, dateTargetCharId, char.id, borrowAmount);
            } else if (borrowAmountStr !== null) {
                alert("请输入有效的借款金额！");
            }
        });
        listEl.appendChild(item);
    });

    document.getElementById('borrow-money-cancel-btn').onclick = () => modal.classList.remove('visible');
    modal.classList.add('visible');
}

async function requestToBorrowMoney(scene, dateTargetCharId, lenderChatId, amount) {
    const dateTargetChat = state.chats[dateTargetCharId]; 
    const lenderChat = state.chats[lenderChatId];     
    if (!lenderChat || !dateTargetChat) return;

    const myNickname = dateTargetChat.settings.myNickname || '我';

    // 1. 先构建payload和文本内容，方便复用
    const reasonText = `用于和“${dateTargetChat.name}”在“${scene.name}”的约会。`;
    const payloadData = {
        lenderName: lenderChat.name,
        amount: amount,
        reason: reasonText
    };
    // ★★★ 这就是我们新增的文本消息内容 ★★★
    const textContent = `向 ${lenderChat.name} 借钱 ${amount.toFixed(2)}元，${reasonText}`;

    // 2. 创建完整的消息对象，同时包含 payload 和 content
    const borrowRequestMessage = {
        role: 'user',
        type: 'borrow_money_request',
        timestamp: Date.now(),
        payload: payloadData,      // payload 用于渲染借条卡片（保持不变）
        content: textContent       // content 用于显示为文本消息（这是新增的）
    };
    
    // 将借条发到“债主”的聊天里 (这部分代码保持不变)
    lenderChat.history.push(borrowRequestMessage);
    
    // 3. 【核心修改】创建给AI看的、带有详细信息的隐藏指令
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户 “${myNickname}” 想向你借 ${amount.toFixed(2)} 金币，用于和 “${dateTargetChat.name}” 在 “${scene.name}” 约会。你的钱包余额是 ${lenderChat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设、你和用户的关系以及你的钱包余额，决定是否借钱。你【必须】使用 'lend_money_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应，并可以在文本消息中说明理由。]`,
        timestamp: Date.now() + 1, // 确保时间戳在后
        isHidden: true
    };
    lenderChat.history.push(hiddenMessage);
    await db.chats.put(lenderChat);

    await showCustomAlert("借钱请求已发送", `已向“${lenderChat.name}”发起了借款请求，请到和Ta的聊天中查看结果。`);
    
    // 打开与“债主”的聊天并触发回应
    openChat(lenderChatId);
    triggerAiResponse();
}
// ▼▼▼ 【全新】约会大作战-文游模式核心功能 ▼▼▼

let datingGameState = {
    isActive: false,
    scene: null,
    characterId: null,
    storyHistory: [], // 用于记录对话历史，方便AI生成后续内容
};
// ▼▼▼ 【最终渐变版】用这整块新代码，替换旧的 renderDatingValues 函数 ▼▼▼
/**
 * 【最终版 | SVG 渐变填充】渲染约会数值条（心形UI）
 * 这个版本使用线性渐变，最稳定、最高效。
 */
function renderDatingValues() {
    const romanceContainer = document.getElementById('romance-value');
    const lustContainer = document.getElementById('lust-value');
    if (!romanceContainer || !lustContainer) return;

    // 清空旧的心形
    romanceContainer.innerHTML = '';
    lustContainer.innerHTML = '';

    // 辅助函数：渲染一个完整的数值条
    const renderValueBar = (container, value, type) => {
        // ★★★ 核心修复：直接在这里定义颜色，不再使用CSS变量 ★★★
        const fillColor = type === 'romance' ? '#ff8fab' : '#ffde59'; // 粉色代表浪漫，黄色代表性欲
        // ★★★ 修复结束 ★★★

        const emptyColor = '#ccc';
        const emptyOpacity = '0.3';

        for (let i = 0; i < 5; i++) {
            // 计算当前这颗心应该被填充的百分比 (0-100)
            const fillPercentage = Math.max(0, Math.min(100, (value - i * 20) * 5));
            
            // 为每个SVG的渐变效果生成一个唯一的ID
            const gradientId = `heart-gradient-${type}-${i}`;

            const heartSvg = `
                <svg viewBox="0 0 24 24">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0" x2="0" y1="1" y2="0">
                            <stop offset="${fillPercentage}%" stop-color="${fillColor}" />
                            <stop offset="${fillPercentage}%" stop-color="${emptyColor}" stop-opacity="${emptyOpacity}" />
                        </linearGradient>
                    </defs>
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"
                          fill="url(#${gradientId})"
                          stroke="#aaa" 
                          stroke-width="1.5"/>
                </svg>
            `;
            container.innerHTML += heartSvg;
        }
    };
    
    // 调用函数，渲染两个数值条
    renderValueBar(romanceContainer, datingGameState.romance, 'romance');
    renderValueBar(lustContainer, datingGameState.lust, 'lust');
}
// ▲▲▲ 替换结束 ▲▲▲




/**
 * 【总入口 V3】开始一场约会 (已适配新版文游逻辑)
 */
async function startDatingScene(scene, targetCharId) {
    console.log(`开始约会: 场景="${scene.name}", 角色ID=${targetCharId}`);

    datingGameState = {
        isActive: true,
        scene: scene,
        characterId: targetCharId,
        storyHistory: [],
        romance: 0,
        lust: 0,
        currentStoryText: "",
        currentSentenceIndex: -1,
        sentences: [],
        isSwitchingSentence: false,
        // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
        isNsfwMode: false, 
        // ▲▲▲ 添加结束 ▲▲▲
    };


    const chat = state.chats[targetCharId];
    if (!chat) return;

    // 2. 准备UI元素
    const backgroundEl = document.getElementById('dating-game-background');
    const charNameEl = document.getElementById('dating-game-char-name');
    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');

    // 3. 重置UI到初始状态
    charNameEl.textContent = chat.name;
    backgroundEl.style.backgroundImage = 'none';
    textContentEl.innerHTML = '<p>AI正在精心构筑你们的约会世界...</p>';
    textContentEl.parentElement.style.opacity = 1;
    choicesEl.innerHTML = '';
    
    // 4. 显示游戏界面
    showScreen('dating-game-screen');

// 5. 加载背景图和第一段剧情
const uiSettings = chat.settings.datingUISettings || {};

// 优先使用用户在设置中保存的背景
if (uiSettings.backgroundUrl) {
    console.log("检测到自定义约会背景，正在加载...");
    backgroundEl.style.backgroundImage = `url(${uiSettings.backgroundUrl})`;
} else {
    // 如果没有设置，才调用AI生成
    console.log("未检测到自定义背景，将由AI生成...");
    const imagePrompt = scene.imagePrompt + ", vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art";
    generateAndLoadImage(imagePrompt)
        .then(imageUrl => { backgroundEl.style.backgroundImage = `url(${imageUrl})`; })
        .catch(error => { 
            console.error("约会背景图加载失败:", error);
            backgroundEl.style.backgroundColor = '#1c1e26'; // 失败时的备用背景
        });
}


    // 重置数值
    datingGameState.romance = 0;
    datingGameState.lust = 0;
        // 重置并显示完成度进度条
    datingGameState.completion = 0;
    renderDatingCompletion();
    document.getElementById('dating-completion-bar-container').style.display = 'block';
    // 渲染并显示心形UI
    renderDatingValues();
    document.getElementById('dating-values-container').style.display = 'flex';
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    await triggerDatingStory("start");
}
// ▼▼▼ 【全新】这是渲染完成度进度条的UI函数 ▼▼▼
/**
 * 渲染并更新约会完成度进度条的UI
 */
function renderDatingCompletion() {
    const container = document.getElementById('dating-completion-bar-container');
    const fill = document.getElementById('dating-completion-bar-fill');
    const text = document.getElementById('dating-completion-text');

    if (!container || !fill || !text) return;
    
    // 从游戏状态中获取完成度
    const completion = datingGameState.completion || 0;
    
    // 更新填充条的宽度和百分比文字
    fill.style.width = `${completion}%`;
    text.textContent = `${Math.round(completion)}%`;
}
// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 【V5 | 最终浪漫版】请用这整块代码，完整替换掉你旧的 triggerDatingStory 函数 ▼▼▼
async function triggerDatingStory(userAction) {
  datingGameState.isNsfwMode = false;
    if (!datingGameState.isActive) return;

    const { scene, characterId, storyHistory } = datingGameState;
    const chat = state.chats[characterId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("API未配置，无法继续约会。");
        return;
    }
    
    if (userAction !== "start") {
        storyHistory.push(`【你的选择】: ${userAction}`);
    }

    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');
    
    textContentEl.innerHTML = '<p><i>对方正在思考...</i></p>';
    choicesEl.innerHTML = '';

    const uiSettings = chat.settings.datingUISettings || {};
    const customPrompt = uiSettings.prompt || '';
    const customStyle = uiSettings.style || '你的回复必须是【第三人称】的旁白，详细描绘场景、角色的动作、神态、心理活动以及对话。让用户感觉像在看小说。';

    let spriteContext = '';
    let spriteChoiceInstruction = '';
    const spriteGroupId = uiSettings.spriteGroupId;

    if (spriteGroupId) {
        const sprites = await db.datingSprites.where('groupId').equals(spriteGroupId).toArray();
        if (sprites.length > 0) {
            spriteContext = `
# 可用角色立绘
你有一个立绘库，请根据当前情景选择一个最能表达角色“${chat.name}”心情和动作的立绘描述。
- ${sprites.map(s => `[描述: ${s.description}]`).join('\n- ')}
`;
            spriteChoiceInstruction = `"sprite": "【从上方列表中选择一个最合适的描述，并填在这里】",`;
        }
    }

// ▼▼▼ 【V6 | 完成度版】用这整块代码，替换旧的 triggerDatingStory 函数里的 systemPrompt ▼▼▼
// ▼▼▼ 【V2 | 智能评分版】用这整块代码，替换旧的 triggerDatingStory 函数里的 systemPrompt ▼▼▼
    const systemPrompt = `
# 角色扮演：恋爱互动小说游戏引擎
你现在是一个顶级的恋爱互动小说游戏引擎。你的任务是根据用户选择，推动一个浪漫约会故事的发展。
## 故事背景
- **你的角色**: 你将扮演角色“${chat.name}”。
- **你的角色人设**: ${chat.settings.aiPersona}\n${customPrompt}
- **用户的人设**: ${chat.settings.myPersona}
- **约会场景**: ${scene.name}
${spriteContext}
## 当前约会状态 (重要参考)
- **浪漫值**: ${datingGameState.romance}/100
- **性欲值**: ${datingGameState.lust}/100
- **约会完成度**: ${datingGameState.completion}%

## 核心规则
1.  **沉浸式叙事**: ${customStyle}
2.  **提供选择**: 在每段叙事后，你【必须】提供 2-4 个供用户选择的行动或对话选项。
3.  **【【【智能评分铁律】】】**: 你【必须】根据当前的故事进展、用户的选择以及你的回应，对本次互动的“质量”进行评估，并给出三个数值的【增加值】。
    - **"romance" (浪漫值)**: 如果互动是甜蜜、温馨或感人的，可以增加5-15分。
    - **"lust" (性欲值)**: 如果互动包含挑逗、暗示或身体接触，可以增加5-15分。
    - **"completion_increase" (完成度增加值)**:
        -   这是一个【可正可负】的数值。
        -   **正面互动**: 如果用户的选择让关系升温（例如，选择了更浪漫或大胆的选项），你应该给一个正数，范围在 **3到10** 之间。
        -   **负面互动**: 如果用户的选择很煞风景、粗鲁或导致尴尬，你应该给一个【负数】，范围在 **-10到-1** 之间，表示约会进度倒退。
        -   **平淡互动**: 如果互动很平淡或只是过渡，可以给 **0** 或 **1-2** 分。
4.  **【【【结束时机铁律】】】**: 当你认为故事已经发展到一个完美的、可以自然结束的节点时（例如：互相道别、回到家中），并且总完成度已接近100%，你【必须】将 \`"isDateOver"\` 字段设置为 \`true\`。
5.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
    {
      ${spriteChoiceInstruction}
      "story": "【这里是你的叙事内容...】",
      "choices": [
        "【选项1的文字描述】",
        "【选项2的文字描述】"
      ],
      "valuesUpdate": {
        "romance": 5,
        "lust": 0,
        "completion_increase": 8
      },
      "isDateOver": false
    }
## 故事历史 (供你参考)
${storyHistory.join('\n')}
现在，请根据用户的最新选择“${userAction}”，生成下一段故事、新的选项和智能评分。
`;
// ▲▲▲ 替换结束 ▲▲▲


    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API 请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        const gameData = JSON.parse(rawContent);

// ▼▼▼ 【V6 | 完成度最终版】用这整块代码，替换旧的 triggerDatingStory 函数里的 if (gameData.story...) 代码块 ▼▼▼
if (gameData.story && Array.isArray(gameData.choices)) {
    if (gameData.valuesUpdate) {
        const romanceChange = gameData.valuesUpdate.romance || 0;
        const lustChange = gameData.valuesUpdate.lust || 0;
        const completionIncrease = gameData.valuesUpdate.completion_increase || 0;

        datingGameState.romance = Math.max(0, Math.min(100, datingGameState.romance + romanceChange));
        datingGameState.lust = Math.max(0, Math.min(100, datingGameState.lust + lustChange));
        datingGameState.completion = Math.max(0, Math.min(100, datingGameState.completion + completionIncrease));
        
        console.log(`数值更新 -> 浪漫: ${datingGameState.romance}/100, 性欲: ${datingGameState.lust}/100, 完成度: ${datingGameState.completion}% (本次变化: ${completionIncrease})`);

        renderDatingValues();
        renderDatingCompletion();
    }
    
    const isDateOver = gameData.isDateOver || false;
    // ★★★ 核心修改：检查约会是否结束，并且完成度达到100% ★★★
    if (isDateOver && datingGameState.completion >= 100) {
        // 如果满足条件，就显示结算卡片，而不是直接结束
        showDatingSummaryCard(gameData.story); 
        return; // 显示卡片后，结束本次函数执行
    }
    
    // 如果约会未结束，则继续正常流程
    const spriteContainer = document.getElementById('dating-game-sprite-container');
    const spriteImg = document.getElementById('dating-game-sprite');
    if (gameData.sprite && spriteGroupId) {
        const chosenSprite = await db.datingSprites.where({ groupId: spriteGroupId, description: gameData.sprite }).first();
        if (chosenSprite) {
            spriteContainer.style.display = 'block';
            spriteContainer.style.left = `${chosenSprite.x}%`;
            spriteContainer.style.bottom = `${100 - chosenSprite.y}%`;
            spriteContainer.style.width = `${chosenSprite.size}%`;
            spriteContainer.style.transform = `translateX(-50%) translateY(${100 - chosenSprite.y}%)`;
            spriteImg.style.opacity = 0;
            setTimeout(() => { spriteImg.src = chosenSprite.url; spriteImg.style.opacity = 1; }, 300);
        } else {
            if (spriteContainer) spriteContainer.style.display = 'none';
        }
    } else {
        if (spriteContainer) spriteContainer.style.display = 'none';
    }
    
    datingGameState.storyHistory.push(`【旁白】: ${gameData.story}`);
    displayStoryText(gameData.story, gameData.choices);
    
    if (datingGameState.lust >= 100 && !datingGameState.isNsfwMode) {
        await triggerNsfwScene();
    }

} else {
    throw new Error("AI返回的数据格式不正确。");
}
// ▲▲▲ 替换结束 ▲▲▲



    } catch (error) {
        console.error("约会剧情生成失败:", error);
        textContentEl.innerHTML = `<p style="color: #ff8a80;">错误: 剧情加载失败，AI可能开小差了... \n(${error.message})</p>`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块【最终修复版】代码，完整替换旧的 triggerNsfwScene 函数 ▼▼▼
/**
 * 【V5 | 最终修复版】当欲望值满时，触发并推进NSFW剧情
 * @param {string} userAction - 用户的选择或自定义行动
 */
async function triggerNsfwScene(userAction = "故事自然发展") {
    // 1. 设置并确认NSFW模式标志
    datingGameState.isNsfwMode = true;
    console.log("NSFW模式已激活，正在生成NSFW剧情...");

    if (!datingGameState.isActive) return;

    // 2. 获取所需的所有数据 (这部分不变)
    const { scene, characterId, storyHistory } = datingGameState;
    const chat = state.chats[characterId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("API未配置，无法继续约会。");
        return;
    }
    
    storyHistory.push(`【你的选择】: ${userAction}`);
    
    // 3. 更新UI为等待状态 (这部分不变)
    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');
    textContentEl.innerHTML = '<p><i>气氛变得有些不一样了...</i></p>';
    choicesEl.innerHTML = '';

    // 4. 读取约会场景的通用设置 (这部分不变)
    const uiSettings = chat.settings.datingUISettings || {};
    const customPrompt = uiSettings.prompt || '';
    const baseStyle = uiSettings.style || '你的回复必须是【第三人称】的旁白，详细描绘场景、角色的动作、神态、心理活动以及对话。让用户感觉像在看小说。';
    const nsfwStyleInstruction = `
# NSFW剧情指令 (最高优先级)
接下来的故事【必须】包含详细、露骨、毫不避讳的性爱场面描写。你需要大胆地描绘角色的身体接触、动作、喘息、对话和内心感受，让故事进入高潮。叙事必须连贯、自然，符合角色性格。`;
    const customStyleWithNsfw = `${baseStyle}\n${nsfwStyleInstruction}`;
    
    // 立绘逻辑 (这部分不变)
    let spriteContext = '';
    let spriteChoiceInstruction = '';
    const spriteGroupId = uiSettings.spriteGroupId;
    if (spriteGroupId) {
        const sprites = await db.datingSprites.where('groupId').equals(spriteGroupId).toArray();
        if (sprites.length > 0) {
            spriteContext = `\n# 可用角色立绘\n${sprites.map(s => `- [描述: ${s.description}]`).join('\n')}`;
            spriteChoiceInstruction = `"sprite": "【从上方列表中选择一个最合适的描述，并填在这里】",`;
        }
    }

    // 5. ★★★ 核心修复：构建全新的、更清晰的System Prompt ★★★
    const systemPrompt = `
# 角色扮演：NSFW恋爱互动小说游戏引擎
你现在是一个顶级的成人小说游戏引擎。你的任务是根据用户选择，续写一段已经发展到高潮的浪漫约会故事。

## 故事背景
- **你的角色**: 你将扮演角色“${chat.name}”。
- **你的角色人设**: ${chat.settings.aiPersona}\n${customPrompt}
- **用户的人设**: ${chat.settings.myPersona}
- **约会场景**: ${scene.name}
${spriteContext}
## 当前约会状态 (重要参考)
- **浪漫值**: ${datingGameState.romance}/100
- **性欲值**: ${datingGameState.lust}/100
- **约会完成度**: ${datingGameState.completion}%

## 核心规则
1.  **沉浸式叙事**: ${customStyleWithNsfw}
2.  **提供选择**: 在每段NSFW叙事后，你【必须】提供 2-4 个供用户选择的、符合当前情景的行动或对话选项。
3.  **智能评分**: 你【必须】根据当前的故事进展、用户的选择以及你的回应，对本次互动的“质量”进行评估，并给出三个数值的【增加值】。
    - "romance" (浪漫值): 如果互动是甜蜜、温馨或感人的，可以增加5-15分。
    - "lust" (性欲值): 因为是NSFW剧情，此项应该持续增加，范围在10-25分之间。
    - "completion_increase" (完成度增加值): 如果用户的选择让关系升温（例如，选择了更浪漫或大胆的选项），你应该给一个正数，范围在 3到10 之间。如果用户的选择很煞风景，你应该给一个负数，范围在 -10到-1 之间。
4.  **【【【结束时机铁律】】】**: 你的主要任务是推进剧情，但当故事发展到一个**自然且满足的结局**时（例如：激情后的温存、相拥而眠、约定下次再见等），你【必须】将 \`"isDateOver"\` 字段设置为 \`true\` 来结束本次约会。这是结束的唯一方式。**不要无限地进行下去。**
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
    {
      ${spriteChoiceInstruction}
      "story": "【这里是你的NSFW叙事内容...】",
      "choices": [
        "【选项1的文字描述】",
        "【选项2的文字描述】"
      ],
      "valuesUpdate": {
        "romance": 5,
        "lust": 15,
        "completion_increase": 7
      },
      "isDateOver": false
    }
## 故事历史 (供你参考)
${storyHistory.join('\n')}

现在，请根据用户的最新选择“${userAction}”，生成下一段NSFW故事、新的选项和智能评分。
`;

    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
        });

        if (!response.ok) throw new Error(`API 请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        const gameData = JSON.parse(rawContent);

        if (gameData.story && Array.isArray(gameData.choices)) {
            // 数值更新逻辑 (不变)
            if (gameData.valuesUpdate) {
                const romanceChange = gameData.valuesUpdate.romance || 0;
                const lustChange = gameData.valuesUpdate.lust || 0;
                const completionIncrease = gameData.valuesUpdate.completion_increase || 1; 
                datingGameState.romance = Math.max(0, Math.min(100, datingGameState.romance + romanceChange));
                datingGameState.lust = Math.max(0, Math.min(100, datingGameState.lust + lustChange));
                datingGameState.completion = Math.max(0, Math.min(100, datingGameState.completion + completionIncrease));
                renderDatingValues();
                renderDatingCompletion();
            }

            // ★★★ 核心修复：只根据 AI 的 `isDateOver` 标志来决定是否结束 ★★★
            const isDateOver = gameData.isDateOver || false;
            if (isDateOver) {
                showDatingSummaryCard(gameData.story); 
                return; 
            }
            
            // 后续的立绘更新、故事记录和文本显示逻辑保持不变
            const spriteContainer = document.getElementById('dating-game-sprite-container');
            const spriteImg = document.getElementById('dating-game-sprite');
            if (gameData.sprite && spriteGroupId) {
                const chosenSprite = await db.datingSprites.where({ groupId: spriteGroupId, description: gameData.sprite }).first();
                if (chosenSprite) {
                    spriteContainer.style.display = 'block';
                    spriteContainer.style.left = `${chosenSprite.x}%`;
                    spriteContainer.style.bottom = `${100 - chosenSprite.y}%`;
                    spriteContainer.style.width = `${chosenSprite.size}%`;
                    spriteContainer.style.transform = `translateX(-50%) translateY(${100 - chosenSprite.y}%)`;
                    spriteImg.style.opacity = 0;
                    setTimeout(() => { spriteImg.src = chosenSprite.url; spriteImg.style.opacity = 1; }, 300);
                } else {
                    if (spriteContainer) spriteContainer.style.display = 'none';
                }
            } else {
                if (spriteContainer) spriteContainer.style.display = 'none';
            }
            
            datingGameState.storyHistory.push(`【旁白】: ${gameData.story}`);
            displayStoryText(gameData.story, gameData.choices);
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("NSFW剧情生成失败:", error);
        textContentEl.innerHTML = `<p style="color: #ff8a80;">错误: NSFW剧情加载失败... \n(${error.message})</p>`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】处理剧情文本的逐句显示
 * @param {string} storyText - AI返回的完整剧情文本
 * @param {Array<string>} choices - AI返回的选项数组
 */
function displayStoryText(storyText, choices) {
    // 1. 按标点符号分割句子
    const sentences = storyText.match(/[^。！？\s][^。！？]*[。！？]?/g) || [storyText];
    
    // 2. 更新游戏状态
    datingGameState.sentences = sentences;
    datingGameState.currentSentenceIndex = -1; // 重置索引
    datingGameState.choices = choices; // 暂存选项

    // 3. 准备UI，但【不显示】选项
    document.getElementById('dating-game-text-content').innerHTML = '';
    document.getElementById('dating-game-choices').innerHTML = '';
    
    // 4. 显示第一句
    showNextSentence();
}

// ▼▼▼ 【最终修正版 V3】请用这块代码，完整替换旧的 showNextSentence 函数 ▼▼▼

// ▼▼▼ 【最终决战版】请用这块代码，完整替换旧的 showNextSentence 函数 ▼▼▼

// ▼▼▼ 【最终决战版】请用这块代码，完整替换旧的 showNextSentence 函数 ▼▼▼

/**
 * 【最终版V4】显示下一句剧情文本，或在结束后显示选项
 * - 修正了文本意外消失的bug (使用appendChild代替innerHTML)
 * - 增加了点击保护，防止跳过句子
 */
function showNextSentence() {
    // 如果正在切换句子，则阻止任何新的操作，防止用户快速点击跳过剧情
    if (datingGameState.isSwitchingSentence) return;
    datingGameState.isSwitchingSentence = true; // 加锁

    const { sentences, choices } = datingGameState;
    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');
    const textboxEl = textContentEl.parentElement;
    
    // ★★★ 这就是我们新增的代码，用来获取进度条元素 ★★★
    const progressBarContainer = document.getElementById('dating-completion-bar-container');

    // 句子索引+1
    datingGameState.currentSentenceIndex++;
    const nextIndex = datingGameState.currentSentenceIndex;
    
    // 用安全的方式移除旧的“点击继续”提示
    const oldIndicator = textboxEl.querySelector('.continue-indicator');
    if (oldIndicator) {
        oldIndicator.remove();
    }
    
    // 先让旧文本淡出
    textContentEl.classList.add('fade-out');

    // 设定一个延迟来执行文本替换和动画
    setTimeout(() => {
        if (nextIndex < sentences.length) {
            const nextSentence = sentences[nextIndex];
            
            // 使用textContent进行安全的文本替换，绝对不会累积
            textContentEl.textContent = nextSentence;
            
            // 如果这不是最后一句...
            if (nextIndex < sentences.length - 1) {
                // ★★★ 因为只显示文字，所以我们在这里【显示】进度条 ★★★
                if (progressBarContainer) progressBarContainer.style.display = 'block';

                // 创建并添加“点击继续”的提示
                const indicator = document.createElement('div');
                indicator.className = 'continue-indicator';
                indicator.textContent = '▼';
                textboxEl.appendChild(indicator);
            } else {
                 // 如果是最后一句了，准备显示选项，所以我们在这里【隐藏】进度条
                if (progressBarContainer) progressBarContainer.style.display = 'none';
                
                choices.forEach(choiceText => {
                    const choiceBtn = document.createElement('button');
                    choiceBtn.className = 'dating-game-choice-btn';
                    choiceBtn.textContent = choiceText;
                    choiceBtn.onclick = () => {
                        if (datingGameState.isNsfwMode) {
                            triggerNsfwScene(choiceText);
                        } else {
                            triggerDatingStory(choiceText);
                        }
                    };
                    choicesEl.appendChild(choiceBtn);
                });

                // 添加“自由输入”按钮
                const inputBtn = document.createElement('button');
                inputBtn.className = 'dating-game-choice-btn input-action';
                inputBtn.textContent = '自定义行动...';
                inputBtn.onclick = async () => {
                    const userInput = await showCustomPrompt("你的行动", "请输入你想说的话或想做的事：");
                    if (userInput && userInput.trim()) {
                        if (datingGameState.isNsfwMode) {
                            triggerNsfwScene(userInput.trim());
                        } else {
                            triggerDatingStory(userInput.trim());
                        }
                    }
                };
                choicesEl.appendChild(inputBtn);
            }
        }
        
        // 让新文本淡入
        textContentEl.classList.remove('fade-out');

        // 所有操作完成后，解锁，允许下一次点击
        datingGameState.isSwitchingSentence = false; 

    }, 250);
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【V2 | 流程重构版】用这块新代码替换旧的 endDate 函数 ▼▼▼
/**
 * 【总入口】当用户点击“结束约会”时，弹出选择框
 */
async function endDate() {
    if (!datingGameState.isActive) return;

    // 1. 弹出选择框，让用户决定如何结束
    const choice = await showChoiceModal(
        '结束约会',
        [
            { text: '生成并记录约会', value: 'record' },
            { text: '直接结束不记录', value: 'discard' }
        ]
    );
    
    // 2. 根据用户的选择执行不同操作
    if (choice === 'record') {
        // 如果选择“记录”，就显示结算卡片
        showDatingSummaryCard();
    } else if (choice === 'discard') {
        // 如果选择“不记录”，就直接结束并返回聊天列表
        finalizeAndExitDate();
    }
    // 如果用户点了取消，则什么也不做，约会继续
}

/**
 * 【全新】最终结束约会并重置状态的函数
 */
async function finalizeAndExitDate() {
    if (!datingGameState.isActive) return;

    const chat = state.chats[datingGameState.characterId];
    if (chat) {
        const endMessage = { role: 'system', type: 'pat_message', content: `你和“${chat.name}”在“${datingGameState.scene.name}”的约会结束了。`, timestamp: Date.now() };
        chat.history.push(endMessage);
        await db.chats.put(chat);
    }
    
    // ▼▼▼【核心修复】就是在这里加上这一行！▼▼▼
    document.getElementById('dating-completion-bar-container').style.display = 'none';
    // ▲▲▲ 修复结束 ▲▲▲

    // 重置游戏状态
    datingGameState = {
        isActive: false, scene: null, characterId: null, storyHistory: [], romance: 0,
        lust: 0, completion: 0, currentStoryText: "", currentSentenceIndex: -1,
        sentences: [], isSwitchingSentence: false, isNsfwMode: false
    };

    // 隐藏结算卡片（如果它还开着）
    document.getElementById('dating-summary-overlay').classList.remove('visible');

    // 返回聊天列表并刷新
    showScreen('chat-list-screen');
    await renderChatList();
}



/* ▲▲▲ 约会大作战文游改造函数结束 ▲▲▲ */
// ▼▼▼ 用这块【已集成新功能】的代码，完整替换旧的 openDatingSettingsModal 函数 ▼▼▼
/**
 * 【总入口】打开约会场景设置弹窗
 */
async function openDatingSettingsModal() {
    const modal = document.getElementById('dating-game-settings-modal');
    const chat = state.chats[datingGameState.characterId];
    if (!chat) return;

    // 1. 加载当前角色的约会UI设置
    currentDatingUISettings = JSON.parse(JSON.stringify(chat.settings.datingUISettings || {
        prompt: '', style: '', backgroundUrl: '',
        spriteGroupId: null, // ★★★ 确保这个属性存在 ★★★
        sprite: { url: '', x: 50, y: 100, size: 80 }
    }));
    
    // 2. 填充弹窗内容 (保持不变)
    document.getElementById('dating-prompt-input').value = currentDatingUISettings.prompt;
    document.getElementById('dating-style-input').value = currentDatingUISettings.style;
    document.getElementById('dating-bg-url-input').value = currentDatingUISettings.backgroundUrl;
    
    // 3. ★★★ 核心修改：在这里调用新的渲染函数 ★★★
    await renderDatingSpriteGroupSelector();
    await renderDatingPresetSelector();

    // 4. 显示弹窗
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心】应用当前的UI设置到游戏界面
 */
function applyDatingUISettings() {
    if (!currentDatingUISettings) return;
    
    // 应用背景图
    const backgroundEl = document.getElementById('dating-game-background');
    if (currentDatingUISettings.backgroundUrl) {
        backgroundEl.style.backgroundImage = `url(${currentDatingUISettings.backgroundUrl})`;
    } else {
        // 如果没有设置，可以恢复到场景默认图或一个通用背景
        const imagePrompt = datingGameState.scene.imagePrompt + ", vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art";
        generateAndLoadImage(imagePrompt)
            .then(imageUrl => { backgroundEl.style.backgroundImage = `url(${imageUrl})`; })
            .catch(() => { backgroundEl.style.backgroundColor = '#1c1e26'; });
    }

    // 应用立绘
    const spriteContainer = document.getElementById('dating-game-sprite-container');
    const spriteImg = document.getElementById('dating-game-sprite');
    const sprite = currentDatingUISettings.sprite;
    if (sprite.url) {
        spriteImg.src = sprite.url;
        spriteContainer.style.display = 'block';
        spriteContainer.style.left = `${sprite.x}%`;
        spriteContainer.style.bottom = `${100 - sprite.y}%`;
        spriteContainer.style.width = `${sprite.size}%`;
        // 根据Y坐标调整transform，使立绘的“脚”能贴住设定的位置
        spriteContainer.style.transform = `translateX(-50%) translateY(${100 - sprite.y}%)`;

    } else {
        spriteImg.src = '';
        spriteContainer.style.display = 'none';
    }
}

// ▼▼▼ 用这块【已集成新功能】的代码，完整替换旧的 saveDatingSettings 函数 ▼▼▼
/**
 * 【核心】保存当前设置到角色数据中
 */
async function saveDatingSettings() {
    if (!datingGameState.characterId) return;
    const chat = state.chats[datingGameState.characterId];
    
    // 从UI读取所有设置值
    currentDatingUISettings.prompt = document.getElementById('dating-prompt-input').value.trim();
    currentDatingUISettings.style = document.getElementById('dating-style-input').value.trim();
    currentDatingUISettings.backgroundUrl = document.getElementById('dating-bg-url-input').value.trim();
    
    // ★★★ 核心新增：保存选中的立绘组ID ★★★
    const selectedSpriteGroupId = document.getElementById('dating-sprite-group-select').value;
    currentDatingUISettings.spriteGroupId = selectedSpriteGroupId ? parseInt(selectedSpriteGroupId) : null;

    // 立绘位置和大小的保存逻辑保持不变 (但我们现在不再在这里保存立绘URL了)
    currentDatingUISettings.sprite.x = 50;
    currentDatingUISettings.sprite.y = 100;
    currentDatingUISettings.sprite.size = 80;
    currentDatingUISettings.sprite.url = ''; // URL由AI动态决定，这里不保存

    // 确保角色的settings对象存在
    if (!chat.settings) chat.settings = {};
    // 保存
    chat.settings.datingUISettings = currentDatingUISettings;
    await db.chats.put(chat);
    
    // 应用并关闭弹窗
    applyDatingUISettings();
    document.getElementById('dating-game-settings-modal').classList.remove('visible');
    alert("场景设置已保存！");
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【辅助】处理图片上传
 * @param {'bg' | 'sprite'} type - 上传类型
 */
function handleDatingImageUpload(type) {
    const inputId = type === 'bg' ? 'dating-bg-upload-input' : 'dating-sprite-upload-input';
    const urlInputId = type === 'bg' ? 'dating-bg-url-input' : 'dating-sprite-url-input';
    document.getElementById(inputId).click();

    document.getElementById(inputId).onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
            const dataUrl = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            document.getElementById(urlInputId).value = dataUrl;
            if(type === 'bg') currentDatingUISettings.backgroundUrl = dataUrl;
            else currentDatingUISettings.sprite.url = dataUrl;
            applyDatingUISettings();
        }
        e.target.value = null; // 清空以便下次选择
    };
}

/**
 * 【重Roll功能】
 */
async function handleDatingReroll() {
    if (!datingGameState.isActive || datingGameState.storyHistory.length === 0) {
        alert("还没有可以重Roll的内容哦！");
        return;
    }

    // 1. 找到最后一次用户的行动
    let lastUserActionIndex = -1;
    for (let i = datingGameState.storyHistory.length - 1; i >= 0; i--) {
        if (datingGameState.storyHistory[i].startsWith('【你的选择】')) {
            lastUserActionIndex = i;
            break;
        }
    }
    
    // 如果找不到用户的行动（比如刚开始），就重Roll第一段剧情
    if (lastUserActionIndex === -1) {
        datingGameState.storyHistory = [];
        await triggerDatingStory("start");
        return;
    }

    // 2. 截取历史记录，回到用户做出选择之前的状态
    const lastUserAction = datingGameState.storyHistory[lastUserActionIndex].replace('【你的选择】: ', '');
    datingGameState.storyHistory = datingGameState.storyHistory.slice(0, lastUserActionIndex);
    
    // 3. 重新触发AI，使用户的最后一次行动再次生效
    await triggerDatingStory(lastUserAction);
}

// --- 以下是预设管理功能 (逻辑与你其他预设功能类似) ---

async function renderDatingPresetSelector() {
    const select = document.getElementById('dating-preset-select');
    const presets = await db.datingPresets.toArray();
    select.innerHTML = '<option value="">-- 自定义 --</option>';
    presets.forEach(p => {
        select.innerHTML += `<option value="${p.id}">${p.name}</option>`;
    });
}

// ▼▼▼ 【约会大作战 | 预设功能修复版】请用这整块代码，替换旧的 handleDatingPresetSelect 函数 ▼▼▼
async function handleDatingPresetSelect() {
    const select = document.getElementById('dating-preset-select');
    const presetId = parseInt(select.value);

    // 如果用户选择的是“-- 自定义 --”（即没有 presetId），则清空输入框，让用户可以自由编辑
    if (!presetId) {
        document.getElementById('dating-prompt-input').value = '';
        document.getElementById('dating-style-input').value = '';
        document.getElementById('dating-bg-url-input').value = '';
        document.getElementById('dating-sprite-group-select').value = '';
        
        // 同样重置临时的设置对象
        if (currentDatingUISettings) {
            currentDatingUISettings.prompt = '';
            currentDatingUISettings.style = '';
            currentDatingUISettings.backgroundUrl = '';
            currentDatingUISettings.spriteGroupId = null;
        }
        // 应用空的背景进行预览
        applyDatingUISettings();
        return;
    }

    // 根据ID从数据库获取预设
    const preset = await db.datingPresets.get(presetId);
    if (preset && preset.settings) {
        const loadedSettings = preset.settings;

        // 确保临时的UI设置对象存在，防止后续操作出错
        if (!currentDatingUISettings) {
            currentDatingUISettings = {
                prompt: '', style: '', backgroundUrl: '', spriteGroupId: null,
                sprite: { url: '', x: 50, y: 100, size: 80 }
            };
        }
        
        // 【核心修复】用加载的预设值，安全地更新当前设置对象，而不是整个替换它
        currentDatingUISettings.prompt = loadedSettings.prompt || '';
        currentDatingUISettings.style = loadedSettings.style || '';
        currentDatingUISettings.backgroundUrl = loadedSettings.backgroundUrl || '';
        currentDatingUISettings.spriteGroupId = loadedSettings.spriteGroupId || null;
        
        // 将新值同步更新到弹窗的UI控件上
        document.getElementById('dating-prompt-input').value = currentDatingUISettings.prompt;
        document.getElementById('dating-style-input').value = currentDatingUISettings.style;
        document.getElementById('dating-bg-url-input').value = currentDatingUISettings.backgroundUrl;
        document.getElementById('dating-sprite-group-select').value = currentDatingUISettings.spriteGroupId || '';

        // 实时应用背景预览。因为我们保留了.sprite结构，所以这里不会再报错。
        applyDatingUISettings();
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新修复版】打开并管理约会场景预设
 */
async function openDatingPresetManager() {
    // 1. 获取当前下拉框选中的预设ID
    const select = document.getElementById('dating-preset-select');
    if (!select) {
        alert("错误：在HTML中找不到ID为 'dating-preset-select' 的元素。");
        return;
    }
    const selectedId = select.value ? parseInt(select.value) : null;

    // 2. 弹出操作选择菜单
    const choice = await showChoiceModal("管理场景预设", [
        { text: '💾 保存当前为新预设', value: 'save' },
        { text: '🔄 更新选中预设', value: 'update', disabled: !selectedId },
        { text: '🗑️ 删除选中预设', value: 'delete', disabled: !selectedId }
    ]);
    
    hidePresetActions(); // 这是你已有的函数，用于关闭选择菜单

    // 3. 根据用户的选择，执行正确的操作
    if (choice === 'save') {
        const name = await showCustomPrompt("保存预设", "请输入预设名称：");
        if (name && name.trim()) {
            // 从UI收集当前的设置
            const currentSettings = {
                prompt: document.getElementById('dating-prompt-input').value.trim(),
                style: document.getElementById('dating-style-input').value.trim(),
                backgroundUrl: document.getElementById('dating-bg-url-input').value.trim(),
                spriteGroupId: document.getElementById('dating-sprite-group-select').value ? parseInt(document.getElementById('dating-sprite-group-select').value) : null
            };
            // 保存到数据库
            await db.datingPresets.add({ name: name.trim(), settings: currentSettings });
            await renderDatingPresetSelector(); // 刷新下拉框
            alert('预设已保存！');
        }
    } else if (choice === 'update') {
        if (selectedId) {
            // 收集当前设置
            const currentSettings = {
                prompt: document.getElementById('dating-prompt-input').value.trim(),
                style: document.getElementById('dating-style-input').value.trim(),
                backgroundUrl: document.getElementById('dating-bg-url-input').value.trim(),
                spriteGroupId: document.getElementById('dating-sprite-group-select').value ? parseInt(document.getElementById('dating-sprite-group-select').value) : null
            };
            // 更新数据库中的预设
            await db.datingPresets.update(selectedId, { settings: currentSettings });
            alert('预设已更新！');
        }
    } else if (choice === 'delete') {
        if (selectedId) {
            const presetToDelete = await db.datingPresets.get(selectedId);
            const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${presetToDelete.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.datingPresets.delete(selectedId);
                await renderDatingPresetSelector(); // 刷新下拉框
                // 删除后清空输入框
                document.getElementById('dating-prompt-input').value = '';
                document.getElementById('dating-style-input').value = '';
                document.getElementById('dating-bg-url-input').value = '';
                document.getElementById('dating-sprite-group-select').value = '';
                alert('预设已删除。');
            }
        }
    }
}

/* ▼▼▼ 【全新】约会立绘功能核心函数 ▼▼▼ */

/**
 * 【渲染】约会设置中“立绘组”的下拉选择器
 */
async function renderDatingSpriteGroupSelector() {
    const select = document.getElementById('dating-sprite-group-select');
    select.innerHTML = '<option value="">-- 不使用立绘 --</option>'; // 默认选项

    const groups = await db.datingSpriteGroups.toArray();
    groups.forEach(group => {
        select.innerHTML += `<option value="${group.id}">${group.name}</option>`;
    });

    // 根据当前加载的预设，自动选中对应的立绘组
    if (currentDatingUISettings && currentDatingUISettings.spriteGroupId) {
        select.value = currentDatingUISettings.spriteGroupId;
    }
}

/**
 * 【总入口】打开立绘组管理器
 */
async function openSpriteGroupManager() {
    await renderSpriteGroupManagerList();
    document.getElementById('sprite-group-manager-modal').classList.add('visible');
}

/**
 * 【渲染】在管理器中渲染立绘组列表
 */
async function renderSpriteGroupManagerList() {
    const container = document.getElementById('sprite-group-list-container');
    container.innerHTML = '';
    const groups = await db.datingSpriteGroups.orderBy('name').toArray();

    if (groups.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何立绘组，点击“新建”创建一个吧！</p>';
        return;
    }

    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'sprite-group-list-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <div class="group-actions">
                <button class="form-button-secondary" data-action="edit" data-id="${group.id}">编辑</button>
                <button class="form-button-secondary" data-action="delete" data-id="${group.id}" style="color: #ff3b30;">删除</button>
            </div>
        `;
        container.appendChild(item);
    });
}

/**
 * 【总入口】打开立绘组编辑器（用于新建或编辑）
 * @param {number|null} groupId - 如果是编辑，则传入ID；如果是新建，则为null
 */
async function openSpriteEditor(groupId = null) {
    editingSpriteGroupId = groupId;
    const modal = document.getElementById('sprite-editor-modal');
    const titleEl = document.getElementById('sprite-editor-title');
    const nameInput = document.getElementById('sprite-group-name-input');
    const listEditor = document.getElementById('sprite-list-editor');
    
    listEditor.innerHTML = ''; // 清空旧的立绘
    
    if (groupId) {
        // 编辑模式
        const group = await db.datingSpriteGroups.get(groupId);
        const sprites = await db.datingSprites.where('groupId').equals(groupId).toArray();
        titleEl.textContent = `编辑立绘组: ${group.name}`;
        nameInput.value = group.name;
        sprites.forEach(sprite => {
            listEditor.appendChild(createSpriteEditCard(sprite));
        });
    } else {
        // 新建模式
        titleEl.textContent = '新建立绘组';
        nameInput.value = '';
        // 默认创建一个空的立绘卡片
        listEditor.appendChild(createSpriteEditCard());
    }

    modal.classList.add('visible');
}

/**
 * 【辅助函数 V2 - 已添加位置大小滑块】创建一个立绘编辑卡片的DOM元素
 * @param {object} sprite - 可选的立绘数据对象
 * @returns {HTMLElement}
 */
function createSpriteEditCard(sprite = {}) {
    const card = document.createElement('div');
    card.className = 'sprite-edit-card';
    card.dataset.spriteId = sprite.id || `new_${Date.now()}_${Math.random()}`;

    // ★★★ 核心修改：为 x, y, size 提供默认值 ★★★
    const xPos = sprite.x ?? 50;  // 默认水平居中
    const yPos = sprite.y ?? 100; // 默认垂直贴底
    const size = sprite.size ?? 80; // 默认大小为80%

    // ★★★ 核心修改：在HTML中加入了三个滑块和数值显示 ★★★
    card.innerHTML = `
        <div class="preview-container" style="background-image: url(${sprite.url || ''})"></div>
        <div class="fields-container">
            <div class="form-group" style="margin:0;">
                <label>描述 (用于AI识别)</label>
                <textarea class="sprite-desc-input" rows="2">${sprite.description || ''}</textarea>
            </div>
            <div class="form-group" style="margin:0;">
                <label>图片 (URL或本地上传)</label>
                <div class="bg-upload-container">
                    <button class="form-button-secondary upload-sprite-btn" style="margin-top:0;">上传</button>
                    <input class="sprite-url-input" type="text" value="${sprite.url || ''}" placeholder="或粘贴URL">
                </div>
            </div>
            
            <!-- ▼▼▼ 从这里开始，是我们新增的滑块UI ▼▼▼ -->
            <div class="position-controls">
                <label>X 位置: <span class="pos-value">${xPos}%</span></label>
                <input type="range" class="sprite-x-slider" min="0" max="100" value="${xPos}">
            </div>
            <div class="position-controls">
                <label>Y 位置: <span class="pos-value">${yPos}%</span></label>
                <input type="range" class="sprite-y-slider" min="0" max="100" value="${yPos}">
            </div>
            <div class="position-controls">
                <label>大小: <span class="pos-value">${size}%</span></label>
                <input type="range" class="sprite-size-slider" min="10" max="150" value="${size}">
            </div>
            <!-- ▲▲▲ 新增UI结束 ▲▲▲ -->

        </div>
        <button class="delete-sprite-btn">×</button>
    `;

    // 为卡片内的按钮绑定事件 (这部分不变)
    card.querySelector('.delete-sprite-btn').onclick = () => card.remove();
    card.querySelector('.upload-sprite-btn').onclick = () => handleSpriteImageUpload(card);
    card.querySelector('.sprite-url-input').oninput = (e) => {
        card.querySelector('.preview-container').style.backgroundImage = `url(${e.target.value})`;
    };
    
    // ★★★ 核心修改：为新滑块绑定事件，实时更新旁边的数值显示 ★★★
    card.querySelectorAll('.position-controls input[type="range"]').forEach(slider => {
        slider.addEventListener('input', () => {
            const valueSpan = slider.previousElementSibling.querySelector('.pos-value');
            if(valueSpan) {
                valueSpan.textContent = `${slider.value}%`;
            }
        });
    });

    return card;
}


/**
 * 【辅助】处理单个立绘的图片上传
 * @param {HTMLElement} cardElement - 对应的立绘编辑卡片
 */
function handleSpriteImageUpload(cardElement) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (file) {
            const dataUrl = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            cardElement.querySelector('.sprite-url-input').value = dataUrl;
            cardElement.querySelector('.preview-container').style.backgroundImage = `url(${dataUrl})`;
        }
    };
    fileInput.click();
}

/**
 * 【核心 V2 - 已支持位置大小】保存整个立绘组（包括所有立绘）
 */
async function saveSpriteGroup() {
    const name = document.getElementById('sprite-group-name-input').value.trim();
    if (!name) {
        alert("立绘组名称不能为空！");
        return;
    }

    // 1. 保存或更新立绘组的名称 (这部分不变)
    let groupId;
    if (editingSpriteGroupId) {
        await db.datingSpriteGroups.update(editingSpriteGroupId, { name });
        groupId = editingSpriteGroupId;
    } else {
        groupId = await db.datingSpriteGroups.add({ name });
    }

    // 2. 准备更新的立绘数据 (★★★ 核心修改在这里 ★★★)
    const spriteCards = document.querySelectorAll('#sprite-list-editor .sprite-edit-card');
    const spritesToSave = [];
    let hasError = false;

    spriteCards.forEach(card => {
        const description = card.querySelector('.sprite-desc-input').value.trim();
        const url = card.querySelector('.sprite-url-input').value.trim();
        
        // ▼▼▼ 从新增的滑块中读取 x, y, size 的值 ▼▼▼
        const x = parseInt(card.querySelector('.sprite-x-slider').value);
        const y = parseInt(card.querySelector('.sprite-y-slider').value);
        const size = parseInt(card.querySelector('.sprite-size-slider').value);
        // ▲▲▲ 读取结束 ▲▲▲

        if (!description || !url) {
            hasError = true;
        }

        spritesToSave.push({
            id: card.dataset.spriteId.startsWith('new_') ? undefined : parseInt(card.dataset.spriteId),
            groupId: groupId,
            description,
            url,
            // ▼▼▼ 将读取到的值添加到要保存的对象中 ▼▼▼
            x: x,
            y: y,
            size: size
            // ▲▲▲ 添加结束 ▲▲▲
        });
    });

    if (hasError) {
        alert("存在描述或图片URL为空的立绘，请填写完整！");
        return;
    }

    // 3. 使用事务，一次性更新所有数据 (这部分不变)
    await db.transaction('rw', db.datingSprites, async () => {
        await db.datingSprites.where('groupId').equals(groupId).delete();
        await db.datingSprites.bulkAdd(spritesToSave);
    });

    // 4. 关闭弹窗并刷新UI (这部分不变)
    document.getElementById('sprite-editor-modal').classList.remove('visible');
    await renderSpriteGroupManagerList();
    await renderDatingSpriteGroupSelector();
    
    if (document.getElementById('dating-game-settings-modal').classList.contains('visible')) {
        document.getElementById('dating-sprite-group-select').value = groupId;
    }
    
    alert('立绘组已保存！');
}


/**
 * 【核心】删除一个立绘组及其所有立绘
 * @param {number} groupId - 要删除的立绘组的ID
 */
async function deleteSpriteGroup(groupId) {
    const group = await db.datingSpriteGroups.get(groupId);
    const confirmed = await showCustomConfirm('删除立绘组', `确定要删除立绘组 “${group.name}” 吗？此操作不可恢复。`, {confirmButtonClass: 'btn-danger'});
    if (confirmed) {
        await db.transaction('rw', db.datingSpriteGroups, db.datingSprites, db.datingPresets, async () => {
            // 1. 删除该组下的所有立绘
            await db.datingSprites.where('groupId').equals(groupId).delete();
            // 2. 删除立绘组本身
            await db.datingSpriteGroups.delete(groupId);
            // 3. 【关键】找到所有引用了这个立绘组的约会预设，并将它们的引用清空
            const presetsToUpdate = await db.datingPresets.where('settings.spriteGroupId').equals(groupId).toArray();
            for (const preset of presetsToUpdate) {
                preset.settings.spriteGroupId = null;
                await db.datingPresets.put(preset);
            }
        });
        await renderSpriteGroupManagerList();
        await renderDatingSpriteGroupSelector();
        alert('立绘组已删除。');
    }
}
/* ▲▲▲ 约会立绘功能核心函数结束 ▲▲▲ */


// ▼▼▼ 用这块【新代码】完整替换旧的 showDatingSummaryCard 函数 ▼▼▼
/**
 * 【全新V2】当约会结束时，显示结算卡片，并自动保存到历史记录
 * @param {string} [finalStory=""] - 约会的最后一段剧情文本
 */
async function showDatingSummaryCard(finalStory = "") { // <--- 关键：将函数声明为 async
    const overlay = document.getElementById('dating-summary-overlay');
    const card = document.querySelector('.dating-summary-card');
    const cardInner = document.querySelector('.dating-summary-card-inner');
    const cardFront = document.querySelector('.card-front');
    const avatarEl = document.getElementById('summary-card-avatar');
    const ratingEl = document.getElementById('summary-card-rating');
    const historyEl = document.getElementById('summary-card-history');

    document.getElementById('summary-share-btn').style.display = 'block';

    card.classList.remove('is-flipped');
    cardFront.classList.remove('romantic', 'passionate', 'perfect');

    const romance = datingGameState.romance;
    const lust = datingGameState.lust;
    const completion = datingGameState.completion;
    let ratingText = '';
    let cardClass = '';
    let finalRatingType = 'anticipation';

// ▼▼▼ 从这里开始复制，替换你的旧代码 ▼▼▼

    if (romance >= 100 && lust >= 100 && completion >= 100) {
        ratingText = '完美之夜 🎊'; // 修改点：添加了庆祝的 emoji
        cardClass = 'perfect';
        finalRatingType = 'perfect';
    } else if (romance >= 100) {
        ratingText = '浪漫之夜 ❤️'; // 修改点：添加了爱心 emoji
        cardClass = 'romantic';
        finalRatingType = 'romantic';
    } else if (lust >= 100) {
        ratingText = '激情之夜 ⭐'; // 修改点：添加了星星 emoji
        cardClass = 'passionate';
        finalRatingType = 'passionate';
    } else {
        ratingText = '期待之夜'; // 保持不变
    }
    
// ▲▲▲ 复制替换到这里结束 ▲▲▲

    const character = state.chats[datingGameState.characterId];
    avatarEl.src = character.settings.aiAvatar || defaultAvatar;
    ratingEl.textContent = ratingText;
    if(cardClass) {
        cardFront.classList.add(cardClass);
    }

    const fullHistory = [...datingGameState.storyHistory, `【旁白】: ${finalStory}`].join('\n\n').replace(/\n/g, '<br>');
    historyEl.innerHTML = `<p>${fullHistory}</p>`;
    
    // 暂存数据，以便分享
    currentDatingSummary = {
        rating: ratingText,
        ratingType: finalRatingType,
        characterId: datingGameState.characterId,
        avatarUrl: avatarEl.src,
        storyHistory: datingGameState.storyHistory,
        finalStory: finalStory,
        sceneName: datingGameState.scene.name
    };

    // ★★★★★ 这就是我们新增的、最核心的保存逻辑！ ★★★★★
    try {
        const historyRecord = {
            ...currentDatingSummary, // 将卡片的所有信息都复制过来
            timestamp: Date.now()   // 加上一个保存时的时间戳
        };
        // 使用 await 异步地将这条记录添加到我们的新数据库表中
        await db.datingHistory.add(historyRecord);
        console.log('约会结算卡片已保存到历史库:', historyRecord);
    } catch (error) {
        console.error('保存约会结算卡片失败:', error);
    }
    // ▲▲▲▲▲ 新增逻辑结束 ▲▲▲▲▲

    overlay.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新V2版】将结算卡片分享到与角色的聊天中 (包含完整记录用于编辑)
 */
async function shareDatingSummary() {
    // 安全检查，确保有结算数据
    if (!currentDatingSummary) return;

    const chat = state.chats[currentDatingSummary.characterId];
    if (!chat) return;

    // 1. 准备一个用于【编辑时】显示的、包含完整约会过程的详细文本
    const storyForEdit = [...currentDatingSummary.storyHistory, `【旁白】: ${currentDatingSummary.finalStory}`].join('\n');
    const contentForEditing = `
[约会记录]
约会场所: ${currentDatingSummary.sceneName}
约会评级: ${currentDatingSummary.rating}
--------------------
${storyForEdit}
    `.trim();

    // 2. 创建一个特殊的消息对象，它将作为聊天记录被保存
    const summaryMessage = {
        role: 'user', // 标记为用户发出的消息
        type: 'dating_summary_card', // 这是我们自定义的新消息类型，用于识别
        timestamp: Date.now(),
        
        // 【核心】这个 content 字段就是你想要的，当编辑这条消息时，就会显示这里的文本
        content: contentForEditing, 
        
        // payload 字段用于存储渲染UI所需的所有数据
        payload: {
            rating: currentDatingSummary.rating,
            ratingType: currentDatingSummary.ratingType,
            avatarUrl: currentDatingSummary.avatarUrl,
            storyHistory: currentDatingSummary.storyHistory,
            finalStory: currentDatingSummary.finalStory,
            sceneName: currentDatingSummary.sceneName,
            characterName: chat.name // 把角色名字也存进去，方便卡片背面显示
        }
    };

    // 3. 将这条新消息添加到聊天记录并保存到数据库
    chat.history.push(summaryMessage);
    await db.chats.put(chat);
    
    // 4. 给出成功提示，并关闭结算卡片、结束约会
    await showCustomAlert('分享成功', '你们的约会记录已发送给Ta！');
    
    document.getElementById('dating-summary-overlay').classList.remove('visible');
    finalizeAndExitDate(); // 这个函数会处理后续的清理工作
    currentDatingSummary = null; // 清理临时数据
}


/**
 * 【全新】重新打开约会结算详情卡片
 * @param {object} payload - 从聊天记录消息中解析出的卡片数据
 */
function reopenDatingSummary(payload) {
    const overlay = document.getElementById('dating-summary-overlay');
    const card = document.querySelector('.dating-summary-card');
    const cardInner = document.querySelector('.dating-summary-card-inner');
    const cardFront = document.querySelector('.card-front');
    const avatarEl = document.getElementById('summary-card-avatar');
    const ratingEl = document.getElementById('summary-card-rating');
    const historyEl = document.getElementById('summary-card-history');

    // 重置卡片状态
    card.classList.remove('is-flipped');
    cardFront.classList.remove('romantic', 'passionate', 'perfect');
    cardFront.style.background = '';
    
    // 从 payload 中恢复数据并填充到UI元素中
    avatarEl.src = payload.avatarUrl;
    ratingEl.textContent = payload.rating;
    if (payload.ratingType && payload.ratingType !== 'anticipation') {
        cardFront.classList.add(payload.ratingType);
    }
    
    const fullHistory = [...payload.storyHistory, `【旁白】: ${payload.finalStory}`].join('\n\n').replace(/\n/g, '<br>');
    historyEl.innerHTML = `<p>${fullHistory}</p>`;

    // 设置卡片背面的标题
    const cardBackHeader = document.querySelector('.card-back .card-back-header span');
    if (cardBackHeader) {
        cardBackHeader.textContent = `${payload.characterName} - ${payload.sceneName}`;
    }

    // 因为只是查看，所以隐藏“分享”按钮
    document.getElementById('summary-share-btn').style.display = 'none';

    overlay.classList.add('visible');
}


/* --- 【全新】约会历史记录功能核心函数 --- */

/**
 * 【总入口】打开历史约会界面
 */
async function openDatingHistory() {
    showScreen('dating-history-screen');
    await renderDatingHistory();
}

/**
 * 【渲染函数】渲染历史约会列表
 */
async function renderDatingHistory() {
    const listEl = document.getElementById('dating-history-list');
    listEl.innerHTML = '';

    // 从数据库读取所有记录，并按时间倒序排列
    const records = await db.datingHistory.orderBy('timestamp').reverse().toArray();

    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何约会记录哦</p>';
        return;
    }

    // 遍历每一条记录，创建对应的卡片并添加到列表中
    records.forEach(record => {
        const card = createDatingHistoryCard(record);
        listEl.appendChild(card);
    });
}

/**
 * 【辅助函数】根据单条历史记录，创建一张可翻转的卡片
 * @param {object} record - 历史记录对象
 * @returns {HTMLElement} - 创建好的卡片DOM元素
 */
function createDatingHistoryCard(record) {
    const cardContainer = document.createElement('div');
    cardContainer.className = 'dating-summary-card'; // 复用结算卡片的样式，很方便！

    // 根据评级类型设置卡片正面的颜色
    let cardClass = '';
    if (record.ratingType === 'romantic') cardClass = 'romantic';
    else if (record.ratingType === 'passionate') cardClass = 'passionate';
    else if (record.ratingType === 'perfect') cardClass = 'perfect';

    // 拼接卡片背面的完整约会记录HTML
    const fullHistoryHtml = [...record.storyHistory, `【旁白】: ${record.finalStory}`]
        .join('\n\n')
        .replace(/\n/g, '<br>');

    // 获取角色名字，如果角色被删了，就显示“未知角色”
    const charName = state.chats[record.characterId]?.name || '未知角色';
    
    // 最终拼接成一个完整的、包含正反两面的卡片HTML
    cardContainer.innerHTML = `
        <div class="dating-summary-card-inner">
            <!-- 卡片正面 -->
            <div class="card-front ${cardClass}">
                <img src="${record.avatarUrl}" alt="角色头像">
                <h2>${record.rating}</h2>
                <p>${new Date(record.timestamp).toLocaleDateString()}</p>
                <p class="summary-card-tip">点击查看详情</p>
            </div>
            <!-- 卡片背面 -->
            <div class="card-back">
                <div class="card-back-header">
                    <span>${charName} - ${record.sceneName}</span>
                </div>
                <div class="card-back-content">
                    <p>${fullHistoryHtml}</p>
                </div>
            </div>
        </div>
    `;
    return cardContainer;
}

/* --- 【全新】约会历史记录功能函数结束 --- */
// ▼▼▼ 把这一整块全新的函数，粘贴到 handleSaveCustomDatingScene 函数的上方 ▼▼▼

// ▼▼▼ 用这块【V2 - 场景重写版】代码，完整替换旧的 getSceneTypeKeywords 函数 ▼▼▼

/**
 * 【V2 - 场景重写版】根据场景名称，智能判断并返回重写后的场景描述和风格关键词
 * @param {string} sceneName - 用户输入的场景名称
 * @returns {{scenePrompt: string, styleKeywords: string}} - 返回包含场景描述和风格词的对象
 */
function getSceneTypeKeywords(sceneName) {
    const name = sceneName.toLowerCase(); // 转换为小写，方便匹配

    const outdoorKeywords = ['公园', '海滩', '山', '森林', '湖', '花园', '夜市', '路边', '街头', 'park', 'beach', 'mountain', 'forest', 'lake', 'garden', 'street'];
    const indoorPublicKeywords = ['咖啡', '书店', '博物馆', '美术馆', '水族馆', '影院', '酒吧', 'cafe', 'bookstore', 'museum', 'gallery', 'aquarium', 'cinema', 'bar'];
    const loveHotelKeywords = ['情趣', 'love hotel', '主题酒店', 'lovers hotel', '成人旅馆'];

    // 1. 【核心修改】优先判断是否为特殊的情趣酒店
    if (loveHotelKeywords.some(keyword => name.includes(keyword))) {
        console.log("场景识别为：情趣酒店（已激活特殊重写模式）");
        // 我们不再使用用户输入的 "情趣酒店" 这个词
        // 而是直接把它“翻译”成一个纯粹的、描述性的场景
        return {
            scenePrompt: 'an empty luxurious romantic hotel room interior, with a heart-shaped bed or a round bed, mirrors on the ceiling, neon mood lighting, Jacuzzi in room, sensual and intimate atmosphere',
            styleKeywords: 'romantic, luxurious, intimate, playful'
        };
    }

    // 2. 对于其他场景，保持原来的逻辑，直接使用用户输入的名称
    if (outdoorKeywords.some(keyword => name.includes(keyword))) {
        console.log("场景识别为：户外");
        return {
            scenePrompt: sceneName,
            styleKeywords: 'natural lighting, golden hour, beautiful scenery, serene atmosphere, epic sky, wide angle'
        };
    }

    if (indoorPublicKeywords.some(keyword => name.includes(keyword))) {
        console.log("场景识别为：室内公共场所");
        return {
            scenePrompt: sceneName,
            styleKeywords: 'cozy interior, ambient lighting, warm and inviting, charming decor, detailed background'
        };
    }

    // 4. 默认情况，也直接使用用户输入的名称
    console.log("场景识别为：通用/现代酒店");
    return {
        scenePrompt: sceneName,
        styleKeywords: 'modern aesthetic, elegant decor, luxurious interior, clean, bright'
    };
}

// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【已适配】的代码，完整替换旧的 handleSaveCustomDatingScene 函数 ▼▼▼
async function handleSaveCustomDatingScene() {
    const name = document.getElementById('scene-name-input').value.trim();
    const imageUrl = document.getElementById('scene-image-url-input').value.trim();
    const costStr = document.getElementById('scene-cost-input').value.trim();

    if (!name || !costStr) {
        alert("场景名称和花费为必填项！");
        return;
    }

    const cost = parseInt(costStr, 10);
    if (isNaN(cost) || cost < 0) {
        alert("请输入有效的花费金额！");
        return;
    }
    
    const newScene = {
        name: name,
        cost: cost,
        uid: 'scene_user_' + Date.now()
    };

    if (imageUrl) {
        if (!imageUrl.startsWith('http') && !imageUrl.startsWith('data:image')) {
            alert("请输入一个有效的网络图片URL！");
            return;
        }
        newScene.imageUrl = imageUrl;
        newScene.imagePrompt = 'User-provided image';
    } else {
        // --- 【核心修改在这里】 ---

        // 1. 这是我们强力的通用指令，确保高质量和【绝对不要人物】
        const universalStyle = "photorealistic, 4k, hyperrealistic, cinematic lighting, masterpiece, best quality, ultra detailed, no dark elements, romantic, (no humans:1.5), no people, no characters, empty room, no one";
        
        // 2. 调用我们升级后的辅助函数，它会返回一个包含 scenePrompt 和 styleKeywords 的对象
        const promptParts = getSceneTypeKeywords(name);
        
        // 3. 将【重写后的场景描述】、【智能风格】和【通用风格】组合成最终的提示词
        newScene.imageUrl = '';
        newScene.imagePrompt = `${promptParts.scenePrompt}, ${promptParts.styleKeywords}, ${universalStyle}`;
        
        console.log("【终极版】生成的Image Prompt:", newScene.imagePrompt); 
    }

    try {
        await db.datingScenes.add(newScene);
        currentDatingScenes.push(newScene);
        document.getElementById('create-dating-scene-modal').classList.remove('visible');
        renderDatingScenes();
        alert('自定义约会场景已成功创建！');
    } catch (error) {
        console.error("保存自定义约会场景失败:", error);
        alert(`保存失败: ${error.message}`);
    }
}
// ▼▼▼ 【V2 - 编辑模式版】用这块代码替换旧的 renderStickerCategories 函数 ▼▼▼
async function renderStickerCategories() {
    const tabsContainer = document.getElementById('sticker-category-tabs');
    if (!tabsContainer) return;

    tabsContainer.innerHTML = ''; // 清空旧的标签
    const categories = await db.userStickerCategories.orderBy('name').toArray();
    userStickerCategories = categories; // 更新全局缓存

    // 1. 渲染“未分类”按钮（这个按钮没有删除功能）
    const uncategorizedBtn = document.createElement('button');
    uncategorizedBtn.className = 'sticker-category-btn';
    uncategorizedBtn.textContent = '未分类';
    uncategorizedBtn.dataset.categoryId = 'uncategorized';
    if (activeStickerCategoryId === 'uncategorized') {
        uncategorizedBtn.classList.add('active');
    }
    tabsContainer.appendChild(uncategorizedBtn);

    // 2. 渲染所有自定义分类
    for (const category of categories) {
        const btn = document.createElement('button');
        btn.className = 'sticker-category-btn';
        // ★ 核心修改1：将ID和名称都存储在父按钮上，方便事件委托获取
        btn.dataset.categoryId = category.id;       
        btn.dataset.categoryName = category.name;    

        const nameSpan = document.createElement('span');
        nameSpan.textContent = category.name;
        btn.appendChild(nameSpan);

        // 如果是当前激活的分类，添加高亮
        if (activeStickerCategoryId === category.id) {
            btn.classList.add('active');
        }
        
        // ★★★ 核心修改2：只在编辑模式下，才创建和添加删除按钮 ★★★
        if (isUserStickerSelectionMode) {
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'sticker-category-delete-btn';
            deleteBtn.textContent = '×';
            deleteBtn.title = `删除分类 "${category.name}"`; // 增加悬浮提示
            btn.appendChild(deleteBtn);
        }
        
        tabsContainer.appendChild(btn);
    }
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 【全新】打开移动表情到分类的模态框
 */
async function openStickerCategoryModal() {
    if (selectedUserStickers.size === 0) {
        alert('请先选择要移动的表情包！');
        return;
    }

    const modal = document.getElementById('sticker-category-modal');
    const listEl = document.getElementById('sticker-category-list');
    const inputEl = document.getElementById('new-sticker-category-input');
    listEl.innerHTML = '';
    inputEl.value = '';

    const categories = await db.userStickerCategories.toArray();
    if (categories.length > 0) {
        categories.forEach(cat => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="radio" name="sticker_category_select" value="${cat.id}"> ${cat.name}`;
            listEl.appendChild(label);
        });
    } else {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类。</p>';
    }

    modal.classList.add('visible');
}

/**
 * 【全新】处理“确认移动”按钮的点击逻辑
 */
async function handleMoveStickers() {
    const newCategoryName = document.getElementById('new-sticker-category-input').value.trim();
    const selectedRadio = document.querySelector('input[name="sticker_category_select"]:checked');
    
    let targetCategoryId = null;

    if (newCategoryName) {
        try {
            // 检查分类是否已存在
            let existingCategory = await db.userStickerCategories.where('name').equalsIgnoreCase(newCategoryName).first();
            if (existingCategory) {
                targetCategoryId = existingCategory.id;
            } else {
                targetCategoryId = await db.userStickerCategories.add({ name: newCategoryName });
            }
        } catch (error) {
            alert('创建新分类失败，可能是名称重复或数据库错误。');
            return;
        }
    } else if (selectedRadio) {
        targetCategoryId = parseInt(selectedRadio.value);
    } else {
        alert('请选择一个分类或创建一个新分类！');
        return;
    }

    try {
        const stickerIdsToMove = Array.from(selectedUserStickers);
        const stickers = await db.userStickers.bulkGet(stickerIdsToMove);
        
        stickers.forEach(sticker => {
            if (sticker) {
                sticker.categoryId = targetCategoryId;
            }
        });

        await db.userStickers.bulkPut(stickers);
        
        // 更新内存中的 state.userStickers
        stickers.forEach(updatedSticker => {
            const index = state.userStickers.findIndex(s => s.id === updatedSticker.id);
            if (index > -1) {
                state.userStickers[index].categoryId = targetCategoryId;
            }
        });

        document.getElementById('sticker-category-modal').classList.remove('visible');
        exitUserStickerSelectionMode(); // 退出编辑模式
        alert(`成功移动 ${stickerIdsToMove.length} 个表情！`);

    } catch (error) {
        console.error("移动表情失败:", error);
        alert("移动表情时发生错误。");
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【备用方案】视频通话控制按钮的事件委托 ▼▼▼

// 这个函数用于统一处理所有通话控制按钮的点击
function handleCallControls(event) {
    // 找到被点击的那个按钮元素
    const button = event.target.closest('.control-btn');
    if (!button) return; // 如果点击的不是按钮，就什么也不做

    // 根据按钮的ID来执行不同的操作
    switch (button.id) {
        case 'user-speak-btn':
        case 'user-speak-btn-visual':
            // 这里调用你原本处理“用户发言”的函数
            handleUserSpeakInCall(); // 假设你的函数名叫这个
            break;
        case 'hang-up-btn':
        case 'hang-up-btn-visual':
            // 调用你原本处理“挂断”的函数
            endVideoCall();
            break;
        case 'join-call-btn':
            // 调用你原本处理“加入通话”的函数
            handleUserJoinCall();
            break;
        case 'reroll-call-btn':
        case 'reroll-call-btn-text':
             // 调用你原本处理“重roll”的函数
            handleVideoCallReroll();
            break;
        case 'switch-camera-btn':
            // 调用你原本处理“切换镜头”的函数
            switchVideoViews();
            break;
        // 如果还有其他按钮，在这里继续添加 case
    }
}

// 在init()函数中，为两个控制栏容器绑定事件
// 注意：因为你的HTML中有两个 controls div，所以我们需要分别绑定
const textModeControls = document.querySelector('#text-call-interface .video-call-controls');
if (textModeControls) {
    textModeControls.addEventListener('click', handleCallControls);
}

const visualModeControls = document.querySelector('#visual-call-interface .video-call-controls');
if (visualModeControls) {
    visualModeControls.addEventListener('click', handleCallControls);
}

// ▲▲▲ JS备用方案结束 ▲▲▲

// ▼▼▼ 【全新】这是你缺失的函数，请将它粘贴到JS功能区 ▼▼▼

/**
 * 【全新】处理用户在通话中点击“发言”按钮的逻辑
 */
async function handleUserSpeakInCall() {
    // 安全检查，如果通话未激活则不执行
    if (!videoCallState.isActive) return;

    // 找到用户头像并添加“正在发言”的高亮效果，提升交互感
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    // 弹出你已经写好的自定义输入框
    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    
    // 无论用户是否输入，只要输入框关闭，就立刻移除头像的高亮效果
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    // 如果用户确实输入了内容，就调用你已有的函数来触发AI响应
    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
  /**
   * 初始化默认的小组
   */
  async function initializeDefaultGroups() {
    const groupCount = await db.forumGroups.count();
    if (groupCount === 0) {
      const defaultGroups = [
        { name: '娱乐小组', description: '分享八卦和快乐', icon: '🍿' },
        { name: '灵异小组', description: '分享你的灵异经历', icon: '👻' },
        { name: '今天我crush了吗', description: '记录心动瞬间', icon: '💖' },
        { name: '请帮我选择小组', description: '选择困难症患者互助', icon: '🤔' },
        { name: '同人文小组', description: '为爱发电，创作故事', icon: '✍️' },
        // ▼▼▼ 就是新增了下面这一行！ ▼▼▼
        { name: '梦角小组', description: 'Char们分享关于user的梦境', icon: '🌙' },
      ];
      await db.forumGroups.bulkAdd(defaultGroups);
      console.log('已成功创建默认小组（包含梦角小组）。');
    }
  }

  // ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】分块导入/导出功能 v3.0 (按App/角色分类 | 已修复错误) ▼▼▼

/**
 * 打开高级导入导出模态框，并动态生成选项列表
 */
async function openAdvancedTransferModal() {
    const appsListEl = document.getElementById('export-apps-list');
    const charactersListEl = document.getElementById('export-characters-list');
    appsListEl.innerHTML = '';
    charactersListEl.innerHTML = '';

    // 1. 定义可独立导出的App数据及其关联的数据库表
    const appsToExport = [
        { id: 'weibo', name: '微博 (全部帖子/角色资料/粉丝数等)', tables: ['weiboPosts', 'qzoneSettings'] },
        { id: 'forum', name: '圈子 (所有小组/帖子/评论/分类)', tables: ['forumGroups', 'forumPosts', 'forumComments', 'forumCategories'] },
        { id: 'taobao', name: '桃宝 (所有商品/订单/购物车/余额记录)', tables: ['taobaoProducts', 'taobaoOrders', 'taobaoCart', 'userWalletTransactions'] },
        { id: 'worldBooks', name: '世界书 (全部书籍及分类)', tables: ['worldBooks', 'worldBookCategories'] },
        { id: 'userStickers', name: '我的表情包 (包含分类)', tables: ['userStickers', 'userStickerCategories'] },
        { id: 'charStickers', name: '角色通用表情包', tables: ['charStickers'] },
        { id: 'gameData', name: '游戏大厅数据 (剧本杀/飞行棋题库等)', tables: ['scriptKillScripts', 'ludoQuestionBanks', 'ludoQuestions'] },
        { id: 'appearance', name: '通用外观预设 (主题/字体/头像框等)', tables: ['themes', 'fontPresets', 'homeScreenPresets', 'customAvatarFrames', 'apiPresets', 'bubbleStylePresets'] }
    ];

    appsToExport.forEach(app => {
        appsListEl.innerHTML += `
            <label style="display: block; margin-bottom: 5px;">
                <input type="checkbox" class="export-app-checkbox" value="${app.id}"> ${app.name}
            </label>
        `;
    });

    // 2. 加载所有单聊角色
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    if (characters.length === 0) {
        charactersListEl.innerHTML = '<p>没有可导出的角色</p>';
    } else {
        characters.forEach(char => {
            charactersListEl.innerHTML += `
                <label style="display: block; margin-bottom: 5px;">
                    <input type="checkbox" class="export-char-checkbox" value="${char.id}"> ${char.name}
                </label>
            `;
        });
    }

    // 重置并绑定全选框
    const selectAllCheckbox = document.getElementById('select-all-characters-checkbox');
    selectAllCheckbox.checked = false;
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newSelectAllCheckbox = selectAllCheckbox.cloneNode(true);
    selectAllCheckbox.parentNode.replaceChild(newSelectAllCheckbox, selectAllCheckbox);
    newSelectAllCheckbox.addEventListener('change', (e) => {
        document.querySelectorAll('.export-char-checkbox').forEach(cb => {
            cb.checked = e.target.checked;
        });
    });

    // 3. 显示模态框
    document.getElementById('advanced-transfer-modal').classList.add('visible');
}

/**
 * 执行分块导出 (v3.0)
 */
async function exportChunkedData() {
    await showCustomAlert("请稍候...", "正在打包您选择的数据...");

    const backupData = {
        type: 'EPhoneChunkedBackup',
        version: 3,
        exportedAt: Date.now(),
        contains: [], 
        data: {}
    };

    try {
        const appCheckboxes = document.querySelectorAll('.export-app-checkbox:checked');
        const charCheckboxes = document.querySelectorAll('.export-char-checkbox:checked');

        if (appCheckboxes.length === 0 && charCheckboxes.length === 0) {
            alert("请至少选择一项要导出的内容！");
            hideCustomModal();
            return;
        }

        const appsToExportMap = {
            weibo: { tables: ['weiboPosts', 'qzoneSettings'] },
            forum: { tables: ['forumGroups', 'forumPosts', 'forumComments', 'forumCategories'] },
            taobao: { tables: ['taobaoProducts', 'taobaoOrders', 'taobaoCart', 'userWalletTransactions'] },
            worldBooks: { tables: ['worldBooks', 'worldBookCategories'] },
            userStickers: { tables: ['userStickers', 'userStickerCategories'] },
            charStickers: { tables: ['charStickers'] },
            gameData: { tables: ['scriptKillScripts', 'ludoQuestionBanks', 'ludoQuestions'] },
            appearance: { tables: ['themes', 'fontPresets', 'homeScreenPresets', 'customAvatarFrames', 'apiPresets', 'bubbleStylePresets'] }
        };

        // 1. 导出选中的App数据
        for (const checkbox of appCheckboxes) {
            const appId = checkbox.value;
            const appInfo = appsToExportMap[appId];
            if (appInfo) {
                backupData.contains.push(appId);
                for (const tableName of appInfo.tables) {
                    backupData.data[tableName] = await db[tableName].toArray();
                    console.log(`已打包App数据表: ${tableName}`);
                }
            }
        }

        // 2. 导出选中的角色数据
        const charIds = Array.from(charCheckboxes).map(cb => cb.value);
        if (charIds.length > 0) {
            backupData.data.chats = await db.chats.bulkGet(charIds);
            backupData.contains.push(...charIds.map(id => `character_${id}`));

            // 打包所有与这些角色关联的数据
            const relatedDataTables = ['memories', 'callRecords', 'qzonePosts', 'weiboPosts', 'datingHistory', 'pomodoroSessions'];
            const relatedKey = {
                'memories': 'chatId',
                'callRecords': 'chatId',
                'qzonePosts': 'authorId',
                'weiboPosts': 'authorId',
                'datingHistory': 'characterId',
                'pomodoroSessions': 'chatId'
            };

            for (const tableName of relatedDataTables) {
                const items = await db[tableName].where(relatedKey[tableName]).anyOf(charIds).toArray();
                if (items.length > 0) {
                    if (!backupData.data[tableName]) backupData.data[tableName] = [];
                    // 使用Set去重，防止因多角色关联同一数据而重复打包
                    const existingIds = new Set(backupData.data[tableName].map(i => i.id));
                    items.forEach(item => {
                        if (!existingIds.has(item.id)) {
                            backupData.data[tableName].push(item);
                            existingIds.add(item.id);
                        }
                    });
                }
            }
            console.log(`已打包 ${charIds.length} 个角色的核心及关联数据。`);
        }

        // 3. 创建JSON文件并触发下载
        const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `EPhone-Partial-Backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功导出您选中的数据！');

    } catch (error) {
        console.error("分块导出失败:", error);
        await showCustomAlert('导出失败', `发生错误: ${error.message}`);
    } finally {
        document.getElementById('advanced-transfer-modal').classList.remove('visible');
    }
}

/**
 * 【V2 | 已修复NotFoundError】执行补充式导入
 * @param {File} file - 用户选择的JSON文件
 */
async function importChunkedData(file) {
    if (!file) return;

    let data;
    try {
        const text = await file.text();
        data = JSON.parse(text);
    } catch (error) {
        await showCustomAlert('导入失败', '文件读取或解析失败，请确保文件是有效的JSON格式。');
        return;
    }
    
    if (data.type !== 'EPhoneChunkedBackup') {
        const confirmed = await showCustomConfirm(
            '文件类型不匹配',
            '这是一个【全量备份】文件，继续导入将会【覆盖】所有数据！是否要继续？',
            { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) importBackup(file);
        return;
    }

    const contentList = data.contains.map(item => {
        const appNameMap = { weibo: '微博', forum: '圈子', taobao: '桃宝', worldBooks: '世界书', userStickers: '我的表情包', charStickers: '角色通用表情包', gameData: '游戏大厅数据', appearance: '通用外观预设' };
        if(item.startsWith('character_')) {
            const charId = item.replace('character_', '');
            const charData = data.data.chats?.find(c => c.id === charId);
            return `角色数据：${charData ? charData.name : '未知角色'}`;
        }
        return appNameMap[item] || item;
    }).join('\n- ');

    const confirmed = await showCustomConfirm(
        '确认导入',
        `即将导入以下内容：\n\n- ${contentList}\n\n注意：如果现有数据中已存在相同ID的内容（如同名角色），他们的数据将会被导入的数据【完全覆盖】。此操作不可撤销！`
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在导入数据，请勿关闭页面...");

    try {
        // ★★★★★ 这就是修复 NotFoundError 的核心代码 ★★★★★

        // 1. 获取导入文件中有哪些数据表
        const tablesInBackup = Object.keys(data.data);
        
        // 2. 获取当前数据库中实际存在的所有数据表名称
        const validTableNames = db.tables.map(t => t.name);

        // 3. 找出二者的交集，这才是我们真正需要操作的数据表
        const tablesToUpdate = tablesInBackup.filter(t => validTableNames.includes(t));
        
        console.log("即将操作的有效数据表:", tablesToUpdate);
        
        // 4. 只对这些有效的数据表开启一个数据库事务
        await db.transaction('rw', tablesToUpdate, async () => {
            for (const tableName of tablesToUpdate) {
                if (Array.isArray(data.data[tableName])) {
                    console.log(`正在向表格 "${tableName}" 中补充/覆盖 ${data.data[tableName].length} 条数据...`);
                    await db[tableName].bulkPut(data.data[tableName]);
                }
            }
        });
        
        // ★★★★★ 修复结束 ★★★★★

        await loadAllDataFromDB();
        await renderChatList();
        
        await showCustomAlert('导入成功', '数据已成功补充！应用将刷新以确保所有数据正确加载。');
        setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
        console.error("补充式导入失败:", error);
        await showCustomAlert('导入失败', `写入数据库时发生错误: ${error.message}`);
    } finally {
        document.getElementById('advanced-transfer-modal').classList.remove('visible');
    }
}
// ▼▼▼ 请用这整块【全新修复版】代码，完整替换你旧的 exportDataFor330 函数 ▼▼▼
// ▼▼▼ 请用这整块【最终修复版】代码，完整替换你旧的 exportDataFor300 函数 ▼▼▼
/**
 * 【兼容330 | V4.3 - 拼写错误修复版】将当前App的数据导出为兼容EPhone 330的格式
 */
async function exportDataFor330() {
    await showCustomAlert("请稍候...", "正在为你准备兼容性备份文件...");

    const backupData = {
        version: 3, // 【核心兼容】将版本号强制写为3，让330版本能识别
        timestamp: Date.now(),
        data: {}
    };

    try {
        const [
            chatsFromDB, 
            worldBooksFromDB,
            userStickersFromDB,
            apiConfigFromDB, 
            globalSettingsFromDB,
            qzonePostsFromDB,
            qzoneAlbumsFromDB,
            qzonePhotosFromDB,
            qzoneSettingsFromDB,
            personaPresetsFromDB,
            memoriesFromDB,
            apiPresetsFromDB,
            favoritesFromDB,
            worldBookCategoriesFromDB,
            callRecordsFromDB,
            stickerCategoriesFromDB, // 【核心修复】修正了上一版中的拼写错误
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.qzoneSettings.get('main'),
            db.personaPresets.toArray(),
            db.memories.toArray(),
            db.apiPresets.toArray(),
            db.favorites.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.userStickerCategories.toArray(), // 【核心修复】从 stickerCategories 改为 userStickerCategories
        ]);

        const transformedWorldBooks = worldBooksFromDB.map(book => {
            const newBookFor330 = { ...book };
            if (typeof newBookFor330.content === 'string' && newBookFor330.content.trim()) {
                newBookFor330.content = [{
                    keys: [book.name],
                    comment: `从 EPhone 导入的条目`,
                    content: book.content,
                    enabled: true
                }];
            } else {
                newBookFor330.content = [];
            }
            return newBookFor330;
        });

        const transformedChats = chatsFromDB.map(chat => {
            if (chat.isGroup) return chat;
            const settingsFor330 = { ...chat.settings, 'ai-persona': chat.settings.aiPersona, 'my-persona': chat.settings.myPersona, 'ai-avatar': chat.settings.aiAvatar, 'my-avatar': chat.settings.myAvatar, };
            return { ...chat, settings: settingsFor330 };
        });

        const transformedNpcs = [];
        const npcIdSet = new Set();
        for (const chat of chatsFromDB) {
            if (!chat.isGroup && Array.isArray(chat.npcLibrary)) {
                chat.npcLibrary.forEach(npc => {
                    if (!npcIdSet.has(npc.id)) {
                        transformedNpcs.push({ id: npc.id, name: npc.name, avatar: npc.avatar, persona: npc.persona, associatedWith: [chat.id] });
                        npcIdSet.add(npc.id);
                    } else {
                        const existingNpc = transformedNpcs.find(n => n.id === npc.id);
                        if (existingNpc) existingNpc.associatedWith.push(chat.id);
                    }
                });
            }
        }
        
        const transformedQzoneSettings = { id: 'main', nickname: qzoneSettingsFromDB?.nickname || '你的昵称', avatar: qzoneSettingsFromDB?.avatar || 'https://files.catbox.moe/q6z5fc.jpeg', banner: qzoneSettingsFromDB?.banner || 'https://files.catbox.moe/r5heyt.gif' };
        
        const transformedDoubanPosts = qzonePostsFromDB.filter(p => p.authorId !== 'user').map(p => ({ id: p.id, timestamp: p.timestamp, groupName: '从动态导入的小组', postTitle: (p.publicText || p.content || '无标题').substring(0, 50), authorName: state.chats[p.authorId]?.name || '未知作者', authorOriginalName: state.chats[p.authorId]?.name || '未知作者', content: p.content || p.publicText || '[图片]', likesCount: p.likes?.length || 0, commentsCount: p.comments?.length || 0, comments: (p.comments || []).map(c => ({ commenter: c.commenterName, text: c.text })) }));

        backupData.data = {
            chats: transformedChats,
            npcs: transformedNpcs,
            worldBooks: transformedWorldBooks,
            worldBookCategories: worldBookCategoriesFromDB,
            userStickers: userStickersFromDB,
            stickerCategories: stickerCategoriesFromDB,
            apiConfig: apiConfigFromDB ? [apiConfigFromDB] : [],
            globalSettings: globalSettingsFromDB ? [globalSettingsFromDB] : [],
            qzoneSettings: [transformedQzoneSettings],
            qzonePosts: qzonePostsFromDB,
            qzoneAlbums: qzoneAlbumsFromDB,
            qzonePhotos: qzonePhotosFromDB,
            personaPresets: personaPresetsFromDB,
            memories: memoriesFromDB,
            apiPresets: apiPresetsFromDB,
            favorites: favoritesFromDB,
            doubanPosts: transformedDoubanPosts,
            callRecords: callRecordsFromDB,
        };
        
        const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const dateStr = new Date().toISOString().split('T')[0];
        link.href = url;
        link.download = `EPhone-Compatible-Backup-v330-${dateStr}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功生成兼容330版本的备份文件！现在你可以去330版本导入它了。');

    } catch (error) {
        console.error("兼容性导出失败:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    } finally {
        const modal = document.getElementById('advanced-transfer-modal');
        if (modal) {
             modal.classList.remove('visible');
        }
    }
}



// ▼▼▼ 【最终修复版 V3】请用这整块代码，完整替换旧的 importFrom330Format 函数 ▼▼▼

/**
 * 【V3 - 世界书拆分版】处理并导入来自330版本格式的备份文件
 * @param {File} file - 用户选择的330格式的JSON文件
 */
async function importFrom330Format(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '您正在从330版本导入数据，这将【完全覆盖】您当前的所有数据！此操作不可撤销！确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );
    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在解析并转换330版本的数据...");

    try {
        const text = await file.text();
        const importedData = JSON.parse(text);

        if (importedData.version !== 3) {
            throw new Error(`文件版本不匹配！需要版本3，但提供的是版本 ${importedData.version}。`);
        }

        const data330 = importedData.data;
        
        // 这是一个安全列表，确保我们只操作您数据库中存在的表
        const existingTables = [
            'chats', 'worldBooks', 'worldBookCategories', 'userStickers', 'userStickerCategories',
            'apiConfig', 'globalSettings', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos', 'qzoneSettings',
            'personaPresets', 'memories', 'apiPresets', 'favorites', 'musicLibrary', 'callRecords',
            'customAvatarFrames', 'themes', 'bubbleStylePresets', 'fontPresets', 'homeScreenPresets',
            'weiboPosts', 'forumGroups', 'forumPosts', 'forumComments', 'forumCategories',
            'tarotReadings', 'pomodoroSessions', 'scriptKillScripts', 'taobaoProducts',
            'taobaoOrders', 'taobaoCart', 'userWalletTransactions', 'ludoQuestionBanks',
            'ludoQuestions', 'datingScenes', 'datingPresets', 'datingSpriteGroups',
            'datingSprites', 'datingHistory'
        ];

        await db.transaction('rw', existingTables, async () => {
            for (const tableName of existingTables) {
                if (db[tableName]) {
                    await db[tableName].clear();
                }
            }
            console.log("330导入：已清空共有的数据表，准备导入...");

            // ▼▼▼ 世界书导入逻辑【重大变更】▼▼▼
            // 我们不再合并，而是将330的每个词条拆分成独立的世界书条目
            if (data330.worldBooks && Array.isArray(data330.worldBooks)) {
                const allNewWorldBookEntries = []; // 创建一个新数组来收集所有拆分后的条目
                let entryCounter = 0; // 用于生成唯一ID

                // 1. 遍历330的每一个“世界书合集”
                data330.worldBooks.forEach(book_330 => {
                    if (Array.isArray(book_330.content)) {
                        // 2. 遍历合集中的每一个词条
                        book_330.content.forEach(entry => {
                            entryCounter++;

                            // 3. 为每个词条生成新的独立世界书名称
                            // 优先使用词条的 `keys` 作为名称，其次是 `comment`，最后是自动生成
                            let newName = `导入条目 ${entryCounter}`;
                            if (entry.keys && entry.keys.length > 0) {
                                newName = entry.keys.join(', '); // 用关键词作为新名称
                            } else if (entry.comment) {
                                newName = entry.comment; // 其次用备注作为新名称
                            }

                            // 4. 为每个词条创建一个全新的、独立的世界书对象
                            const newBookEntry = {
                                id: `imported_wb_${Date.now()}_${entryCounter}`, // 生成唯一ID
                                name: newName,
                                content: entry.content || '', // 内容就是词条的内容
                                categoryId: book_330.categoryId || 0, // 继承原合集的分类ID
                                isEnabled: entry.enabled !== false, // 继承启用状态，默认为true
                            };
                            
                            // 5. 将这个全新的独立条目添加到我们的收集中
                            allNewWorldBookEntries.push(newBookEntry);
                        });
                    }
                });
                
                // 6. 一次性将所有拆分后的新条目写入数据库
                await db.worldBooks.bulkPut(allNewWorldBookEntries);
                console.log(`330导入：成功“拆分”并导入 ${allNewWorldBookEntries.length} 条独立世界书条目。`);
            }
            // 分类信息保持不变，正常导入
            if (data330.worldBookCategories) await db.worldBookCategories.bulkPut(data330.worldBookCategories);
            // ▲▲▲ 世界书导入逻辑变更结束 ▲▲▲


            // --- 其他数据的导入逻辑保持不变 ---
            
            // 转换并导入【聊天和NPC】
            if (data330.chats && Array.isArray(data330.chats)) {
                const chatsToImport = [...data330.chats];
                const npcs = data330.npcs || [];
                chatsToImport.forEach(chat => {
                    if (!chat.isGroup) {
                        chat.npcLibrary = [];
                        npcs.forEach(npc => {
                            if (npc.associatedWith && npc.associatedWith.includes(chat.id)) {
                                chat.npcLibrary.push({ id: npc.id, name: npc.name, persona: npc.persona, avatar: npc.avatar });
                            }
                        });
                    }
                });
                await db.chats.bulkPut(chatsToImport);
                console.log(`330导入：成功转换并导入 ${chatsToImport.length} 个聊天。`);
            }

            // 转换并导入【豆瓣/圈子】数据
            if (data330.doubanPosts && Array.isArray(data330.doubanPosts)) {
                const groupMap = new Map();
                for (const post of data330.doubanPosts) {
                    let groupId;
                    if (groupMap.has(post.groupName)) { groupId = groupMap.get(post.groupName); } 
                    else {
                        const newGroup = { name: post.groupName, description: '从330导入的小组', icon: '📖' };
                        groupId = await db.forumGroups.add(newGroup);
                        groupMap.set(post.groupName, groupId);
                    }
                    await db.forumPosts.add({ id: post.id, groupId: groupId, title: post.postTitle, content: post.content, authorNickname: post.authorName, timestamp: post.timestamp, likes: post.likesCount || 0 });
                    if (post.comments && post.comments.length > 0) {
                        const commentsToSave = post.comments.map(c => ({ postId: post.id, author: c.commenter, content: c.text, timestamp: Date.now() }));
                        await db.forumComments.bulkAdd(commentsToSave);
                    }
                }
                console.log(`330导入：成功转换并导入 ${data330.doubanPosts.length} 条圈子帖子。`);
            }
            
            // 转换并导入单对象设置
            if (data330.apiConfig?.[0]) await db.apiConfig.put(data330.apiConfig[0]);
            if (data330.globalSettings?.[0]) await db.globalSettings.put(data330.globalSettings[0]);
            if (data330.qzoneSettings?.[0]) await db.qzoneSettings.put(data330.qzoneSettings[0]);
            if (data330.musicLibrary?.[0]) await db.musicLibrary.put(data330.musicLibrary[0]);

            // 直接导入其他结构相同的【共有】数据表
            const directImportTables = [ 'userStickers', 'personaPresets', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos', 'favorites', 'memories', 'callRecords', 'apiPresets', 'stickerCategories', 'customAvatarFrames' ];
            for (const tableName of directImportTables) {
                if (data330[tableName] && Array.isArray(data330[tableName]) && db[tableName]) {
                    await db[tableName].bulkPut(data330[tableName]);
                    console.log(`330导入：成功导入 ${data330[tableName].length} 条数据到 ${tableName}。`);
                }
            }
        });

        // 导入成功后刷新页面
        await showCustomAlert('导入成功', '来自330版本的数据已成功导入！应用即将刷新以应用所有更改。');
        setTimeout(() => { window.location.reload(); }, 1500);

    } catch (error) {
        console.error("从330格式导入失败:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 请用这个【全新的、能识别GIF】的版本，完整替换旧的 compressImage 函数 ▼▼▼

/**
 * 【全新V2 | 修复GIF问题】压缩图片至指定质量并返回Base64，同时跳过GIF
 * @param {string} base64Str - 原始图片的Base64字符串 (data:...)
 * @param {number} quality - 压缩质量 (0.1 - 1.0)
 * @returns {Promise<string>} - 返回压缩后的JPEG格式的Base64字符串，或原始的GIF/PNG字符串
 */
function compressImage(base64Str, quality) {
    return new Promise((resolve, reject) => {
        // ★★★ 核心修复1：在这里添加对 GIF 的判断！ ★★★
        // 如果是 GIF，或者质量设置为1.0（不压缩），直接返回原图，不进行任何处理。
        if (base64Str.startsWith('data:image/gif') || quality >= 1.0 || !base64Str.startsWith('data:image')) {
            resolve(base64Str);
            return;
        }

        const img = new Image();
        img.src = base64Str;

        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            // ★★★ 核心修复2：依然输出为JPEG，但我们已经提前排除了GIF ★★★
            // 这确保了 PNG 和其他静态图能被正确压缩。
            const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
            resolve(compressedBase64);
        };

        img.onerror = (err) => {
            console.error("图片加载失败，无法压缩:", err);
            reject(new Error('图片加载失败，无法压缩'));
        };
    });
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】通用文件上传并压缩处理函数
 * @param {File} file - 用户选择的文件
 * @returns {Promise<string>} - 返回压缩后的Base64字符串
 */
async function handleImageUploadAndCompress(file) {
    const base64Url = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });

    const quality = state.globalSettings.imageCompressionQuality || 0.7;
    console.log(`准备压缩图片，质量: ${quality}`);
    
    const compressedBase64 = await compressImage(base64Url, quality);
    console.log(`图片压缩完成。原始大小: ${base64Url.length}, 压缩后大小: ${compressedBase64.length}`);

    return compressedBase64;
}

/**
 * 【全新】计算Base64字符串的近似文件大小
 * @param {string} base64Str - Base64字符串 (可以带'data:...'前缀)
 * @returns {number} - 字节大小
 */
function getBase64Size(base64Str) {
    if (!base64Str || typeof base64Str !== 'string' || !base64Str.startsWith('data:image')) return 0;
    const base64 = base64Str.split(',')[1] || base64Str;
    const padding = (base64.endsWith('==') ? 2 : (base64.endsWith('=') ? 1 : 0));
    return (base64.length * 3 / 4) - padding;
}

/**
 * 【全新】将字节数格式化为易读的字符串 (KB, MB, GB)
 * @param {number} bytes - 字节数
 * @returns {string} - 格式化后的字符串
 */
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// ▼▼▼ 用这块【新代码】替换旧的 calculateTotalImageSize 函数 ▼▼▼
/**
 * 【全新V2】计算并显示数据库中所有图片的总大小，并返回数值
 * @returns {Promise<number>} - 返回总字节数
 */
async function calculateTotalImageSize() {
    const displayEl = document.getElementById('image-data-size-display');
    displayEl.textContent = '正在计算中...';

    let totalSize = 0;
    const processedUrls = new Set(); 

    const calculateSize = (url) => {
        if (!url || typeof url !== 'string' || !url.startsWith('data:image') || processedUrls.has(url)) {
            return 0;
        }
        const size = getBase64Size(url);
        processedUrls.add(url);
        return size;
    };

    try {
        const allTables = db.tables.map(table => table.name);
        for (const tableName of allTables) {
            try {
                const items = await db[tableName].toArray();
                for (const item of items) {
                    const findImagesRecursive = (obj) => {
                        for (const key in obj) {
                            if (typeof obj[key] === 'string') {
                                totalSize += calculateSize(obj[key]);
                            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                                findImagesRecursive(obj[key]);
                            }
                        }
                    };
                    findImagesRecursive(item);
                }
            } catch(e) {
                console.warn(`扫描表 ${tableName} 出错:`, e);
            }
        }
        
        displayEl.textContent = `当前图片数据总量约: ${formatBytes(totalSize)}`;
        return totalSize; // 返回计算出的总大小

    } catch (error) {
        console.error("计算图片大小时出错:", error);
        displayEl.textContent = '计算失败，请查看控制台。';
        return 0;
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 用这块【修复了无限转圈问题】的代码，替换旧的 compressAllImagesInDB 函数 ▼▼▼

/**
 * 【全新V2 | 修复转圈问题】一键压缩数据库中所有图片的核心函数
 */
async function compressAllImagesInDB() {
    const confirmed = await showCustomConfirm(
        '高风险操作确认',
        '此操作将扫描并【永久性地】压缩数据库中的【所有静态图片（PNG/JPG等）】。<br><br>【GIF动图会被自动跳过，不会被压缩】。<br><br>压缩是不可逆的，建议在操作前先【导出数据】进行备份！<br><br>确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    const loadingOverlay = document.getElementById('generation-overlay');
    const loadingText = loadingOverlay.querySelector('p');
    loadingText.textContent = '正在全力压缩图片，请耐心等待...';
    loadingOverlay.classList.add('visible');

    try {
        const quality = parseFloat(document.getElementById('image-quality-slider').value) || 0.7;
        const originalTotalSize = await calculateTotalImageSize();
        let itemsProcessed = 0;
        let compressedCount = 0;

        const findAndCompressImagesInObject = async (obj) => {
            let hasCompressed = false;
            for (const key in obj) {
                if (typeof obj[key] === 'string' && obj[key].startsWith('data:image')) {
                    const originalUrl = obj[key];
                    const compressedUrl = await compressImage(originalUrl, quality);
                    if (originalUrl !== compressedUrl) {
                        obj[key] = compressedUrl;
                        hasCompressed = true;
                        compressedCount++; // 记录压缩了多少张图片
                    }
                } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                    if (await findAndCompressImagesInObject(obj[key])) {
                        hasCompressed = true;
                    }
                }
            }
            return hasCompressed;
        };

        const allTables = db.tables.map(table => table.name);
        for (const tableName of allTables) {
            loadingText.textContent = `正在扫描表: ${tableName}...`;
            const itemsToUpdate = [];
            const allItems = await db[tableName].toArray();

            for (const item of allItems) {
                if (await findAndCompressImagesInObject(item)) {
                    itemsToUpdate.push(item);
                }
                itemsProcessed++;
                if (itemsProcessed % 20 === 0) {
                   loadingText.textContent = `已处理 ${itemsProcessed} 条数据... 压缩了 ${compressedCount} 张图片...`;
                }
            }

            if (itemsToUpdate.length > 0) {
                loadingText.textContent = `正在保存 ${tableName} 的压缩结果...`;
                await db[tableName].bulkPut(itemsToUpdate);
                console.log(`表 ${tableName} 中有 ${itemsToUpdate.length} 条记录的图片被压缩。`);
            }
        }

        // ★★★ 核心修复：在这里先隐藏加载动画，再去弹窗 ★★★
        loadingOverlay.classList.remove('visible');

        const newTotalSize = await calculateTotalImageSize();
        const savedSize = originalTotalSize - newTotalSize;

        await showCustomAlert('压缩完成！', `操作成功！\n原始大小: ${formatBytes(originalTotalSize)}\n压缩后大小: ${formatBytes(newTotalSize)}\n成功为您节省了 ${formatBytes(savedSize)} 的空间！\n\n应用即将刷新以应用所有更改。`);
        
        setTimeout(() => window.location.reload(), 2000);

    } catch (error) {
        // 出错时也要确保加载动画被隐藏
        loadingOverlay.classList.remove('visible');
        console.error("压缩全部图片时出错:", error);
        await showCustomAlert('压缩失败', `发生了一个错误: ${error.message}`);
    } 
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新】流式导出函数 (大数据专用)
 * 原理：不再一次性读取所有数据库表到内存，而是逐个表读取、写入，
 * 利用 ReadableStream 和 Response 流式传输给用户，从而极大降低内存占用。
 */
async function exportDataStream() {
    await showCustomAlert("请稍候...", "正在准备流式导出，这可能需要一些时间，但不会使浏览器崩溃。");

    // 定义所有需要备份的数据库表名
    const tablesToExport = [
        'chats', 'apiConfig', 'globalSettings', 'userStickers', 'charStickers', 
        'worldBooks', 'musicLibrary', 'personaPresets', 'qzoneSettings', 'qzonePosts',
        'qzoneAlbums', 'qzonePhotos', 'favorites', 'qzoneGroups', 'memories',
        'worldBookCategories', 'callRecords', 'customAvatarFrames', 'themes',
        'apiPresets', 'bubbleStylePresets', 'fontPresets', 'homeScreenPresets', 'weiboPosts',
        'forumGroups', 'forumPosts', 'forumComments', 'forumCategories', 'tarotReadings', 
        'pomodoroSessions', 'scriptKillScripts', 'taobaoProducts', 'taobaoOrders', 
        'taobaoCart', 'userWalletTransactions', 'userStickerCategories', 'datingScenes',
        'datingPresets', 'datingSpriteGroups', 'datingSprites', 'datingHistory'
    ];

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();

            // 1. 写入JSON文件的开头
            controller.enqueue(encoder.encode('{\n'));

            // 2. 添加版本和时间戳元数据
            const metaData = `"version": 1,\n"timestamp": ${Date.now()},\n`;
            controller.enqueue(encoder.encode(metaData));

            // 3. 逐个处理数据库表
            for (let i = 0; i < tablesToExport.length; i++) {
                const tableName = tablesToExport[i];
                console.log(`流式导出：正在处理表 ${tableName}...`);
                
                try {
                    const tableData = await db[tableName].toArray();
                    const jsonString = JSON.stringify(tableData);
                    
                    // 写入 "tableName": [...]
                    controller.enqueue(encoder.encode(`"${tableName}": ${jsonString}`));
                    
                    // 如果不是最后一个表，就加上逗号和换行符
                    if (i < tablesToExport.length - 1) {
                        controller.enqueue(encoder.encode(',\n'));
                    } else {
                        controller.enqueue(encoder.encode('\n'));
                    }
                } catch (e) {
                    console.error(`流式导出时，处理表 ${tableName} 失败:`, e);
                    // 即使某个表失败，也继续尝试下一个
                }
            }

            // 4. 写入JSON文件的结尾
            controller.enqueue(encoder.encode('}'));
            
            // 5. 通知流已经结束
            controller.close();
            console.log("流式导出：所有数据写入完成。");
        }
    });

    // 6. 使用 Response 将流包装成可下载的文件
    const response = new Response(stream, {
        headers: { 'Content-Type': 'application/json' }
    });

    // 7. 创建并触发下载链接
    const url = URL.createObjectURL(await response.blob());
    const link = document.createElement('a');
    link.href = url;
    link.download = `EPhone-Stream-Backup-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    // 关闭“请稍候”的弹窗
    hideCustomModal(); 
}
/**
 * 【全新】通用的多选模态框
 * @param {string} title - 标题
 * @param {Array} items - 选项数组 {id, name}
 * @param {string} confirmText - 确认按钮文本
 * @param {string} confirmClass - 确认按钮样式类 (e.g. 'btn-danger')
 */
function showGenericMultiSelectModal(title, items, confirmText = '确定', confirmClass = '') {
    return new Promise(resolve => {
        const modal = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');

        modalTitle.textContent = title;
        let optionsHtml = '<div style="text-align: left; max-height: 300px; overflow-y: auto;">';
        // 全选按钮
        optionsHtml += `<label style="display: block; padding: 5px; border-bottom: 1px solid #eee; cursor: pointer;"><input type="checkbox" id="generic-select-all-toggle"> <strong>全选/全不选</strong></label>`;
        
        items.forEach(item => {
            optionsHtml += `
                <label style="display: block; padding: 8px 5px; cursor: pointer;">
                    <input type="checkbox" class="generic-item-checkbox" value="${item.id}">
                    ${item.name}
                </label>
            `;
        });
        optionsHtml += '</div>';
        modalBody.innerHTML = optionsHtml;

        // 绑定全选/单选逻辑 (延迟绑定以确保DOM已渲染)
        setTimeout(() => {
             const selectAllCheckbox = document.getElementById('generic-select-all-toggle');
             const itemCheckboxes = document.querySelectorAll('.generic-item-checkbox');
             
             if(selectAllCheckbox) {
                 selectAllCheckbox.onchange = (e) => {
                    itemCheckboxes.forEach(cb => cb.checked = e.target.checked);
                 };
             }
             
             itemCheckboxes.forEach(cb => {
                 cb.onchange = () => {
                     const allChecked = Array.from(itemCheckboxes).every(c => c.checked);
                     if(selectAllCheckbox) selectAllCheckbox.checked = allChecked;
                 };
             });
        }, 0);

        modalConfirmBtn.textContent = confirmText;
        // 重置并应用样式
        modalConfirmBtn.className = 'confirm-btn'; 
        if (confirmClass) modalConfirmBtn.classList.add(confirmClass);
        
        modalCancelBtn.style.display = 'block';
        modal.classList.add('visible');

        const cleanup = () => {
             modal.classList.remove('visible');
             modalConfirmBtn.onclick = null;
             modalCancelBtn.onclick = null;
             // 恢复默认样式 (可选，但下次调用会重置)
             modalConfirmBtn.classList.remove('btn-danger'); 
        };

        modalConfirmBtn.onclick = () => {
            const selectedIds = Array.from(document.querySelectorAll('.generic-item-checkbox:checked')).map(cb => cb.value);
            cleanup();
            resolve(selectedIds);
        };
        modalCancelBtn.onclick = () => {
            cleanup();
            resolve(null);
        };
    });
}

/**
 * [全新] 恢复所有App名称为默认值 (支持单选/多选)
 */
async function resetAppNamesToDefault() {
    const customLabels = state.globalSettings.appLabels || {};
    const customAppIds = Object.keys(customLabels);
    
    if (customAppIds.length === 0) {
        await showCustomAlert('提示', '当前没有修改过名称的App。');
        return;
    }

    // 构建选项列表
    const items = customAppIds.map(id => ({
        id: id,
        // 显示 "当前名称 (原: 默认名称)"
        name: `<span style="font-weight:bold; color: var(--text-primary);">${customLabels[id]}</span> <span style="color: var(--text-secondary); font-size:0.9em;">(原: ${DEFAULT_APP_LABELS[id] || '未知'})</span>`
    }));

    // 弹出多选框
    const selectedIds = await showGenericMultiSelectModal(
        '选择要恢复默认名称的App', 
        items, 
        '恢复选中', 
        'btn-danger'
    );

    if (selectedIds && selectedIds.length > 0) {
         // 删除选中的自定义名称
         selectedIds.forEach(id => {
             delete state.globalSettings.appLabels[id];
         });
         
         // 保存并刷新
         await db.globalSettings.put(state.globalSettings);
         applyAppLabels(); 
         renderAppNameSettings(); 
         
         await showCustomAlert('操作成功', `已恢复 ${selectedIds.length} 个App的默认名称。`);
    }
}
// forum.js

/**
 * 【全新】将一个新创建的帖子元素添加到列表的顶部
 * @param {object} post - 包含ID的完整帖子对象
 */
function prependNewPostElement(post) {
  const listEl = document.getElementById('group-post-list');

  // 检查列表当前是否显示“空空如也”的消息，如果是，就清空它
  const emptyMessage = listEl.querySelector('p');
  if (emptyMessage && (emptyMessage.textContent.includes('还没有帖子') || emptyMessage.textContent.includes('没有找到符合'))) {
    listEl.innerHTML = '';
  }

  // 创建新帖子的DOM元素（这段代码与renderGroupPosts中的逻辑几乎一样）
  const commentCount = 0; // 新帖子的评论数永远是0
  const item = document.createElement('div');
  item.className = 'forum-post-item';
  item.dataset.postId = post.id;

  let categoriesHtml = '';
  if (post.categories && post.categories.length > 0) {
    categoriesHtml = `
      <div class="category-tag-container">
          ${post.categories.map(cat => `<span class="category-tag">#${cat}</span>`).join('')}
      </div>
    `;
  }

  item.innerHTML = `
      <div class="post-item-title">${post.title}</div>
      ${categoriesHtml}
      <div class="post-item-meta">
          <span>作者: ${post.author}</span>
          <span>评论: ${commentCount}</span>
      </div>
      <button class="forum-post-delete-btn" title="删除帖子">×</button>
  `;

  // 使用 prepend() 将新帖子添加到列表的【最前面】
  listEl.prepend(item);
}

// forum.js

// ▼▼▼ 用这个【已修复时序问题】的版本，完整替换你旧的 handleCreateForumPost 函数 ▼▼▼

/**
 * 【已修复】处理用户点击“发布”按钮，创建新帖子的逻辑
 */
async function handleCreateForumPost() {
  const title = document.getElementById('forum-post-title-input').value.trim();
  const content = document.getElementById('post-public-text').value.trim();
  if (!title || !content) {
    alert('帖子标题和内容都不能为空哦！');
    return;
  }

  const categoryInput = document.getElementById('forum-post-category-input').value.trim();
  const categories = categoryInput ? categoryInput.match(/#(\S+)/g)?.map(tag => tag.substring(1)) || [] : [];

  const newPost = {
    groupId: activeGroupId,
    title: title,
    content: content,
    author: state.qzoneSettings.nickname || '我',
    timestamp: Date.now(),
    categories: categories,
  };

  // ★★★★★ 这就是本次修复的核心逻辑 ★★★★★

  // 1. 将数据库 add() 操作返回的【ID】捕获到一个变量中。
  const postId = await db.forumPosts.add(newPost);
  // 2. 将这个ID赋值回我们的 newPost 对象，现在它是一个完整的、包含ID的对象了。
  newPost.id = postId;

  // 3. 关闭发帖弹窗。
  document.getElementById('create-post-modal').classList.remove('visible');
  
  // 4. 【关键】不再调用可能出错的 renderGroupPosts，而是调用我们新的、可靠的 prependNewPostElement 函数。
  prependNewPostElement(newPost);
  
  // 5. 给出成功提示。
  alert('帖子发布成功！');

  // ★★★★★ 修复结束 ★★★★★
}
// ▲▲▲ 替换结束 ▲▲▲

let activeGroupId = null; // 记录当前打开的小组ID
  /**
   * 【已修复】渲染小组内的帖子列表及其分类（已支持筛选）
   */
  async function renderGroupPosts(groupId) {
    const listEl = document.getElementById('group-post-list');
    const allPosts = await db.forumPosts.where('groupId').equals(groupId).reverse().sortBy('timestamp');
    listEl.innerHTML = '';

    const groupFilters = activeForumFilters.group[groupId];
    let postsToRender = allPosts;

    if (groupFilters && groupFilters.length > 0) {
      postsToRender = allPosts.filter(
        post => post.categories && post.categories.some(cat => groupFilters.includes(cat)),
      );
    }

    if (postsToRender.length === 0) {
      const message = groupFilters && groupFilters.length > 0 ? '没有找到符合筛选条件的帖子哦' : '这个小组还没有帖子哦';
      listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; padding: 50px 0;">${message}</p>`;
      return;
    }

    for (const post of postsToRender) {
      // ★★★★★ 这就是唯一的、核心的修复！ ★★★★★
      // 在使用 post.id 查询前，先用 parseInt() 确保它一定是数字类型。
      const commentCount = await db.forumComments.where('postId').equals(parseInt(post.id)).count();
      // ★★★★★ 修复结束 ★★★★★

      const item = document.createElement('div');
      item.className = 'forum-post-item';
      item.dataset.postId = post.id;

      let categoriesHtml = '';
      if (post.categories && post.categories.length > 0) {
        categoriesHtml = `
                <div class="category-tag-container">
                    ${post.categories.map(cat => `<span class="category-tag">#${cat}</span>`).join('')}
                </div>
            `;
      }

      item.innerHTML = `
            <div class="post-item-title">${post.title}</div>
            ${categoriesHtml}
            <div class="post-item-meta">
                <span>作者: ${post.author}</span>
                <span>评论: ${commentCount}</span>
            </div>
            <button class="forum-post-delete-btn" title="删除帖子">×</button>
        `;
      listEl.appendChild(item);
    }

    // 更新筛选按钮状态
    const filterBtn = document.getElementById('group-filter-btn');
    if (filterBtn) {
      filterBtn.classList.toggle('active', groupFilters && groupFilters.length > 0);
    }
  }
// ▼▼▼ 【全新】这是亲密值系统的所有核心JS代码，请粘贴到 init() 函数的正上方 ▼▼▼

// ▼▼▼ 在 main-app.js 中，用这个新版本替换旧的 SYMBOL_THRESHOLDS 常量 ▼▼▼
const SYMBOL_THRESHOLDS = [
    { id: 'first_heartbeat', level: 100,  symbol: 'https://i.postimg.cc/DZSsNzMB/5BF06FFB38AAF2B394F89F6270D328D5.png', name: '初识心动', description: '心跳是故事的开始。' },
    { id: 'shining_star',    level: 300,  symbol: 'https://i.postimg.cc/L47gJRb3/7227080E4BF5950D1B182043D1F734DB.png', name: '星光闪烁', description: '你们的关系像星光一样开始闪耀。' },
    { id: 'burning_passion', level: 700,  symbol: 'https://i.postimg.cc/yNQcnRvT/BD0C0CC3C6692D736014BACE73C07F8E.png', name: '热情如火', description: '每一次互动都让感情升温。' },
    { id: 'only_crown',      level: 1500, symbol: 'https://i.postimg.cc/B6jDzvVh/92DD1E30EFEEC589E3BE0FFB630F8B4E.png', name: '唯一王冠', description: '在彼此的世界里，对方是独一无二的存在。' },
    { id: 'eternal_diamond', level: 5000, symbol: 'https://i.postimg.cc/C1RD2KQc/B0E2B3034728540DA4198357D5B8131C.png', name: '永恒之钻', description: '你们的关系如钻石般坚固而璀璨。' }
];
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 核心：计算亲密值
 * @param {object} chat - 聊天对象
 * @returns {number} - 计算出的亲密值分数
 */
function calculateIntimacy(chat) {
    if (!chat || !chat.settings.streak) return 0;
    
    // 基础分：火花天数，每天都很重要！
    const streakDays = chat.settings.streak.currentDays || 0;
    const streakScore = streakDays * 15; // 每天火花提供15点基础分

    // 互动分：累计消息总数
    const stats = chat.interactionStats || {};
    const totalMessages = Object.values(stats).reduce((sum, count) => sum + count, 0);
    const messageScore = totalMessages * 0.2; // 每条消息提供0.2点互动分

    const intimacy = streakScore + messageScore;
    return Math.floor(intimacy); // 返回整数
}

/**
 * 核心：检查并解锁新的徽章
 * @param {object} chat - 聊天对象
 * @param {number} intimacyValue - 当前的亲密值
 * @returns {Promise<boolean>} - 如果有新徽章解锁，返回true
 */
async function checkAndUnlockSymbols(chat, intimacyValue) {
    let newUnlock = false;
    if (!chat.unlockedSymbols) chat.unlockedSymbols = [];

    SYMBOL_THRESHOLDS.forEach(threshold => {
        // 检查：亲密值是否达标？这个徽章是不是还没解锁过？
        if (intimacyValue >= threshold.level && !chat.unlockedSymbols.some(s => s.symbol === threshold.symbol)) {
            // 如果都满足，就解锁！
            chat.unlockedSymbols.push({
                symbol: threshold.symbol,
                name: threshold.name,
                unlockedAt: Date.now() // 记录解锁的精确时间
            });
            newUnlock = true;
            console.log(`徽章解锁！角色: ${chat.name}, 徽章: ${threshold.name}`);
        }
    });

    // 如果有新解锁的徽章，就更新数据库并弹窗提示
    if (newUnlock) {
        await db.chats.put(chat);
        // 找到最新解锁的那个徽章来显示通知
        const latestUnlock = chat.unlockedSymbols[chat.unlockedSymbols.length - 1];
        await showCustomAlert('新徽章已解锁！', `恭喜你和“${chat.name}”解锁了新的亲密徽章：${latestUnlock.name}`);
    }
    return newUnlock;
}

// ▼▼▼ 用这块【V2 - 图片佩戴版】代码，完整替换旧的 openIntimacyPanel 函数 ▼▼▼
async function openIntimacyPanel(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // --- 数据计算 ---
    const intimacyValue = calculateIntimacy(chat);
    await checkAndUnlockSymbols(chat, intimacyValue);

    // --- 填充UI (这部分逻辑不变) ---
    document.getElementById('intimacy-score-display').textContent = intimacyValue;
    const today = new Date().toISOString().split('T')[0];
    const todayMsgs = chat.interactionStats?.[today] || 0;
    const totalMsgs = Object.values(chat.interactionStats || {}).reduce((sum, count) => sum + count, 0);
    document.getElementById('intimacy-streak-days').textContent = `${chat.settings.streak?.currentDays || 0} 天`;
    document.getElementById('intimacy-today-msgs').textContent = `${todayMsgs} 条`;
    document.getElementById('intimacy-total-msgs').textContent = `${totalMsgs} 条`;
    
    // --- ★★★ 核心改造：渲染可点击的徽章列表 ★★★ ---
    const symbolListContainer = document.getElementById('symbol-list-container');
    symbolListContainer.innerHTML = '';
    
    // 添加一个“不佩戴”的选项
    const noneItem = document.createElement('div');
    noneItem.className = 'symbol-item unlocked'; // 让它总是可点击
    if (!chat.settings.selectedIntimacyBadge) {
        noneItem.classList.add('selected'); // 如果当前没佩戴，就高亮这个
    }
    noneItem.innerHTML = `<div class="symbol-icon no-badge">🚫</div><div class="symbol-name">不佩戴</div>`;
    noneItem.onclick = () => selectIntimacyBadge(chatId, ''); // 点击时，传入空字符串表示不佩戴
    symbolListContainer.appendChild(noneItem);

    // 渲染所有可解锁的徽章
    SYMBOL_THRESHOLDS.forEach(threshold => {
        const isUnlocked = intimacyValue >= threshold.level;
        const isSelected = chat.settings.selectedIntimacyBadge === threshold.symbol;
        
        const item = document.createElement('div');
        item.className = `symbol-item ${isUnlocked ? 'unlocked' : ''} ${isSelected ? 'selected' : ''}`;
        
        // ★★★ 核心修改：使用 <img> 标签来显示图片 ★★★
        item.innerHTML = `
            <div class="symbol-icon ${!isUnlocked ? 'not-unlocked' : ''}">
                <img src="${threshold.symbol}" alt="${threshold.name}">
            </div>
            <div class="symbol-name">${threshold.name}</div>
            <div class="symbol-level">${isUnlocked ? '已解锁' : `${threshold.level}分解锁`}</div>
        `;

        // 只有解锁了的徽章才能点击
        if (isUnlocked) {
            item.onclick = () => selectIntimacyBadge(chatId, threshold.symbol);
        }
        
        symbolListContainer.appendChild(item);
    });

    // --- 渲染解锁记录 (这部分逻辑不变) ---
    const recordsContainer = document.getElementById('unlocked-symbols-record');
    recordsContainer.innerHTML = '';
    if (chat.unlockedSymbols && chat.unlockedSymbols.length > 0) {
        const sortedRecords = [...chat.unlockedSymbols].sort((a, b) => b.unlockedAt - a.unlockedAt);
        sortedRecords.forEach(record => {
            const recordItem = document.createElement('div');
            recordItem.className = 'record-item';
            recordItem.innerHTML = `<span class="symbol"><img src="${record.symbol}" style="height:1em; vertical-align:middle;"></span><span>${record.name}</span><span class="date">${new Date(record.unlockedAt).toLocaleDateString()}</span>`;
            recordsContainer.appendChild(recordItem);
        });
    } else {
        recordsContainer.innerHTML = '<p style="text-align:center; color:#999; font-size:13px;">暂无已解锁的徽章</p>';
    }

    // --- 显示面板 ---
    document.getElementById('intimacy-panel').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 openIntimacyPanel 函数的下方，粘贴这个新函数 ▼▼▼
/**
 * 【全新】选择并佩戴一个亲密徽章
 * @param {string} chatId - 角色ID
 * @param {string} symbol - 要佩戴的徽章符号，或''表示不佩戴
 */
async function selectIntimacyBadge(chatId, symbol) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 更新选择
    chat.settings.selectedIntimacyBadge = symbol;
    
    // 保存到数据库
    await db.chats.put(chat);
    
    // 重新渲染面板，更新高亮状态
    await openIntimacyPanel(chatId);
    
    // 重新渲染聊天列表，让徽章立刻显示出来
    await renderChatList();
}
// ▲▲▲ 新增函数结束 ▲▲▲

/**
 * 核心：为指定聊天的今天消息数+1
 * @param {string} chatId - 聊天ID
 */
async function incrementMessageCount(chatId) {
    const chat = state.chats[chatId];
    // 只为单人聊天计数
    if (!chat || chat.isGroup) return;

    const today = new Date().toISOString().split('T')[0]; // 获取 YYYY-MM-DD 格式的日期
    
    if (!chat.interactionStats) {
        chat.interactionStats = {};
    }
    
    chat.interactionStats[today] = (chat.interactionStats[today] || 0) + 1;

    // 将更新后的聊天数据保存回数据库
    await db.chats.put(chat);
}

// ▲▲▲ 新增JS代码结束 ▲▲▲
/**
 * 获取或生成当前设备的唯一设备码
 * @returns {string} - 一长串唯一的设备码
 */
function getDeviceCode() {
    const deviceIdKey = 'ephone-device-code'; // 使用一个新的键名
    let deviceId = localStorage.getItem(deviceIdKey);
    if (!deviceId) {
        deviceId = crypto.randomUUID();
        localStorage.setItem(deviceIdKey, deviceId);
    }
    return deviceId;
}

/**
 * 根据设备码生成对应的PIN码 (这个函数必须和 get_pin.html 中的完全一致！)
 * @param {string} deviceCode - 设备码
 * @returns {string} - 6位大写的PIN码
 */
function generatePinFromDeviceCode(deviceCode) {
    if (!deviceCode || deviceCode.length < 6) return 'INVALID';
    // 算法：将设备码反转，取前6位，转大写
    return deviceCode.split('').reverse().join('').substring(0, 6).toUpperCase();
}
/**
 * 【全新】清空所有好友动态（不包括微博和圈子）
 */
async function clearAllQzonePosts() {
    // 1. 弹出确认框，防止用户误操作
    const confirmed = await showCustomConfirm(
        '确认清空',
        '此操作将永久删除所有好友动态（不包括微博和圈子），且无法恢复。确定要继续吗？',
        { confirmButtonClass: 'btn-danger' } // 使用红色按钮警示
    );

    if (!confirmed) {
        return; // 如果用户点击“取消”，则不执行任何操作
    }

    try {
        // 2. 清空数据库中的 `qzonePosts` 表，这是存储所有动态的地方
        await db.qzonePosts.clear();
        console.log('`qzonePosts` table has been cleared.');

        // 3. 清理所有角色的历史记录，移除与动态相关的系统通知，保持数据一致性
        const allChats = Object.values(state.chats);
        const chatsToUpdate = [];
        for(const chat of allChats) {
            const originalHistoryLength = chat.history.length;
            // 筛选掉内容包含“发布了”的系统消息
            chat.history = chat.history.filter(msg => 
                !(msg.role === 'system' && msg.content && msg.content.includes('发布了'))
            );
            if (chat.history.length < originalHistoryLength) {
                chatsToUpdate.push(chat);
            }
        }
        if (chatsToUpdate.length > 0) {
            await db.chats.bulkPut(chatsToUpdate);
            console.log(`已从 ${chatsToUpdate.length} 个角色的历史记录中移除动态通知。`);
        }

        // 4. 重新渲染动态列表，界面会显示为空
        await renderQzonePosts();
        
        // 5. 给出成功提示
        alert('所有好友动态已清空！');

    } catch (error) {
        console.error("清空好友动态时出错:", error);
        await showCustomAlert('操作失败', `清空动态时发生错误: ${error.message}`);
    }
}
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼

/* --- 【全新】头像形状自定义与预设核心功能 --- */

// 预设形状的CSS代码
const AVATAR_SHAPE_PRESETS = {
    default: 'inset(0% round 20%)',
    circle: 'circle(50% at 50% 50%)'
};

/**
 * 【核心渲染】将保存的形状设置应用为CSS规则
 * @param {string} chatId - 当前聊天的ID
 */
function applyAvatarShapes(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const styleTag = document.getElementById('dynamic-avatar-shapes-style');
    if (!styleTag) return;

    const myShapeCss = chat.settings.myAvatarShape || 'default';
    const aiShapeCss = chat.settings.aiAvatarShape || 'default';

    const myClipPath = AVATAR_SHAPE_PRESETS[myShapeCss] || myShapeCss;
    const aiClipPath = AVATAR_SHAPE_PRESETS[aiShapeCss] || aiShapeCss;

    // 为真实聊天界面和设置预览区同时生成CSS规则
    const finalCss = `
        /* --- 真实聊天界面 --- */
        #chat-messages .message-wrapper.user .avatar-img,
        #chat-messages .message-wrapper.user .avatar {
            clip-path: ${myClipPath};
        }
        #chat-messages .message-wrapper.ai .avatar-img,
        #chat-messages .message-wrapper.ai .avatar {
            clip-path: ${aiClipPath};
        }

        /* --- 设置预览区 --- */
        #settings-preview-area .message-wrapper.user .avatar-img,
        #settings-preview-area .message-wrapper.user .avatar {
            clip-path: ${myClipPath};
        }
        #settings-preview-area .message-wrapper.ai .avatar-img,
        #settings-preview-area .message-wrapper.ai .avatar {
            clip-path: ${aiClipPath};
        }
    `;

    styleTag.innerHTML = finalCss;
}

/**
 * 【UI加载】加载并显示当前聊天的头像形状设置
 */
async function loadAvatarShapeSettings() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 加载用户头像形状
    const myShape = chat.settings.myAvatarShape || 'default';
    const myCustomTextarea = document.getElementById('my-avatar-shape-custom');
    if (AVATAR_SHAPE_PRESETS[myShape]) {
        document.querySelector(`input[name="my-avatar-shape"][value="${myShape}"]`).checked = true;
        myCustomTextarea.style.display = 'none';
    } else {
        document.querySelector('input[name="my-avatar-shape"][value="custom"]').checked = true;
        myCustomTextarea.value = myShape;
        myCustomTextarea.style.display = 'block';
    }

    // 加载AI头像形状
    const aiShape = chat.settings.aiAvatarShape || 'default';
    const aiCustomTextarea = document.getElementById('ai-avatar-shape-custom');
    if (AVATAR_SHAPE_PRESETS[aiShape]) {
        document.querySelector(`input[name="ai-avatar-shape"][value="${aiShape}"]`).checked = true;
        aiCustomTextarea.style.display = 'none';
    } else {
        document.querySelector('input[name="ai-avatar-shape"][value="custom"]').checked = true;
        aiCustomTextarea.value = aiShape;
        aiCustomTextarea.style.display = 'block';
    }

    // 加载并渲染两个预设下拉框
    await renderAvatarShapePresets('user');
    await renderAvatarShapePresets('char');
}

/**
 * 【数据保存】将UI上的设置保存到state和数据库
 */
function saveAvatarShapeSettings() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 保存用户头像形状
    const myShapeChoice = document.querySelector('input[name="my-avatar-shape"]:checked').value;
    if (myShapeChoice === 'custom') {
        chat.settings.myAvatarShape = document.getElementById('my-avatar-shape-custom').value.trim();
    } else {
        chat.settings.myAvatarShape = myShapeChoice;
    }

    // 保存AI头像形状
    const aiShapeChoice = document.querySelector('input[name="ai-avatar-shape"]:checked').value;
    if (aiShapeChoice === 'custom') {
        chat.settings.aiAvatarShape = document.getElementById('ai-avatar-shape-custom').value.trim();
    } else {
        chat.settings.aiAvatarShape = aiShapeChoice;
    }
}

/**
 * 【UI渲染】渲染指定类型的预设下拉框
 * @param {'user' | 'char'} type - 'user' 代表用户, 'char' 代表角色
 */
async function renderAvatarShapePresets(type) {
    const selectId = type === 'user' ? 'my-avatar-shape-presets-select' : 'ai-avatar-shape-presets-select';
    const selectEl = document.getElementById(selectId);
    const dbTable = type === 'user' ? db.userAvatarShapePresets : db.charAvatarShapePresets;

    selectEl.innerHTML = '<option value="">-- 选择预设 --</option>';
    const presets = await dbTable.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });
}

/**
 * 【核心】处理预设选择，将CSS代码填充到输入框
 * @param {'user' | 'char'} type
 */
async function handleAvatarShapePresetSelection(type) {
    const selectId = type === 'user' ? 'my-avatar-shape-presets-select' : 'ai-avatar-shape-presets-select';
    const textareaId = type === 'user' ? 'my-avatar-shape-custom' : 'ai-avatar-shape-custom';
    const dbTable = type === 'user' ? db.userAvatarShapePresets : db.charAvatarShapePresets;

    const selectEl = document.getElementById(selectId);
    const textareaEl = document.getElementById(textareaId);
    const presetId = parseInt(selectEl.value);

    if (presetId) {
        const preset = await dbTable.get(presetId);
        if (preset) {
            textareaEl.value = preset.css;
            // 自动切换到“自定义”模式
            const customRadioName = type === 'user' ? 'my-avatar-shape' : 'ai-avatar-shape';
            document.querySelector(`input[name="${customRadioName}"][value="custom"]`).checked = true;
            textareaEl.style.display = 'block';
        }
    }
}

/**
 * 【核心】保存当前自定义CSS为一个新预设
 * @param {'user' | 'char'} type
 */
async function saveAvatarShapePreset(type) {
    const textareaId = type === 'user' ? 'my-avatar-shape-custom' : 'ai-avatar-shape-custom';
    const dbTable = type === 'user' ? db.userAvatarShapePresets : db.charAvatarShapePresets;
    
    const cssCode = document.getElementById(textareaId).value.trim();
    if (!cssCode) {
        alert('自定义代码不能为空！');
        return;
    }

    const presetName = await showCustomPrompt('保存预设', '请输入预设名称：');
    if (presetName && presetName.trim()) {
        await dbTable.add({ name: presetName.trim(), css: cssCode });
        await renderAvatarShapePresets(type);
        alert(`预设 "${presetName.trim()}" 已保存！`);
    }
}

/**
 * 【核心】打开多选删除模态框
 * @param {'user' | 'char'} type
 */
async function openDeleteShapePresetsModal(type) {
    const dbTable = type === 'user' ? db.userAvatarShapePresets : db.charAvatarShapePresets;
    const presets = await dbTable.toArray();
    if (presets.length === 0) {
        alert('没有可删除的预设。');
        return;
    }
    
    // 复用一个通用的多选删除弹窗
    const idsToDelete = await showMultiSelectDeleteModal('删除预设', presets);

    if (idsToDelete && idsToDelete.length > 0) {
        await dbTable.bulkDelete(idsToDelete);
        await renderAvatarShapePresets(type);
        alert(`成功删除 ${idsToDelete.length} 个预设。`);
    }
}

/**
 * 【辅助】通用的多选删除模态框
 * @param {string} title - 弹窗标题
 * @param {Array} items - 要显示的条目数组，每个条目需要有 'id' 和 'name'
 * @returns {Promise<Array|null>} - 返回被选中要删除的ID数组，或null
 */
function showMultiSelectDeleteModal(title, items) {
    return new Promise(resolve => {
        const modal = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');

        modalTitle.textContent = title;
        let optionsHtml = '<div style="text-align: left; max-height: 300px; overflow-y: auto;">';
        optionsHtml += `<label style="display: block; padding: 5px; border-bottom: 1px solid #eee;"><input type="checkbox" id="delete-select-all-toggle"> <strong>全选/全不选</strong></label>`;
        items.forEach(item => {
            optionsHtml += `
                <label style="display: block; padding: 8px 5px;">
                    <input type="checkbox" class="delete-item-checkbox" value="${item.id}">
                    ${item.name}
                </label>
            `;
        });
        optionsHtml += '</div>';
        modalBody.innerHTML = optionsHtml;

        document.getElementById('delete-select-all-toggle').onchange = (e) => {
            document.querySelectorAll('.delete-item-checkbox').forEach(cb => cb.checked = e.target.checked);
        };

        modalConfirmBtn.textContent = '删除选中';
        modalConfirmBtn.classList.add('btn-danger');
        modalCancelBtn.style.display = 'block';

        modal.classList.add('visible');

        modalConfirmBtn.onclick = () => {
            const selectedIds = Array.from(document.querySelectorAll('.delete-item-checkbox:checked')).map(cb => parseInt(cb.value));
            modal.classList.remove('visible');
            resolve(selectedIds);
        };
        modalCancelBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(null);
        };
    });
}

/* --- 头像形状自定义功能结束 --- */

// ▲▲▲ 新增功能函数粘贴结束 ▲▲▲
        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        
/**
 * 【全新】确保题库内容充实，包含大学专业海量题目
 */
async function ensureMassiveQuestionBanks() {
    const subjects = [
        { name: '护理学', category: 'university' },
        { name: '计算机科学', category: 'university' },
        { name: '临床医学', category: 'university' },
        { name: '会计学', category: 'university' },
        { name: '土木工程', category: 'university' },
        { name: '心理学', category: 'university' },
        { name: '法学', category: 'university' },
        { name: '英语', category: 'university' },
        { name: '高等数学', category: 'university' },
        { name: '经济学', category: 'university' },
        { name: '管理学', category: 'university' },
        { name: '汉语言文学', category: 'university' },
        { name: '机械工程', category: 'university' },
        { name: '电子信息', category: 'university' },
        { name: '建筑学', category: 'university' }
    ];

    // 1. 确保科目存在
    for (const sub of subjects) {
        let subject = await db.studySubjects.where('name').equals(sub.name).first();
        if (!subject) {
            await db.studySubjects.add({
                name: sub.name,
                category: sub.category,
                isDefault: true
            });
            console.log(`自动添加科目: ${sub.name}`);
        }
    }

    // 2. 确保每个科目（包括现有的）都有海量题目
    const allSubjects = await db.studySubjects.toArray();
    for (const subject of allSubjects) {
        const count = await db.questionBanks.where('subjectId').equals(subject.id).count();
        const targetCount = 300; // 设定目标为至少300题
        
        if (count < targetCount) {
            const needed = targetCount - count;
            console.log(`正在为 ${subject.name} 生成 ${needed} 道题目...`);
            const newQuestions = generateMassiveMockQuestions(subject.id, subject.name, needed);
            await db.questionBanks.bulkAdd(newQuestions);
        }
    }
}

function generateMassiveMockQuestions(subjectId, subjectName, count) {
    const questions = [];
    const types = ['single', 'multiple', 'judge'];
    
    for (let i = 0; i < count; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        let content, options, answer;
        
        if (type === 'single') {
            content = `【${subjectName}模拟题】这是第 ${i+1} 道单项选择题，考察关于${subjectName}的基础知识点。`;
            options = ['选项A：这是正确答案的可能性分析', '选项B：这是干扰项之一', '选项C：这是另一个干扰项', '选项D：这是最后的干扰项'];
            answer = options[Math.floor(Math.random() * 4)];
        } else if (type === 'multiple') {
            content = `【${subjectName}进阶题】(多选) 下列关于${subjectName}的描述中，正确的有哪些？（第 ${i+1} 题）`;
            options = ['描述A：这是一个正确的观点', '描述B：这也是一个正确的观点', '描述C：这是一个错误的观点', '描述D：这是一个无关的描述'];
            answer = [options[0], options[1]];
        } else {
            content = `【${subjectName}判断题】第 ${i+1} 题：${subjectName}的核心理论之一是XXXXXX。`;
            options = ['正确', '错误'];
            answer = Math.random() > 0.5 ? '正确' : '错误';
        }
        
        questions.push({
            subjectId: subjectId,
            type: type,
            content: content,
            options: options,
            answer: answer,
            difficulty: Math.random() > 0.5 ? 'medium' : 'easy',
            explanation: `这是第 ${i+1} 题的详细解析。掌握${subjectName}的基础非常重要。`
        });
    }
    return questions;
}

        async function init() {
    // ▼▼▼ 在 init()    // ▼▼▼ 在这里粘贴下面这几行新代码 ▼▼▼
    // 更新小组件的月份显示
    const monthElement = document.getElementById('widget-month-display');
    if (monthElement) {
        const currentMonth = new Date().getMonth() + 1; // getMonth()返回0-11，所以要+1
        monthElement.textContent = currentMonth;
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲ 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
    applyTheme(savedTheme);
    // ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的开头粘贴 ▼▼▼
const dynamicAvatarShapesStyle = document.createElement('style');
dynamicAvatarShapesStyle.id = 'dynamic-avatar-shapes-style';
document.head.appendChild(dynamicAvatarShapesStyle);
// ▲▲▲ 新增代码结束 ▲▲▲
    // ▼▼▼ 新增代码 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲


    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

            window.showScreen = showScreen;
            window.openLoversSpaceFromCard = openLoversSpaceFromCard; // <-- 在这里添加这一行
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();
                // ★★★ 核心修复2：在这里添加启动时加载CSS的逻辑 ★★★
    // 优先应用保存在 activeCustomCss 里的代码
    if (state.globalSettings.activeCustomCss) {
        applyThemeCss(state.globalSettings.activeCustomCss);
    } 
    // 如果没有自定义CSS，再尝试应用上次选中的主题
    else if (state.globalSettings.activeThemeId) {
        const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
        if (activeTheme) {
            console.log(`正在应用已保存的主题: "${activeTheme.name}"`);
            applyThemeCss(activeTheme.css);
        }
    }
    // ★★★ 修复结束 ★★★

            // 在 loadAllDataFromDB 函数末尾，init(); 调用之前添加
if (typeof state.globalSettings.notificationSoundUrl === 'undefined') {
    state.globalSettings.notificationSoundUrl = 'https://files.catbox.moe/k369mf.mp3';
}
            // ▼▼▼ 把新代码粘贴到这里 ▼▼▼
            renderHomeScreenProfileFrame(); // 初始化时渲染主页头像框
            // ▲▲▲ 粘贴结束 ▲▲▲
            applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
            await loadAllFontPresetsOnStartup(); // <---- 在这里添加这一行新代码
            await migrateDefaultLudoQuestions();
            await addDefaultDarkModeThemeIfNeeded();
            applyWidgetData();

if (state.globalSettings.homeIconWidgetTextColor) {
    applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
}

// 2. 应用已保存的“去除阴影”设置
document.getElementById('phone-screen').classList.toggle('no-home-font-shadow', !!state.globalSettings.removeHomeFontShadow);

            // 初始化未读动态计数
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代码添加结束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 【核心修复】初始化时，自动加载并应用已保存的主题
    if (state.globalSettings.activeThemeId) {
        const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
        if (activeTheme) {
            console.log(`正在应用已保存的主题: "${activeTheme.name}"`);
            applyThemeCss(activeTheme.css);
        }
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();
applyAppLabels();
    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    initDraggableLyricsBar(); // 初始化悬浮歌词栏的拖动功能
    // ▲▲▲ 添加结束 ▲▲▲
    
    // ▼▼▼ 初始化定时导出提醒功能 ▼▼▼
    initExportReminder(); // 初始化定时导出提醒
    console.log('✅ [定时导出提醒] 初始化完成');
    // ▲▲▲ 定时导出提醒初始化结束 ▲▲▲
    
    // ▼▼▼ 初始化定时自动导出功能 ▼▼▼
    initAutoExport(); // 初始化定时自动导出
    console.log('✅ [定时自动导出] 初始化完成');
    // ▲▲▲ 定时自动导出初始化结束 ▲▲▲

            // ==========================================================
            // --- 各种事件监听器 ---
            // ==========================================================
            // ▼▼▼ 在 init() 函数的事件监听器区域末尾，添加下面这行代码 ▼▼▼
// ▼▼▼ 用这块新代码，替换旧的 weibo-screen 事件监听器 ▼▼▼
            // ▼▼▼ 【全新】“查角色手机”功能事件监听器 (V2 - 单独生成版) ▼▼▼

            // 1. 绑定主屏幕上的“查手机”APP图标
            document.getElementById('check-phone-btn').addEventListener('click', openCharacterSelectionScreen);

            // 2. 角色选择列表的点击事件 (事件委托)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });

            // 3. 【总生成/清空】角色手机顶部的“刷新”和“清空”按钮
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

// ▼▼▼ 请用这一整块【功能增强版】的代码，完整替换掉你旧的 character-phone-container 事件监听器 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const backBtn = e.target.closest('.back-btn');
    const actionBtn = e.target.closest('.action-btn');

    // 1. 处理返回按钮
    if (backBtn) {
        if (backBtn.dataset.targetPage) {
            showCharacterPhonePage(backBtn.dataset.targetPage);
        } else if (backBtn.dataset.targetScreen) {
            showScreen(backBtn.dataset.targetScreen);
        }
        return;
    }
    
    // 2. 处理所有操作按钮（生成 + 删除）
    if (actionBtn) {
        switch (actionBtn.id) {
            // --- 单独生成按钮 ---
            case 'generate-chat-message-btn': 
                generateCharacterPhoneDataSegment('chats'); break;
            case 'generate-cart-item-btn':
                generateCharacterPhoneDataSegment('shoppingCart'); break;
            case 'generate-memo-btn':
                generateCharacterPhoneDataSegment('memos'); break;
            case 'generate-browser-history-btn':
                generateCharacterPhoneDataSegment('browserHistory'); break;
            case 'generate-album-photo-btn':
                generateCharacterPhoneDataSegment('photoAlbum'); break;
            case 'generate-bank-transaction-btn':
                generateCharacterPhoneDataSegment('bank'); break;
            case 'generate-trajectory-btn':
                generateCharacterPhoneDataSegment('trajectory'); break;
            case 'generate-app-usage-btn':
                generateCharacterPhoneDataSegment('appUsage'); break;
            case 'generate-diary-entry-btn':
                generateCharacterPhoneDataSegment('diary'); break;

            // --- ★★★ 这就是我们新增的全部删除按钮的逻辑 ★★★ ---
            case 'clear-npc-chats-btn':
                handleClearCharacterDataSegment('chats'); break;
            case 'clear-cart-items-btn':
                handleClearCharacterDataSegment('shoppingCart'); break;
            case 'clear-memos-btn':
                handleClearCharacterDataSegment('memos'); break;
            case 'clear-browser-history-btn':
                handleClearCharacterDataSegment('browserHistory'); break;
            case 'clear-album-photos-btn':
                handleClearCharacterDataSegment('photoAlbum'); break;
            case 'clear-bank-transactions-btn':
                handleClearCharacterDataSegment('bank.transactions'); break;
            case 'clear-trajectory-btn':
                handleClearCharacterDataSegment('trajectory'); break;
            case 'clear-app-usage-btn':
                handleClearCharacterDataSegment('appUsage'); break;
            case 'clear-diary-entries-btn':
                handleClearCharacterDataSegment('diary'); break;
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V3最终美化版】主屏幕预设功能事件绑定 ▼▼▼
document.getElementById('home-preset-selector').addEventListener('change', handleHomePresetSelection);
document.getElementById('apply-home-preset-btn').addEventListener('click', applySelectedHomeScreenPreset);
// 【核心修改】这里按钮的ID变了
document.getElementById('save-home-preset-btn').addEventListener('click', saveCurrentHomeScreenAsPreset); 
document.getElementById('update-home-preset-btn').addEventListener('click', updateSelectedHomeScreenPreset); // <-- 新增这一行
document.getElementById('rename-home-preset-btn').addEventListener('click', renameSelectedHomeScreenPreset);
document.getElementById('delete-home-preset-btn').addEventListener('click', deleteSelectedHomeScreenPreset);
document.getElementById('export-home-preset-btn').addEventListener('click', exportHomeScreenPreset);
document.getElementById('import-home-preset-btn').addEventListener('click', () => document.getElementById('import-home-preset-input').click());
document.getElementById('import-home-preset-input').addEventListener('change', (e) => {
    importHomeScreenPreset(e.target.files[0]);
    e.target.value = null;
});

            document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
// ▼▼▼ 【全新】聊天记录搜索功能事件绑定 ▼▼▼
document.getElementById('search-chat-btn').addEventListener('click', openChatSearchScreen);

document.getElementById('search-back-btn').addEventListener('click', () => {
    // 返回时，重新打开聊天设置弹窗
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

document.getElementById('perform-search-btn').addEventListener('click', performChatSearch);

// 使用事件委托来处理所有搜索结果的点击
document.getElementById('chat-search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.timestamp) {
        jumpToMessage(parseInt(item.dataset.timestamp));
    }
});
// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】聊天记忆统计功能 ▼▼▼
/**
 * 打开聊天记忆统计弹窗并显示统计信息
 */
async function openChatMemoryStats() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    const modal = document.getElementById('chat-memory-stats-modal');
    modal.classList.add('visible');
    
    // 1. 统计消息数量（排除隐藏消息）
    const visibleMessages = chat.history.filter(msg => !msg.isHidden);
    const messageCount = visibleMessages.length;
    document.getElementById('stats-message-count').textContent = messageCount;
    
    // 2. 统计通话次数（从数据库查询）
    const callRecords = await db.callRecords.where('chatId').equals(state.activeChatId).toArray();
    const callCount = callRecords.length;
    document.getElementById('stats-call-count').textContent = callCount;
    
    // 3. 统计转账金额
    let aiTransferTotal = 0;
    let userTransferTotal = 0;
    
    visibleMessages.forEach(msg => {
        if (msg.type === 'transfer' && msg.amount) {
            if (msg.role === 'assistant') {
                aiTransferTotal += parseFloat(msg.amount);
            } else if (msg.role === 'user') {
                userTransferTotal += parseFloat(msg.amount);
            }
        }
    });
    
    document.getElementById('stats-ai-transfer').textContent = `¥${aiTransferTotal.toFixed(2)}`;
    document.getElementById('stats-user-transfer').textContent = `¥${userTransferTotal.toFixed(2)}`;
    
    // 4. 统计最常说的话
    const aiMessages = [];
    const userMessages = [];
    
    visibleMessages.forEach(msg => {
        // 只统计普通文本消息
        if (msg.type && !['text', 'sticker'].includes(msg.type)) return;
        if (typeof msg.content !== 'string') return;
        if (msg.content.trim().length === 0) return;
        
        // 排除系统消息和特殊格式
        const content = msg.content.trim();
        if (content.startsWith('[') || content.startsWith('{')) return;
        
        if (msg.role === 'assistant') {
            aiMessages.push(content);
        } else if (msg.role === 'user') {
            userMessages.push(content);
        }
    });
    
    // 分析AI最常说的话
    const aiCommonWords = analyzeCommonPhrases(aiMessages);
    document.getElementById('stats-ai-common-words').innerHTML = aiCommonWords.length > 0 
        ? aiCommonWords.slice(0, 3).map((item, index) => 
            `${index + 1}. "${item.phrase}" <span style="color: #999;">(${item.count}次)</span>`
          ).join('<br>') 
        : '暂无数据';
    
    // 分析用户最常说的话
    const userCommonWords = analyzeCommonPhrases(userMessages);
    document.getElementById('stats-user-common-words').innerHTML = userCommonWords.length > 0 
        ? userCommonWords.slice(0, 3).map((item, index) => 
            `${index + 1}. "${item.phrase}" <span style="color: #999;">(${item.count}次)</span>`
          ).join('<br>') 
        : '暂无数据';
}

/**
 * 分析常用短语
 * @param {Array<string>} messages - 消息数组
 * @returns {Array<{phrase: string, count: number}>} 按出现次数排序的短语数组
 */
function analyzeCommonPhrases(messages) {
    const phraseCount = {};
    
    messages.forEach(msg => {
        const cleanMsg = msg.replace(/<[^>]*>/g, '').trim(); // 移除HTML标签
        if (cleanMsg.length < 2 || cleanMsg.length > 30) return; // 只统计2-30字符的短语
        
        // 统计出现次数
        if (phraseCount[cleanMsg]) {
            phraseCount[cleanMsg]++;
        } else {
            phraseCount[cleanMsg] = 1;
        }
    });
    
    // 转换为数组并排序
    const phrases = Object.entries(phraseCount)
        .map(([phrase, count]) => ({ phrase, count }))
        .filter(item => item.count >= 2) // 至少出现2次
        .sort((a, b) => b.count - a.count);
    
    return phrases;
}

// 绑定事件监听器
document.getElementById('chat-memory-stats-btn').addEventListener('click', openChatMemoryStats);
document.getElementById('close-chat-memory-stats-btn').addEventListener('click', () => {
    document.getElementById('chat-memory-stats-modal').classList.remove('visible');
});
// ▲▲▲ 聊天记忆统计功能结束 ▲▲▲

// ▼▼▼ 【全新】头像形状自定义功能事件监听器 ▼▼▼

// 监听聊天设置弹窗的打开，以加载当前设置
document.getElementById('chat-settings-btn').addEventListener('click', loadAvatarShapeSettings);

// 监听两个“自定义”单选按钮的变化，以显示/隐藏文本框
document.querySelectorAll('input[name="my-avatar-shape"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        document.getElementById('my-avatar-shape-custom').style.display = e.target.value === 'custom' ? 'block' : 'none';
    });
});
document.querySelectorAll('input[name="ai-avatar-shape"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        document.getElementById('ai-avatar-shape-custom').style.display = e.target.value === 'custom' ? 'block' : 'none';
    });
});

// 监听“应用”和“重置”按钮
document.getElementById('apply-avatar-shape-btn').addEventListener('click', () => {
    saveAvatarShapeSettings(); // 先保存UI上的选择到state
    applyAvatarShapes(state.activeChatId); // 再应用CSS
    updateSettingsPreview(); // 刷新预览区
});
document.getElementById('reset-avatar-shape-btn').addEventListener('click', async () => {
    const chat = state.chats[state.activeChatId];
    chat.settings.myAvatarShape = 'default';
    chat.settings.aiAvatarShape = 'default';
    await loadAvatarShapeSettings(); // 重新加载UI
    applyAvatarShapes(state.activeChatId); // 应用CSS
    updateSettingsPreview(); // 刷新预览区
});

// 监听两个预设下拉框的选择
document.getElementById('my-avatar-shape-presets-select').addEventListener('change', () => handleAvatarShapePresetSelection('user'));
document.getElementById('ai-avatar-shape-presets-select').addEventListener('change', () => handleAvatarShapePresetSelection('char'));

// 监听两个“保存”和“删除”按钮
document.getElementById('save-my-avatar-shape-preset-btn').addEventListener('click', () => saveAvatarShapePreset('user'));
document.getElementById('delete-my-avatar-shape-preset-btn').addEventListener('click', () => openDeleteShapePresetsModal('user'));
document.getElementById('save-ai-avatar-shape-preset-btn').addEventListener('click', () => saveAvatarShapePreset('char'));
document.getElementById('delete-ai-avatar-shape-preset-btn').addEventListener('click', () => openDeleteShapePresetsModal('char'));

// ▲▲▲ 新增事件监听器结束 ▲▲▲

// ▼▼▼ 自定义输入框文案功能 ▼▼▼
// 加载自定义输入框文案
function loadCustomPlaceholder() {
    const savedPlaceholder = localStorage.getItem('custom-chat-placeholder');
    const chatInput = document.getElementById('chat-input');
    const placeholderInput = document.getElementById('custom-placeholder-input');
    
    if (savedPlaceholder) {
        chatInput.placeholder = savedPlaceholder;
        if (placeholderInput) {
            placeholderInput.value = savedPlaceholder;
        }
    } else {
        chatInput.placeholder = '输入消息...';
        if (placeholderInput) {
            placeholderInput.value = '';
        }
    }
}

// 应用自定义输入框文案
function applyCustomPlaceholder() {
    const placeholderInput = document.getElementById('custom-placeholder-input');
    const chatInput = document.getElementById('chat-input');
    const newPlaceholder = placeholderInput.value.trim();
    
    if (newPlaceholder) {
        localStorage.setItem('custom-chat-placeholder', newPlaceholder);
        chatInput.placeholder = newPlaceholder;
        alert('输入框文案已更新！');
    } else {
        alert('请输入文案内容');
    }
}

// 重置输入框文案为默认值
function resetCustomPlaceholder() {
    const chatInput = document.getElementById('chat-input');
    const placeholderInput = document.getElementById('custom-placeholder-input');
    
    localStorage.removeItem('custom-chat-placeholder');
    chatInput.placeholder = '输入消息...';
    placeholderInput.value = '';
    alert('已重置为默认文案！');
}

// 监听应用和重置按钮
document.getElementById('apply-placeholder-btn').addEventListener('click', applyCustomPlaceholder);
document.getElementById('reset-placeholder-btn').addEventListener('click', resetCustomPlaceholder);

// 页面加载时应用保存的文案
loadCustomPlaceholder();
// ▲▲▲ 自定义输入框文案功能结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域粘贴 ▼▼▼
document.getElementById('manage-my-avatar-library-btn').addEventListener('click', openMyAvatarLibraryModal);
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这行新代码 ▼▼▼

document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这行新代码 ▼▼▼
document.getElementById('delete-expired-songs-btn').addEventListener('click', deleteExpiredSearchedSongs);
// ▼▼▼ 【修改】用这块【功能增强版】的代码，完整替换掉你旧的 weibo-following-list-container 事件监听器 ▼▼▼
document.getElementById('weibo-following-list-container').addEventListener('click', (e) => {
    const item = e.target.closest('.weibo-following-item');
    if (!item) return;

    // 1. 检查点击的是否是“操作”按钮
    const triggerBtn = e.target.closest('.weibo-action-trigger-btn');
    if (triggerBtn) {
        const targetInfo = {
            id: triggerBtn.dataset.targetId,
            name: triggerBtn.dataset.targetName,
            isNpc: triggerBtn.dataset.isNpc === 'true',
            ownerId: triggerBtn.dataset.ownerId || null
        };
        openWeiboActionModal(targetInfo);
    } 
    // 2. 如果点击的不是操作按钮，就视为点击了整行，触发“查看私信”
    else {
        // 先隐藏当前的关注列表弹窗
        document.getElementById('weibo-following-modal').classList.remove('visible');
        
        // 从整行item上获取角色信息
        const actionBtn = item.querySelector('.weibo-action-trigger-btn'); // 找到这一行的按钮以获取数据
        if (actionBtn) {
            const targetInfo = {
                id: actionBtn.dataset.targetId,
                name: actionBtn.dataset.targetName,
                isNpc: actionBtn.dataset.isNpc === 'true',
                ownerId: actionBtn.dataset.ownerId || null
            };
            // ★★★ 核心修改：调用我们新写的总入口函数 ★★★
            openWeiboDms(targetInfo);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('cancel-weibo-action-btn').addEventListener('click', () => {
    document.getElementById('weibo-action-modal').classList.remove('visible');
});

document.getElementById('confirm-weibo-action-btn').addEventListener('click', handleWeiboAiAction);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// 【已修改】为“生成热搜”和“生成广场”按钮绑定新的带角色选择的事件
document.getElementById('generate-hot-search-btn').addEventListener('click', async () => {
    const result = await showMultiCharacterSelectorForWeibo(); // 调用新的多选函数
    if (result) { 
        await generateHotSearch(result.targets, result.recognition); 
    }
});
document.getElementById('generate-plaza-feed-btn').addEventListener('click', async () => {
    const result = await showMultiCharacterSelectorForWeibo();
    if (result) {
        await generatePlazaFeed(null, result.targets, result.recognition); 
    }
});


// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这整块新代码 ▼▼▼

// --- 微博热搜与广场功能事件绑定 ---

// 1. 绑定热搜详情页的“返回”按钮
document.getElementById('back-from-hottopic-btn').addEventListener('click', () => {
    switchToWeiboView('weibo-hot-search-view');
});

// 2. 绑定热搜详情页的“换一批”按钮
document.getElementById('refresh-hottopic-feed-btn').addEventListener('click', () => {
    if (currentHotTopic) {
        generateHotSearchFeed(currentHotTopic);
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // ▼▼▼ 第2步 第5处修改（新增事件监听器） ▼▼▼
    // 【全新】角色表情包管理功能事件绑定
    document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
        if (e.target.id === 'manage-char-stickers-btn') {
            document.getElementById('chat-settings-modal').classList.remove('visible');
            openCharStickerManager();
        }
    });

    document.getElementById('back-from-sticker-manager').addEventListener('click', () => {
        showScreen('chat-interface-screen');
        document.getElementById('chat-settings-btn').click();
    });

// ▼▼▼ 用这块新代码替换旧的页签切换事件 ▼▼▼
const stickerTabExclusive = document.getElementById('sticker-tab-exclusive');
const stickerTabCommon = document.getElementById('sticker-tab-common');
const stickerContentExclusive = document.getElementById('sticker-content-exclusive');
const stickerContentCommon = document.getElementById('sticker-content-common');

stickerTabExclusive.addEventListener('click', () => {
    stickerTabExclusive.classList.add('active');
    stickerTabCommon.classList.remove('active');
    stickerContentExclusive.classList.add('active');
    stickerContentCommon.classList.remove('active');
    // 切换时如果处于选择模式，需要重新渲染
    if (isCharStickerSelectionMode) renderCharStickers('exclusive');
});

stickerTabCommon.addEventListener('click', () => {
    stickerTabCommon.classList.add('active');
    stickerTabExclusive.classList.remove('active');
    stickerContentCommon.classList.add('active');
    stickerContentExclusive.classList.remove('active');
    // 切换时如果处于选择模式，需要重新渲染
    if (isCharStickerSelectionMode) renderCharStickers('common');
});
// ▲▲▲ 替换结束 ▲▲▲

    // 绑定各种添加/上传按钮
    document.getElementById('add-exclusive-sticker-btn').addEventListener('click', () => bulkAddCharStickers('exclusive'));
    document.getElementById('upload-exclusive-sticker-btn').addEventListener('click', () => uploadCharStickersLocal('exclusive'));
    document.getElementById('add-common-sticker-btn').addEventListener('click', () => bulkAddCharStickers('common'));
    document.getElementById('upload-common-sticker-btn').addEventListener('click', () => uploadCharStickersLocal('common'));

    // ▲▲▲ 新增事件监听器结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新】心声历史记录删除功能事件绑定 ▼▼▼
document.getElementById('clear-all-history-btn').addEventListener('click', clearAllInnerVoiceHistory);

// 使用事件委托处理单条删除
document.getElementById('inner-voice-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('history-item-delete-btn')) {
        const timestamp = parseInt(e.target.dataset.timestamp);
        if (!isNaN(timestamp)) {
            deleteSingleInnerVoice(timestamp);
        }
    }
});
// ▲▲▲ 心声历史删除事件绑定结束 ▲▲▲

// ▼▼▼ 使用下面这整块新的代码来替换你的旧代码 ▼▼▼
document.getElementById('import-character-card-btn').addEventListener('click', async () => {
    const unlockKey = 'isCharacterImportUnlocked';
    
    // 1. 检查是否已经解锁
    if (localStorage.getItem(unlockKey) === 'true') {
        document.getElementById('character-card-input').click();
        return;
    }

    // 2. 如果未解锁，获取设备码
    const deviceCode = getDeviceCode();

    // 3. 构建一个包含设备码和输入框的HTML内容
    const modalHtmlContent = `
        <p style="margin-bottom: 15px;">请前往取PIN网站，使用下面的设备码获取PIN。</p>
        <div style="background: #eee; padding: 10px; border-radius: 6px; margin-bottom: 15px; user-select: all; cursor: copy;" title="点击复制设备码">
            <strong>设备码:</strong> <span id="device-code-to-copy">${deviceCode}</span>
        </div>
        <p id="copy-device-code-feedback" style="height: 15px; font-size: 12px; color: green;"></p>
    `;

    // 4. 使用 showCustomPrompt 弹出增强版模态框
    const userPin = await window.showCustomPrompt(
        '功能解锁', 
        '请在此输入获取到的PIN码...', // 这是输入框的placeholder
        '', 
        'text', 
        modalHtmlContent // 这是我们额外添加的HTML内容
    );
    
    // 5. 如果用户点击了取消，则直接返回
    if (userPin === null) return;
    
    // 6. 验证PIN码
    const correctPin = generatePinFromDeviceCode(deviceCode);
    if (userPin.trim().toUpperCase() === correctPin) {
        localStorage.setItem(unlockKey, 'true');
        await showCustomAlert('解锁成功！', '导入功能已解锁，此设备无需再次输入PIN码。');
        document.getElementById('character-card-input').click();
    } else {
        await showCustomAlert('解锁失败', 'PIN码错误，请重新获取或输入。');
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾，添加这块新代码 ▼▼▼
// 为自定义模态框添加点击复制设备码的功能
document.getElementById('custom-modal-body').addEventListener('click', (e) => {
    const codeElement = e.target.closest('#device-code-to-copy');
    if (codeElement) {
        const deviceCode = codeElement.textContent;
        const feedbackEl = document.getElementById('copy-device-code-feedback');
        navigator.clipboard.writeText(deviceCode).then(() => {
            if(feedbackEl) feedbackEl.textContent = '设备码已复制！';
            setTimeout(() => {
                if(feedbackEl) feedbackEl.textContent = '';
            }, 2000);
        }).catch(err => {
             if(feedbackEl) feedbackEl.textContent = '复制失败，请手动复制。';
        });
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
        document.getElementById('character-card-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // 当用户选择了文件后，调用我们的总处理函数
                handleCharacterImport(file);
            }
            // 清空选择，这样用户下次还能选择同一个文件
            event.target.value = null; 
        });
        // ▲▲▲ 新事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域，粘贴这行新代码 ▼▼▼
document.getElementById('phone-screen').addEventListener('click', unlockAudioContext, { once: true });
// ▲▲▲ 新代码粘贴结束 ▲▲▲
            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('clear-orphaned-data-btn').addEventListener('click', clearOrphanedData);
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            
            // ▼▼▼ 定时导出提醒功能事件监听 ▼▼▼
            document.getElementById('export-reminder-toggle').addEventListener('change', handleExportReminderToggle);
            document.getElementById('export-reminder-time').addEventListener('change', saveExportReminderSettings);
            // ▲▲▲ 定时导出提醒功能事件监听结束 ▲▲▲
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 
 stopPetDecayTimer();
    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

exitSelectionMode(); state.activeChatId = null;
// 【心声功能】返回列表时，隐藏心形按钮
document.getElementById('char-heart-btn').style.display = 'none';
 showScreen('chat-list-screen'); });
            // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
            // 为歌曲封面/歌词区域绑定点击切换事件
            document.getElementById('music-display-area').addEventListener('click', () => {
                const displayArea = document.getElementById('music-display-area');
                // 直接切换 .show-lyrics 这个类，CSS会自动处理显示/隐藏
                displayArea.classList.toggle('show-lyrics');
            });
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

                        document.getElementById('add-chat-btn').addEventListener('click', async () => { 
                const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字'); 
                if (name && name.trim()) { 
                    const newChatId = 'chat_' + Date.now(); 
                    
                    // ▼▼▼ 从这里开始替换 ▼▼▼
                const newChat = {
                    id: newChatId,
                    name: name.trim(),
                    isGroup: false,
                    isPinned: false,
                    npcLibrary: [], // 角色专属NPC库
                    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
                    status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
                    settings: {
                        aiPersona: '你是谁呀。',
                        myPersona: '我是谁呀。',
                        maxMemory: 10,
                        aiAvatar: defaultAvatar,
                        myAvatar: defaultAvatar,
                        background: '',
                        theme: 'default',
                        fontSize: 13,
                        customCss: '',
                        linkedWorldBookIds: [],
                        aiAvatarLibrary: [],
                        stickerLibrary: [], // 专属表情库
                        // === 以下是本次修复新增的初始化属性 ===
                        linkedMemories: [], // 【修复核心】初始化记忆互通数组
                        offlineMode: { enabled: false, prompt: '', style: '', wordCount: 300, presets: [] }, // 初始化线下模式
                        timePerceptionEnabled: true, // 初始化时间感知
                        customTime: '', // 初始化自定义时间
                        isCoupleAvatar: false, // 初始化情侣头像开关
                        coupleAvatarDescription: '', // 初始化情侣头像描述
                        weiboProfession: '', // 初始化微博职业
                        weiboInstruction: '' // 初始化微博指令
                    },
                    history: [],
                    musicData: { totalTime: 0 },
                    // 手机数据也保持完整
                    characterPhoneData: {
                        lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
                        browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
                        trajectory: [], appUsage: [], diary: []
                    }
                };
// ▲▲▲ 替换到这里结束 ▲▲▲


                    state.chats[newChatId] = newChat; 
                    await db.chats.put(newChat); 
                    renderChatList(); 
                } 
            });

            // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 替换结束 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);
            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            // ▼▼▼ 【全新】BGM搜索功能事件绑定 ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲

            audioPlayer.addEventListener('ended', playNext);

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => { 
    const content = chatInput.value.trim(); 
    if (!content || !state.activeChatId) return;
    
    // --- ▼▼▼【核心修复代码】▼▼▼ ---
    try {
        const command = JSON.parse(content);
        // 检查：这是否是一个让角色发微博的指令？
        if (command && command.type === 'weibo_post') {
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                alert("不能在群聊中为单个角色发布微博。");
                return;
            }

            // 创建一个新的微博帖子对象
            const newPost = {
                authorId: chat.id, // 关键！作者ID是当前角色的ID，而不是'user'
                authorType: 'char',
                authorNickname: chat.name,
                authorAvatar: chat.settings.aiAvatar || defaultAvatar,
                content: command.content || '',
                timestamp: Date.now(),
                likes: [],
                comments: [],
                baseLikesCount: command.baseLikesCount || 0,
                baseCommentsCount: command.baseCommentsCount || 0
            };

            // 如果JSON里有路人评论，就解析并添加
            if (command.comments && typeof command.comments === 'string') {
                newPost.comments = command.comments.split('\n').map(c => {
                    const parts = c.split(/[:：]/);
                    const commenter = parts.shift() || '路人';
                    const commentText = parts.join(':').trim();
                    return { commentId: 'comment_' + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
                }).filter(c => c.commentText);
            }

            await db.weiboPosts.add(newPost);
            
            // 刷新“关注的人”列表，新微博就会出现了！
            await renderFollowingWeiboFeed();

            await showCustomAlert('操作成功', `已为 “${chat.name}” 发布了一条新微博！`);
            
            chatInput.value = ''; // 清空输入框
            return; // 结束函数，不再执行后面的代码
        }
    } catch (e) {
        // 如果解析JSON失败，说明它不是指令，只是普通文本，就让代码继续往下走
    }
    // --- ▲▲▲【修复代码结束】▲▲▲ ---
    const chat = state.chats[state.activeChatId]; 
        // 1. 如果是群聊，并且你被禁言了
    if (chat && chat.isGroup && chat.settings.isUserMuted) {
        alert('你已被禁言，无法发言！');
        return; // 阻止发送
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    
    // ▼▼▼ TOKEN过大提示检查 ▼▼▼
    if (chat && chat.settings.tokenWarningEnabled) {
        const contextTextForToken = await getContextForTokenCalculation(state.activeChatId);
        const tokenCount = calculateTokenCount(contextTextForToken);
        
        let shouldWarn = false;
        
        // 如果设置了阈值，就用阈值判断
        if (chat.settings.tokenWarningThreshold && tokenCount > chat.settings.tokenWarningThreshold) {
            shouldWarn = true;
        }
        // 如果没有设置阈值，默认在可能卡顿时提示（假设4000为卡顿阈值）
        else if (!chat.settings.tokenWarningThreshold && tokenCount > 4000) {
            shouldWarn = true;
        }
        
        if (shouldWarn) {
            const confirmSend = confirm(`当前上下文Token数为 ${tokenCount}，可能导致响应卡顿。是否继续发送？`);
            if (!confirmSend) {
                return; // 用户选择不发送
            }
        }
    }
    // ▲▲▲ TOKEN过大提示检查结束 ▲▲▲
    
    // --- 【核心修改】在这里添加 ---
    const msg = { 
        role: 'user', 
        content, 
        timestamp: Date.now() 
    };

    // 检查当前是否处于引用回复模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
    }
    // --- 【修改结束】 ---
    
    chat.history.push(msg); 
    await incrementMessageCount(state.activeChatId);
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    chatInput.value = ''; 
    chatInput.style.height = 'auto'; 
    chatInput.focus(); 
    
    // --- 【核心修改】发送后，取消引用模式 ---
    cancelReplyMode(); 
});
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
// ▼▼▼ 请用这整块【修复版】代码，替换你旧的 'save-wallpaper-btn' 事件监听器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 保存锁屏壁纸
    if (newLockscreenWallpaperBase64) {
        state.globalSettings.lockscreenWallpaper = newLockscreenWallpaperBase64;
        changesMade = true;
    }

    // 保存全局聊天背景
    if (newGlobalBgBase64 === 'REMOVED') { 
        state.globalSettings.globalChatBackground = '';
        changesMade = true;
    } else if (newGlobalBgBase64) { 
        state.globalSettings.globalChatBackground = newGlobalBgBase64;
        changesMade = true;
    }

    // ★★★ 核心修复1：在这里保存CSS编辑框的当前内容 ★★★
    // 我们将CSS代码保存到一个新属性 activeCustomCss 中
    state.globalSettings.activeCustomCss = document.getElementById('theme-css-editor').value;
    // 同时，保存当前选择的【主题ID】，如果用户没选，就保存null
    const activeThemeSelector = document.getElementById('theme-selector');
    state.globalSettings.activeThemeId = activeThemeSelector.value ? parseInt(activeThemeSelector.value) : null;
    changesMade = true; // 只要点击保存，就认为CSS有变动
    // ★★★ 修复结束 ★★★

    // 保存密码
    const newPassword = document.getElementById('password-set-input').value;
    state.globalSettings.password = newPassword;

    // 保存铃声和提示音
    state.globalSettings.ringtoneUrl = document.getElementById('ringtone-url-input').value.trim();
    state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
    
    // 保存锁屏和状态栏开关状态
    const isLockEnabled = document.getElementById('enable-lock-screen-toggle').checked;
    state.globalSettings.enableLockScreen = isLockEnabled;
    localStorage.setItem('lockScreenEnabled', isLockEnabled);
    
    // 保存主屏幕字体颜色和阴影设置
    state.globalSettings.homeIconWidgetTextColor = document.getElementById('home-icon-widget-text-color-picker').value;
    state.globalSettings.removeHomeFontShadow = document.getElementById('remove-home-font-shadow-toggle').checked;
    
    // 保存App名称
    saveAppLabels();

    // 将所有设置一次性写入数据库
    await db.globalSettings.put(state.globalSettings);

    // 应用所有更改
    if (changesMade) {
        applyGlobalWallpaper();        
        applyLockscreenWallpaper(); 
        applyThemeCss(state.globalSettings.activeCustomCss); // 应用刚刚保存的CSS
        newWallpaperBase64 = null;        
        newLockscreenWallpaperBase64 = null; 
        newGlobalBgBase64 = null; 
    }
    applyAppIcons(); 
    applyAppLabels();
    
    alert('所有外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { 

    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const isBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isBlocked) {
    alert('错误：该 API 站点已被禁用，无法使用。');
    return; // 阻止保存
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); 
state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); 
state.apiConfig.model = document.getElementById('model-select').value; 
state.apiConfig.temperature = parseFloat(document.getElementById('temperature-slider').value);
    // 【核心新增】保存 Minimax 设置
    state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
    state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
    state.apiConfig.minimaxSpeechModel = document.getElementById('minimax-speech-model-select').value;
await db.apiConfig.put(state.apiConfig); 

// 在 'save-api-settings-btn' 的 click 事件监听器内部
// await db.apiConfig.put(state.apiConfig); 这行之后
state.globalSettings.imageCompressionQuality = parseFloat(document.getElementById('image-quality-slider').value);
// ▼▼▼ 将之前那段保存后台活动设置的逻辑，替换为下面这个增强版 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 只有在用户“从关到开”时，才弹出警告
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【高费用警告】\n\n" +
        "您正在启用“后台角色活动”功能。\n\n" +
        "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
        "但请注意：\n" +
        "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
        "您确定要开启吗？"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 用户取消，把开关拨回去
        return; // 阻止后续逻辑
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// 动态启动或停止模拟器
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
} else {
    console.log("后台活动模拟已停止。");
}
// ▲▲▲ 替换结束 ▲▲▲

alert('API设置已保存!'); });

                    // gemini 密钥聚焦的时候显示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        document.getElementById('fetch-models-btn').addEventListener('click', async () => {
            const url = document.getElementById('proxy-url').value.trim();
            const key = document.getElementById('api-key').value.trim();
            if (!url || !key) return alert('请先填写反代地址和密钥');
            try {

                let  isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`,isGemini ? undefined : {headers: {'Authorization': `Bearer ${key}`}});
                if (!response.ok) throw new Error('无法获取模型列表');
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if(isGemini){
                    models = models.map((model)=>{
                        const parts = model.name.split('/');
                        return {
                            id:parts.length > 1 ? parts[1] : model.name
                        }
                    })
                }
                const modelSelect = document.getElementById('model-select');
                modelSelect.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === state.apiConfig.model) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型列表已更新');
            } catch (error) {
                alert(`拉取模型失败: ${error.message}`);
            }
        });
        document.getElementById('fetch-minimax-speech-models-btn').addEventListener('click', fetchMinimaxSpeechModels);
        
        // ▼▼▼ NovelAI系统的JavaScript事件监听器 ▼▼▼
        document.getElementById('novelai-switch').addEventListener('change', (e) => {
            const detailsDiv = document.getElementById('novelai-details');
            detailsDiv.style.display = e.target.checked ? 'block' : 'none';
        });
        
        // NovelAI API Key显示/隐藏切换
        document.getElementById('novelai-key-toggle').addEventListener('click', function() {
            const input = document.getElementById('novelai-api-key');
            if (input.type === 'password') {
                input.type = 'text';
                this.textContent = '😌';
            } else {
                input.type = 'password';
                this.textContent = '🧐';
            }
        });
        
        // 打开NovelAI设置弹窗
        document.getElementById('novelai-settings-btn').addEventListener('click', () => {
            loadNovelAISettings();
            document.getElementById('novelai-settings-modal').style.display = 'flex';
        });
        
        // CORS代理选择器变化事件
        document.getElementById('nai-cors-proxy').addEventListener('change', (e) => {
            const customProxyGroup = document.getElementById('nai-custom-proxy-group');
            if (e.target.value === 'custom') {
                customProxyGroup.style.display = 'block';
            } else {
                customProxyGroup.style.display = 'none';
            }
        });
        
        // 关闭NovelAI设置弹窗
        document.getElementById('close-novelai-settings').addEventListener('click', () => {
            document.getElementById('novelai-settings-modal').style.display = 'none';
        });
        
        // 保存NovelAI设置
        document.getElementById('save-nai-settings-btn').addEventListener('click', () => {
            saveNovelAISettings();
            document.getElementById('novelai-settings-modal').style.display = 'none';
            alert('NovelAI设置已保存！');
        });
        
        // 恢复默认设置
        document.getElementById('reset-nai-settings-btn').addEventListener('click', () => {
            if (confirm('确定要恢复默认设置吗？')) {
                resetNovelAISettings();
            }
        });
        
        // 打开NovelAI测试弹窗
        document.getElementById('novelai-test-btn').addEventListener('click', () => {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            if (!apiKey) {
                alert('请先填写NovelAI API Key！');
                return;
            }
            document.getElementById('novelai-test-modal').style.display = 'flex';
            document.getElementById('nai-test-result').style.display = 'none';
            document.getElementById('nai-test-error').style.display = 'none';
        });
        
        // 关闭NovelAI测试弹窗
        document.getElementById('close-novelai-test').addEventListener('click', () => {
            document.getElementById('novelai-test-modal').style.display = 'none';
        });
        
        document.getElementById('close-nai-test-btn').addEventListener('click', () => {
            document.getElementById('novelai-test-modal').style.display = 'none';
        });
        
        // NovelAI生成图像按钮
        document.getElementById('nai-generate-btn').addEventListener('click', async () => {
            await generateNovelAIImage();
        });
        
        // NovelAI下载图像按钮
        document.getElementById('nai-download-btn').addEventListener('click', () => {
            const img = document.getElementById('nai-result-image');
            const link = document.createElement('a');
            link.href = img.src;
            link.download = 'novelai-generated-' + Date.now() + '.png';
            link.click();
        });

        // ▼▼▼ 角色专属NAI提示词弹窗事件监听器 ▼▼▼

        // 打开角色专属NAI提示词配置弹窗
        document.getElementById('character-nai-prompts-btn').addEventListener('click', () => {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            // 加载当前角色的NAI提示词配置
            const naiSettings = chat.settings.naiSettings || {
                promptSource: 'system',
                characterPositivePrompt: '',
                characterNegativePrompt: ''
            };
            
            // ★★★ 严格加载角色配置，不与系统配置混淆 ★★★
            // 填了就有，没填就为空，绝不使用系统配置填充
            document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
            document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';
            
            document.getElementById('character-nai-prompts-modal').style.display = 'flex';
        });

        // 关闭角色专属NAI提示词弹窗
        document.getElementById('close-character-nai-prompts').addEventListener('click', () => {
            document.getElementById('character-nai-prompts-modal').style.display = 'none';
        });

        // 保存角色专属NAI提示词
        document.getElementById('save-character-nai-prompts-btn').addEventListener('click', async () => {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            if (!chat.settings.naiSettings) {
                chat.settings.naiSettings = {
                    promptSource: 'system'
                };
            }
            
            chat.settings.naiSettings.characterPositivePrompt = document.getElementById('character-nai-positive').value.trim();
            chat.settings.naiSettings.characterNegativePrompt = document.getElementById('character-nai-negative').value.trim();
            
            console.log('💾 [专属弹窗] 保存角色NAI提示词');
            console.log('   characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
            console.log('   characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
            console.log('   promptSource:', chat.settings.naiSettings.promptSource);
            
            // 保存到数据库
            await db.chats.put(chat);
            
            document.getElementById('character-nai-prompts-modal').style.display = 'none';
            alert('角色专属NAI提示词已保存！');
        });

        // 清空角色专属NAI提示词配置
        document.getElementById('reset-character-nai-prompts-btn').addEventListener('click', () => {
            if (confirm('确定要清空当前角色的NAI提示词配置吗？')) {
                document.getElementById('character-nai-positive').value = '';
                document.getElementById('character-nai-negative').value = '';
            }
        });

        // ▲▲▲ 角色专属NAI提示词弹窗事件监听器结束 ▲▲▲

        // ▼▼▼ 群聊角色专属NAI提示词弹窗事件监听器 ▼▼▼
        document.getElementById('group-character-nai-prompts-btn').addEventListener('click', () => {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            
            // 加载当前角色的NAI提示词配置
            const naiSettings = chat.settings.naiSettings || {
                promptSource: 'system',
                characterPositivePrompt: '',
                characterNegativePrompt: ''
            };
            
            // ★★★ 严格加载角色配置，不与系统配置混淆 ★★★
            // 填了就有，没填就为空，绝不使用系统配置填充
            document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
            document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';
            
            document.getElementById('character-nai-prompts-modal').style.display = 'flex';
        });
        // ▲▲▲ 群聊角色专属NAI提示词弹窗事件监听器结束 ▲▲▲
        // ▲▲▲ NovelAI系统事件监听器结束 ▲▲▲
        
document.getElementById('import-world-book-btn').addEventListener('click', async () => {
    const unlockKey = 'isCharacterImportUnlocked';
    
    // 1. 检查是否已经解锁 (和角色卡导入共用一个解锁状态)
    if (localStorage.getItem(unlockKey) === 'true') {
        document.getElementById('world-book-import-input').click(); // 直接打开文件选择器
        return;
    }

    // 2. 如果未解锁，获取设备码
    const deviceCode = getDeviceCode();

    // 3. 构建一个包含设备码和输入框的HTML内容 (和角色卡导入的弹窗一样)
    const modalHtmlContent = `
        <p style="margin-bottom: 15px;">请前往取PIN网站，使用下面的设备码获取PIN。</p>
        <div style="background: #eee; padding: 10px; border-radius: 6px; margin-bottom: 15px; user-select: all; cursor: copy;" title="点击复制设备码">
            <strong>设备码:</strong> <span id="device-code-to-copy">${deviceCode}</span>
        </div>
        <p id="copy-device-code-feedback" style="height: 15px; font-size: 12px; color: green;"></p>
    `;

    // 4. 使用 showCustomPrompt 弹出增强版模态框，让用户输入PIN
    const userPin = await window.showCustomPrompt(
        '功能解锁', 
        '请在此输入获取到的PIN码...', 
        '', 
        'text', 
        modalHtmlContent 
    );
    
    // 5. 如果用户点击了取消，则直接返回
    if (userPin === null) return;
    
    // 6. 验证PIN码
    const correctPin = generatePinFromDeviceCode(deviceCode);
    if (userPin.trim().toUpperCase() === correctPin) {
        localStorage.setItem(unlockKey, 'true');
        await showCustomAlert('解锁成功！', '导入功能已解锁，此设备无需再次输入PIN码。');
        // ★★★ 核心修改：触发世界书的文件选择器 ★★★
        document.getElementById('world-book-import-input').click(); 
    } else {
        await showCustomAlert('解锁失败', 'PIN码错误，请重新获取或输入。');
    }
});


document.getElementById('world-book-import-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        // 当用户选择了文件后，调用我们的核心处理函数
        handleImportSillyTavernWorldBook(file);
    }
    // 每次用完后清空，这样用户下次还能选择同一个文件
    e.target.value = null; 
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲

            document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建世界书', '请输入书名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('书名不能为空！'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; 

        // ▼▼▼ 【核心修改】在这里保存分类ID ▼▼▼
        const categoryId = document.getElementById('world-book-category-select').value;
        // 如果选择了“未分类”，存入 null；否则存入数字ID
        book.categoryId = categoryId ? parseInt(categoryId) : null; 
        // ▲▲▲ 修改结束 ▲▲▲

await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });
// ▼▼▼ 第3步：用这整块【全新的】代码，完整替换旧的 'chat-messages' 点击事件监听器 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    
    const voiceBody = e.target.closest('.voice-message-body');
    if (voiceBody) {
        const bubble = voiceBody.closest('.message-bubble');
        if (!bubble) return;

        // 如果是用户自己的语音，只切换文字显示，不播放
        if (bubble.classList.contains('user')) {
            toggleVoiceTranscript(bubble);
            return;
        }

// ▼▼▼ 请用下面这段【已修复点击收起功能】的代码，完整替换你旧的AI语音点击处理逻辑 ▼▼▼
        // 如果是AI的语音消息
        const chat = state.chats[state.activeChatId];
        if (!chat) return;

        // --- 核心逻辑开始 ---

        // 1. 检查是否点击了正在播放的语音条
        if (isTtsPlaying && currentTtsAudioBubble === bubble) {
            // 如果是，则停止播放并收起所有关联的文字
            stopMinimaxAudio(); 
        } 
        // 2. 检查点击的是否是已经展开了文字但没有播放的语音条
        else if (bubble.dataset.state === 'expanded') {
            // 如果是，则只收起文字，不影响其他
            toggleVoiceTranscript(bubble);
        }
        // 3. 如果以上都不是，说明是想开始播放或只展开文字
        else {
            const clickedTimestamp = parseInt(bubble.dataset.timestamp);
            const startIndex = chat.history.findIndex(m => m.timestamp === clickedTimestamp);
            if (startIndex === -1) return;

            // 查找连续的语音消息
            const messagesToPlay = findConsecutiveAiVoiceMessages(chat.history, startIndex);
            if (messagesToPlay.length > 0) {
                const bubblesToAnimate = messagesToPlay.map(m => document.querySelector(`.message-bubble[data-timestamp="${m.timestamp}"]`)).filter(Boolean);
                
                // 检查配置，决定是播放还是只显示文字
                const groupId = state.apiConfig.minimaxGroupId;
                const apiKey = state.apiConfig.minimaxApiKey;
                const voiceId = chat.settings.minimaxVoiceId;

                if (groupId && apiKey && voiceId) {
                    // 【播放分支】
                    // 先展开所有文字
                    bubblesToAnimate.forEach(b => {
                        if (b.dataset.state !== 'expanded') {
                            toggleVoiceTranscript(b);
                        }
                    });
                    // 然后调用播放器
                    const combinedText = messagesToPlay.map(m => m.content.trim()).join('，');
                    playMinimaxAudio(combinedText, voiceId, bubblesToAnimate);
                } else {
                    // 【只显示文字分支】
                    // 只展开当前点击的这一个语音条的文字
                    toggleVoiceTranscript(bubble);
                }
            }
        }
        
        return; // 处理完语音后退出
    }
// ▲▲▲ 替换结束 ▲▲▲




    // --- 你原来的其他点击事件逻辑 ---
    const aiImage = e.target.closest('.ai-generated-image');
    if (aiImage) {
        const description = aiImage.dataset.description;
        if (description) showCustomAlert('照片描述', description);
        return;
    }
    const linkCard = e.target.closest('.link-share-card');
    if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        if (!isNaN(timestamp)) {
            openBrowser(timestamp);
        }
    }
    const packetCard = e.target.closest('.red-packet-card');
    if (packetCard) {
        const messageBubble = packetCard.closest('.message-bubble');
        if (messageBubble && messageBubble.dataset.timestamp) {
            const timestamp = parseInt(messageBubble.dataset.timestamp);
            handlePacketClick(timestamp);
        }
    }
    const pollCard = e.target.closest('.poll-card');
    if (pollCard) {
        const timestamp = parseInt(pollCard.dataset.pollTimestamp);
        if (isNaN(timestamp)) return;
        const optionItem = e.target.closest('.poll-option-item');
        if (optionItem && !pollCard.classList.contains('closed')) {
            handleUserVote(timestamp, optionItem.dataset.option);
            return;
        }
        const actionBtn = e.target.closest('.poll-action-btn');
        if (actionBtn) {
            if (pollCard.classList.contains('closed')) {
                showPollResults(timestamp);
            } else {
                endPoll(timestamp);
            }
            return;
        }
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        }
    }
    const card = e.target.closest('.waimai-card');
    if (card) {
        const messageBubble = card.closest('.message-bubble');
        const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));
        if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
            const choice = e.target.dataset.choice;
            if (choice) {
                handleLoversSpaceResponse(invitationMsg.timestamp, choice);
            }
        }
    }
    const repostCard = e.target.closest('.link-share-card[data-post-id]');
    if (repostCard) {
        const postId = parseInt(repostCard.dataset.postId);
        if (!isNaN(postId)) {
            openPost(postId);
        }
    }
    
    // 【新增】处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        if(!isNaN(timestamp)) {
            const msg = state.chats[state.activeChatId].history.find(m=>m.timestamp===timestamp);
            if(msg && msg.type === 'share_card') openSharedHistoryViewer(timestamp);
            else if(msg && msg.type === 'share_link') openBrowser(timestamp);
        }
    }
    
    // 【新增】处理已撤回消息的点击
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (placeholder) {
        const wrapper = placeholder.closest('.message-wrapper');
        const chat = state.chats[state.activeChatId];
        if (chat && wrapper) {
            const timestamp = parseInt(wrapper.dataset.timestamp);
            const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
            if (recalledMsg && recalledMsg.recalledData) {
                let originalContentText = '';
                const recalled = recalledMsg.recalledData;
                if (recalled.originalType === 'text') {
                    originalContentText = `原文: "${recalled.originalContent}"`;
                } else {
                    originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
                }
                showCustomAlert('已撤回的消息', originalContentText);
            }
        }
    }
        // ▼▼▼ 在这个函数的逻辑块内，添加下面这段新代码 ▼▼▼
    const chatCard = e.target.closest('.dating-summary-chat-card');
    if (chatCard && chatCard.dataset.summaryPayload) {
        try {
            // 读取并解析存储在 data-* 属性中的卡片数据
            const payloadString = chatCard.dataset.summaryPayload.replace(/&apos;/g, "'").replace(/"/g, '&quot;');
            const payload = JSON.parse(payloadString);
            // 调用我们新写的函数，打开详情卡片
            reopenDatingSummary(payload);
        } catch (error) {
            console.error("解析分享的约会记录失败:", error);
            alert("无法打开这个约会记录。");
        }
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
});
// ▲▲▲ 替换结束 ▲▲▲
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 点击选择 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已选择 ${checkedBoxes.length} 项`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

// ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;
    document.getElementById('offline-mode-section').style.display = isGroup ? 'none' : 'block';
document.getElementById('couple-avatar-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('streak-settings-section').style.display = isGroup ? 'none' : 'block';
// ▼▼▼ 在 const chat = ... 的下一行，粘贴这段新代码 ▼▼▼
// 计算总消息条数并更新显示
const totalMessages = chat.history.length;
const countDisplay = document.getElementById('total-message-count-display');
if (countDisplay) {
    countDisplay.textContent = `${totalMessages} 条`;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // 计算并显示上下文Token数
    const contextTextForToken = await getContextForTokenCalculation(state.activeChatId);
    const tokenCount = calculateTokenCount(contextTextForToken);
    const tokenDisplay = document.getElementById('context-token-count-display');
    if (tokenDisplay) {
        tokenDisplay.textContent = tokenCount.toLocaleString(); // toLocaleString() 会给数字加上千位分隔符，例如 "1,234"
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    // --- 统一显示/隐藏控件 ---
    // ▼▼▼ 在 chat-settings-btn 的 click 事件中，粘贴这段代码 ▼▼▼
const videoCallSettingsGroup = document.getElementById('video-call-settings-group');
const visualCallSwitch = document.getElementById('visual-video-call-switch');
const imageUploadsDiv = document.getElementById('video-call-image-uploads');
// --- 加载聊天总结设置 ---
const summarySettings = chat.settings.summary || {};
const summaryToggle = document.getElementById('summary-toggle');
const summaryDetails = document.getElementById('summary-details-container');

summaryToggle.checked = summarySettings.enabled || false;
summaryDetails.style.display = summaryToggle.checked ? 'block' : 'none';

document.querySelector(`input[name="summary-mode"][value="${summarySettings.mode || 'auto'}"]`).checked = true;
document.getElementById('summary-count-input').value = summarySettings.count || 20;
document.getElementById('summary-prompt-input').value = summarySettings.prompt || '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。';

// 为开关添加实时交互
summaryToggle.onchange = () => {
    summaryDetails.style.display = summaryToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 新代码粘贴结束 ▲▲▲
if (isGroup) {
    videoCallSettingsGroup.style.display = 'none'; // 群聊不支持，隐藏整个设置区
} else {
    videoCallSettingsGroup.style.display = 'block'; // 单聊显示
    
    // 加载当前设置
    visualCallSwitch.checked = chat.settings.visualVideoCallEnabled || false;
    imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    document.getElementById('char-video-image-preview').src = chat.settings.charVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
    document.getElementById('user-video-image-preview').src = chat.settings.userVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';

    // 为开关添加实时交互
    visualCallSwitch.onchange = () => {
        imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    };
}
// ▲▲▲ 粘贴结束 ▲▲▲
    
    // --- 线下模式UI渲染 ---
    const offlineModeSettings = chat.settings.offlineMode || { enabled: false, presets: [] }; // 安全获取
    const offlineToggle = document.getElementById('offline-mode-toggle');
    const offlineDetails = document.getElementById('offline-mode-details');

    // 1. 设置开关状态并绑定事件
    offlineToggle.checked = offlineModeSettings.enabled;
    offlineDetails.style.display = offlineToggle.checked ? 'block' : 'none';
    offlineToggle.onchange = () => {
        offlineDetails.style.display = offlineToggle.checked ? 'block' : 'none';
    };

    // 2. 填充输入框
    document.getElementById('offline-prompt-input').value = offlineModeSettings.prompt || '';
    document.getElementById('offline-style-input').value = offlineModeSettings.style || '';
    document.getElementById('offline-word-count-input').value = offlineModeSettings.wordCount || 300;

    // 3. 渲染预设下拉框
    renderOfflinePresetsSelector();

    // ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新】为气泡导入/导出按钮绑定事件 ▼▼▼
document.getElementById('export-bubble-preset-btn').addEventListener('click', exportSelectedBubblePreset);

document.getElementById('import-bubble-preset-btn').addEventListener('click', () => {
    // 点击“导入”按钮时，触发隐藏的文件选择框
    document.getElementById('import-bubble-preset-input').click();
});

document.getElementById('import-bubble-preset-input').addEventListener('change', (e) => {
    // 当用户选择了文件后，调用导入函数处理
    importBubblePreset(e.target.files[0]);
    e.target.value = null; // 每次用完后清空，方便下次选择同一个文件
});
// ▲▲▲ 新事件绑定结束 ▲▲▲


    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('minimax-voice-id-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
        // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    document.getElementById('npc-library-group').style.display = isGroup ? 'none' : 'block';
    // ▲▲▲ 粘贴结束 ▲▲▲
    
    // ▼▼▼ NAI出图设置的显示/隐藏和加载 ▼▼▼
    const naiCharacterSettingsGroup = document.getElementById('nai-character-settings-group');
    // 检查系统是否启用了NovelAI
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
    if (!isGroup && novelaiEnabled) {
        naiCharacterSettingsGroup.style.display = 'block';
        
        // 加载角色NAI设置
        const naiSettings = chat.settings.naiSettings || {
            promptSource: 'system',
            characterPositivePrompt: '',
            characterNegativePrompt: ''
        };
        
        console.log('📖 [加载设置] 角色NAI设置:', naiSettings);
        console.log('   promptSource:', naiSettings.promptSource);
        console.log('   characterPositivePrompt:', naiSettings.characterPositivePrompt);
        console.log('   characterNegativePrompt:', naiSettings.characterNegativePrompt);
        
        // 设置提示词来源选项
        const promptSourceRadios = document.querySelectorAll('input[name="nai-prompt-source"]');
        promptSourceRadios.forEach(radio => {
            radio.checked = (radio.value === naiSettings.promptSource);
            console.log(`   设置单选按钮 ${radio.value}: ${radio.checked}`);
        });
    } else {
        naiCharacterSettingsGroup.style.display = 'none';
    }
    // ▲▲▲ NAI出图设置加载结束 ▲▲▲

    // ▼▼▼ 群聊NAI出图设置的显示/隐藏和加载 ▼▼▼
    const groupNaiSettingsGroup = document.getElementById('group-nai-settings-group');
    if (isGroup && novelaiEnabled) {
        groupNaiSettingsGroup.style.display = 'block';
        
        // 加载群聊角色NAI设置
        const groupNaiSettings = chat.settings.naiSettings || {
            promptSource: 'system',
            characterPositivePrompt: '',
            characterNegativePrompt: ''
        };
        
        console.log('📖 [加载设置] 群聊角色NAI设置:', groupNaiSettings);
        console.log('   promptSource:', groupNaiSettings.promptSource);
        console.log('   characterPositivePrompt:', groupNaiSettings.characterPositivePrompt);
        console.log('   characterNegativePrompt:', groupNaiSettings.characterNegativePrompt);
        
        // 设置提示词来源选项
        const groupPromptSourceRadios = document.querySelectorAll('input[name="group-nai-prompt-source"]');
        groupPromptSourceRadios.forEach(radio => {
            radio.checked = (radio.value === groupNaiSettings.promptSource);
            console.log(`   设置单选按钮 ${radio.value}: ${radio.checked}`);
        });
    } else {
        groupNaiSettingsGroup.style.display = 'none';
    }
    // ▲▲▲ 群聊NAI出图设置加载结束 ▲▲▲

            // ▼▼▼ 第2步 第1处修改（新增代码） ▼▼▼
        // 【修改】根据是否为单聊或群聊，显示表情管理按钮
        const charStickerGroup = document.getElementById('char-sticker-group');
        if (charStickerGroup) {
            // 现在无论是单聊还是群聊，这个按钮都会显示
            charStickerGroup.style.display = 'block';
        }

// 【核心新增】根据是否为群聊，显示或隐藏微博设置
document.getElementById('weibo-profession-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('weibo-instruction-group').style.display = isGroup ? 'none' : 'block';
    // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // 【新增】根据是否为群聊，显示或隐藏"角色真名"输入框
    document.getElementById('real-name-group').style.display = isGroup ? 'none' : 'block';
    
    // --- 加载表单数据 ---
    // 【新增】加载角色真名（兼容旧数据：如果没有realName，则使用当前的name）
    if (!isGroup) {
        document.getElementById('real-name-input').value = chat.realName || chat.name;
    }
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
// ▼▼▼ 【全新】记忆互通功能 - UI渲染逻辑 (V2 - 带头像版) ▼▼▼
const memoryLinkSelectBox = document.querySelector('#memory-link-multiselect .select-box');
const memoryLinkCheckboxesContainer = document.getElementById('memory-link-checkboxes-container');
memoryLinkCheckboxesContainer.innerHTML = ''; // 清空旧选项

// 1. 获取除了当前聊天以外的所有聊天
const otherChats = Object.values(state.chats).filter(c => c.id !== chat.id);

// 2. 动态创建带头像的复选框
otherChats.forEach(otherChat => {
    const existingLink = chat.settings.linkedMemories.find(link => link.chatId === otherChat.id);
    const isChecked = existingLink ? 'checked' : '';
    
    // 【核心修改1】根据是群聊还是单聊，获取正确的头像URL
    const avatarUrl = otherChat.isGroup 
        ? (otherChat.settings.groupAvatar || defaultGroupAvatar) 
        : (otherChat.settings.aiAvatar || defaultAvatar);

    const label = document.createElement('label');
    
    // 【核心修改2】构建包含 <img> 标签的新HTML结构
    label.innerHTML = `
        <input type="checkbox" value="${otherChat.id}" ${isChecked}>
        <img src="${avatarUrl}" class="avatar-preview">
        <span>${otherChat.name} ${otherChat.isGroup ? '(群聊)' : ''}</span>
    `;
    memoryLinkCheckboxesContainer.appendChild(label);
});


// 3. 更新已选数量的显示和记忆条数
function updateMemoryLinkDisplay() {
    const checkedBoxes = memoryLinkCheckboxesContainer.querySelectorAll('input:checked');
    const displayText = memoryLinkSelectBox.querySelector('.selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else {
        displayText.textContent = `已链接 ${checkedBoxes.length} 个聊天`;
    }
}

    // 4. 加载记忆条数设置
    // 我们现在从一个独立的设置项加载，确保它总能被正确读取
    document.getElementById('link-memory-depth-input').value = chat.settings.linkMemoryDepth || 5;


// 5. 绑定事件
updateMemoryLinkDisplay(); // 初始化显示
memoryLinkCheckboxesContainer.addEventListener('change', updateMemoryLinkDisplay);
// 使用克隆节点技巧来防止事件重复绑定
const newSelectBox = memoryLinkSelectBox.cloneNode(true);
memoryLinkSelectBox.parentNode.replaceChild(newSelectBox, memoryLinkSelectBox);
newSelectBox.addEventListener('click', (e) => {
    e.stopPropagation();
    memoryLinkCheckboxesContainer.classList.toggle('visible');
    newSelectBox.classList.toggle('expanded');
});
// ▲▲▲ 记忆互通UI逻辑结束 ▲▲▲

    // ▼▼▼ 在 max-memory 赋值的下一行，粘贴这一整块代码 ▼▼▼
const timeToggle = document.getElementById('time-perception-toggle');
const customTimeContainer = document.getElementById('custom-time-container');
const customTimeInput = document.getElementById('custom-time-input');

// 如果是旧聊天，给一个默认值 true（开启）
const isTimeEnabled = chat.settings.timePerceptionEnabled ?? true; 
timeToggle.checked = isTimeEnabled;
customTimeInput.value = chat.settings.customTime || '';

// 根据开关状态，决定是否显示自定义时间输入框
customTimeContainer.style.display = isTimeEnabled ? 'none' : 'block';
// ▲▲▲ 粘贴结束 ▲▲▲

    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
        // 加载群聊后台活动设置
const groupActivityGroup = document.getElementById('group-background-activity-group');
const groupActivitySwitch = document.getElementById('group-background-activity-switch');
const groupIntervalSettings = document.getElementById('group-background-interval-settings');
const groupIntervalInput = document.getElementById('group-background-interval-input');

groupActivityGroup.style.display = 'block'; // 显示设置区域
const bgSettings = chat.settings.backgroundActivity || { enabled: false, interval: 120 };
groupActivitySwitch.checked = bgSettings.enabled;
groupIntervalInput.value = bgSettings.interval;
groupIntervalSettings.style.display = bgSettings.enabled ? 'block' : 'none';

// 为开关添加实时交互
groupActivitySwitch.onchange = () => {
    groupIntervalSettings.style.display = groupActivitySwitch.checked ? 'block' : 'none';
};
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        // 【核心修复】加载当前角色的微博职业和指令
document.getElementById('weibo-profession-input').value = chat.settings.weiboProfession || '';
document.getElementById('weibo-instruction-input').value = chat.settings.weiboInstruction || '';
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('minimax-voice-id-input').value = chat.settings.minimaxVoiceId || '';
// ▼▼▼ 用这块【功能增强版】代码替换旧的 couple-avatar-group 逻辑 ▼▼▼
const coupleAvatarToggle = document.getElementById('couple-avatar-toggle');
const coupleAvatarDetailsContainer = document.getElementById('couple-avatar-details-container');
const recognitionToggle = document.getElementById('couple-avatar-recognition-toggle');
const coupleAvatarDescInput = document.getElementById('couple-avatar-description');

// 加载总开关状态
coupleAvatarToggle.checked = chat.settings.isCoupleAvatar || false;

// 加载识图开关状态
recognitionToggle.checked = chat.settings.enableCoupleAvatarRecognition || false;

// 加载描述
coupleAvatarDescInput.value = chat.settings.coupleAvatarDescription || '';

// 加载头像预览
document.getElementById('couple-avatar-preview-my').src = chat.settings.myAvatar || defaultAvatar;
document.getElementById('couple-avatar-preview-ai').src = chat.settings.aiAvatar || defaultAvatar;

// 根据总开关状态，决定是否显示详细设置
coupleAvatarDetailsContainer.style.display = coupleAvatarToggle.checked ? 'block' : 'none';

// 为总开关添加实时交互
coupleAvatarToggle.onchange = () => {
    coupleAvatarDetailsContainer.style.display = coupleAvatarToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 替换结束 ▲▲▲
        document.getElementById('group-background-activity-group').style.display = 'none';
        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果当前好友已经有分组，就默认选中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
// ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 获取所有分类和世界书
const categories = await db.worldBookCategories.toArray();
const books = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
const hasUncategorized = books.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组
const booksByCategoryId = books.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍历分类，创建带折叠功能的列表
categories.forEach(category => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <span class="arrow">▼</span>
            <input type="checkbox" class="wb-category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIds.has(book.id);
            const label = document.createElement('label');
            // 【核心修复】给书名包一个span，方便CSS做省略号处理
            label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${book.id}" data-parent-category="${category.id}" ${isChecked ? 'checked' : ''}> <span class="wb-book-name">${book.name}</span>`;
            bookContainer.appendChild(label);
        });

        // 默认将所有文件夹设置为折叠状态，保持界面整洁
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');

        worldBookCheckboxesContainer.appendChild(header);
        worldBookCheckboxesContainer.appendChild(bookContainer);
    }
});

updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼


    // 加载并更新所有预览相关控件
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 用这块【新代码】替换旧的火花加载逻辑 ▼▼▼
// --- 加载火花设置 ---
const streakSettings = chat.settings.streak || { enabled: false, initialDays: 0, extinguishThreshold: 1 };
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// --- 【全新】加载自定义火花图标和颜色设置 ---
document.getElementById('streak-lit-icon-url').value = streakSettings.litIconUrl || '';
document.getElementById('streak-extinguished-icon-url').value = streakSettings.extinguishedIconUrl || '';
document.getElementById('streak-font-color-picker').value = streakSettings.fontColor || '#ff6f00'; // 默认橙色
// ▲▲▲ 新代码粘贴结束 ▲▲▲
const streakToggle = document.getElementById('streak-enabled-toggle');
const streakDetails = document.getElementById('streak-details-container');
const initialDaysInput = document.getElementById('streak-initial-days-input');
const thresholdSelect = document.getElementById('streak-extinguish-threshold-select');

streakToggle.checked = streakSettings.enabled;
streakDetails.style.display = streakSettings.enabled ? 'block' : 'none';
// ▼▼▼ 在这里添加下面这几行新代码 ▼▼▼
const intimacyBtn = document.getElementById('open-intimacy-panel-btn');
if (intimacyBtn) {
    intimacyBtn.style.display = streakSettings.enabled ? 'block' : 'none';
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
initialDaysInput.value = streakSettings.initialDays || 0;
thresholdSelect.value = streakSettings.extinguishThreshold || 1;

// 为开关添加实时交互
streakToggle.onchange = () => {
    streakDetails.style.display = streakToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 替换结束 ▲▲▲

// === 加载攻略模式设置 ===
const conquestSettings = chat.settings.conquestMode || { enabled: false, initialAffection: 50, successAffection: 90, currentAffection: 50, previousAffection: 50 };
const conquestToggle = document.getElementById('conquest-mode-toggle');
const conquestDetails = document.getElementById('conquest-mode-details');
const initialAffectionInput = document.getElementById('conquest-initial-affection');
const successAffectionInput = document.getElementById('conquest-success-affection');
const currentAffectionInput = document.getElementById('conquest-current-affection');
const affectionValueDisplay = document.getElementById('affection-value');
const affectionTargetDisplay = document.getElementById('affection-target');

conquestToggle.checked = conquestSettings.enabled;
conquestDetails.style.display = conquestSettings.enabled ? 'block' : 'none';
initialAffectionInput.value = conquestSettings.initialAffection || 50;
successAffectionInput.value = conquestSettings.successAffection || 90;
currentAffectionInput.value = conquestSettings.currentAffection || 50;
affectionValueDisplay.textContent = conquestSettings.currentAffection || 50;
affectionTargetDisplay.textContent = conquestSettings.successAffection || 90;

// 攻略模式开关交互
conquestToggle.onchange = () => {
    if (conquestToggle.checked) {
        // 显示警告弹窗
        const userConfirmed = confirm('⚠️ 攻略模式警告\n\n为了避免让正常聊天和攻略模式混淆造成记忆错乱，建议你：\n\n1. 保存当前对话状态到记忆库\n2. 新开一个对话来专门玩攻略模式\n\n是否继续开启攻略模式？\n\n注意：开启后角色将进入攻略系统，如果攻略失败，角色即将和你失去联系，永远不见！');
        
        if (userConfirmed) {
            conquestDetails.style.display = 'block';
        } else {
            conquestToggle.checked = false;
        }
    } else {
        conquestDetails.style.display = 'none';
    }
};

// 更新好感度按钮
document.getElementById('update-affection-btn').addEventListener('click', async () => {
    const newAffection = parseInt(currentAffectionInput.value) || 50;
    const previousAffection = conquestSettings.currentAffection || 50;
    const affectionChange = newAffection - previousAffection;
    
    // 更新显示
    affectionValueDisplay.textContent = newAffection;
    affectionTargetDisplay.textContent = successAffectionInput.value;
    
    // 如果攻略模式开启且好感度发生变化，向聊天发送隐藏系统消息
    if (conquestToggle.checked && affectionChange !== 0) {
        const chat = state.chats[state.activeChatId];
        if (chat) {
            const changeText = affectionChange > 0 ? `上升了${affectionChange}点` : `下降了${Math.abs(affectionChange)}点`;
            const hiddenMessage = {
                role: 'system',
                content: `[攻略系统提示：用户对你的好感度${changeText}！当前好感度：${newAffection}/${successAffectionInput.value}]`,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(hiddenMessage);
            
            // 更新conquestSettings中的当前好感度
            conquestSettings.currentAffection = newAffection;
            conquestSettings.previousAffection = newAffection;
            chat.settings.conquestMode = conquestSettings;
            
            await db.chats.put(chat);
            
            alert(`好感度已更新：${newAffection}/${successAffectionInput.value}\n变化：${changeText}`);
        }
    }
});

// 实时更新目标好感度显示
successAffectionInput.addEventListener('input', () => {
    affectionTargetDisplay.textContent = successAffectionInput.value;
});

// 当修改初始好感度时，同步更新实时好感度的默认值
initialAffectionInput.addEventListener('input', () => {
    const newInitialValue = initialAffectionInput.value;
    // 同步更新实时好感度输入框和显示
    currentAffectionInput.value = newInitialValue;
    affectionValueDisplay.textContent = newInitialValue;
});
// === 攻略模式加载结束 ===

    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 
    
    // 【新增】加载自定义气泡颜色到UI
    loadCustomBubbleColorsToUI();

// 【这三行就是我们新加的，现在已经放在正确的位置了】
renderBubblePresetSelector();
document.getElementById('bubble-style-preset-select').addEventListener('change', handlePresetSelectChange);
document.getElementById('manage-bubble-presets-btn').addEventListener('click', openBubblePresetManager);
    
    // ▼▼▼ 加载TOKEN过大提示设置 ▼▼▼
    const tokenWarningEnabled = chat.settings.tokenWarningEnabled || false;
    const tokenWarningThreshold = chat.settings.tokenWarningThreshold || '';
    
    document.getElementById('token-warning-enabled').checked = tokenWarningEnabled;
    document.getElementById('token-warning-threshold').value = tokenWarningThreshold;
    document.getElementById('token-threshold-group').style.display = tokenWarningEnabled ? 'block' : 'none';
    // ▲▲▲ 加载TOKEN过大提示设置结束 ▲▲▲
    
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重构】★★★
        // 显示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

// ▼▼▼ 用这整块代码，替换你旧的 openMemberEditor 函数 ▼▼▼
function openMemberEditor(memberId) { 
    editingMemberId = memberId; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === memberId); 
    if (!member) return;

    if (typeof member.isMuted === 'undefined') {
        member.isMuted = false; // 为旧数据兼容
    }
    
    document.getElementById('member-name-input').value = member.groupNickname; 
    document.getElementById('member-persona-input').value = member.persona; 
    document.getElementById('member-avatar-preview').src = member.avatar; 

    // ★★★ 我们在这里为新按钮绑定了点击事件 ★★★
    const changeFrameBtn = document.getElementById('member-editor-change-frame-btn');
    const newChangeFrameBtn = changeFrameBtn.cloneNode(true);
    changeFrameBtn.parentNode.replaceChild(newChangeFrameBtn, changeFrameBtn);
    
    newChangeFrameBtn.addEventListener('click', () => {
        // 调用头像框选择器，并告诉它我们正在为'member'类型的成员（也就是NPC）设置头像框
        openFrameSelectorModal('member', memberId);
    });
    // ★★★ 添加结束 ★★★

    document.getElementById('member-settings-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { 
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    
    // ★★★【核心重构】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵称
    member.persona = document.getElementById('member-persona-input').value; 
    member.avatar = document.getElementById('member-avatar-preview').src; 
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
});
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('备注名/群名不能为空！');
    chat.name = newName;
    
    // 【新增】保存角色真名（仅单聊）
    if (!chat.isGroup) {
        const newRealName = document.getElementById('real-name-input').value.trim();
        if (!newRealName) return alert('角色真名不能为空！');
        chat.realName = newRealName;
    }
    // ▼▼▼ 【全新】记忆互通功能 - 保存逻辑 ▼▼▼
    const linkedMemoryCheckboxes = document.querySelectorAll('#memory-link-checkboxes-container input:checked');
    const memoryDepth = parseInt(document.getElementById('link-memory-depth-input').value) || 5;

    // ▼▼▼ 在这里新增下面这一行 ▼▼▼
    chat.settings.linkMemoryDepth = memoryDepth; // 独立保存记忆条数设置
    // ▲▲▲ 新增结束 ▲▲▲

    chat.settings.linkedMemories = Array.from(linkedMemoryCheckboxes).map(checkbox => ({
        chatId: checkbox.value,
        depth: memoryDepth // 对所有选中的链接应用相同的深度
    }));
    // ▲▲▲ 保存逻辑结束 ▲▲▲


    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        // 保存群聊后台活动设置
const groupActivityEnabled = document.getElementById('group-background-activity-switch').checked;
const groupActivityInterval = parseInt(document.getElementById('group-background-interval-input').value) || 120;

// 确保 lastActivityTimestamp 字段存在
const lastTimestamp = chat.settings.backgroundActivity ? chat.settings.backgroundActivity.lastActivityTimestamp : 0;

chat.settings.backgroundActivity = {
    enabled: groupActivityEnabled,
    interval: groupActivityInterval,
    lastActivityTimestamp: lastTimestamp // 保留上次的时间戳
};

    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.minimaxVoiceId = document.getElementById('minimax-voice-id-input').value.trim();
// ▼▼▼ 用这块【功能增强版】代码替换旧的 couple-avatar-group 保存逻辑 ▼▼▼
// 1. 保存总开关和描述 (这部分不变)
chat.settings.isCoupleAvatar = document.getElementById('couple-avatar-toggle').checked;
chat.settings.coupleAvatarDescription = document.getElementById('couple-avatar-description').value.trim();

// 2. 【核心】处理识图功能的保存与触发
const oldRecognitionState = chat.settings.enableCoupleAvatarRecognition;
const newRecognitionState = document.getElementById('couple-avatar-recognition-toggle').checked;
chat.settings.enableCoupleAvatarRecognition = newRecognitionState;

// 3. 【核心】如果用户刚刚更换了“我的头像”，就清空旧的AI记忆，强制重新识别
if (chat.settings.myAvatar !== document.getElementById('my-avatar-preview').src) {
    chat.settings.coupleAvatarRecognitionMemory = '';
    console.log("检测到用户头像已更换，已清空情侣头像AI记忆。");
}

// 4. 【核心】只有当用户从“关闭”切换到“开启”识图功能时，才触发AI识别
if (newRecognitionState && !oldRecognitionState) {
    // 使用 setTimeout 延迟执行，确保设置先保存完毕
    setTimeout(() => {
        triggerCoupleAvatarRecognition(chat.id);
    }, 100);
}
// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 在 save-chat-settings-btn 的 click 事件的 else 块内，粘贴这段代码 ▼▼▼
        // 【核心新增】从输入框读取值并保存
    chat.settings.weiboProfession = document.getElementById('weibo-profession-input').value.trim();
    chat.settings.weiboInstruction = document.getElementById('weibo-instruction-input').value.trim();
// 保存视频通话设置
chat.settings.visualVideoCallEnabled = document.getElementById('visual-video-call-switch').checked;
chat.settings.charVideoImage = document.getElementById('char-video-image-preview').src;
chat.settings.userVideoImage = document.getElementById('user-video-image-preview').src;
// ▲▲▲ 粘贴结束 ▲▲▲

        // ▼▼▼ 保存NAI出图设置 ▼▼▼
        const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
        if (novelaiEnabled) {
            if (!chat.settings.naiSettings) {
                chat.settings.naiSettings = {};
            }
            
            // 根据是否为群聊选择不同的radio按钮组
            const isGroup = chat.isGroup;
            const promptSourceRadio = document.querySelector(
                isGroup ? 'input[name="group-nai-prompt-source"]:checked' : 'input[name="nai-prompt-source"]:checked'
            );
            
            chat.settings.naiSettings.promptSource = promptSourceRadio ? promptSourceRadio.value : 'system';
            console.log('💾 保存NAI设置 - promptSource:', chat.settings.naiSettings.promptSource);
            console.log('💾 保存NAI设置 - characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
            console.log('💾 保存NAI设置 - characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
            // 角色专属提示词已经在专属弹窗中保存，这里只保存来源选择
        }
        // ▲▲▲ NAI出图设置保存结束 ▲▲▲
        
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    // ▼▼▼ 在 chat.settings.maxMemory = ... 的下一行添加 ▼▼▼
chat.settings.timePerceptionEnabled = document.getElementById('time-perception-toggle').checked;
chat.settings.customTime = document.getElementById('custom-time-input').value;
// ▲▲▲ 添加结束 ▲▲▲
    // --- 保存线下模式设置 ---
    if (!chat.settings.offlineMode) chat.settings.offlineMode = {}; // 初始化
    chat.settings.offlineMode.enabled = document.getElementById('offline-mode-toggle').checked;
    chat.settings.offlineMode.prompt = document.getElementById('offline-prompt-input').value.trim();
    chat.settings.offlineMode.style = document.getElementById('offline-style-input').value.trim();
    chat.settings.offlineMode.wordCount = parseInt(document.getElementById('offline-word-count-input').value) || 300;
    // presets 的数据在管理函数中直接操作，这里无需保存
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// --- 保存聊天总结设置 ---
if (!chat.settings.summary) chat.settings.summary = {}; // 初始化
chat.settings.summary.enabled = document.getElementById('summary-toggle').checked;
chat.settings.summary.mode = document.querySelector('input[name="summary-mode"]:checked').value;
chat.settings.summary.count = parseInt(document.getElementById('summary-count-input').value) || 20;
chat.settings.summary.prompt = document.getElementById('summary-prompt-input').value.trim();
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 在 'save-chat-settings-btn' 的 click 事件监听器内部...

// ▼▼▼ 用这整块【新代码】替换旧的火花保存逻辑 ▼▼▼
const isStreakEnabled = document.getElementById('streak-enabled-toggle').checked;
const newInitialDays = parseInt(document.getElementById('streak-initial-days-input').value) || 0;
const newThreshold = parseInt(document.getElementById('streak-extinguish-threshold-select').value);

const oldStreak = chat.settings.streak || {}; // 安全地获取旧设置

if (isStreakEnabled) {
    // 检查是否是首次开启
    const isFirstTimeEnabled = !oldStreak.enabled;

    // 【核心】只有在首次开启时，才用“初始天数”覆盖“当前天数”。
    // 否则，必须保留用户已经积累的 currentDays 和 lastInteractionDate。
    chat.settings.streak = {
        enabled: true,
        currentDays: isFirstTimeEnabled ? newInitialDays : oldStreak.currentDays,
        lastInteractionDate: isFirstTimeEnabled ? null : oldStreak.lastInteractionDate,
        initialDays: newInitialDays,
        extinguishThreshold: newThreshold,
        litIconUrl: document.getElementById('streak-lit-icon-url').value.trim(),
        extinguishedIconUrl: document.getElementById('streak-extinguished-icon-url').value.trim(),
        fontColor: document.getElementById('streak-font-color-picker').value
    };
} else {
    // 如果用户关闭了功能，就重置所有设置
    chat.settings.streak = {
        enabled: false, initialDays: 0, currentDays: 0, extinguishThreshold: 1, lastInteractionDate: null,
        litIconUrl: '', extinguishedIconUrl: '', fontColor: '#ff6f00'
    };
}
// ▲▲▲ 替换结束 ▲▲▲

// === 保存攻略模式设置 ===
const conquestModeEnabled = document.getElementById('conquest-mode-toggle').checked;
const oldConquestSettings = chat.settings.conquestMode || {};

if (conquestModeEnabled) {
    const initialAffection = parseInt(document.getElementById('conquest-initial-affection').value) || 50;
    const successAffection = parseInt(document.getElementById('conquest-success-affection').value) || 90;
    const currentAffection = parseInt(document.getElementById('conquest-current-affection').value) || 50;
    
    // 如果是首次开启，设置初始好感度
    const isFirstTimeEnabled = !oldConquestSettings.enabled;
    
    chat.settings.conquestMode = {
        enabled: true,
        initialAffection: initialAffection,
        successAffection: successAffection,
        currentAffection: isFirstTimeEnabled ? initialAffection : currentAffection,
        previousAffection: isFirstTimeEnabled ? initialAffection : (oldConquestSettings.previousAffection || currentAffection)
    };
} else {
    // 关闭攻略模式，重置所有设置
    chat.settings.conquestMode = {
        enabled: false,
        initialAffection: 50,
        successAffection: 90,
        currentAffection: 50,
        previousAffection: 50
    };
}
// === 攻略模式保存结束 ===

    // ▼▼▼ 保存TOKEN过大提示设置 ▼▼▼
    chat.settings.tokenWarningEnabled = document.getElementById('token-warning-enabled').checked;
    const thresholdValue = document.getElementById('token-warning-threshold').value.trim();
    chat.settings.tokenWarningThreshold = thresholdValue ? parseInt(thresholdValue) : null;
    // ▲▲▲ 保存TOKEN过大提示设置结束 ▲▲▲
    
    await db.chats.put(chat);
saveAvatarShapeSettings(); // 保存头像形状的设置

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});

document.getElementById('clear-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    // 显示清空数据选项弹窗
    const clearDataModal = document.getElementById('clear-data-options-modal');
    clearDataModal.classList.add('visible');
    
    // 取消按钮
    document.getElementById('cancel-clear-data-btn').onclick = () => {
        clearDataModal.classList.remove('visible');
    };
    
    // 确认按钮
    document.getElementById('confirm-clear-data-btn').onclick = async () => {
        const chat = state.chats[state.activeChatId];
        
        // 清空聊天记录
        chat.history = chat.history.filter(msg => msg.type === 'summary');
        if (chat.innerVoiceHistory) {
            chat.innerVoiceHistory = [];
        }
        chat.latestInnerVoice = null;
        await db.chats.put(chat);
        
        // 检查是否需要清空记账数据
        if (document.getElementById('clear-accounting-checkbox').checked) {
            await db.accountingRecords.clear();
            await db.accountingCategories.clear();
            await db.accountingGoals.clear();
            // 重新初始化默认分类
            await initDefaultCategories();
        }
        
        // 检查是否需要清空月经数据
        if (document.getElementById('clear-period-checkbox').checked) {
            await db.periodSettings.clear();
            await db.periodMarks.clear();
        }
        
        // 检查是否需要清空学习数据
        if (document.getElementById('clear-study-checkbox').checked) {
            await db.studySubjects.clear();
            await db.questionBanks.clear();
            await db.studyRecords.clear();
        }
        
        // 关闭弹窗
        clearDataModal.classList.remove('visible');
        chatSettingsModal.classList.remove('visible');
        
        // 重置复选框
        document.getElementById('clear-accounting-checkbox').checked = false;
        document.getElementById('clear-period-checkbox').checked = false;
        document.getElementById('clear-study-checkbox').checked = false;
        
        // 刷新界面
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 如果当前在记账、月经或学习界面，刷新对应界面
        if (document.getElementById('accounting-screen').style.display !== 'none') {
            loadAccountingRecords();
            loadFinancialGoals();
        }
        if (document.getElementById('period-screen').style.display !== 'none') {
            renderPeriodCalendar();
            loadPeriodStats();
        }
        
        alert('清空操作已完成！');
    };
});

            // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 导出聊天记录按钮
document.getElementById('export-chat-history-btn').addEventListener('click', exportChatHistory);

// “导入聊天记录”这个可见的按钮
document.getElementById('import-chat-history-btn').addEventListener('click', () => {
    // 点击它时，我们去触发那个隐藏的文件选择框
    document.getElementById('import-chat-history-input').click();
});

// 隐藏的文件选择框
document.getElementById('import-chat-history-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        importChatHistory(file);
    }
    // 每次选择后清空，这样下次还能选择同一个文件
    event.target.value = null; 
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 用这块【增强版】代码，完整替换旧的 setupFileUpload 函数 ▼▼▼
const setupFileUpload = (inputId, callback) => {
    document.getElementById(inputId).addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
            try {
                // 调用新的通用压缩函数
                const compressedDataUrl = await handleImageUploadAndCompress(file);
                callback(compressedDataUrl); // 将压缩后的结果传给回调
            } catch (error) {
                console.error(`处理文件 ${file.name} 失败:`, error);
                alert(`处理图片失败: ${error.message}`);
            } finally {
                 event.target.value = null;
            }
        }
    });
};
// ▲▲▲ 替换结束 ▲▲▲

            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            // ▼▼▼ 在 init() 函数的事件监听器区域，添加这两行 ▼▼▼
setupFileUpload('char-video-image-input', (base64) => document.getElementById('char-video-image-preview').src = base64);
setupFileUpload('user-video-image-input', (base64) => document.getElementById('user-video-image-preview').src = base64);
// ▲▲▲ 添加结束 ▲▲▲
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            // ▼▼▼ 将原来的 add-sticker-btn 事件监听器替换为下面这行 ▼▼▼
document.getElementById('add-sticker-btn').addEventListener('click', openBulkAddStickersModal);
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());

            // ▼▼▼ 用下面这段【支持多选】的代码，替换旧的 sticker-upload-input 事件监听器 ▼▼▼
document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
    const files = event.target.files;
    if (!files.length) return;

    const newStickers = [];
    let canceled = false;

    // 使用 for...of 循环来逐个处理选中的文件
    for (const file of files) {
        if (canceled) break; // 如果用户中途取消了，就跳出循环

        // 为每个文件生成一个临时的本地预览URL
        const previewUrl = URL.createObjectURL(file);
        
        // 弹出带图片预览的命名框
        const name = await showCustomPrompt(
            `为表情命名 (${newStickers.length + 1}/${files.length})`,
            "请输入表情名称",
            file.name.replace(/\.[^/.]+$/, ""), // 默认使用文件名作为名字
            'text',
            // 这是 showCustomPrompt 的一个隐藏功能，可以插入额外的HTML
            `<img src="${previewUrl}" style="max-width: 100px; max-height: 100px; margin-bottom: 10px; border-radius: 8px;">`
        );
        
        // 释放临时的预览URL，避免内存泄漏
        URL.revokeObjectURL(previewUrl);
        
        if (name && name.trim()) {
            // 用户确认命名，读取文件内容并准备保存
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newStickers.push({
                id: 'sticker_' + (Date.now() + newStickers.length),
                url: base64Url,
                name: name.trim()
            });
        } else if (name === null) {
            // 如果用户点击了“取消”
            const confirmCancel = await showCustomConfirm("确认取消", "确定要取消剩余表情的上传吗？");
            if (confirmCancel) {
                canceled = true;
            }
        } else {
            alert("表情名不能为空！");
        }
    }
    
    // 循环结束后，如果收集到了新表情，就批量添加到数据库
    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
        await showCustomAlert("上传成功", `已成功添加 ${newStickers.length} 个新表情！`);
    }

    // 清空文件选择器的值，以便下次能选择相同的文件
    event.target.value = null;
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【全新】外卖请求功能事件绑定 ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('请输入商品信息！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('请输入有效的代付金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    
    // 那一大段代码已经被删除了
    
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);


// ▲▲▲ 替换到这里结束 ▲▲▲


            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
            }
        }
        
        // 2. 更新后端的历史记录
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        
        // 3. 【核心加强】构建更具体的“遗忘指令”
        let forgetReason = "一些之前的消息已被用户删除。";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
        }
        forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

        const forgetInstruction = {
            role: 'system',
            content: `[系统提示：${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(forgetInstruction);
        
        // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
        await db.chats.put(chat);
        
        // 5. 最后才更新UI
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 用下面这两行，替换掉旧的事件绑定 ▼▼▼

document.getElementById('create-shuoshuo-btn').addEventListener('click', () => openQZonePublisher('shuoshuo'));
document.getElementById('create-post-btn').addEventListener('click', () => openQZonePublisher('complex'));

// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上传成功！');
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

// --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到图片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '删除照片',
            '确定要删除这张照片吗？此操作不可恢复。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已删除。');
        }
    } 
    else if (photoThumb) {
        // 这就是恢复的图片点击放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢复图片查看器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢复键盘左右箭头和ESC键的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 请用下面这一整块【修复后】的代码，替换掉刚才删除的旧代码 ▼▼▼

// ▼▼▼ 用这【一整块】代码，替换掉旧的 'confirm-create-post-btn' 事件监听器 ▼▼▼

// ▼▼▼ 用这块【新代码】替换旧的 'confirm-create-post-btn' 事件监听器 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;

    // 【核心改造】我们在这里加一个判断
    // 如果当前是 'forum' (小组发帖) 模式，就调用我们刚刚写的发帖函数
    if (mode === 'forum') {
        await handleCreateForumPost();
        return; // 执行完就结束，不往下走了
    }
    
    // 如果是 'weibo' 模式，就调用发微博的函数
    if (mode === 'weibo') {
        await handlePublishWeibo();
        return;
    }

    // --- 下面是你原来已有的发布“动态”的逻辑，我们保持不变 ---
    const editingId = parseInt(modal.dataset.editingPostId);
    const areCommentsVisible = document.getElementById('post-comments-toggle').checked;
    
    const visibility = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    if (visibility === 'groups') {
        visibleGroupIds = Array.from(document.querySelectorAll('#post-visibility-groups input:checked'))
                           .map(cb => parseInt(cb.value));
        if (visibleGroupIds.length === 0) {
            alert("请至少选择一个可见的分组！");
            return;
        }
    }

    let postData = {};

    if (mode === 'edit') {
        const existingPost = await db.qzonePosts.get(editingId);
        if (!existingPost) {
            alert('错误：找不到要编辑的动态！');
            return;
        }
        postData = { 
            ...existingPost, 
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds
        };
        
        if (postData.type === 'shuoshuo') {
            postData.content = document.getElementById('post-public-text').value.trim();
        } else {
            postData.publicText = document.getElementById('post-public-text').value.trim();
            if (postData.type === 'image_post') {
                postData.imageUrl = document.getElementById('post-image-preview').src;
                postData.imageDescription = document.getElementById('post-image-description').value.trim();
            } else if (postData.type === 'text_image') {
                postData.hiddenContent = document.getElementById('post-hidden-text').value.trim();
            }
        }
        await db.qzonePosts.put(postData);

    } else {
        const basePostData = {
            timestamp: Date.now(),
            authorId: 'user',
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds
        };
        
        if (mode === 'shuoshuo') {
            const content = document.getElementById('post-public-text').value.trim();
            if (!content) return alert('说说内容不能为空哦！');
            postData = { ...basePostData, type: 'shuoshuo', content: content };
        } else {
            const publicText = document.getElementById('post-public-text').value.trim();
            const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
            if (isImageModeActive) {
                const imageUrl = document.getElementById('post-image-preview').src;
                const imageDescription = document.getElementById('post-image-description').value.trim();
                if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) return alert('请先添加一张图片再发布动态哦！');
                if (!imageDescription) return alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                postData = { ...basePostData, type: 'image_post', publicText, imageUrl, imageDescription };
            } else {
                const hiddenText = document.getElementById('post-hidden-text').value.trim();
                if (!hiddenText) return alert('请输入文字图描述！');
                postData = { ...basePostData, type: 'text_image', publicText, hiddenContent: hiddenText };
            }
        }
        const newPostId = await db.qzonePosts.add(postData);
        postData.id = newPostId;
    }
    
    let postSummary = postData.content || postData.publicText || postData.imageDescription || postData.hiddenContent || "（无文字内容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue;
        const historyMessage = { role: 'system', content: `[系统提示：用户${editingId ? '编辑了' : '发布了'}一条动态(ID: ${editingId || postData.id})，内容摘要是：“${postSummary}”。]`, timestamp: Date.now(), isHidden: true };
        chat.history.push(historyMessage);
        await db.chats.put(chat);
    }
    
    await renderQzonePosts();
    modal.classList.remove('visible');
    delete modal.dataset.editingPostId;
    delete modal.dataset.mode;
    alert(`动态${editingId ? '编辑' : '发布'}成功！`);
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这【一整块】新代码 ▼▼▼

// 【全新】为全局聊天背景的上传按钮绑定事件
document.getElementById('global-bg-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise((res) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        newGlobalBgBase64 = dataUrl; // 将新背景存入临时变量
        // 实时更新预览
        const preview = document.getElementById('global-bg-preview');
        preview.style.backgroundImage = `url(${dataUrl})`;
        preview.textContent = '';
    }
});

// 【全新】为全局聊天背景的移除按钮绑定事件
document.getElementById('remove-global-bg-btn').addEventListener('click', () => {
    newGlobalBgBase64 = 'REMOVED'; // 用一个特殊标记表示“移除”
    const preview = document.getElementById('global-bg-preview');
    preview.style.backgroundImage = 'none';
    preview.textContent = '已移除';
    alert('全局背景将在点击“保存”后被移除。');
});

// 【全新】为“一键清空单人背景”按钮绑定事件
document.getElementById('clear-all-single-bgs-btn').addEventListener('click', clearAllSingleChatBackgrounds);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 绑定所有滑动事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// ▼▼▼ 步骤3.3：用这整块代码替换旧的 qzone-posts-list 的 click 事件监听器 ▼▼▼
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const summonBtn = target.closest('.action-icon.summon-npc');
if (summonBtn) {
    const postId = parseInt(summonBtn.dataset.postId);
    const authorId = summonBtn.dataset.authorId;
    if (!isNaN(postId) && authorId) {
        handleNpcSummonClick(postId, authorId);
    }
    return; // 处理完召唤逻辑后，直接结束，不执行后续的点赞等判断
}
// ▲▲▲ 粘贴结束 ▲▲▲

    // ★★★★★【核心修改：处理点击评论本身（用于回复）】★★★★★
    const commentItem = target.closest('.comment-item');
    // 确保点击的不是删除按钮或评论里的名字链接
    if (commentItem && !target.classList.contains('comment-delete-btn') && !target.classList.contains('commenter-name') && !target.classList.contains('reply-target-name')) {
        const postContainer = commentItem.closest('.qzone-post-container');
        if (postContainer) {
            const commenterName = commentItem.dataset.commenterName;
            const myNickname = state.qzoneSettings.nickname;
            
            // 如果点击的是自己的评论，则不进入回复模式
            if (commenterName !== myNickname) {
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `回复 ${commenterName}:`;
                commentInput.dataset.replyTo = commenterName; // 把要回复的人的名字，临时存起来
                commentInput.focus(); // 自动聚焦到输入框
            }
        }
        return; // 处理完点击评论后，就不用往下执行了
    }

    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;
        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;
        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm('删除评论', `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            post.comments.splice(commentIndex, 1);
            await db.qzonePosts.update(postId, { comments: post.comments });
            await renderQzonePosts();
            alert('评论已删除。');
        }
        return;
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-delete-action').parentElement;
        if (!container) return;
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;
        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                 }
                 await renderQzonePosts();
                 alert('动态已删除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    
    // ★★★★★【核心修改：处理评论发送逻辑】★★★★★
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('评论内容不能为空哦！');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];

        // 创建新的评论对象
        const newComment = { 
            commenterName: state.qzoneSettings.nickname, 
            text: commentText, 
            timestamp: Date.now() 
        };

        // 检查是不是在回复模式
        if (commentInput.dataset.replyTo) {
            newComment.replyTo = commentInput.dataset.replyTo; // 如果是，就把回复对象的名字加上
        }

        post.comments.push(newComment);
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                let aiNotification = `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论：“${commentText}”`;
                if(newComment.replyTo) {
                    aiNotification += ` (这是对'${newComment.replyTo}'的回复)`;
                }
                aiNotification += `]`;
                chat.history.push({ role: 'system', content: aiNotification, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        
        // 发送后，重置输入框状态
        commentInput.value = '';
        commentInput.placeholder = '友善的评论是交流的起点';
        delete commentInput.dataset.replyTo; // 清除回复状态

        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ 步骤3.3替换结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

            // 绑定动态页和收藏页的返回按钮
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

            // 收藏页搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 控制清除按钮的显示/隐藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                    return;
                }

                // 筛选逻辑
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 同时搜索内容和作者，并且不区分大小写
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按钮的点击事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 代码检查结束 ▲▲▲

            // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
            
            // 为聊天界面的批量收藏按钮绑定事件
                        // 为聊天界面的批量收藏按钮绑定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引进行查询
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 这是收藏操作发生的时间
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                } else {
                    await showCustomAlert('提示', '选中的消息均已收藏过。');
                }
                
                exitSelectionMode();
            });

            // 收藏页面的"编辑"按钮事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
            const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 进入编辑模式 ---
                    favoritesEditBtn.textContent = '完成';
                    favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                    mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                } else {
                    // --- 退出编辑模式 ---
                    favoritesEditBtn.textContent = '编辑';
                    favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                    mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                    // 退出时清空所有选择
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                }
            });

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏列表的点击选择事件 (事件委托)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完就退出，不继续执行选择逻辑
    }
    
    // 如果不在选择模式，则不执行后续的选择操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的选择逻辑，保持不变 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切换选择状态
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部删除按钮的计数
    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
});

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏页面批量删除按钮事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除', 
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');
        
        // 【核心修正1】从前端缓存中也移除被删除的项
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最后，再退出编辑模式
        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
    }
});

// ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("后台活动模拟已自动启动。");
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

// --- 统一处理所有影响预览的控件的事件 ---

// 1. 监听主题选择
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. 监听字体大小滑块
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. 实时更新数值显示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新预览
    updateSettingsPreview();
});

// 3. 监听自定义CSS输入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. 监听重置按钮
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▼▼▼ 一键适配CSS功能 ▼▼▼
/**
 * 智能适配CSS样式到当前设备尺寸
 * 分析并调整CSS中的尺寸相关属性（px、em、rem、width、height、font-size、padding、margin等）
 */
function adaptCssToDevice(cssText) {
    if (!cssText || cssText.trim() === '') {
        return cssText;
    }
    
    // 获取当前设备信息
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const dpr = window.devicePixelRatio || 1; // 设备像素比
    
    // 计算适配比例
    // 标准参考宽度（大多数设计基于1920px或更小的屏幕）
    const referenceWidth = 1920;
    const scaleFactor = Math.min(viewportWidth / referenceWidth, 1.2); // 最大放大到1.2倍
    
    // 如果设备宽度小于768px（移动设备），使用更激进的缩放
    let mobileScaleFactor = 1;
    if (viewportWidth < 768) {
        mobileScaleFactor = viewportWidth / 768;
    }
    
    const finalScaleFactor = viewportWidth < 768 ? mobileScaleFactor : scaleFactor;
    
    // 处理CSS文本
    let adaptedCss = cssText;
    
    // 1. 适配固定像素值（px）
    // 匹配所有带px单位的数值属性
    adaptedCss = adaptedCss.replace(/(\d+(?:\.\d+)?)px/g, (match, value) => {
        const originalValue = parseFloat(value);
        const adaptedValue = Math.round(originalValue * finalScaleFactor * 10) / 10; // 保留一位小数
        return `${adaptedValue}px`;
    });
    
    // 2. 适配百分比宽度（如果有绝对值限制）
    // 例如：max-width: 800px; 这类限制性宽度也需要调整
    // 已经在上面的px替换中处理了
    
    // 3. 处理特殊的响应式单位（vw, vh）
    // 如果CSS中使用了vw/vh，根据设备调整
    adaptedCss = adaptedCss.replace(/(\d+(?:\.\d+)?)vw/g, (match, value) => {
        const originalValue = parseFloat(value);
        // 移动设备上可能需要稍微调整vw的使用
        if (viewportWidth < 768) {
            const adaptedValue = Math.round(originalValue * 1.1 * 10) / 10;
            return `${adaptedValue}vw`;
        }
        return match; // 桌面设备保持不变
    });
    
    // 4. 处理阴影和边框（box-shadow, text-shadow, border-width）
    // box-shadow: 0 4px 10px rgba(0,0,0,0.1); 中的4px和10px需要适配
    // 已经在第1步的px替换中处理了
    
    // 5. 添加注释说明适配信息
    const adaptInfo = `/* 已自动适配到当前设备 - 设备宽度: ${viewportWidth}px, 缩放比例: ${Math.round(finalScaleFactor * 100)}% */\n`;
    
    return adaptInfo + adaptedCss;
}

// 一键适配按钮事件监听器
document.getElementById('adapt-css-btn').addEventListener('click', () => {
    const customCssInput = document.getElementById('custom-css-input');
    const adaptTips = document.getElementById('adapt-css-tips');
    const adaptBtn = document.getElementById('adapt-css-btn');
    
    const originalCss = customCssInput.value.trim();
    
    if (!originalCss) {
        alert('请先输入自定义气泡样式CSS代码！');
        return;
    }
    
    // 显示提示信息
    adaptTips.style.display = 'block';
    adaptBtn.disabled = true;
    adaptBtn.style.opacity = '0.6';
    adaptBtn.style.cursor = 'not-allowed';
    
    // 使用setTimeout模拟处理过程，提升用户体验
    setTimeout(() => {
        try {
            // 移除之前的适配注释（如果有）
            let cleanCss = originalCss.replace(/\/\*\s*已自动适配到当前设备[^\*]*\*\/\s*/g, '');
            
            // 执行适配
            const adaptedCss = adaptCssToDevice(cleanCss);
            
            // 更新输入框
            customCssInput.value = adaptedCss;
            
            // 更新预览
            updateSettingsPreview();
            
            // 隐藏提示，显示成功消息
            adaptTips.textContent = '✅ 适配成功！已根据当前设备尺寸优化样式';
            adaptTips.style.color = '#4caf50';
            
            // 3秒后隐藏提示
            setTimeout(() => {
                adaptTips.style.display = 'none';
                adaptTips.textContent = '正在智能适配当前设备尺寸...';
                adaptTips.style.color = '#999';
            }, 3000);
            
        } catch (error) {
            console.error('CSS适配失败:', error);
            adaptTips.textContent = '❌ 适配失败，请检查CSS格式是否正确';
            adaptTips.style.color = '#f44336';
            
            setTimeout(() => {
                adaptTips.style.display = 'none';
                adaptTips.textContent = '正在智能适配当前设备尺寸...';
                adaptTips.style.color = '#999';
            }, 3000);
        } finally {
            // 恢复按钮状态
            adaptBtn.disabled = false;
            adaptBtn.style.opacity = '1';
            adaptBtn.style.cursor = 'pointer';
        }
    }, 500); // 延迟500ms，让用户看到处理过程
});
// ▲▲▲ 一键适配CSS功能结束 ▲▲▲

// ▼▼▼ 【全新】自定义气泡颜色事件监听器 ▼▼▼
// 颜色选择器和文本框同步
document.getElementById('user-bubble-bg-color').addEventListener('input', (e) => {
    document.getElementById('user-bubble-bg-hex').value = e.target.value;
});
document.getElementById('user-bubble-bg-hex').addEventListener('input', (e) => {
    const color = e.target.value;
    if (/^#[0-9A-F]{6}$/i.test(color)) {
        document.getElementById('user-bubble-bg-color').value = color;
    }
});

document.getElementById('user-bubble-text-color').addEventListener('input', (e) => {
    document.getElementById('user-bubble-text-hex').value = e.target.value;
});
document.getElementById('user-bubble-text-hex').addEventListener('input', (e) => {
    const color = e.target.value;
    if (/^#[0-9A-F]{6}$/i.test(color)) {
        document.getElementById('user-bubble-text-color').value = color;
    }
});

document.getElementById('char-bubble-bg-color').addEventListener('input', (e) => {
    document.getElementById('char-bubble-bg-hex').value = e.target.value;
});
document.getElementById('char-bubble-bg-hex').addEventListener('input', (e) => {
    const color = e.target.value;
    if (/^#[0-9A-F]{6}$/i.test(color)) {
        document.getElementById('char-bubble-bg-color').value = color;
    }
});

document.getElementById('char-bubble-text-color').addEventListener('input', (e) => {
    document.getElementById('char-bubble-text-hex').value = e.target.value;
});
document.getElementById('char-bubble-text-hex').addEventListener('input', (e) => {
    const color = e.target.value;
    if (/^#[0-9A-F]{6}$/i.test(color)) {
        document.getElementById('char-bubble-text-color').value = color;
    }
});

// 应用颜色按钮
document.getElementById('apply-custom-bubble-colors').addEventListener('click', () => {
    saveCustomBubbleColorsFromUI();
    updateSettingsPreview();
    if (state.activeChatId) {
        applyCustomBubbleColorsToChat(state.activeChatId);
    }
});

// 重置单个颜色按钮
document.getElementById('reset-user-bubble-color').addEventListener('click', () => {
    syncColorPicker('user-bubble-bg-color', 'user-bubble-bg-hex', '#ffffff');
});
document.getElementById('reset-user-text-color').addEventListener('click', () => {
    syncColorPicker('user-bubble-text-color', 'user-bubble-text-hex', '#585858');
});
document.getElementById('reset-char-bubble-color').addEventListener('click', () => {
    syncColorPicker('char-bubble-bg-color', 'char-bubble-bg-hex', '#ffffff');
});
document.getElementById('reset-char-text-color').addEventListener('click', () => {
    syncColorPicker('char-bubble-text-color', 'char-bubble-text-hex', '#585858');
});

// 全部重置按钮
document.getElementById('reset-all-bubble-colors').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm(
        '确认重置',
        '确定要重置所有自定义气泡颜色吗？',
        { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
        // 重置UI
        syncColorPicker('user-bubble-bg-color', 'user-bubble-bg-hex', '#ffffff');
        syncColorPicker('user-bubble-text-color', 'user-bubble-text-hex', '#585858');
        syncColorPicker('char-bubble-bg-color', 'char-bubble-bg-hex', '#ffffff');
        syncColorPicker('char-bubble-text-color', 'char-bubble-text-hex', '#585858');
        
        // 清除state中的自定义颜色
        if (state.activeChatId) {
            const chat = state.chats[state.activeChatId];
            chat.settings.customBubbleColors = {};
            updateSettingsPreview();
            applyCustomBubbleColorsToChat(state.activeChatId);
        }
        
        await showCustomAlert('已重置', '自定义气泡颜色已恢复默认。');
    }
});
// ▲▲▲ 自定义气泡颜色事件监听器结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天设置里的分组列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次点击以重新打开
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
// 消息操作菜单的按钮事件
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在这里添加新代码 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修复】在关闭菜单前，先捕获时间戳
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕获到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 动态操作菜单的按钮事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然后再打开成员管理屏幕
    openMemberManagementScreen();
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢复】从好友列表添加的事件
    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

// 绑定单聊和群聊的发起按钮
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// 绑定“挂断”按钮
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 绑定“取消呼叫”按钮
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【全新】绑定“加入通话”按钮
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“拒绝”按钮
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    stopRingtone(); 
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】从专用信道获取来电者ID
    if (!callerChatId) return;

    const chat = state.chats[callerChatId];
    if (!chat) return;
    
    // 【核心修正2】根据是否群聊，执行不同的拒绝逻辑
    if (videoCallState.isGroupCall) {
        // 对于群聊，拒绝=旁观，这个逻辑不变
        videoCallState.isUserParticipating = false;
        const systemNote = {
            role: 'system',
            content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        await triggerAiResponse(); 
    } else { 
        // 对于单聊，我们不再打扰用户当前界面，而是静默处理
        const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now(), isHidden: true };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 【核心修正3】只通知，不切换屏幕
        showNotification(callerChatId, "你已拒绝通话邀请。");
        // 【重要】在后台为对方触发一个响应，让它知道自己被拒绝了
        // 我们需要临时切换activeChatId来触发，然后再换回来
        const originalActiveChatId = state.activeChatId;
        state.activeChatId = callerChatId;
        await triggerAiResponse();
        state.activeChatId = originalActiveChatId;
    }
    
    // 清理状态
    videoCallState.isAwaitingResponse = false;
    videoCallState.activeChatId = null;
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“接听”按钮
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    stopRingtone();
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】从专用信道获取ID
    if (!callerChatId) return;
    
    // 【核心修正2】在接听时，我们才真正改变全局状态，并打开通话界面
    state.activeChatId = callerChatId; // <-- 在这里，我们才授权修改全局状态！
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    
    if (videoCallState.isGroupCall) {
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = [];
        }
    }
    
    startVideoCall(); // 启动通话界面
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
// 绑定用户在通话中发言的按钮
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    
    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
// 1. 将“回忆”页签和它的视图连接起来
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切换前，确保"收藏"页面的编辑模式已关闭
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 点击时渲染
});

// 2. 绑定回忆录界面的返回按钮
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 新增结束 ▲▲▲

// 【全新】约定/倒计时功能事件绑定
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('请输入一个有效的、未来的日期！');
        return;
    }

    const newCountdown = {
        chatId: null, // 用户创建的，不属于任何特定AI
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【全新】拉黑功能事件绑定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '确认拉黑', 
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        
        // 关闭设置弹窗，并刷新聊天界面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能会有UI变化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【新增】处理申请好友按钮的点击事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '发送好友申请', 
            `请输入你想对“${chat.name}”说的申请理由：`,
            "我们和好吧！"
        );
        // 只有当用户输入了内容并点击“确定”后才继续
        if (reason !== null) {
            // 更新关系状态为“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，显示“等待通过”的界面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【关键】触发AI响应，让它去处理这个好友申请
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

// 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 红包模态框内部的控制按钮
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 红包模态框的页签切换逻辑
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 实时更新红包金额显示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被点击的红包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

    // 2. 从红包卡片的父级.message-bubble获取时间戳
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 调用我们现有的处理函数
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
// 在输入框工具栏添加按钮
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票创建模态框的按钮
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委托处理投票卡片内的所有点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 点击了选项
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 点击了动作按钮（结束投票/查看结果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

  // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
            // ▼▼▼ 【请求4】App图标上传功能升级 (请用这整块代码替换旧的icon-settings-grid监听器) ▼▼▼
            document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
                if (e.target.classList.contains('change-icon-btn')) {
                    const item = e.target.closest('.icon-setting-item');
                    const iconId = item.dataset.iconId;
                    if (!iconId) return;

                    // 1. 弹出选择模态框
                    const choice = await showChoiceModal("更换图标", [
                        { text: '📁 从本地上传', value: 'local' },
                        { text: '🌐 使用网络URL', value: 'url' },
                        { text: '🔄 恢复默认', value: 'reset' }
                    ]);

                    let newUrl = null;

                    // 2. 根据用户的选择执行不同操作
                    if (choice === 'local') {
                        newUrl = await uploadImageLocally(); // 调用我们之前写好的本地上传辅助函数
                    } else if (choice === 'url') {
                        const currentUrl = state.globalSettings.appIcons[iconId];
                        newUrl = await showCustomPrompt(`更换“${item.querySelector('.icon-preview').alt}”图标`, '请输入新的图片URL', currentUrl, 'url');
                    } else if (choice === 'reset') {
                        if (typeof DEFAULT_APP_ICONS !== 'undefined' && DEFAULT_APP_ICONS[iconId]) {
                            newUrl = DEFAULT_APP_ICONS[iconId];
                            alert("已恢复默认图标");
                        } else {
                            alert("该App没有默认图标，无法恢复。");
                        }
                    }

                    // 3. 处理最终结果
                    if (newUrl && newUrl.trim()) {
                        const trimmedUrl = newUrl.trim();
                        // 仅在内存中更新，等待用户点击“保存”
                        state.globalSettings.appIcons[iconId] = trimmedUrl;
                        // 实时更新设置页面的预览图
                        item.querySelector('.icon-preview').src = trimmedUrl;
                    } else if (newUrl !== null && choice !== 'reset') {
                        alert("请输入一个有效的URL或选择一个文件！");
                    }
                }
            });
            // ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 使用 .closest() 向上查找被点击的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 调用我们的函数
            }
        }
    });

    // 浏览器返回按钮的事件监听，确保它只绑定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    // 1. 绑定输入框上方“分享链接”按钮的点击事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. 绑定模态框中“取消”按钮的点击事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 绑定模态框中“分享”按钮的点击事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
// 绑定消息操作菜单中的“引用”按钮
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 绑定回复预览栏中的“取消”按钮
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 粘贴结束 ▲▲▲

// 在你的 init() 函数的事件监听器区域...

// ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被点击的元素是否在一个消息气泡内
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在这里添加严格的筛选条件
    // 必须是 AI 的消息 (.ai)
    // 必须是转账类型 (.is-transfer)
    // 必须是我们标记为“待处理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有满足所有条件，才执行后续逻辑
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 在 init() 的事件监听区域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 绑定通话记录页面的“返回”按钮
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天列表页面，而不是聊天界面
    showScreen('chat-list-screen');
});

// 3. 监听卡片点击的逻辑保持不变
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 关闭详情弹窗的逻辑保持不变
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 检查点击的是否是语音条
    const voiceBody = e.target.closest('.voice-message-body');
    if (!voiceBody) return;

    // 2. 找到相关的DOM元素
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');

    // 如果正在加载中，则不响应点击
    if (bubble.dataset.state === 'loading') {
        return;
    }

    // 3. 如果文字已经展开，则收起
    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    } 
    // 4. 如果是收起状态，则开始“转录”流程
    else {
        bubble.dataset.state = 'loading'; // 进入加载状态
        spinner.style.display = 'block';   // 显示加载动画

        // 模拟1.5秒的语音识别过程
        setTimeout(() => {
            // 检查此时元素是否还存在（可能用户已经切换了聊天）
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText; // 填充文字
                
                spinner.style.display = 'none';      // 隐藏加载动画
                transcriptEl.style.display = 'block';// 显示文字
                bubble.dataset.state = 'expanded';     // 进入展开状态
            }
        }, 500);
    }
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件监听器区域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打开我们即将创建的目标选择器
    }
});

// 在 init() 的事件监听器区域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);

    if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
    }

    // 1. 打包聊天记录
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }
    
    // 2. 创建分享卡片消息对象
    const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
            sourceChatName: sourceChat.name,
            title: `来自“${sourceChat.name}”的聊天记录`,
            sharedHistory: sharedHistory
        }
    };

    // 3. 循环发送到所有目标聊天
    for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push(shareCardMessage);
            await db.chats.put(targetChat);
        }
    }
    
    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多选模式
    await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
    renderChatList(); // 刷新列表，可能会有新消息提示
});

// 绑定取消按钮
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 在 init() 的事件监听器区域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他点击事件逻辑...

    // 新增逻辑：处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 绑定查看器的关闭按钮
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 创建新函数来处理渲染逻辑
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空旧内容

    // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    // ▼▼▼ 在 lyrics-btn 的判断逻辑【上方】，添加这段新代码 ▼▼▼
            if (target.classList.contains('cover-btn')) {
                const index = parseInt(target.dataset.index);
                if (!isNaN(index)) {
                    handleCoverUpload(index);
                }
                return; // 处理完就退出，避免触发其他逻辑
            }
// ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 请用这【一整块新代码】替换旧的 lyrics-btn 点击逻辑 ▼▼▼
            if (target.classList.contains('lyrics-btn')) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;

                // 1. 弹窗询问用户选择（已移除图标）
                const choice = await showChoiceModal("选择歌词来源", [
                    { text: '使用网络URL', value: 'url' },
                    { text: '从本地上传', value: 'local' }
                ]);

                let lrcContent = null;

                // 2. 根据选择执行不同操作
                if (choice === 'url') {
                    const url = await showCustomPrompt("歌词URL", "请输入.lrc歌词文件的网络链接");
                    if (url && url.trim()) {
                        try {
                            const response = await fetch(url.trim());
                            if (response.ok) {
                                lrcContent = await response.text();
                            } else {
                                alert('无法获取歌词文件，请检查URL是否正确。');
                            }
                        } catch (error) {
                            alert('获取歌词失败: ' + error.message);
                        }
                    }
                } else if (choice === 'local') {
                    lrcContent = await new Promise(resolve => {
                        const lrcInput = document.getElementById('lrc-upload-input');
                        const handler = (event) => {
                            const file = event.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (re) => resolve(re.target.result);
                                reader.readAsText(file);
                            } else {
                                resolve(null);
                            }
                            lrcInput.removeEventListener('change', handler);
                            lrcInput.value = '';
                        };
                        lrcInput.addEventListener('change', handler);
                        lrcInput.click();
                    });
                }

                // 3. 如果成功获取到歌词，就保存并更新
                if (lrcContent !== null) {
                    musicState.playlist[index].lrcContent = lrcContent;
                    await saveGlobalPlaylist();
                    alert('歌词导入成功！');
                    if (musicState.currentIndex === index) {
                        musicState.parsedLyrics = parseLRC(lrcContent);
                        renderLyrics();
                    }
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

// 使用事件委托来处理所有“已撤回消息”的点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 检查被点击的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就从聊天记录中找到对应的数据并显示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 从父容器上找到时间戳
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域，粘贴这段新代码 ▼▼▼
document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
document.getElementById('close-category-manager-btn').addEventListener('click', () => {
    document.getElementById('world-book-category-manager-modal').classList.remove('visible');
    renderWorldBookScreen(); // 关闭后刷新主列表
});
document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
document.getElementById('existing-categories-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteCategory(categoryId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// --- ▼▼▼ 【全新】自定义头像框功能事件绑定 ▼▼▼ ---

// 打开“选择”弹窗的按钮
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal(e.target.dataset.type);
    }
});
document.getElementById('member-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('member', editingMemberId);
    }
});

// “选择”弹窗内的按钮
// “选择”弹窗内的按钮（已修正）
document.getElementById('manage-custom-frames-btn').addEventListener('click', () => {
    // 1. 先关闭当前的选择弹窗
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // 2. 然后再打开管理弹窗
    openFrameManager();
});
document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => document.getElementById('avatar-frame-modal').classList.remove('visible'));
document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);

// “管理”弹窗内的按钮
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadCustomFrame);
document.getElementById('close-frame-manager-btn').addEventListener('click', () => {
    document.getElementById('custom-frame-manager-modal').classList.remove('visible');
    // 关闭管理后，刷新选择界面，因为列表可能变了
    openFrameSelectorModal(currentFrameSelection.type, currentFrameSelection.target);
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】聊天列表左滑功能JS逻辑 ▼▼▼
const chatListEl = document.getElementById('chat-list');
let chatSwipeState = { isDragging: false, startX: 0, activeContent: null };

// 关闭所有已滑开的项
function resetAllChatSwipes(exceptThisOne = null) {
    document.querySelectorAll('.chat-list-item-content.swiped').forEach(content => {
        if (content !== exceptThisOne) {
            content.classList.remove('swiped');
        }
    });
}

chatListEl.addEventListener('mousedown', (e) => {
    const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.pageX;
        chatSwipeState.activeContent = content;
        // 阻止拖动时选中文本
        e.preventDefault();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.pageX - chatSwipeState.startX;
    if (diffX < 0 && diffX > -170) { // 只允许向左滑, 限制最大距离
        chatSwipeState.activeContent.style.transition = 'none'; // 滑动时禁用动画
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
});

document.addEventListener('mouseup', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) { // 滑动超过阈值
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = ''; // 清除内联样式，交由CSS class控制

    // 重置状态
    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});

// 移动端触摸事件的兼容
chatListEl.addEventListener('touchstart', (e) => {
     const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.touches[0].pageX;
        chatSwipeState.activeContent = content;
    }
}, { passive: true });

chatListEl.addEventListener('touchmove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.touches[0].pageX - chatSwipeState.startX;
     if (diffX < 0 && diffX > -170) {
        chatSwipeState.activeContent.style.transition = 'none';
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
}, { passive: true });

chatListEl.addEventListener('touchend', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) {
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = '';

    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});
// ▲▲▲ 新JS逻辑粘贴结束 ▲▲▲

// ▼▼▼ 【全新】聊天列表操作按钮点击事件 ▼▼▼
chatListEl.addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('swipe-action-btn')) {
        const container = target.closest('.chat-list-item-swipe-container');
        if (!container) return;

        const chatId = container.dataset.chatId;
        const chat = state.chats[chatId];
        if (!chat) return;

        if (target.classList.contains('pin') || target.classList.contains('unpin')) {
            // 置顶或取消置顶
            chat.isPinned = !chat.isPinned;
            await db.chats.put(chat);
            await renderChatList(); // 重新渲染列表以更新排序
        } else if (target.classList.contains('delete')) {
            // 删除
            const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
                delete state.chats[chat.id];
                if (state.activeChatId === chat.id) state.activeChatId = null;
                await db.chats.delete(chat.id);
                await renderChatList();
            } else {
                // 如果取消删除，则把滑块收回去
                const content = container.querySelector('.chat-list-item-content');
                if (content) content.classList.remove('swiped');
            }
        }
    }
});
// ▲▲▲ 新事件监听粘贴结束 ▲▲▲
// ▼▼▼ 从这里开始，把下面这两块完整的 eventListener 代码【剪切】掉 ▼▼▼

// 使用事件委托来处理所有点击和勾选事件，效率更高
worldBookCheckboxesContainer.addEventListener('click', (e) => {
    const header = e.target.closest('.wb-category-header');
    // 如果点击的是文件夹头部，并且不是点在复选框上
    if (header && !e.target.matches('input[type="checkbox"]')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        if (categoryId) {
            const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;
    
    // 如果点击的是分类的“全选”复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => cb.checked = isChecked);
    }
    
    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查它是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类“全选”复选框的状态
            if(categoryCheckbox) categoryCheckbox.checked = allChecked;
        }
    }
    
    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplay();
});

// ▲▲▲ 把上面这两块完整的 eventListener 代码【剪切】掉 ▲▲▲


    // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这一整块新代码 ▼▼▼

    // --- 美化功能事件绑定 ---
    const themeEditor = document.getElementById('theme-css-editor');
    
    // 页面加载时，加载主题列表并显示模板
    await loadThemesToDropdown();
    themeEditor.value = THEME_CSS_TEMPLATE;

    // 绑定下拉框选择事件
    document.getElementById('theme-selector').addEventListener('change', handleThemeSelection);
    
    // 绑定所有操作按钮
    document.getElementById('apply-theme-btn').addEventListener('click', () => applyThemeCss(themeEditor.value));
    document.getElementById('save-theme-btn').addEventListener('click', saveCurrentTheme);
    document.getElementById('save-as-new-theme-btn').addEventListener('click', saveAsNewTheme);
    document.getElementById('rename-theme-btn').addEventListener('click', renameSelectedTheme);
    document.getElementById('delete-theme-btn').addEventListener('click', deleteSelectedTheme);
    document.getElementById('export-theme-btn').addEventListener('click', exportTheme);
    
    // 绑定导入按钮和隐藏的文件选择器
    document.getElementById('import-theme-btn').addEventListener('click', () => {
        document.getElementById('import-theme-input').click();
    });
    document.getElementById('import-theme-input').addEventListener('change', (e) => {
        importTheme(e.target.files[0]);
        e.target.value = null; // 清空，以便下次能选择同一个文件
    });
    
    // 绑定手机美化一键适配按钮
    document.getElementById('adapt-mobile-theme-btn').addEventListener('click', () => {
        const themeEditor = document.getElementById('theme-css-editor');
        const adaptTips = document.getElementById('adapt-mobile-theme-tips');
        const adaptBtn = document.getElementById('adapt-mobile-theme-btn');
        
        const originalCss = themeEditor.value.trim();
        
        if (!originalCss) {
            alert('请先输入美化代码！');
            return;
        }
        
        // 显示提示信息
        adaptTips.style.display = 'block';
        adaptBtn.disabled = true;
        adaptBtn.style.opacity = '0.6';
        adaptBtn.style.cursor = 'not-allowed';
        
        // 使用setTimeout模拟处理过程
        setTimeout(() => {
            try {
                // 移除之前的适配注释（如果有）
                let cleanCss = originalCss.replace(/\/\*\s*已自动适配到当前设备[^\*]*\*\/\s*/g, '');
                
                // 执行适配（使用相同的适配函数）
                const adaptedCss = adaptCssToDevice(cleanCss);
                
                // 更新编辑器
                themeEditor.value = adaptedCss;
                
                // 可选：自动应用适配后的代码
                applyThemeCss(adaptedCss);
                
                // 显示成功消息
                adaptTips.textContent = '✅ 适配成功！美化代码已优化';
                adaptTips.style.color = '#4caf50';
                
                // 3秒后隐藏提示
                setTimeout(() => {
                    adaptTips.style.display = 'none';
                    adaptTips.textContent = '正在智能适配美化代码...';
                    adaptTips.style.color = '#999';
                }, 3000);
                
            } catch (error) {
                console.error('美化代码适配失败:', error);
                adaptTips.textContent = '❌ 适配失败，请检查CSS格式';
                adaptTips.style.color = '#f44336';
                
                setTimeout(() => {
                    adaptTips.style.display = 'none';
                    adaptTips.textContent = '正在智能适配美化代码...';
                    adaptTips.style.color = '#999';
                }, 3000);
            } finally {
                // 恢复按钮状态
                adaptBtn.disabled = false;
                adaptBtn.style.opacity = '1';
                adaptBtn.style.cursor = 'pointer';
            }
        }, 500);
    });
    
    // ▲▲▲ 新事件绑定结束 ▲▲▲

document.getElementById('api-preset-select').addEventListener('change', handleApiPresetSelectChange);
document.getElementById('manage-api-presets-btn').addEventListener('click', openApiPresetManager);

            // ▼▼▼ 【全新】锁屏功能事件监听器 ▼▼▼

            // 1. 锁屏壁纸上传
            document.getElementById('lockscreen-wallpaper-upload-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if(file) {
                    const dataUrl = await new Promise((res, rej) => {
                        const reader = new FileReader();
                        reader.onload = () => res(reader.result);
                        reader.onerror = () => rej(reader.error);
                        reader.readAsDataURL(file);
                    });
                    newLockscreenWallpaperBase64 = dataUrl;
                    renderWallpaperScreen(); // 上传后实时预览
                }
            });

            // 2. 密码输入框按钮
            document.getElementById('password-confirm-btn').addEventListener('click', checkPassword);
            document.getElementById('password-cancel-btn').addEventListener('click', hidePasswordModal);
            // 允许在输入框内按回车键确认
            document.getElementById('password-input-field').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });

            // 3. 【全新】带有动画效果的上滑解锁手势
            const lockScreen = document.getElementById('lock-screen');
            const unlockHint = document.getElementById('unlock-hint');
            let touchStartY = 0;
            let isSwiping = false;

// 统一的开始处理函数
const handleUnlockStart = (e) => {
    if (document.getElementById('password-modal-overlay').classList.contains('visible')) return;
    
    // (你原来的其他逻辑保持不变)
    const blurBg = document.getElementById('lock-screen-background-blur');
    if (state.globalSettings.password) {
        blurBg.style.backgroundImage = lockScreen.style.backgroundImage;
        blurBg.style.display = 'block';
    } else {
        document.getElementById('home-screen').classList.add('active');
    }
    
    touchStartY = getEventCoords(e).y; // 使用辅助函数获取Y坐标
    isSwiping = true;
    lockScreen.style.transition = 'none';
    unlockHint.style.transition = 'none';
};

// 统一的移动处理函数
const handleUnlockMove = (e) => {
    if (!isSwiping) return;
    const currentY = getEventCoords(e).y; // 使用辅助函数
    let diffY = currentY - touchStartY;
    // (你原来的其他逻辑保持不变)
    if (diffY > 0) diffY = 0;
    lockScreen.style.transform = `translateY(${diffY}px)`;
    unlockHint.style.opacity = Math.max(0, 1 - Math.abs(diffY) / 100);
    if (state.globalSettings.password) {
        const blurBg = document.getElementById('lock-screen-background-blur');
        blurBg.style.opacity = Math.min(1, Math.abs(diffY) / 80);
    }
};

// 统一的结束处理函数
const handleUnlockEnd = (e) => {
    if (!isSwiping) return;
    isSwiping = false;

    // (你原来的其他逻辑保持不变)
    lockScreen.style.transition = 'transform 0.3s ease-out';
    unlockHint.style.transition = 'opacity 0.3s ease-out';
    const blurBg = document.getElementById('lock-screen-background-blur');
    
    // 注意：touchend事件的坐标在 e.changedTouches[0]
    const touchEndY = e.changedTouches ? e.changedTouches[0].clientY : e.pageY;
    const swipeDistance = touchStartY - touchEndY;
    
    if (swipeDistance > 80) {
        lockScreen.style.transform = 'translateY(-100%)';
        setTimeout(() => {
            if (state.globalSettings.password) {
                showPasswordModal();
            } else {
                unlockPhone();
            }
        }, 300);
    } else {
        lockScreen.style.transform = 'translateY(0)';
        unlockHint.style.opacity = '1';
        if (state.globalSettings.password) {
            blurBg.style.opacity = '0';
            setTimeout(() => { blurBg.style.display = 'none'; }, 300);
        } else {
            document.getElementById('home-screen').classList.remove('active');
        }
    }
};

// 2. 绑定两种事件到同一套处理逻辑上
lockScreen.addEventListener('touchstart', handleUnlockStart, { passive: true });
lockScreen.addEventListener('touchmove', handleUnlockMove, { passive: true });
lockScreen.addEventListener('touchend', handleUnlockEnd, { passive: true });

lockScreen.addEventListener('mousedown', handleUnlockStart);
// 注意：mousemove和mouseup最好绑定在document上，防止鼠标拖出范围后失效
document.addEventListener('mousemove', handleUnlockMove);
document.addEventListener('mouseup', handleUnlockEnd);
            
            // ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

// 【全新】为聊天底部工具栏添加鼠标拖动滚动功能
const actionsTopBar = document.getElementById('chat-input-actions-top');
let isDown = false;
let startX;
let scrollLeft;

actionsTopBar.addEventListener('mousedown', (e) => {
    isDown = true;
    actionsTopBar.classList.add('grabbing'); // 添加一个class来改变鼠标样式
    startX = e.pageX - actionsTopBar.offsetLeft;
    scrollLeft = actionsTopBar.scrollLeft;
});

actionsTopBar.addEventListener('mouseleave', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mouseup', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    const x = e.pageX - actionsTopBar.offsetLeft;
    const walk = (x - startX) * 2; // 乘以2可以增加拖动速度，感觉更灵敏
    actionsTopBar.scrollLeft = scrollLeft - walk;
});

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
document.getElementById('location-cancel-btn').addEventListener('click', () => {
    document.getElementById('send-location-modal').classList.remove('visible');
});
document.getElementById('location-confirm-btn').addEventListener('click', sendUserLocation);
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为定位模态框的“添加途经点”按钮绑定事件
document.getElementById('add-trajectory-point-btn').addEventListener('click', () => {
    // 限制最多添加3个途经点，防止UI过于拥挤
    if (document.querySelectorAll('.trajectory-point-input').length < 3) {
        addTrajectoryPointInput();
    } else {
        alert("最多只能添加3个途经点哦！");
    }
});

// 【新增】打开定位模态框时，清空旧的途经点
document.getElementById('send-location-btn').addEventListener('click', () => {
    document.getElementById('trajectory-points-container').innerHTML = '';
    document.getElementById('send-location-modal').classList.add('visible');
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼
document.getElementById('reroll-btn').addEventListener('click', handleRerollClick);
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】粘贴这整块事件监听代码到 init() 末尾 ▼▼▼

// --- 悬浮歌词栏设置功能 ---
document.getElementById('lyrics-settings-btn').addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡触发拖动或打开播放器
    document.getElementById('lyrics-settings-modal').classList.add('visible');
});

document.getElementById('close-lyrics-settings-btn').addEventListener('click', async () => {
    // 保存设置到全局状态并写入数据库
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
    document.getElementById('lyrics-settings-modal').classList.remove('visible');
    alert('设置已保存！');
});

document.getElementById('reset-lyrics-settings-btn').addEventListener('click', () => {
    // 恢复到默认值
    lyricsBarSettings = { fontSize: 14, bgOpacity: 0, fontColor: '#FFFFFF', showOnClose: true };
    applyLyricsSettings(); // 应用默认设置
});

// 实时更新样式
document.getElementById('lyrics-font-size-slider').addEventListener('input', (e) => {
    lyricsBarSettings.fontSize = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-bg-opacity-slider').addEventListener('input', (e) => {
    lyricsBarSettings.bgOpacity = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-font-color-picker').addEventListener('input', (e) => {
    lyricsBarSettings.fontColor = e.target.value;
    applyLyricsSettings();
});

// 歌词栏上的关闭按钮
document.querySelector('#floating-lyrics-bar .close-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('floating-lyrics-bar').style.display = 'none';
});

// 播放器里的“悬浮/隐藏”开关
document.getElementById('toggle-lyrics-bar-btn').addEventListener('click', async (e) => {
    lyricsBarSettings.showOnClose = !lyricsBarSettings.showOnClose;
    e.target.textContent = lyricsBarSettings.showOnClose ? '悬浮' : '隐藏';
    e.target.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    // 立即保存这个设置
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
});

// 【重要】在页面加载时，就应用一次已保存的设置
applyLyricsSettings();

// ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】“查角色手机”功能事件监听器 ▼▼▼

            // 1. 绑定主屏幕上的“查手机”APP图标
            const checkPhoneAppIcon = document.querySelector('.app-icon[data-app-id="check-phone"]');
            if (checkPhoneAppIcon) {
                checkPhoneAppIcon.onclick = openCharacterSelectionScreen; // 修改onclick事件
            }

            // 2. 角色选择列表的点击事件 (事件委托)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });
// ▼▼▼ 请用这整块代码替换 ▼▼▼
// 【V3版】角色手机聊天列表的点击事件 (事件委托)
document.getElementById('character-chat-list').addEventListener('click', (e) => {
    const item = e.target.closest('.chat-list-item');
    if (item && item.dataset.contactName) {
        // ▼▼▼ 在这里粘贴探针 #2 ▼▼▼
        const isUserChat = item.dataset.isUserChat === 'true';
        console.log("【诊断日志 2】: 点击了聊天列表项", {
            contactName: item.dataset.contactName,
            isUserChat: isUserChat
        });
        // ▲▲▲ 探针结束 ▲▲▲
        
        // 将联系人名字和“身份证”一起传递给渲染函数
        renderCharacterChatHistory(item.dataset.contactName, isUserChat);
        showCharacterPhonePage('character-chat-history-screen');
    }
});
// ▲▲▲ 替换结束 ▲▲▲



            // 3. 角色手机顶部的“刷新”和“清空”按钮
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

            // ▲▲▲ 事件监听器添加结束 ▲▲▲

            // ▼▼▼ 【全新】角色手机内部统一返回事件监听器 ▼▼▼
            document.getElementById('character-phone-container').addEventListener('click', (e) => {
                const backBtn = e.target.closest('.back-btn');
                if (!backBtn) return;

                // 检查是返回到角色手机内部页面，还是返回到主屏幕
                if (backBtn.dataset.targetPage) {
                    showCharacterPhonePage(backBtn.dataset.targetPage);
                } else if (backBtn.dataset.targetScreen) {
                    showScreen(backBtn.dataset.targetScreen);
                }
            });
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】角色手机日记APP事件监听器 ▼▼▼
            document.getElementById('character-app-grid').addEventListener('click', (e) => {
                const icon = e.target.closest('.app-icon');
                if (icon && icon.querySelector('.label').textContent === '日记') {
                    renderCharacterDiary();
                }
            });
            document.getElementById('generate-diary-entry-btn').addEventListener('click', generateNewDiaryEntry);
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能事件绑定 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.item-delete-btn');
    if (deleteBtn) {
        // 【新增】处理微信消息删除
        if (deleteBtn.classList.contains('message-delete-btn')) {
            const contactName = deleteBtn.dataset.contactName;
            const index = parseInt(deleteBtn.dataset.index);
            if (contactName && !isNaN(index)) {
                handleCharacterChatMessageDeletion(contactName, index);
            }
        } 
        // 处理其他列表删除
        else {
            const dataType = deleteBtn.dataset.type;
            const index = parseInt(deleteBtn.dataset.index);
            if (dataType && !isNaN(index)) {
                handleCharacterDataDeletion(dataType, index);
            }
        }
    }
});
// ▲▲▲ 删除功能事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】NPC库管理功能事件绑定 ▼▼▼

// 聊天设置里的“管理NPC库”按钮
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manage-npcs-btn') {
        // 先关闭聊天设置，再打开NPC管理
        document.getElementById('chat-settings-modal').classList.remove('visible');
        openNpcManager();
    }
});

// NPC管理界面的返回按钮
document.getElementById('back-from-npc-management').addEventListener('click', () => {
    // 返回时，重新打开聊天设置
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

// NPC管理界面的“+”按钮
document.getElementById('add-new-npc-btn').addEventListener('click', () => openNpcEditor(null));



// ▼▼▼ 【全新】粘贴这整块事件监听器代码 ▼▼▼
// --- 后台活动设置界面的事件绑定 ---

// 1. 总开关的事件
document.getElementById('background-activity-switch').addEventListener('change', () => {
    // 每次点击总开关，都重新渲染一次详细设置区（它会根据开关状态自动显示或隐藏）
    renderBackgroundFrequencySelector();
});

// 2. 全选按钮
document.getElementById('bg-select-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = true;
    });
});

// 3. 全不选按钮
document.getElementById('bg-deselect-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = false;
    });
});

// 这是修复后的新代码块，用它替换掉旧的
document.querySelector('#background-activity-details').addEventListener('click', async (e) => { // 注意这里加了 async
    if (e.target.classList.contains('bg-freq-btn')) {
        const freq = e.target.dataset.freq;
        const selectedCheckboxes = document.querySelectorAll('.bg-char-checkbox:checked');
        
        if (selectedCheckboxes.length === 0) {
            alert('请先选择至少一个角色！');
            return;
        }

        const config = state.globalSettings.backgroundActivityConfig || {};
        selectedCheckboxes.forEach(checkbox => {
            const chatId = checkbox.dataset.chatId;
            if (freq === 'none') {
                delete config[chatId];
            } else {
                config[chatId] = freq;
            }
        });
        
        state.globalSettings.backgroundActivityConfig = config;
        
        // ★★★★★ 这就是我们新加的关键代码！★★★
        await db.globalSettings.put(state.globalSettings);
        // ★★★★★ 添加结束 ★★★★★
        
        renderBackgroundFrequencySelector();

        const freqTextMap = {low:'低', medium:'中', high:'高', none: '关闭'};
        const freqText = freqTextMap[freq];
        alert(`已为 ${selectedCheckboxes.length} 个角色将后台活动频率设为 "${freqText}"`);
    }
});
// 使用事件委托，为所有可编辑元素统一绑定点击事件
// ▼▼▼ 用这块【功能增强版】的代码替换旧的 ▼▼▼
// 使用事件委托，为所有可编辑元素统一绑定点击事件
document.getElementById('home-screen').addEventListener('click', async (e) => { // <-- 把这行也改成 async
    // 【核心修正】使用 .closest() 来确保即使点击到子元素也能正确触发
    const editableText = e.target.closest('.editable-text');
    if (editableText) {
        handleEditText(editableText);
        return; // 处理完就退出，避免重复触发
    }

    const editableImage = e.target.closest('.editable-image');
    if (editableImage) {
        // --- ▼▼▼ 这就是我们本次修改的核心代码 ▼▼▼ ---
        // 1. 判断被点击的图片是不是主屏幕的那个大头像
        if (editableImage.id === 'profile-avatar-img') {
            // 2. 如果是，就弹出一个选择菜单
            const choice = await showChoiceModal("编辑头像", [
                { text: '更换头像图片', value: 'avatar' },
                { text: '更换头像框', value: 'frame' }
            ]);
            
            // 3. 根据用户的选择，执行不同的操作
            if (choice === 'avatar') {
                handleEditImage(editableImage); // 调用原来的更换图片函数
            } else if (choice === 'frame') {
                openFrameSelectorModal('home_profile'); // 调用我们新增的更换头像框函数
            }
        } else {
            // 4. 如果点击的不是主头像（比如是其他小组件的图片），就还执行原来的逻辑
            handleEditImage(editableImage);
        }
        // --- ▲▲▲ 核心代码修改结束 ▲▲▲ ---
        return;
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 【核心修改】处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break; // 新增
            case 'trajectory': renderCharacterTrajectory(); break;   // 新增
            case 'appUsage': renderCharacterAppUsage(); break;       // 新增
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;   // 新增
        }
        alert('记录已删除。');
    }
}
// 使用事件委托来处理所有删除按钮的点击
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    if (e.target.classList.contains('item-delete-btn')) {
        const dataType = e.target.dataset.type;
        const index = parseInt(e.target.dataset.index);
        if (dataType && !isNaN(index)) {
            handleCharacterDataDeletion(dataType, index);
        }
    }
});
// ▲▲▲ 删除功能结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('记录已删除。');
    }
}
// ▲▲▲ 删除功能结束 ▲▲▲
startGroupSimulation(); // 启动群聊专属的后台时钟
// ▲▲▲ 新事件绑定结束 ▲▲▲
    // ▼▼▼ 步骤3.3：在 init() 的前面粘贴这段新代码 ▼▼▼
    // 使用事件委托，监听整个动态列表的“焦点移出”事件
    document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
        // 如果是评论输入框失去了焦点
        if (e.target.classList.contains('comment-input')) {
            const commentInput = e.target;
            // 并且输入框是空的
            if (commentInput.value.trim() === '') {
                // 就重置它的状态，取消回复
                commentInput.placeholder = '友善的评论是交流的起点';
                delete commentInput.dataset.replyTo;
            }
        }
    });
    // ▲▲▲ 步骤3.3粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块代码，粘贴到 init(); 的正上方 ▼▼▼
// 【全新】为时间感知开关添加实时交互事件
document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
    const customTimeContainer = document.getElementById('custom-time-container');
    customTimeContainer.style.display = e.target.checked ? 'none' : 'block';
});

// 【全新】为TOKEN过大提示开关添加实时交互事件
document.getElementById('token-warning-enabled').addEventListener('change', (e) => {
    const tokenThresholdGroup = document.getElementById('token-threshold-group');
    tokenThresholdGroup.style.display = e.target.checked ? 'block' : 'none';
});

// 【全新】删除指定范围聊天记录功能
document.getElementById('delete-messages-range-btn').addEventListener('click', async () => {
    const rangeInput = document.getElementById('delete-messages-range').value.trim();
    
    // 验证输入格式
    if (!rangeInput) {
        await showCustomAlert('输入错误', '请输入要删除的消息范围，例如：2-10');
        return;
    }
    
    const rangeMatch = rangeInput.match(/^(\d+)-(\d+)$/);
    if (!rangeMatch) {
        await showCustomAlert('格式错误', '请使用正确的格式，例如：2-10');
        return;
    }
    
    const startIndex = parseInt(rangeMatch[1]);
    const endIndex = parseInt(rangeMatch[2]);
    
    // 验证范围合法性
    if (startIndex < 1 || endIndex < 1) {
        await showCustomAlert('范围错误', '消息序号必须从1开始');
        return;
    }
    
    if (startIndex > endIndex) {
        await showCustomAlert('范围错误', '起始位置不能大于结束位置');
        return;
    }
    
    const chatId = state.activeChatId;
    if (!chatId) {
        await showCustomAlert('错误', '当前没有打开的聊天');
        return;
    }
    
    const chat = state.chats[chatId];
    if (!chat || !chat.messages || chat.messages.length === 0) {
        await showCustomAlert('错误', '当前聊天没有消息');
        return;
    }
    
    const totalMessages = chat.messages.length;
    
    // 验证范围是否超出消息总数
    if (startIndex > totalMessages || endIndex > totalMessages) {
        await showCustomAlert('范围错误', `当前聊天只有 ${totalMessages} 条消息，无法删除超出范围的消息`);
        return;
    }
    
    // 确认删除
    const deleteCount = endIndex - startIndex + 1;
    const confirmed = confirm(`确定要删除第 ${startIndex} 到第 ${endIndex} 条消息吗？（共 ${deleteCount} 条消息）\n\n注意：此操作不可撤销！`);
    
    if (!confirmed) {
        return;
    }
    
    try {
        // 删除指定范围的消息（数组索引从0开始，所以要减1）
        chat.messages.splice(startIndex - 1, deleteCount);
        
        // 保存到数据库
        await db.chats.put(chat);
        
        // 刷新聊天界面
        await renderChatList();
        openChat(chatId);
        
        // 清空输入框
        document.getElementById('delete-messages-range').value = '';
        
        await showCustomAlert('删除成功', `已成功删除第 ${startIndex} 到第 ${endIndex} 条消息`);
    } catch (error) {
        console.error('删除消息失败:', error);
        await showCustomAlert('删除失败', error.message || '删除消息时发生错误');
    }
});
// ▲▲▲ 粘贴结束 ▲▲▲
// 请用这段新代码替换上面的错误代码
document.getElementById('char-heart-btn').addEventListener('click', openInnerVoiceModal);

document.getElementById('close-inner-voice-modal').addEventListener('click', () => {
    document.getElementById('inner-voice-modal').classList.remove('visible');
});
document.getElementById('inner-voice-history-btn').addEventListener('click', toggleInnerVoiceHistory);
document.getElementById('back-from-history-btn').addEventListener('click', toggleInnerVoiceHistory);
// ▲▲▲ 心声功能事件监听器结束 ▲▲▲
// ▼▼▼ 把下面这一整块新函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】导出当前角色的聊天记录
 */
async function exportChatHistory() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 创建一个只包含聊天记录和角色名的对象
    const exportData = {
        characterName: chat.name,
        exportedAt: new Date().toISOString(),
        history: chat.history
    };

    // 2. 将这个对象转换为格式化的JSON字符串
    const jsonString = JSON.stringify(exportData, null, 2);
    
    // 3. 创建一个Blob对象
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    // 4. 创建一个临时的下载链接
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // 5. 设置下载链接的属性，包括文件名
    const dateStr = new Date().toISOString().split('T')[0];
    link.href = url;
    link.download = `[${chat.name}]-聊天记录-${dateStr}.json`;
    
    // 6. 模拟点击链接来触发下载
    document.body.appendChild(link);
    link.click();
    
    // 7. 清理临时创建的元素和URL
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    await showCustomAlert('导出成功', `与“${chat.name}”的聊天记录已开始下载！`);
}

/**
 * 【全新】导入聊天记录到当前角色
 */
async function importChatHistory(file) {
    if (!file) return;
    if (!state.activeChatId) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);

            // 关键验证：检查导入的文件是否包含一个名为 'history' 的数组
            if (!data.history || !Array.isArray(data.history)) {
                throw new Error("文件格式不正确，缺少有效的'history'数据。");
            }

            const chat = state.chats[state.activeChatId];
            
            // 安全警告：提醒用户这将覆盖现有记录
            const confirmed = await showCustomConfirm(
                '确认导入',
                `这将会【覆盖】你与“${chat.name}”的当前所有聊天记录。此操作无法撤销，确定要继续吗？`,
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                // 替换历史记录
                chat.history = data.history;
                // 保存到数据库
                await db.chats.put(chat);
                // 刷新界面
                renderChatInterface(state.activeChatId);
                renderChatList(); // 刷新列表以更新最后一条消息
                await showCustomAlert('导入成功', '聊天记录已成功导入并覆盖！');
            }
        } catch (error) {
            console.error("导入聊天记录失败:", error);
            await showCustomAlert('导入失败', `无法导入文件，请检查文件是否为正确的聊天记录备份文件。\n\n错误: ${error.message}`);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】气泡样式预设导入/导出功能 ▼▼▼

/**
 * 导出当前选中的气泡样式预设
 */
async function exportSelectedBubblePreset() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (!selectedId) {
        alert("请先从下拉框中选择一个要导出的预设。");
        return;
    }

    const preset = await db.bubbleStylePresets.get(selectedId);
    if (!preset) {
        alert("找不到选中的预设。");
        return;
    }

    // 准备要导出的数据
    const exportData = {
        presetName: preset.name,
        presetCss: preset.css
    };

    // 创建并触发下载
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[EPhone气泡]${preset.name}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * 处理导入的气泡样式预设文件
 * @param {File} file - 用户选择的.json文件
 */
function importBubblePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 验证文件内容是否正确
            if (data.presetName && typeof data.presetCss !== 'undefined') {
                const newPreset = {
                    name: `${data.presetName} (导入)`,
                    css: data.presetCss
                };
                const newId = await db.bubbleStylePresets.add(newPreset);

                if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
                state.bubbleStylePresets.push({ id: newId, ...newPreset });

                // 刷新下拉框并自动选中新导入的预设
                renderBubblePresetSelector();
                document.getElementById('bubble-style-preset-select').value = newId;
                handlePresetSelectChange();
                await showCustomAlert('导入成功', `气泡预设 "${newPreset.name}" 已成功导入！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这【一整块】代码，替换掉所有旧的、和微博相关的事件监听器 ▼▼▼

// ▼▼▼ 请用下面这【一整块】代码，完整替换掉上面那段旧代码 ▼▼▼
document.getElementById('weibo-app-icon').addEventListener('click', () => {
    renderWeiboProfile(); // 渲染个人资料
    renderMyWeiboFeed(); // <-- 就是新增了这一行！主动渲染“我的微博”列表
    switchToWeiboView('weibo-my-profile-view'); // 默认显示“我的微博”
    showScreen('weibo-screen');
});
// ▲▲▲ 替换结束 ▲▲▲


// 2. 绑定微博页面内的各种点击事件 (使用事件委托)
document.getElementById('weibo-screen').addEventListener('click', async (e) => {
    // --- 【全新】处理微博帖子中头像点击的逻辑 ---
    const avatarWrapper = e.target.closest('.weibo-post-avatar-clickable');
    if (avatarWrapper) {
        const charId = avatarWrapper.dataset.charId;
        // 如果点击的不是用户自己，就打开TA的主页
        if (charId && charId !== 'user') {
            openWeiboCharProfile(charId);
        }
        return; // 处理完就结束，不再执行后面的逻辑
    }
    
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    const target = e.target;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
            // ▼▼▼ 在 'const target = e.target;' 的下一行，粘贴下面这整块新代码 ▼▼▼

            // --- 【全新】处理热搜和广场帖子的删除按钮 ---
            const deleteBtn = target.closest('.weibo-post-delete-btn');
            if (deleteBtn) {
                const postItem = deleteBtn.closest('.weibo-post-item');
                if (postItem) {
                    // 先给用户一个确认的机会，防止误删
                    const confirmed = await showCustomConfirm(
                        '删除动态',
                        '确定要删除这条动态吗？（此操作仅在本页面生效）',
                        { confirmButtonClass: 'btn-danger' }
                    );
                    
                    if (confirmed) {
                        // 如果用户确认，就播放一个好看的消失动画，然后移除帖子
                        postItem.style.transition = 'opacity 0.3s, transform 0.3s';
                        postItem.style.opacity = '0';
                        postItem.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            postItem.remove();
                        }, 300); // 等动画播放完再彻底删除
                    }
                }
                return; // ★★★ 关键！处理完删除后，必须立刻结束，防止触发下面的其他点击事件
            }
            
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
// 【核心修复】处理微博中的“文字图”点击事件
if (target.classList.contains('weibo-post-image') && target.dataset.hiddenText) {
    showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
    return; // 处理完后，立刻退出，避免触发其他逻辑
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    const postItem = target.closest('.weibo-post-item');
    const postId = postItem ? parseInt(postItem.dataset.postId) : null;

    // --- 处理“删除评论”按钮 ---
    const deleteCommentBtn = target.closest('.comment-delete-btn');
    if (deleteCommentBtn) {
        const commentItem = deleteCommentBtn.closest('.weibo-comment-item');
        if (postId && commentItem && commentItem.dataset.commentId) {
            deleteWeiboComment(postId, commentItem.dataset.commentId);
        }
        return;
    }

    // --- 处理“生成评论”按钮 ---
    const generateBtn = target.closest('.generate-comments-btn');
    if (generateBtn) {
        if (postId) {
            generateWeiboComments(postId);
        }
        return; 
    }

    // --- 处理底部导航栏切换 ---
    const navItem = target.closest('.weibo-nav-item');
    if (navItem && navItem.dataset.view) {
        switchToWeiboView(navItem.dataset.view);
        return;
    }

// ▼▼▼ 用这块新代码替换 ▼▼▼

            const actionsBtn = target.closest('.post-actions-btn');
            if (actionsBtn) {
                // 核心修正1：从按钮本身获取正确的 postId
                const postId = parseInt(actionsBtn.dataset.postId);

                const confirmed = await showCustomConfirm('删除微博', '确定要永久删除这条微博吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
                
                // 核心修正2：检查 postId 是否是一个有效的数字
                if (confirmed && !isNaN(postId)) { 
                    await db.weiboPosts.delete(postId);
                    // 删除后，刷新所有相关的微博列表和个人资料
                    await renderMyWeiboFeed(); 
                    await renderFollowingWeiboFeed();
                    await renderWeiboProfile();
                    alert('微博已删除。');
                }
                return;
            }

// ▲▲▲ 替换结束 ▲▲▲

    
    // --- 处理点赞、评论、回复 ---
    if (target.closest('.like-btn')) { if (postId) handleWeiboLike(postId); return; }
    if (target.closest('.weibo-comment-send-btn')) { const input = postItem.querySelector('.weibo-comment-input'); if (postId && input) handleWeiboComment(postId, input); return; }
    
    const commentItem = target.closest('.weibo-comment-item');
    if (commentItem) {
        const commenterName = commentItem.dataset.commenterName;
        const commentId = commentItem.dataset.commentId;
        const input = postItem.querySelector('.weibo-comment-input');
        if (input.dataset.replyToId === commentId) {
            input.placeholder = '留下你的精彩评论吧...';
            delete input.dataset.replyToId; delete input.dataset.replyToNickname;
        } else {
            input.placeholder = `回复 @${commenterName}:`;
            input.dataset.replyToId = commentId; input.dataset.replyToNickname = commenterName;
            input.focus();
        }
        return;
    }
});

// 3. 【核心】为微博个人主页的所有可编辑元素，绑定专属的编辑函数
// ▼▼▼ 用这块【功能增强版】的代码，替换旧的 weibo-profile-page 事件监听器 ▼▼▼
document.getElementById('weibo-profile-page').addEventListener('click', async (e) => {
    const target = e.target;
    
    // --- ▼▼▼ 核心修改在这里 ▼▼▼ ---
    if (target.id === 'weibo-avatar-img' || target.closest('.weibo-avatar-container')) {
        // 1. 弹出一个选择菜单，让用户决定是换头像还是换框
        const choice = await showChoiceModal("编辑头像", [
            { text: '更换头像图片', value: 'avatar' },
            { text: '更换头像框', value: 'frame' }
        ]);
        
        // 2. 根据用户的选择，执行不同的操作
        if (choice === 'avatar') {
            editWeiboAvatar(); // 调用原来的更换头像函数
        } else if (choice === 'frame') {
            openFrameSelectorModal('weibo_profile'); // 调用我们新增的更换头像框函数
        }
        return; // 处理完后直接退出
    } 
    // --- ▲▲▲ 修改结束 ▲▲▲

    else if (target.id === 'weibo-nickname') {
        editWeiboNickname();
    } 
    else if (target.id === 'weibo-user-profession-display') {
        openWeiboUserSettingsModal();
    } 
    else if (target.id === 'weibo-background-img') {
        editWeiboBackground();
    } else if (target.closest('#weibo-fans-item')) {
        editWeiboFansCount();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 4. 【核心】为“关注”数字和“发布微博”按钮绑定事件
document.getElementById('weibo-following-btn').addEventListener('click', showFollowingList);
document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);
document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【已隐藏可见范围】的代码，替换旧的 openWeiboPublisherClean 函数 ▼▼▼
function openWeiboPublisherClean() {
    // 1. 重置并获取模态框
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“微博”模式，并修改标题和提示语
    modal.dataset.mode = 'weibo';
    document.getElementById('create-post-modal-title').textContent = '发微博';
    document.getElementById('post-public-text').placeholder = '有什么新鲜事想分享给大家？';

    // 3. 确保所有“动态”专属的HTML元素都被隐藏
    const imageDescGroup = document.getElementById('post-image-desc-group');
    if (imageDescGroup) imageDescGroup.style.display = 'none';
    
    const commentsToggleGroup = document.getElementById('post-comments-toggle-group');
    if (commentsToggleGroup) commentsToggleGroup.style.display = 'none';

    // ▼▼▼ 就是在这里新增了一行代码！▼▼▼
    const visibilityGroup = document.getElementById('post-visibility-group');
    if (visibilityGroup) visibilityGroup.style.display = 'none';
    // ▲▲▲ 新增结束 ▲▲▲

    // 4. 显示微博需要的控件
    const modeSwitcher = document.getElementById('post-mode-switcher');
    if (modeSwitcher) modeSwitcher.style.display = 'flex';
    
    // 5. 显示弹窗
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 用这块【已修复】的代码，完整替换掉你旧的 `editWeiboProfileBtn` 事件监听器 ▼▼▼
    // 【全新】微博用户人设设置功能事件绑定
    document.getElementById('edit-weibo-profile-btn').addEventListener('click', openWeiboUserSettingsModal);
    document.getElementById('cancel-weibo-user-settings-btn').addEventListener('click', () => {
        document.getElementById('weibo-user-settings-modal').classList.remove('visible');
    });
    document.getElementById('save-weibo-user-settings-btn').addEventListener('click', saveWeiboUserSettings);
    document.getElementById('weibo-user-preset-select').addEventListener('change', handleWeiboUserPresetSelection);
    document.getElementById('manage-weibo-user-presets-btn').addEventListener('click', openWeiboUserPresetManager);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 把这一整块全新的事件监听器代码，粘贴到 init() 函数的末尾，就在 init(); 的正上方 ▼▼▼

// --- 塔罗牌占卜功能事件绑定 ---
document.getElementById('open-tarot-btn').addEventListener('click', openTarotModal);
document.getElementById('close-tarot-modal-btn').addEventListener('click', () => {
    document.getElementById('tarot-divination-modal').classList.remove('visible');
});
document.getElementById('draw-tarot-cards-btn').addEventListener('click', handleDrawCards);
document.getElementById('back-to-tarot-setup-btn').addEventListener('click', () => {
    document.getElementById('tarot-result-view').style.display = 'none';
    document.getElementById('tarot-setup-view').style.display = 'block';
});
document.getElementById('send-tarot-result-btn').addEventListener('click', sendTarotReadingToChat);
document.getElementById('tarot-history-btn').addEventListener('click', openTarotHistory);
document.getElementById('back-to-tarot-main-btn').addEventListener('click', () => {
    document.getElementById('tarot-history-view').style.display = 'none';
    document.getElementById('tarot-setup-view').style.display = 'block';
});
// 使用事件委托处理历史记录的删除按钮
document.getElementById('tarot-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('tarot-history-delete-btn')) {
        const readingId = parseInt(e.target.dataset.id);
        if (!isNaN(readingId)) {
            deleteTarotReading(readingId);
        }
    }
});

// --- 塔罗牌占卜功能事件绑定结束 ---

// ▼▼▼ 八卦六爻占卜功能事件绑定 ▼▼▼
document.getElementById('open-bagua-btn').addEventListener('click', openBaguaModal);
document.getElementById('close-bagua-modal-btn').addEventListener('click', () => {
    document.getElementById('bagua-divination-modal').classList.remove('visible');
});
document.getElementById('start-bagua-btn').addEventListener('click', startBaguaDivination);
document.getElementById('back-to-bagua-setup-btn').addEventListener('click', () => {
    document.getElementById('bagua-result-view').style.display = 'none';
    document.getElementById('bagua-setup-view').style.display = 'block';
});
document.getElementById('send-bagua-result-btn').addEventListener('click', sendBaguaReadingToChat);
document.getElementById('bagua-history-btn').addEventListener('click', openBaguaHistory);
document.getElementById('back-to-bagua-main-btn').addEventListener('click', () => {
    document.getElementById('bagua-history-view').style.display = 'none';
    document.getElementById('bagua-setup-view').style.display = 'block';
});
// 使用事件委托处理历史记录的删除按钮
document.getElementById('bagua-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('bagua-history-delete-btn')) {
        const readingId = parseInt(e.target.dataset.id);
        if (!isNaN(readingId)) {
            deleteBaguaReading(readingId);
        }
    }
});
// --- 八卦六爻占卜功能事件绑定结束 ---

// 1. 初始化时创建默认小组
await initializeDefaultGroups();
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 【全新】情侣空间功能事件监听器 ▼▼▼

// ▼▼▼ 【全新】这是主屏幕滑动分页的JS逻辑 ▼▼▼
function initHomeScreenSlider() {
    const slider = document.querySelector('.home-screen-slider');
    const dots = document.querySelectorAll('.pagination-dots .dot');

    if (!slider || dots.length === 0) return;

    // 页面状态管理
    let currentPage = 0; // 当前页码
    let isScrolling = false; // 滚动锁，防止快速连续滑动
    let scrollTimeout = null;
    let touchStartX = 0;
    let touchStartY = 0;
    let isDragging = false;

    // 获取总页数
    function getTotalPages() {
        return slider.querySelectorAll('.home-page').length;
    }

    // 滚动到指定页面
    function scrollToPage(pageIndex, smooth = true) {
        const totalPages = getTotalPages();
        
        // 确保页码在有效范围内
        if (pageIndex < 0 || pageIndex >= totalPages) return;
        
        // 检查是否跳页（只允许移动到相邻页面）
        if (Math.abs(pageIndex - currentPage) > 1) {
            console.log(`阻止跳页：从第${currentPage + 1}页跳到第${pageIndex + 1}页`);
            // 如果尝试跳页，只移动到相邻页面
            pageIndex = pageIndex > currentPage ? currentPage + 1 : currentPage - 1;
        }
        
        isScrolling = true;
        currentPage = pageIndex;
        
        slider.scrollTo({
            left: slider.clientWidth * pageIndex,
            behavior: smooth ? 'smooth' : 'auto'
        });
        
        // 更新小圆点状态
        updateDots();
        
        // 解锁滚动
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            isScrolling = false;
        }, 500); // 500ms后解锁
    }

    // 更新小圆点状态
    function updateDots() {
        dots.forEach((dot, index) => {
            dot.classList.toggle('active', index === currentPage);
        });
    }

    // 监听滚动结束事件，确保页面对齐
    slider.addEventListener('scroll', () => {
        if (isScrolling) return; // 如果是程序控制的滚动，跳过
        
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            // 计算实际停留的页码
            const actualPage = Math.round(slider.scrollLeft / slider.clientWidth);
            
            // 检查是否跳页
            if (Math.abs(actualPage - currentPage) > 1) {
                console.log(`检测到跳页：从第${currentPage + 1}页到第${actualPage + 1}页，强制回到相邻页`);
                // 强制回到相邻页面
                const targetPage = actualPage > currentPage ? currentPage + 1 : currentPage - 1;
                scrollToPage(targetPage, true);
            } else if (actualPage !== currentPage) {
                // 正常的相邻页切换
                currentPage = actualPage;
                updateDots();
            }
        }, 150); // 滚动停止150ms后检查
    });

    // 移动端触摸控制
    slider.addEventListener('touchstart', (e) => {
        if (isScrolling) {
            e.preventDefault();
            return;
        }
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        isDragging = true;
    }, { passive: false });

    slider.addEventListener('touchmove', (e) => {
        if (!isDragging || isScrolling) return;
        
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const deltaX = touchX - touchStartX;
        const deltaY = touchY - touchStartY;
        
        // 判断是水平滑动还是垂直滑动
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            // 水平滑动，阻止页面内滚动
            e.preventDefault();
        }
    }, { passive: false });

    slider.addEventListener('touchend', (e) => {
        if (!isDragging || isScrolling) return;
        
        const touchEndX = e.changedTouches[0].clientX;
        const deltaX = touchEndX - touchStartX;
        const swipeThreshold = 50; // 滑动阈值
        
        // 判断滑动方向
        if (Math.abs(deltaX) > swipeThreshold) {
            if (deltaX > 0 && currentPage > 0) {
                // 向右滑动，去上一页
                scrollToPage(currentPage - 1);
            } else if (deltaX < 0 && currentPage < getTotalPages() - 1) {
                // 向左滑动，去下一页
                scrollToPage(currentPage + 1);
            } else {
                // 回弹到当前页
                scrollToPage(currentPage);
            }
        } else {
            // 滑动距离不够，回弹到当前页
            scrollToPage(currentPage);
        }
        
        isDragging = false;
    });

    // 初始化小圆点
    updateDots();
    
    // 暴露scrollToPage方法供外部使用
    slider.scrollToPage = scrollToPage;
    slider.getCurrentPage = () => currentPage;
}
// ▲▲▲ 新增JS逻辑结束 ▲▲▲
initHomeScreenSlider(); // 初始化主屏幕滑动功能

// ▼▼▼ 【全新】主屏幕页面管理功能 ▼▼▼
// 页面管理功能：增删主屏幕页面
function initHomePageManager() {
    // 获取DOM元素
    const slider = document.querySelector('.home-screen-slider');
    const paginationDots = document.querySelector('.pagination-dots');
    const pageListContainer = document.getElementById('home-page-list');
    const addPageBtn = document.getElementById('add-home-page-btn');
    const deleteSelectedBtn = document.getElementById('delete-selected-pages-btn');
    
    if (!slider || !paginationDots || !pageListContainer) return;
    
    // 从localStorage加载自定义页面数据
    function loadCustomPages() {
        const saved = localStorage.getItem('homeCustomPages');
        return saved ? JSON.parse(saved) : [];
    }
    
    // 保存自定义页面数据到localStorage
    function saveCustomPages(pages) {
        localStorage.setItem('homeCustomPages', JSON.stringify(pages));
    }
    
    // 渲染页面列表
    function renderPageList() {
        const homePages = slider.querySelectorAll('.home-page');
        const customPages = loadCustomPages();
        
        pageListContainer.innerHTML = '';
        
        homePages.forEach((page, index) => {
            const isDefault = index < 3; // 前三页是默认页面
            const pageItem = document.createElement('div');
            pageItem.className = 'home-page-item' + (isDefault ? ' default-page' : '');
            
            pageItem.innerHTML = `
                <input type="checkbox" class="home-page-checkbox" data-index="${index}" ${isDefault ? 'disabled' : ''}>
                <div class="home-page-info">
                    <span class="home-page-number">页面 ${index + 1}</span>
                    <span class="home-page-badge ${isDefault ? 'default' : 'custom'}">
                        ${isDefault ? '默认' : '自定义'}
                    </span>
                </div>
            `;
            
            pageListContainer.appendChild(pageItem);
        });
    }
    
    // 更新分页点
    function updatePaginationDots() {
        const homePages = slider.querySelectorAll('.home-page');
        const currentIndex = Math.round(slider.scrollLeft / slider.clientWidth);
        
        paginationDots.innerHTML = '';
        
        homePages.forEach((_, index) => {
            const dot = document.createElement('span');
            dot.className = 'dot' + (index === currentIndex ? ' active' : '');
            paginationDots.appendChild(dot);
        });
        
        // 重新初始化滑动监听
        initHomeScreenSlider();
    }
    
    // 添加新页面
    function addNewPage() {
        const newPage = document.createElement('div');
        newPage.className = 'home-page';
        // 完全空白的页面，不显示任何内容
        
        slider.appendChild(newPage);
        
        // 保存到localStorage
        const customPages = loadCustomPages();
        customPages.push({ id: Date.now(), created: new Date().toISOString() });
        saveCustomPages(customPages);
        
        // 更新UI
        updatePaginationDots();
        renderPageList();
        
        // 滚动到新页面
        setTimeout(() => {
            const pageCount = slider.querySelectorAll('.home-page').length;
            slider.scrollLeft = slider.clientWidth * (pageCount - 1);
        }, 100);
        
        alert(`已添加页面 ${slider.querySelectorAll('.home-page').length}`);
    }
    
    // 删除选中的页面
    function deleteSelectedPages() {
        const checkboxes = pageListContainer.querySelectorAll('.home-page-checkbox:checked:not([disabled])');
        
        if (checkboxes.length === 0) {
            alert('请选择要删除的页面！');
            return;
        }
        
        if (!confirm(`确定要删除选中的 ${checkboxes.length} 个页面吗？`)) {
            return;
        }
        
        // 获取要删除的索引（从大到小排序，避免删除时索引错乱）
        const indicesToDelete = Array.from(checkboxes)
            .map(cb => parseInt(cb.dataset.index))
            .sort((a, b) => b - a);
        
        // 删除页面
        const homePages = slider.querySelectorAll('.home-page');
        indicesToDelete.forEach(index => {
            if (index >= 3 && homePages[index]) { // 确保不删除前三页
                homePages[index].remove();
            }
        });
        
        // 更新localStorage
        const customPages = loadCustomPages();
        const remainingCount = slider.querySelectorAll('.home-page').length - 3;
        saveCustomPages(customPages.slice(0, remainingCount));
        
        // 更新UI
        updatePaginationDots();
        renderPageList();
        
        // 如果当前页被删除，返回第一页
        if (slider.scrollLeft >= slider.scrollWidth - slider.clientWidth) {
            slider.scrollLeft = 0;
        }
        
        alert(`已删除 ${indicesToDelete.length} 个页面`);
    }
    
    // 全选/取消全选功能
    pageListContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('home-page-checkbox')) {
            // 可以添加全选逻辑
        }
    });
    
    // 绑定按钮事件
    addPageBtn.addEventListener('click', addNewPage);
    deleteSelectedBtn.addEventListener('click', deleteSelectedPages);
    
    // 初始化时加载自定义页面
    const customPages = loadCustomPages();
    customPages.forEach(() => {
        const newPage = document.createElement('div');
        newPage.className = 'home-page';
        // 完全空白的页面，不显示任何内容
        slider.appendChild(newPage);
    });
    
    // 初始化页面列表和分页点
    updatePaginationDots();
    renderPageList();
}

// 初始化页面管理功能
initHomePageManager();
// ▲▲▲ 页面管理功能结束 ▲▲▲

// ▼▼▼ 在这里粘贴新代码 ▼▼▼
// 监听主屏幕图标和小组件颜色选择器的实时变化
document.getElementById('home-icon-widget-text-color-picker').addEventListener('input', (e) => {
    applyHomeIconWidgetTextColor(e.target.value);
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 【全新】主屏幕字体阴影开关的实时预览事件
document.getElementById('remove-home-font-shadow-toggle').addEventListener('change', (e) => {
    document.getElementById('phone-screen').classList.toggle('no-home-font-shadow', e.target.checked);
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲




// ▲▲▲ 新增事件监听结束 ▲▲▲

// ▼▼▼ 【全新】钱包功能 ▼▼▼

// 打开钱包模态框
function openWalletModal() {
    updateWalletDisplay();
    document.getElementById('wallet-modal').classList.add('visible');
}

// 更新钱包余额显示
function updateWalletDisplay() {
    const balance = state.globalSettings.userBalance || 0;
    document.getElementById('wallet-balance-display').textContent = `¥ ${balance.toFixed(2)}`;
    
    // 同步更新桃宝的余额显示
    const taobaoBalanceEl = document.getElementById('user-balance-display');
    if (taobaoBalanceEl) {
        taobaoBalanceEl.textContent = `¥ ${balance.toFixed(2)}`;
    }
}

// 修改余额功能 - 直接调用桃宝的handleModifyBalance
async function modifyWalletBalance() {
    // 调用桃宝已有的余额修改函数，这样会正确记录交易并同步所有显示
    if (typeof handleModifyBalance === 'function') {
        await handleModifyBalance();
        // 确保钱包显示也更新了
        updateWalletDisplay();
    } else {
        alert('余额修改功能未加载，请确保桃宝模块已正确加载。');
    }
}

// 亲属卡功能（占位）
function openFamilyCard() {
    alert('亲属卡功能正在开发中...\n\n您可以在这里设置亲属卡，让亲人也能使用您的余额！');
}

// 钱包功能事件监听器
document.getElementById('wallet-action-btn').addEventListener('click', openWalletModal);
document.getElementById('wallet-modal-close-btn').addEventListener('click', () => {
    document.getElementById('wallet-modal').classList.remove('visible');
});
document.getElementById('wallet-modify-balance-btn').addEventListener('click', modifyWalletBalance);
document.getElementById('wallet-family-card-btn').addEventListener('click', openFamilyCard);

// ▲▲▲ 钱包功能结束 ▲▲▲

// ▼▼▼ 【全新】记账功能 ▼▼▼

// 默认分类数据
const DEFAULT_ACCOUNTING_CATEGORIES = {
    expense: [
        { name: '餐饮', emoji: '🍔', isCustom: false },
        { name: '交通', emoji: '🚗', isCustom: false },
        { name: '购物', emoji: '🛍️', isCustom: false },
        { name: '娱乐', emoji: '🎬', isCustom: false },
        { name: '医疗', emoji: '💊', isCustom: false },
        { name: '住房', emoji: '🏠', isCustom: false },
        { name: '通讯', emoji: '📱', isCustom: false },
        { name: '其他', emoji: '💰', isCustom: false }
    ],
    income: [
        { name: '工资', emoji: '💼', isCustom: false },
        { name: '奖金', emoji: '🎁', isCustom: false },
        { name: '兼职', emoji: '💻', isCustom: false },
        { name: '投资', emoji: '📈', isCustom: false },
        { name: '红包', emoji: '🧧', isCustom: false },
        { name: '其他', emoji: '💰', isCustom: false }
    ]
};

// 全局状态
let currentAccountingType = 'expense'; // 'expense' 或 'income'
let selectedCategory = null;
let currentTimeFilter = 'all';

// 初始化默认分类到数据库
async function initDefaultCategories() {
    const existingCategories = await db.accountingCategories.toArray();
    if (existingCategories.length === 0) {
        const categories = [];
        for (const type of ['expense', 'income']) {
            for (const cat of DEFAULT_ACCOUNTING_CATEGORIES[type]) {
                categories.push({
                    name: cat.name,
                    emoji: cat.emoji,
                    type: type,
                    isCustom: cat.isCustom
                });
            }
        }
        await db.accountingCategories.bulkAdd(categories);
    }
}

// 打开记账模态框
async function openAccountingModal() {
    await initDefaultCategories();
    document.getElementById('accounting-modal').classList.add('visible');
    
    // 重置表单
    currentAccountingType = 'expense';
    document.getElementById('accounting-amount').value = '';
    document.getElementById('accounting-note').value = '';
    document.getElementById('accounting-date').valueAsDate = new Date();
    
    // 【优化】从localStorage读取用户上次的开关设置，默认为true
    const savedNotifyCharState = localStorage.getItem('accountingNotifyChar');
    document.getElementById('notify-char-toggle').checked = savedNotifyCharState !== null ? savedNotifyCharState === 'true' : true;
    
    selectedCategory = null;
    
    // 切换到记一笔面板
    switchAccountingTab('record');
    
    // 渲染分类
    await renderAccountingCategories();
}

// Tab切换
function switchAccountingTab(tab) {
    // 更新tab样式
    document.querySelectorAll('.accounting-tab').forEach(t => {
        t.classList.remove('active');
        t.style.borderBottom = 'none';
        t.style.color = '#666';
    });
    const activeTab = document.querySelector(`.accounting-tab[data-tab="${tab}"]`);
    activeTab.classList.add('active');
    activeTab.style.borderBottom = '3px solid #667eea';
    activeTab.style.color = '#667eea';
    
    // 显示对应面板
    document.querySelectorAll('.accounting-panel').forEach(p => p.style.display = 'none');
    const panel = document.getElementById(`accounting-${tab}-panel`);
    panel.style.display = 'flex';
    panel.style.flexDirection = 'column';
    
    // 如果切换到账单面板，加载记录
    if (tab === 'list') {
        loadAccountingRecords();
    } else if (tab === 'goals') {
        loadFinancialGoals();
    }
}

// 切换支出/收入类型
function switchAccountingType(type) {
    currentAccountingType = type;
    selectedCategory = null;
    
    // 更新按钮样式
    document.querySelectorAll('.accounting-type-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.type === 'expense') {
            btn.style.background = 'white';
            btn.style.color = '#ff6b6b';
        } else {
            btn.style.background = 'white';
            btn.style.color = '#51cf66';
        }
    });
    
    const activeBtn = document.querySelector(`.accounting-type-btn[data-type="${type}"]`);
    activeBtn.classList.add('active');
    if (type === 'expense') {
        activeBtn.style.background = '#ff6b6b';
        activeBtn.style.color = 'white';
    } else {
        activeBtn.style.background = '#51cf66';
        activeBtn.style.color = 'white';
    }
    
    // 重新渲染分类
    renderAccountingCategories();
}

// 渲染分类按钮
async function renderAccountingCategories() {
    const container = document.getElementById('accounting-categories');
    container.innerHTML = '';
    
    const categories = await db.accountingCategories
        .where('type').equals(currentAccountingType)
        .toArray();
    
    categories.forEach(cat => {
        const btn = document.createElement('div');
        btn.style.cssText = `
            padding: 15px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        `;
        btn.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 5px;">${cat.emoji}</div>
            <div style="font-size: 12px; color: #666;">${cat.name}</div>
        `;
        btn.onclick = () => selectCategory(cat, btn);
        
        // 如果是自定义分类，添加删除按钮
        if (cat.isCustom) {
            const deleteBtn = document.createElement('span');
            deleteBtn.innerHTML = '×';
            deleteBtn.style.cssText = `
                position: absolute;
                top: -5px;
                right: -5px;
                width: 20px;
                height: 20px;
                background: #ff3b30;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                cursor: pointer;
            `;
            deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                if (confirm(`确定删除分类"${cat.name}"吗？`)) {
                    await db.accountingCategories.delete(cat.id);
                    renderAccountingCategories();
                }
            };
            btn.style.position = 'relative';
            btn.appendChild(deleteBtn);
        }
        
        container.appendChild(btn);
    });
}

// 选择分类
function selectCategory(cat, btnElement) {
    // 清除之前的选中状态
    document.querySelectorAll('#accounting-categories > div').forEach(b => {
        b.style.borderColor = '#e0e0e0';
        b.style.background = 'white';
    });
    
    // 设置当前选中
    selectedCategory = cat;
    btnElement.style.borderColor = currentAccountingType === 'expense' ? '#ff6b6b' : '#51cf66';
    btnElement.style.background = currentAccountingType === 'expense' ? '#fff5f5' : '#f0fdf4';
}

// 添加自定义分类
async function addCustomCategory() {
    const name = prompt(`请输入${currentAccountingType === 'expense' ? '支出' : '收入'}分类名称：`);
    if (!name || !name.trim()) return;
    
    const emoji = prompt('请输入一个emoji表情（可选）：') || '📝';
    
    await db.accountingCategories.add({
        name: name.trim(),
        emoji: emoji,
        type: currentAccountingType,
        isCustom: true
    });
    
    await renderAccountingCategories();
}

// 保存记账记录
async function saveAccountingRecord() {
    const amount = parseFloat(document.getElementById('accounting-amount').value);
    const note = document.getElementById('accounting-note').value.trim();
    const date = new Date(document.getElementById('accounting-date').value);
    const notifyChar = document.getElementById('notify-char-toggle').checked;
    
    if (!amount || amount <= 0) {
        alert('请输入有效的金额');
        return;
    }
    
    if (!selectedCategory) {
        alert('请选择分类');
        return;
    }
    
    // 保存到数据库
    const record = {
        type: currentAccountingType,
        amount: amount,
        category: selectedCategory.name,
        categoryEmoji: selectedCategory.emoji,
        note: note,
        timestamp: date.getTime(),
        notifyChar: notifyChar,
        chatId: notifyChar ? state.activeChatId : null
    };
    
    // 先保存记录，获取生成的ID
    const recordId = await db.accountingRecords.add(record);
    
    // 只有开启通知角色时，才在聊天记录中显示记账通知
    if (state.activeChatId && notifyChar) {
        const chat = state.chats[state.activeChatId];
        const typeText = currentAccountingType === 'expense' ? '支出' : '收入';
        const now = new Date(date.getTime());
        const dateTimeStr = `${now.getMonth() + 1}月${now.getDate()}日 ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        
        // 1. 创建可见的灰色系统通知（用户可以看到）
        const visibleMessage = {
            role: 'system',
            type: 'accounting',
            content: `📊 记账通知：${typeText} ${currentAccountingType === 'expense' ? '-' : '+'}¥${amount.toFixed(2)}\n🏷️ ${selectedCategory.emoji} ${selectedCategory.name} · ${dateTimeStr}${note ? '\n📝 ' + note : ''}`,
            timestamp: Date.now(),
            recordId: recordId  // 【新增】记录ID，方便删除时查找
        };
        chat.history.push(visibleMessage);
        
        // 立即显示在聊天界面
        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chat.id;
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
        
        // 2. 创建给AI看的详细信息（隐藏消息）
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚记了一笔${typeText}账单]
📅 时间：${dateTimeStr}
💰 金额：${currentAccountingType === 'expense' ? '-' : '+'}¥${amount.toFixed(2)}
🏷️ 分类：${selectedCategory.emoji} ${selectedCategory.name}${note ? `\n📝 备注：${note}` : ''}

这是用户的生活记账，你可以关心一下或者给出建议。`,
            timestamp: Date.now() + 1,
            isHidden: true,
            recordId: recordId  // 【新增】记录ID，方便删除时查找
        };
        chat.history.push(hiddenMessage);
        
        await db.chats.put(chat);
        
        // 触发自动回复
        if (typeof autoReply === 'function') {
            await autoReply();
        }
    }
    
    // 检查是否超支
    await checkBudgetAlert(record);
    
    alert('记账成功！');
    
    // 清空表单
    document.getElementById('accounting-amount').value = '';
    document.getElementById('accounting-note').value = '';
    selectedCategory = null;
    await renderAccountingCategories();
}

// 加载记账记录
async function loadAccountingRecords() {
    let records = await db.accountingRecords.reverse().sortBy('timestamp');
    
    // 应用时间筛选
    if (currentTimeFilter !== 'all') {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        
        records = records.filter(r => {
            const recordDate = new Date(r.timestamp);
            if (currentTimeFilter === 'today') {
                return recordDate >= today;
            } else if (currentTimeFilter === 'week') {
                const weekStart = new Date(today);
                weekStart.setDate(today.getDate() - today.getDay());
                return recordDate >= weekStart;
            } else if (currentTimeFilter === 'month') {
                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                return recordDate >= monthStart;
            }
            return true;
        });
    }
    
    // 计算总支出和总收入
    const totalExpense = records
        .filter(r => r.type === 'expense')
        .reduce((sum, r) => sum + r.amount, 0);
    const totalIncome = records
        .filter(r => r.type === 'income')
        .reduce((sum, r) => sum + r.amount, 0);
    
    document.getElementById('total-expense-display').textContent = `¥ ${totalExpense.toFixed(2)}`;
    document.getElementById('total-income-display').textContent = `¥ ${totalIncome.toFixed(2)}`;
    
    // 渲染记录列表
    const container = document.getElementById('accounting-records-list');
    container.innerHTML = '';
    
    if (records.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">暂无记录</div>';
        return;
    }
    
    records.forEach(record => {
        const div = document.createElement('div');
        const date = new Date(record.timestamp);
        const dateStr = `${date.getMonth() + 1}月${date.getDate()}日 ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        
        div.style.cssText = `
            display: flex;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        `;
        
        div.innerHTML = `
            <div style="font-size: 28px; margin-right: 15px;">${record.categoryEmoji}</div>
            <div style="flex: 1;">
                <div style="font-size: 15px; font-weight: 500; margin-bottom: 3px;">${record.category}</div>
                <div style="font-size: 12px; color: #999;">${dateStr}${record.note ? ` · ${record.note}` : ''}</div>
            </div>
            <div style="font-size: 18px; font-weight: 600; color: ${record.type === 'expense' ? '#ff6b6b' : '#51cf66'};">
                ${record.type === 'expense' ? '-' : '+'}¥${record.amount.toFixed(2)}
            </div>
            <button class="delete-record-btn" data-id="${record.id}" style="margin-left: 10px; padding: 5px 10px; background: #ff3b30; color: white; border: none; border-radius: 5px; cursor: pointer;">删除</button>
        `;
        
        container.appendChild(div);
    });
    
    // 绑定删除按钮事件
    document.querySelectorAll('.delete-record-btn').forEach(btn => {
        btn.onclick = async () => {
            if (confirm('确定删除这条记录吗？')) {
                const recordId = parseInt(btn.dataset.id);
                
                // 1. 获取要删除的记录信息
                const record = await db.accountingRecords.get(recordId);
                
                // 2. 如果记录关联了聊天，删除聊天记录中的相关消息
                if (record && record.chatId) {
                    // 从数据库重新加载chat对象，确保数据是最新的
                    const chat = await db.chats.get(record.chatId);
                    
                    if (chat) {
                        // 过滤掉所有recordId匹配的消息（包括可见消息和隐藏消息）
                        const originalLength = chat.history.length;
                        chat.history = chat.history.filter(msg => msg.recordId !== recordId);
                        
                        // 只有在确实删除了消息时才保存
                        if (chat.history.length < originalLength) {
                            // 保存到数据库
                            await db.chats.put(chat);
                            
                            // 同步更新内存中的chat对象
                            state.chats[record.chatId] = chat;
                            
                            // 如果当前正在查看这个聊天，立即刷新显示
                            if (state.activeChatId === record.chatId && 
                                document.getElementById('chat-interface-screen').classList.contains('active')) {
                                renderChatInterface(record.chatId);
                            }
                        }
                    }
                }
                
                // 3. 删除账单记录本身
                await db.accountingRecords.delete(recordId);
                
                // 4. 刷新账单列表
                loadAccountingRecords();
            }
        };
    });
}

// 时间筛选
function filterRecordsByTime(filter) {
    currentTimeFilter = filter;
    
    // 更新按钮样式
    document.querySelectorAll('.time-filter-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'white';
        btn.style.color = '#666';
    });
    
    const activeBtn = document.querySelector(`.time-filter-btn[data-filter="${filter}"]`);
    activeBtn.classList.add('active');
    activeBtn.style.background = '#667eea';
    activeBtn.style.color = 'white';
    
    loadAccountingRecords();
}

// 保存财务目标
async function saveFinancialGoal() {
    const period = document.getElementById('goal-period').value;
    const expenseLimit = parseFloat(document.getElementById('goal-expense-limit').value) || null;
    const incomeTarget = parseFloat(document.getElementById('goal-income-target').value) || null;
    const reminder = document.getElementById('goal-reminder-toggle').checked;
    
    let startDate, endDate;
    
    if (period === 'custom') {
        startDate = new Date(document.getElementById('goal-start-date').value).getTime();
        endDate = new Date(document.getElementById('goal-end-date').value).getTime();
        if (!startDate || !endDate || startDate >= endDate) {
            alert('请选择有效的日期范围');
            return;
        }
    } else {
        const now = new Date();
        if (period === 'daily') {
            startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            endDate = startDate + 24 * 60 * 60 * 1000;
        } else if (period === 'weekly') {
            const day = now.getDay();
            startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - day).getTime();
            endDate = startDate + 7 * 24 * 60 * 60 * 1000;
        } else if (period === 'monthly') {
            startDate = new Date(now.getFullYear(), now.getMonth(), 1).getTime();
            endDate = new Date(now.getFullYear(), now.getMonth() + 1, 1).getTime();
        }
    }
    
    if (!expenseLimit && !incomeTarget) {
        alert('请至少设置一个目标');
        return;
    }
    
    await db.accountingGoals.add({
        period: period,
        startDate: startDate,
        endDate: endDate,
        expenseLimit: expenseLimit,
        incomeTarget: incomeTarget,
        reminder: reminder,
        createdAt: Date.now()
    });
    
    // 【新增】在聊天记录中添加系统消息，通知CHAR用户设置了财务目标
    if (state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        const periodText = {
            'daily': '每日',
            'weekly': '每周',
            'monthly': '每月',
            'custom': '自定义'
        }[period];
        
        const startDateStr = new Date(startDate).toLocaleDateString('zh-CN');
        const endDateStr = new Date(endDate).toLocaleDateString('zh-CN');
        
        let goalDescription = `🎯 财务目标设置通知\n\n用户设置了${periodText}财务目标：\n`;
        goalDescription += `📅 时间范围：${startDateStr} 至 ${endDateStr}\n`;
        
        if (expenseLimit) {
            goalDescription += `💵 支出限额：¥${expenseLimit.toFixed(2)}\n`;
        }
        if (incomeTarget) {
            goalDescription += `💰 收入目标：¥${incomeTarget.toFixed(2)}\n`;
        }
        if (reminder) {
            goalDescription += `⏰ 已开启预算提醒\n`;
        }
        
        goalDescription += `\n💡 你可以在用户消费时关注TA是否超支，必要时给予提醒和建议！`;
        
        // 创建系统消息（隐藏消息，只给AI看）
        const systemMessage = {
            role: 'system',
            content: goalDescription,
            timestamp: Date.now(),
            isHidden: true
        };
        
        chat.history.push(systemMessage);
        await db.chats.put(chat);
    }
    
    alert('财务目标已保存！');
    loadFinancialGoals();
}

// 加载财务目标
async function loadFinancialGoals() {
    const goals = await db.accountingGoals.reverse().sortBy('createdAt');
    const container = document.getElementById('goals-list');
    container.innerHTML = '';
    
    if (goals.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">暂无财务目标</div>';
        return;
    }
    
    const now = Date.now();
    
    for (const goal of goals) {
        // 计算目标期间的实际支出和收入
        const records = await db.accountingRecords
            .where('timestamp')
            .between(goal.startDate, goal.endDate)
            .toArray();
        
        const actualExpense = records
            .filter(r => r.type === 'expense')
            .reduce((sum, r) => sum + r.amount, 0);
        const actualIncome = records
            .filter(r => r.type === 'income')
            .reduce((sum, r) => sum + r.amount, 0);
        
        const isActive = now >= goal.startDate && now < goal.endDate;
        const periodText = {
            'daily': '每日',
            'weekly': '每周',
            'monthly': '每月',
            'custom': '自定义'
        }[goal.period];
        
        const div = document.createElement('div');
        div.style.cssText = `
            padding: 15px;
            background: ${isActive ? '#f0f9ff' : '#f8f9fa'};
            border: 2px solid ${isActive ? '#667eea' : '#e0e0e0'};
            border-radius: 10px;
            margin-bottom: 10px;
        `;
        
        let content = `<div style="font-weight: 600; margin-bottom: 10px; color: ${isActive ? '#667eea' : '#666'};">${periodText}目标 ${isActive ? '(进行中)' : '(已结束)'}</div>`;
        
        if (goal.expenseLimit) {
            const percent = (actualExpense / goal.expenseLimit * 100).toFixed(1);
            const color = percent > 100 ? '#ff3b30' : percent > 80 ? '#ff9500' : '#34c759';
            content += `
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">支出：¥${actualExpense.toFixed(2)} / ¥${goal.expenseLimit.toFixed(2)}</div>
                    <div style="height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${Math.min(percent, 100)}%; height: 100%; background: ${color};"></div>
                    </div>
                    <div style="font-size: 12px; color: ${color}; margin-top: 3px;">${percent}%</div>
                </div>
            `;
        }
        
        if (goal.incomeTarget) {
            const percent = (actualIncome / goal.incomeTarget * 100).toFixed(1);
            const color = percent >= 100 ? '#34c759' : percent >= 80 ? '#ff9500' : '#999';
            content += `
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">收入：¥${actualIncome.toFixed(2)} / ¥${goal.incomeTarget.toFixed(2)}</div>
                    <div style="height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${Math.min(percent, 100)}%; height: 100%; background: ${color};"></div>
                    </div>
                    <div style="font-size: 12px; color: ${color}; margin-top: 3px;">${percent}%</div>
                </div>
            `;
        }
        
        content += `<button class="delete-goal-btn" data-id="${goal.id}" style="padding: 5px 15px; background: #ff3b30; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">删除目标</button>`;
        
        div.innerHTML = content;
        container.appendChild(div);
    }
    
    // 绑定删除按钮事件
    document.querySelectorAll('.delete-goal-btn').forEach(btn => {
        btn.onclick = async () => {
            if (confirm('确定删除这个财务目标吗？')) {
                await db.accountingGoals.delete(parseInt(btn.dataset.id));
                loadFinancialGoals();
            }
        };
    });
}

// 检查预算提醒
async function checkBudgetAlert(newRecord) {
    if (newRecord.type !== 'expense') return;
    
    // 【关键修改】如果用户关闭了通知角色，则不进行任何预算检查和通知
    // 这样角色完全不知道记账和预算的存在
    if (newRecord.notifyChar !== true) return;
    
    // 获取所有有支出限额的活跃目标（不管是否开启提醒）
    const activeGoals = await db.accountingGoals
        .filter(g => g.expenseLimit && Date.now() >= g.startDate && Date.now() < g.endDate)
        .toArray();
    
    for (const goal of activeGoals) {
        const records = await db.accountingRecords
            .where('timestamp')
            .between(goal.startDate, goal.endDate)
            .toArray();
        
        // 【关键修改】只统计开启了通知角色的支出记录
        const totalExpense = records
            .filter(r => r.type === 'expense' && r.notifyChar === true)
            .reduce((sum, r) => sum + r.amount, 0);
        
        const percent = (totalExpense / goal.expenseLimit) * 100;
        
        const periodText = {
            'daily': '每日',
            'weekly': '每周',
            'monthly': '每月',
            'custom': '自定义'
        }[goal.period] || '当前';
        
        // 超出预算时，必定弹窗提醒
        if (percent >= 100) {
            alert(`🚨 预算超支警告！\n\n您的${periodText}支出已超过预算限额！\n\n💰 已支出：¥${totalExpense.toFixed(2)}\n📊 预算额度：¥${goal.expenseLimit.toFixed(2)}\n⚠️ 超支金额：¥${(totalExpense - goal.expenseLimit).toFixed(2)}\n\n建议控制支出，注意财务健康！`);
            
            // 【新增】在聊天记录中添加隐藏消息，通知CHAR用户超支了
            if (state.activeChatId) {
                const chat = state.chats[state.activeChatId];
                const alertMessage = {
                    role: 'system',
                    content: `⚠️ 预算超支提醒！\n\n用户的${periodText}支出已超过预算限额！\n💰 已支出：¥${totalExpense.toFixed(2)}\n📊 预算额度：¥${goal.expenseLimit.toFixed(2)}\n⚠️ 超支金额：¥${(totalExpense - goal.expenseLimit).toFixed(2)}\n超支比例：${percent.toFixed(1)}%\n\n💡 建议：你可以关心一下用户的财务状况，提醒TA注意控制支出，避免过度消费。`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(alertMessage);
                await db.chats.put(chat);
            }
        } 
        // 如果开启了提醒，在达到80%时也提醒
        else if (goal.reminder && percent >= 80) {
            alert(`⚡ 预算提醒\n\n您的${periodText}支出已达预算的 ${percent.toFixed(1)}%\n\n💰 已支出：¥${totalExpense.toFixed(2)}\n📊 预算额度：¥${goal.expenseLimit.toFixed(2)}\n💵 剩余额度：¥${(goal.expenseLimit - totalExpense).toFixed(2)}\n\n请注意控制开支哦！`);
            
            // 【新增】在聊天记录中添加隐藏消息，通知CHAR预算接近上限
            if (state.activeChatId) {
                const chat = state.chats[state.activeChatId];
                const alertMessage = {
                    role: 'system',
                    content: `⚡ 预算提醒\n\n用户的${periodText}支出已达预算的 ${percent.toFixed(1)}%\n💰 已支出：¥${totalExpense.toFixed(2)}\n📊 预算额度：¥${goal.expenseLimit.toFixed(2)}\n💵 剩余额度：¥${(goal.expenseLimit - totalExpense).toFixed(2)}\n\n💡 建议：你可以温馨提醒用户注意控制开支，避免超支。`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(alertMessage);
                await db.chats.put(chat);
            }
        }
    }
}

// 记账功能事件监听器
document.getElementById('accounting-action-btn').addEventListener('click', openAccountingModal);
document.getElementById('accounting-modal-close-btn').addEventListener('click', () => {
    document.getElementById('accounting-modal').classList.remove('visible');
});

// Tab切换事件
document.querySelectorAll('.accounting-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        switchAccountingTab(tab.dataset.tab);
    });
});

// 支出/收入类型切换事件
document.getElementById('expense-tab-btn').addEventListener('click', () => switchAccountingType('expense'));
document.getElementById('income-tab-btn').addEventListener('click', () => switchAccountingType('income'));

// 添加自定义分类事件
document.getElementById('add-category-btn').addEventListener('click', addCustomCategory);

// 保存记账记录事件
document.getElementById('save-accounting-btn').addEventListener('click', saveAccountingRecord);

// 【优化】监听"通知当前角色"开关的变化，实时保存到localStorage
document.getElementById('notify-char-toggle').addEventListener('change', (e) => {
    localStorage.setItem('accountingNotifyChar', e.target.checked.toString());
});

// 时间筛选事件
document.querySelectorAll('.time-filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        filterRecordsByTime(btn.dataset.filter);
    });
});

// 财务目标周期选择事件
document.getElementById('goal-period').addEventListener('change', (e) => {
    document.getElementById('custom-period-inputs').style.display = 
        e.target.value === 'custom' ? 'block' : 'none';
});

// 保存财务目标事件
document.getElementById('save-goal-btn').addEventListener('click', saveFinancialGoal);

// 获取用户账单摘要（供CHAR查看）
async function getAccountingSummaryForChar(chatId, daysBack = 30) {
    const now = Date.now();
    const startTime = now - (daysBack * 24 * 60 * 60 * 1000);
    
    // 获取最近指定天数的记录
    const allRecords = await db.accountingRecords
        .where('timestamp')
        .above(startTime)
        .reverse()
        .sortBy('timestamp');
    
    // 过滤出与当前聊天相关的记录（或所有记录）
    const records = chatId ? allRecords.filter(r => r.chatId === chatId || !r.chatId) : allRecords;
    
    // 【关键修改】只保留用户允许通知角色的记录（notifyChar === true）
    // 这样关闭通知后，角色完全看不到该记账记录
    const notifiableRecords = records.filter(r => r.notifyChar === true);
    
    if (notifiableRecords.length === 0) {
        return null;  // 没有可通知角色的记录，返回null，角色完全看不到记账信息
    }
    
    // 计算统计数据（只统计允许通知角色的记录）
    const expenses = notifiableRecords.filter(r => r.type === 'expense');
    const incomes = notifiableRecords.filter(r => r.type === 'income');
    const totalExpense = expenses.reduce((sum, r) => sum + r.amount, 0);
    const totalIncome = incomes.reduce((sum, r) => sum + r.amount, 0);
    
    // 分类统计
    const categoryStats = {};
    expenses.forEach(r => {
        if (!categoryStats[r.category]) {
            categoryStats[r.category] = { emoji: r.categoryEmoji, amount: 0, count: 0 };
        }
        categoryStats[r.category].amount += r.amount;
        categoryStats[r.category].count++;
    });
    
    // 构建摘要文本
    let summary = `\n═══════════════════════════\n📊 用户账单摘要（最近${daysBack}天）\n═══════════════════════════\n\n`;
    summary += `💵 总支出：¥${totalExpense.toFixed(2)} (${expenses.length}笔)\n`;
    summary += `💰 总收入：¥${totalIncome.toFixed(2)} (${incomes.length}笔)\n`;
    summary += `📈 收支差：${totalIncome >= totalExpense ? '+' : ''}¥${(totalIncome - totalExpense).toFixed(2)}\n\n`;
    
    // 支出分类统计
    if (Object.keys(categoryStats).length > 0) {
        summary += `📋 支出分类明细：\n`;
        const sortedCategories = Object.entries(categoryStats).sort((a, b) => b[1].amount - a[1].amount);
        sortedCategories.forEach(([cat, data]) => {
            const percent = (data.amount / totalExpense * 100).toFixed(1);
            summary += `  ${data.emoji} ${cat}：¥${data.amount.toFixed(2)} (${data.count}笔, ${percent}%)\n`;
        });
        summary += '\n';
    }
    
    // 【新增】获取活跃的财务目标
    const activeGoals = await db.accountingGoals
        .filter(g => now >= g.startDate && now < g.endDate)
        .toArray();
    
    if (activeGoals.length > 0) {
        summary += `🎯 当前财务目标\n`;
        summary += `═══════════════════════════\n`;
        
        for (const goal of activeGoals) {
            // 计算目标期间的实际支出和收入（只统计允许通知角色的记录）
            const goalRecords = await db.accountingRecords
                .where('timestamp')
                .between(goal.startDate, goal.endDate)
                .toArray();
            
            // 只统计notifyChar为true的记录
            const goalExpense = goalRecords
                .filter(r => r.type === 'expense' && r.notifyChar === true)
                .reduce((sum, r) => sum + r.amount, 0);
            const goalIncome = goalRecords
                .filter(r => r.type === 'income' && r.notifyChar === true)
                .reduce((sum, r) => sum + r.amount, 0);
            
            const periodText = {
                'daily': '每日',
                'weekly': '每周',
                'monthly': '每月',
                'custom': '自定义'
            }[goal.period];
            
            summary += `\n📅 ${periodText}目标：\n`;
            
            // 支出目标
            if (goal.expenseLimit) {
                const expensePercent = (goalExpense / goal.expenseLimit * 100).toFixed(1);
                const remaining = goal.expenseLimit - goalExpense;
                const status = goalExpense > goal.expenseLimit ? '⚠️ 已超支' : 
                              goalExpense > goal.expenseLimit * 0.8 ? '⚡ 接近上限' : 
                              '✅ 正常';
                summary += `  💵 支出限额：¥${goal.expenseLimit.toFixed(2)}\n`;
                summary += `     实际支出：¥${goalExpense.toFixed(2)} (${expensePercent}%)\n`;
                summary += `     剩余额度：¥${remaining.toFixed(2)}\n`;
                summary += `     状态：${status}\n`;
            }
            
            // 收入目标
            if (goal.incomeTarget) {
                const incomePercent = (goalIncome / goal.incomeTarget * 100).toFixed(1);
                const remaining = goal.incomeTarget - goalIncome;
                const status = goalIncome >= goal.incomeTarget ? '🎉 已完成' : 
                              goalIncome >= goal.incomeTarget * 0.8 ? '💪 接近目标' : 
                              '📈 努力中';
                summary += `  💰 收入目标：¥${goal.incomeTarget.toFixed(2)}\n`;
                summary += `     实际收入：¥${goalIncome.toFixed(2)} (${incomePercent}%)\n`;
                summary += `     还需赚取：¥${remaining > 0 ? remaining.toFixed(2) : '0.00'}\n`;
                summary += `     状态：${status}\n`;
            }
        }
        summary += '\n';
    }
    
    // 最近的10笔记录（只显示允许通知角色的记录）
    summary += `📝 最近记录（最多显示10笔）：\n`;
    const recentRecords = notifiableRecords.slice(0, 10);
    recentRecords.forEach((r, idx) => {
        const date = new Date(r.timestamp);
        const dateStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        const sign = r.type === 'expense' ? '-' : '+';
        summary += `  ${idx + 1}. ${dateStr} ${r.categoryEmoji} ${r.category} ${sign}¥${r.amount.toFixed(2)}`;
        if (r.note) summary += ` (${r.note})`;
        summary += '\n';
    });
    
    summary += `\n═══════════════════════════\n💡 提示：你可以根据用户的消费习惯、财务状况和目标完成情况给出关心或建议\n`;
    if (activeGoals.length > 0) {
        summary += `💡 用户设置了财务目标，你可以鼓励TA坚持，或在超支时提醒TA注意控制支出\n`;
    }
    summary += `═══════════════════════════\n`;
    
    return summary;
}

// 在全局暴露，供消息处理使用
window.getAccountingSummaryForChar = getAccountingSummaryForChar;

// ▲▲▲ 记账功能结束 ▲▲▲

// ▼▼▼ 月经追踪功能开始 ▼▼▼

// 当前查看的月份
let currentViewYear = new Date().getFullYear();
let currentViewMonth = new Date().getMonth();

// 打开月经追踪模态框
document.getElementById('period-tracker-btn').addEventListener('click', async () => {
    document.getElementById('period-tracker-modal').classList.add('visible');
    // 默认显示日历面板
    switchPeriodTab('calendar');
    // 加载设置并渲染日历
    await loadPeriodSettings();
    renderPeriodCalendar();
});

// 关闭月经追踪模态框
document.getElementById('period-modal-close-btn').addEventListener('click', () => {
    document.getElementById('period-tracker-modal').classList.remove('visible');
});

// Tab切换功能
document.querySelectorAll('.period-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        switchPeriodTab(tab.dataset.tab);
    });
});

function switchPeriodTab(tabName) {
    // 更新Tab样式
    document.querySelectorAll('.period-tab').forEach(t => {
        t.classList.remove('active');
        t.style.borderBottom = 'none';
        t.style.color = '#666';
    });
    const activeTab = document.querySelector(`.period-tab[data-tab="${tabName}"]`);
    activeTab.classList.add('active');
    activeTab.style.borderBottom = '3px solid #ff6b9d';
    activeTab.style.color = '#ff6b9d';
    
    // 切换面板
    document.querySelectorAll('.period-panel').forEach(p => p.style.display = 'none');
    document.getElementById(`period-${tabName}-panel`).style.display = 'block';
    
    // 根据不同tab加载相应内容
    if (tabName === 'calendar') {
        renderPeriodCalendar();
    } else if (tabName === 'settings') {
        loadPeriodSettings();
    } else if (tabName === 'stats') {
        loadPeriodStats();
    }
}

// 月份导航
document.getElementById('prev-month-btn').addEventListener('click', () => {
    currentViewMonth--;
    if (currentViewMonth < 0) {
        currentViewMonth = 11;
        currentViewYear--;
    }
    renderPeriodCalendar();
});

document.getElementById('next-month-btn').addEventListener('click', () => {
    currentViewMonth++;
    if (currentViewMonth > 11) {
        currentViewMonth = 0;
        currentViewYear++;
    }
    renderPeriodCalendar();
});

// 渲染日历
async function renderPeriodCalendar() {
    const year = currentViewYear;
    const month = currentViewMonth;
    
    // 更新月份显示
    document.getElementById('current-month-display').textContent = `${year}年${month + 1}月`;
    
    // 获取当月第一天和最后一天
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startWeekday = firstDay.getDay(); // 0=周日, 1=周一...
    
    // 获取月经设置
    const settings = await db.periodSettings.get('default');
    
    // 获取手动标记
    const marks = await db.periodMarks.toArray();
    const marksMap = {};
    marks.forEach(m => {
        marksMap[m.date] = m.dayNumber;
    });
    
    // 计算预测的经期日期
    const predictedDates = [];
    if (settings && settings.lastPeriodStart && settings.cycle) {
        const lastStart = new Date(settings.lastPeriodStart);
        const cycleMs = settings.cycle * 24 * 60 * 60 * 1000;
        const duration = settings.duration || 7;
        
        // 预测未来3个月的经期
        for (let i = 0; i < 3; i++) {
            const nextStart = new Date(lastStart.getTime() + cycleMs * (i + 1));
            for (let d = 0; d < duration; d++) {
                const date = new Date(nextStart);
                date.setDate(date.getDate() + d);
                const dateStr = formatDateToYYYYMMDD(date);
                predictedDates.push(dateStr);
            }
        }
    }
    
    // 渲染日历格子
    const grid = document.getElementById('calendar-grid');
    grid.innerHTML = '';
    
    // 填充空白格子（本月第一天之前）
    for (let i = 0; i < startWeekday; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.style.cssText = 'aspect-ratio: 1; background: transparent;';
        grid.appendChild(emptyCell);
    }
    
    // 渲染本月的每一天
    for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        const dateStr = formatDateToYYYYMMDD(date);
        const isToday = dateStr === formatDateToYYYYMMDD(new Date());
        
        const cell = document.createElement('div');
        cell.style.cssText = `
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            background: white;
            border: 2px solid transparent;
        `;
        
        // 判断是否在经期（根据设置自动标记）
        const isPeriodDay = settings && isInPeriod(date, settings);
        
        // 判断是否有手动标记
        const manualMark = marksMap[dateStr];
        
        // 判断是否为预测日期
        const isPredicted = predictedDates.includes(dateStr);
        
        // 设置背景色
        if (manualMark) {
            // 手动标记优先级最高
            cell.style.background = 'white';
            cell.style.border = '2px solid #ff6b9d';
        } else if (isPeriodDay) {
            // 经期日（根据设置）
            cell.style.background = 'linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%)';
            cell.style.color = 'white';
        } else if (isPredicted) {
            // 预测经期
            cell.style.background = '#e3f2fd';
        }
        
        // 今天加特殊边框
        if (isToday && !manualMark) {
            cell.style.border = '2px solid #4CAF50';
        }
        
        // 日期数字
        const dayNum = document.createElement('div');
        dayNum.textContent = day;
        dayNum.style.cssText = `font-size: 14px; font-weight: ${isToday ? 'bold' : '500'};`;
        cell.appendChild(dayNum);
        
        // 如果有手动标记，显示第几天
        if (manualMark) {
            const markLabel = document.createElement('div');
            markLabel.textContent = manualMark;
            markLabel.style.cssText = 'font-size: 10px; font-weight: bold; color: #ff6b9d; margin-top: 2px;';
            cell.appendChild(markLabel);
        }
        
        // 点击事件：手动标记或取消标记
        cell.addEventListener('click', () => {
            togglePeriodMark(dateStr);
        });
        
        grid.appendChild(cell);
    }
}

// 判断某个日期是否在经期内（基于设置）
function isInPeriod(date, settings) {
    if (!settings || !settings.lastPeriodStart) return false;
    
    const lastStart = new Date(settings.lastPeriodStart);
    const duration = settings.duration || 7;
    const cycle = settings.cycle || 28;
    
    // 计算从上次经期开始到当前日期的天数
    const daysDiff = Math.floor((date - lastStart) / (24 * 60 * 60 * 1000));
    
    if (daysDiff < 0) return false; // 日期在上次经期之前
    
    // 判断是否在某个周期的经期内
    const dayInCycle = daysDiff % cycle;
    return dayInCycle < duration;
}

// 切换手动标记
async function togglePeriodMark(dateStr) {
    const existingMark = await db.periodMarks.where('date').equals(dateStr).first();
    
    if (existingMark) {
        // 如果已有标记，删除
        await db.periodMarks.delete(existingMark.id);
    } else {
        // 否则添加标记，弹窗询问第几天
        const dayNumber = prompt('请输入这是经期的第几天（1-10）：');
        if (dayNumber && parseInt(dayNumber) > 0 && parseInt(dayNumber) <= 10) {
            await db.periodMarks.add({
                date: dateStr,
                dayNumber: parseInt(dayNumber),
                timestamp: Date.now()
            });
        } else if (dayNumber !== null) {
            alert('请输入有效的天数（1-10）');
            return;
        } else {
            return; // 用户取消
        }
    }
    
    // 重新渲染日历
    renderPeriodCalendar();
    // 更新统计
    loadPeriodStats();
}

// 加载经期设置
async function loadPeriodSettings() {
    const settings = await db.periodSettings.get('default');
    
    if (settings) {
        document.getElementById('last-period-start').value = settings.lastPeriodStart || '';
        document.getElementById('period-duration').value = settings.duration || 7;
        document.getElementById('period-cycle').value = settings.cycle || 28;
        document.getElementById('notify-char-period-toggle').checked = settings.notifyChar !== false;
        
        // 更新当前设置显示
        const infoContent = document.getElementById('period-info-content');
        infoContent.innerHTML = `
            <p>上次经期开始：${settings.lastPeriodStart || '未设置'}</p>
            <p>经期持续天数：${settings.duration || 7}天</p>
            <p>经期周期：${settings.cycle || 28}天</p>
            <p>通知角色：${settings.notifyChar !== false ? '已开启' : '已关闭'}</p>
        `;
    } else {
        document.getElementById('period-info-content').textContent = '暂无设置';
    }
}

// 保存经期设置
document.getElementById('save-period-settings-btn').addEventListener('click', async () => {
    const lastPeriodStart = document.getElementById('last-period-start').value;
    const duration = parseInt(document.getElementById('period-duration').value);
    const cycle = parseInt(document.getElementById('period-cycle').value);
    const notifyChar = document.getElementById('notify-char-period-toggle').checked;
    
    if (!lastPeriodStart) {
        alert('请选择上次经期开始日期');
        return;
    }
    
    if (duration < 1 || duration > 10) {
        alert('经期持续天数请设置在1-10天之间');
        return;
    }
    
    if (cycle < 21 || cycle > 35) {
        alert('经期周期请设置在21-35天之间');
        return;
    }
    
    await db.periodSettings.put({
        id: 'default',
        lastPeriodStart,
        duration,
        cycle,
        notifyChar
    });
    
    alert('保存成功！');
    loadPeriodSettings();
    renderPeriodCalendar();
    loadPeriodStats();
});

// 加载统计数据
async function loadPeriodStats() {
    const settings = await db.periodSettings.get('default');
    const marks = await db.periodMarks.orderBy('timestamp').reverse().toArray();
    
    // 显示平均周期和持续天数（目前基于设置）
    if (settings) {
        document.getElementById('avg-cycle-display').textContent = `${settings.cycle || '--'} 天`;
        document.getElementById('avg-duration-display').textContent = `${settings.duration || '--'} 天`;
        
        // 计算下次预测
        if (settings.lastPeriodStart && settings.cycle) {
            const lastStart = new Date(settings.lastPeriodStart);
            const nextStart = new Date(lastStart);
            nextStart.setDate(nextStart.getDate() + settings.cycle);
            
            const today = new Date();
            const daysUntil = Math.ceil((nextStart - today) / (24 * 60 * 60 * 1000));
            
            document.getElementById('next-period-prediction').innerHTML = `
                预计下次经期开始日期：<strong>${formatDateToYYYYMMDD(nextStart)}</strong><br>
                距今还有 <strong>${daysUntil}</strong> 天
            `;
        } else {
            document.getElementById('next-period-prediction').textContent = '请先在"经期设置"中设置您的经期信息';
        }
    }
    
    // 显示手动标记历史
    const historyDiv = document.getElementById('period-marks-history');
    if (marks.length === 0) {
        historyDiv.innerHTML = '<p style="font-size: 14px; color: #999; text-align: center; padding: 20px;">暂无标记记录</p>';
    } else {
        historyDiv.innerHTML = marks.map(m => `
            <div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong style="color: #333;">${m.date}</strong>
                    <span style="color: #999; margin-left: 10px;">第${m.dayNumber}天</span>
                </div>
                <button onclick="deletePeriodMark(${m.id})" style="padding: 5px 10px; background: #ff6b9d; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">删除</button>
            </div>
        `).join('');
    }
}

// 删除手动标记
async function deletePeriodMark(id) {
    if (confirm('确定要删除这条标记吗？')) {
        await db.periodMarks.delete(id);
        renderPeriodCalendar();
        loadPeriodStats();
    }
}

// 工具函数：格式化日期为 YYYY-MM-DD
function formatDateToYYYYMMDD(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// 获取经期信息（供CHAR查询）- 完整版本
async function getPeriodInfoForChar() {
    const settings = await db.periodSettings.get('default');
    const marks = await db.periodMarks.orderBy('timestamp').reverse().toArray();
    
    // 如果没有任何设置和标记，返回空
    if ((!settings || !settings.lastPeriodStart) && marks.length === 0) {
        return null; // 用户还没有使用月经追踪功能
    }
    
    // 如果用户关闭了通知功能
    if (settings && settings.notifyChar === false) {
        return null; // 用户已关闭月经追踪通知功能
    }
    
    let info = `════════════════════════════\n`;
    info += `📅 【用户的月经追踪数据】\n`;
    info += `════════════════════════════\n\n`;
    
    // 1. 基本设置信息
    if (settings && settings.lastPeriodStart) {
        const cycle = settings.cycle || 28;
        const duration = settings.duration || 7;
        
        info += `📋 基本设置：\n`;
        info += `  • 上次经期开始：${settings.lastPeriodStart}\n`;
        info += `  • 经期周期：${cycle}天\n`;
        info += `  • 经期持续：${duration}天\n`;
        info += `  • 平均周期：${cycle}天\n`;
        info += `  • 平均持续：${duration}天\n\n`;
        
        // 2. 当前状态判断
        const lastStart = new Date(settings.lastPeriodStart);
        const today = new Date();
        const daysSinceLast = Math.floor((today - lastStart) / (24 * 60 * 60 * 1000));
        const dayInCycle = daysSinceLast % cycle;
        const isInPeriod = dayInCycle < duration;
        
        info += `🔴 当前状态：\n`;
        if (isInPeriod) {
            const periodDay = dayInCycle + 1;
            info += `  ⚠️ 用户正处于经期中，今天是第${periodDay}天\n`;
            info += `  💡 建议：多关心、理解用户，提醒她注意休息、保暖，避免剧烈运动\n\n`;
        } else {
            info += `  ✅ 用户当前不在经期\n\n`;
        }
        
        // 3. 下次经期预测
        const nextStart = new Date(lastStart);
        nextStart.setDate(nextStart.getDate() + cycle);
        const daysUntilNext = Math.ceil((nextStart - today) / (24 * 60 * 60 * 1000));
        
        info += `🔮 下次经期预测：\n`;
        info += `  • 预计开始日期：${formatDateToYYYYMMDD(nextStart)}\n`;
        info += `  • 距今还有：${daysUntilNext}天\n`;
        info += `  • 预计结束日期：${formatDateToYYYYMMDD(new Date(nextStart.getTime() + (duration - 1) * 24 * 60 * 60 * 1000))}\n\n`;
    } else {
        info += `📋 基本设置：用户尚未设置经期周期等基本信息\n\n`;
    }
    
    // 4. 手动标记历史记录
    info += `📝 手动标记记录（最近10条）：\n`;
    if (marks.length === 0) {
        info += `  • 暂无手动标记记录\n\n`;
    } else {
        const recentMarks = marks.slice(0, 10); // 只显示最近10条
        recentMarks.forEach(mark => {
            info += `  • ${mark.date} - 经期第${mark.dayNumber}天\n`;
        });
        if (marks.length > 10) {
            info += `  （共${marks.length}条记录，仅显示最近10条）\n`;
        }
        info += `\n`;
    }
    
    // 5. 经期统计分析
    if (marks.length >= 2) {
        info += `📊 经期统计分析：\n`;
        info += `  • 总标记次数：${marks.length}次\n`;
        
        // 找出所有标记为"第1天"的日期
        const firstDayMarks = marks.filter(m => m.dayNumber === 1);
        if (firstDayMarks.length >= 2) {
            const cycles = [];
            for (let i = 0; i < firstDayMarks.length - 1; i++) {
                const date1 = new Date(firstDayMarks[i + 1].date);
                const date2 = new Date(firstDayMarks[i].date);
                const diff = Math.floor((date2 - date1) / (24 * 60 * 60 * 1000));
                if (diff > 0 && diff < 60) { // 合理范围内的周期
                    cycles.push(diff);
                }
            }
            if (cycles.length > 0) {
                const avgCycle = Math.round(cycles.reduce((a, b) => a + b, 0) / cycles.length);
                info += `  • 根据标记计算的平均周期：约${avgCycle}天\n`;
            }
        }
        
        // 最近一次标记
        const latestMark = marks[0];
        info += `  • 最近一次标记：${latestMark.date}（第${latestMark.dayNumber}天）\n`;
        info += `\n`;
    }
    
    info += `════════════════════════════\n`;
    info += `💝 提示：这些都是用户在月经追踪功能中记录的私密信息，\n`;
    info += `请根据这些数据适当关心用户，但不要过度提及。\n`;
    info += `如果用户处于经期，可以更温柔、体贴地回应。\n`;
    info += `════════════════════════════\n`;
    
    return info;
}

// 在全局暴露，供消息处理使用
window.getPeriodInfoForChar = getPeriodInfoForChar;

// ▲▲▲ 月经追踪功能结束 ▲▲▲

// ▼▼▼ 学习功能开始 ▼▼▼

// 全局变量
let currentStudySubject = null;
let currentStudySession = {
    questions: [],
    currentIndex: 0,
    answers: [],
    startTime: 0,
    timerInterval: null,
    mode: 'practice', // 'practice' or 'exam'
    subjectName: ''
};

// 初始化
(async function initStudyFeature() {
    // 延迟初始化，确保DB已就绪
    setTimeout(async () => {
        await checkAndInitDefaultBanks();
        updateStudyStatsDisplay();
    }, 1000);
    
    // 绑定按钮事件
    const studyBtn = document.getElementById('study-btn');
    if(studyBtn) studyBtn.addEventListener('click', openStudyModal);
    
    const closeBtn = document.getElementById('study-modal-close-btn');
    if(closeBtn) closeBtn.addEventListener('click', () => {
        document.getElementById('study-modal').classList.remove('visible');
        stopStudyTimer();
    });
    
    // Tabs
    document.querySelectorAll('.study-tab').forEach(tab => {
        tab.addEventListener('click', () => switchStudyTab(tab.dataset.tab));
    });

    // Start Buttons
    const startPracBtn = document.getElementById('start-practice-btn');
    if(startPracBtn) startPracBtn.addEventListener('click', () => startStudySession('practice'));
    
    const startExamBtn = document.getElementById('start-exam-btn');
    if(startExamBtn) startExamBtn.addEventListener('click', () => startStudySession('exam'));
    
    // Navigation
    const submitBtn = document.getElementById('submit-answer-btn');
    if(submitBtn) submitBtn.addEventListener('click', checkAnswer);
    
    const nextBtn = document.getElementById('next-question-btn');
    if(nextBtn) nextBtn.addEventListener('click', nextQuestion);
    
    const quitBtn = document.getElementById('quit-practice-btn');
    if(quitBtn) quitBtn.addEventListener('click', quitStudySession);
    
    // Exam Navigation
    const examNext = document.getElementById('exam-next-btn');
    if(examNext) examNext.addEventListener('click', nextQuestion);
    
    const examPrev = document.getElementById('exam-prev-btn');
    if(examPrev) examPrev.addEventListener('click', prevQuestion);
    
    const examSubmit = document.getElementById('exam-submit-paper-btn');
    if(examSubmit) examSubmit.addEventListener('click', finishExam);
    
    const examBack = document.getElementById('exam-back-btn');
    if(examBack) examBack.addEventListener('click', () => {
         document.getElementById('exam-result-view').style.display = 'none';
         document.getElementById('exam-setup-view').style.display = 'block';
         switchStudyTab('exam');
    });

    // Import
    const importBtn = document.getElementById('import-bank-btn');
    if(importBtn) importBtn.addEventListener('click', () => document.getElementById('bank-file-input').click());
    
    const fileInput = document.getElementById('bank-file-input');
    if(fileInput) fileInput.addEventListener('change', handleBankImport);

    // Ask CHAR
    const askBtn = document.getElementById('study-ask-char-btn');
    if(askBtn) askBtn.addEventListener('click', askCharForStudyHelp);
    
    // Goals
    const saveGoalsBtn = document.getElementById('save-goals-btn');
    if(saveGoalsBtn) saveGoalsBtn.addEventListener('click', saveStudyGoals);
    
    // Refresh Question Banks
    const refreshBanksBtn = document.getElementById('refresh-question-banks-btn');
    if(refreshBanksBtn) refreshBanksBtn.addEventListener('click', handleRefreshQuestionBanks);

    // Canvas
    setupCanvas('question-canvas', 'canvas-color', 'clear-canvas-btn');
    setupCanvas('exam-question-canvas', 'exam-canvas-color', 'exam-clear-canvas-btn');

    // Expose for Context
    window.getStudyInfoForChar = getStudyInfoForChar;
})();

// 初始化默认题库
async function checkAndInitDefaultBanks() {
    const count = await db.studySubjects.count();
    if (count === 0) {
        console.log('Initializing default question banks...');
        const subjects = [
            { name: '高等数学', category: 'university', isDefault: 1 },
            { name: '大学英语', category: 'university', isDefault: 1 },
            { name: '线性代数', category: 'university', isDefault: 1 },
            { name: '大学物理', category: 'university', isDefault: 1 },
            { name: '计算机基础', category: 'university', isDefault: 1 },
            { name: '雅思英语', category: 'exam', isDefault: 1 },
            { name: 'CET-4', category: 'exam', isDefault: 1 },
            { name: 'CET-6', category: 'exam', isDefault: 1 },
            { name: 'HSK中文', category: 'exam', isDefault: 1 }
        ];
        
        for (const sub of subjects) {
            const id = await db.studySubjects.add(sub);
            // Add some sample questions
            await addSampleQuestions(id, sub.name);
        }
    }
}

async function addSampleQuestions(subjectId, name) {
    // 使用 generateQuestionsForSubject 函数生成初始题目
    const questions = generateQuestionsForSubject(subjectId, name, 20);
    
    for (const q of questions) {
        await db.questionBanks.add(q);
    }
}

// 刷新题库按钮处理函数
async function handleRefreshQuestionBanks() {
    const btn = document.getElementById('refresh-question-banks-btn');
    if (!btn) return;
    
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg> 刷新中...';
    
    try {
        const subjects = await db.studySubjects.toArray();
        let totalAdded = 0;
        
        for (const subject of subjects) {
            const existingCount = await db.questionBanks.where('subjectId').equals(subject.id).count();
            
            if (existingCount < 300) {
                const needCount = 300 - existingCount;
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg> 正在为【${subject.name}】生成题目...`;
                
                const questions = generateQuestionsForSubject(subject.id, subject.name, needCount);
                for (const q of questions) {
                    await db.questionBanks.add(q);
                }
                totalAdded += needCount;
            }
        }
        
        btn.innerHTML = originalText;
        btn.disabled = false;
        
        if (totalAdded > 0) {
            alert(`✅ 题库刷新完成！\n\n共新增 ${totalAdded} 道题目。\n现在您可以开始练习或考试了！`);
        } else {
            alert('✅ 所有科目题库均已充足（≥300题），无需补充！');
        }
        
        loadBanksList();
    } catch (error) {
        console.error('刷新题库失败:', error);
        btn.innerHTML = originalText;
        btn.disabled = false;
        alert('❌ 刷新题库时发生错误，请重试！');
    }
}

// 为指定科目生成题目
function generateQuestionsForSubject(subjectId, subjectName, count) {
    const questions = [];
    
    // 真实题库模板
    const questionBank = {
        '高等数学': {
            single: [
                { content: '求极限 lim(x→0) (sin x)/x = ?', options: ['0', '1', '∞', '不存在'], answer: '1', explanation: '这是重要极限之一，lim(x→0) (sin x)/x = 1' },
                { content: '函数 f(x) = x² 在 x = 2 处的导数是多少？', options: ['2', '4', '2x', 'x²'], answer: '4', explanation: 'f\'(x) = 2x，当 x=2 时，f\'(2) = 4' },
                { content: '∫x dx = ?', options: ['x²', 'x²/2 + C', 'x + C', '2x + C'], answer: 'x²/2 + C', explanation: '幂函数积分公式：∫x^n dx = x^(n+1)/(n+1) + C' },
                { content: '下列函数中，哪个是奇函数？', options: ['f(x) = x²', 'f(x) = x³', 'f(x) = |x|', 'f(x) = x² + 1'], answer: 'f(x) = x³', explanation: '奇函数满足 f(-x) = -f(x)，只有 x³ 满足' },
                { content: 'd(e^x)/dx = ?', options: ['e^x', 'xe^(x-1)', '1/e^x', 'ln x'], answer: 'e^x', explanation: '指数函数 e^x 的导数是它本身' },
                { content: '∫(1/x) dx = ?', options: ['ln|x| + C', 'x + C', '1/x² + C', 'e^x + C'], answer: 'ln|x| + C', explanation: '1/x 的不定积分是自然对数函数' },
                { content: '若函数 f(x) 在点 x₀ 处可导，则 f(x) 在 x₀ 处必定：', options: ['连续', '可微', '可积', '以上都对'], answer: '连续', explanation: '可导必连续，但连续不一定可导' },
                { content: 'lim(x→∞) (1 + 1/x)^x = ?', options: ['1', 'e', '∞', '0'], answer: 'e', explanation: '这是自然对数 e 的定义式' },
                { content: '函数 y = ln x 的定义域是？', options: ['(-∞, +∞)', '(0, +∞)', '[0, +∞)', '(-∞, 0)'], answer: '(0, +∞)', explanation: '对数函数要求真数大于 0' },
                { content: 'd(sin x)/dx = ?', options: ['cos x', '-cos x', 'sin x', '-sin x'], answer: 'cos x', explanation: '正弦函数的导数是余弦函数' },
            ],
            judge: [
                { content: '连续函数一定可导', answer: '错误', explanation: '连续不一定可导，如 f(x)=|x| 在 x=0 处连续但不可导' },
                { content: '可导函数一定连续', answer: '正确', explanation: '这是微分学的基本定理' },
                { content: '两个无穷小量的商仍是无穷小量', answer: '错误', explanation: '两个无穷小量的商可能是任意值，如 lim(x→0) x/x² = ∞' },
                { content: '定积分的值与积分变量的字母无关', answer: '正确', explanation: '∫[a,b] f(x)dx = ∫[a,b] f(t)dt，积分变量是哑变量' },
                { content: 'e^(ln x) = x 对所有实数 x 成立', answer: '错误', explanation: '只对 x > 0 成立，因为 ln x 的定义域是 (0, +∞)' },
            ]
        },
        '线性代数': {
            single: [
                { content: '矩阵 A = [[1,2],[3,4]] 的行列式 det(A) = ?', options: ['-2', '2', '10', '0'], answer: '-2', explanation: 'det(A) = 1×4 - 2×3 = -2' },
                { content: '设 A 是 n 阶方阵，则 |kA| = ?', options: ['k|A|', 'k^n|A|', 'k^2|A|', '|A|'], answer: 'k^n|A|', explanation: '数乘矩阵的行列式等于该数的 n 次方乘以原行列式' },
                { content: '零向量与任意向量的内积等于？', options: ['0', '1', '该向量的模', '不确定'], answer: '0', explanation: '零向量与任何向量的内积都是 0' },
                { content: '矩阵的秩 rank(A) 最大不超过？', options: ['行数', '列数', 'min(行数,列数)', 'max(行数,列数)'], answer: 'min(行数,列数)', explanation: '秩不能超过行数和列数中的较小值' },
                { content: 'n 维向量组的极大线性无关组的个数？', options: ['唯一', '不唯一', '不存在', '无穷多个'], answer: '不唯一', explanation: '极大线性无关组不唯一，但个数（秩）唯一' },
            ],
            judge: [
                { content: '可逆矩阵的行列式不为零', answer: '正确', explanation: '矩阵可逆的充要条件是其行列式不为零' },
                { content: '对称矩阵的特征值都是实数', answer: '正确', explanation: '实对称矩阵的特征值必为实数' },
                { content: 'AB = BA 对所有矩阵成立', answer: '错误', explanation: '矩阵乘法一般不满足交换律' },
                { content: '单位矩阵的行列式为 1', answer: '正确', explanation: '单位矩阵的行列式等于 1' },
            ]
        },
        '大学英语': {
            single: [
                { content: 'Choose the correct form: "She _____ to the store yesterday."', options: ['go', 'goes', 'went', 'gone'], answer: 'went', explanation: '"yesterday" 表明是过去时，go 的过去式是 went' },
                { content: 'What is the synonym of "difficult"?', options: ['easy', 'hard', 'simple', 'soft'], answer: 'hard', explanation: 'difficult 和 hard 都表示"困难的"' },
                { content: 'Choose the correct article: "I saw ___ elephant at the zoo."', options: ['a', 'an', 'the', 'no article'], answer: 'an', explanation: 'elephant 是元音开头，用 an' },
                { content: '"Ubiquitous" means:', options: ['rare', 'everywhere', 'beautiful', 'expensive'], answer: 'everywhere', explanation: 'ubiquitous 意为"无处不在的"' },
                { content: 'Past participle of "write" is:', options: ['wrote', 'writing', 'written', 'writes'], answer: 'written', explanation: 'write 的过去分词是 written' },
                { content: 'Which is grammatically correct?', options: ['He don\'t like it', 'He doesn\'t likes it', 'He doesn\'t like it', 'He not like it'], answer: 'He doesn\'t like it', explanation: '第三人称单数用 doesn\'t，后接动词原形' },
                { content: '"Benevolent" is closest in meaning to:', options: ['cruel', 'kind', 'angry', 'neutral'], answer: 'kind', explanation: 'benevolent 意为"仁慈的，善良的"' },
            ],
            judge: [
                { content: '"I have been studying English for 5 years" is in present perfect continuous tense.', answer: '正确', explanation: 'have/has been doing 是现在完成进行时' },
                { content: '"They was happy" is grammatically correct.', answer: '错误', explanation: 'They 要用 were，不能用 was' },
                { content: 'Adjectives in English usually come before the noun.', answer: '正确', explanation: '英语中形容词通常放在名词前面' },
                { content: '"Information" is a countable noun.', answer: '错误', explanation: 'information 是不可数名词' },
            ]
        },
        '大学物理': {
            single: [
                { content: '牛顿第二定律的表达式是？', options: ['F = ma', 'E = mc²', 'F = Gm₁m₂/r²', 'v = v₀ + at'], answer: 'F = ma', explanation: '牛顿第二定律：物体的加速度与合外力成正比，与质量成反比' },
                { content: '真空中的光速约为？', options: ['3×10⁸ m/s', '3×10⁶ m/s', '3×10¹⁰ m/s', '3×10⁴ m/s'], answer: '3×10⁸ m/s', explanation: '真空光速 c ≈ 3×10⁸ m/s' },
                { content: '重力加速度 g 的标准值约为？', options: ['9.8 m/s²', '10 m/s²', '8.9 m/s²', '11 m/s²'], answer: '9.8 m/s²', explanation: '地球表面重力加速度约为 9.8 m/s²' },
                { content: '下列哪个物理量是矢量？', options: ['质量', '速度', '温度', '时间'], answer: '速度', explanation: '矢量既有大小又有方向，速度是矢量' },
                { content: '电阻的单位是？', options: ['安培(A)', '伏特(V)', '欧姆(Ω)', '瓦特(W)'], answer: '欧姆(Ω)', explanation: '电阻的单位是欧姆，符号 Ω' },
                { content: '根据能量守恒定律，孤立系统的总能量如何变化？', options: ['增加', '减少', '保持不变', '先增后减'], answer: '保持不变', explanation: '能量守恒定律：孤立系统的总能量保持不变' },
            ],
            judge: [
                { content: '力是改变物体运动状态的原因', answer: '正确', explanation: '牛顿第一定律表明力是改变物体运动状态的原因' },
                { content: '动能可以为负值', answer: '错误', explanation: '动能 Ek = ½mv²，由于 v² ≥ 0，所以动能总是非负的' },
                { content: '摩擦力的方向总是与物体运动方向相反', answer: '错误', explanation: '静摩擦力可以与运动方向相同，如传送带上的物体' },
                { content: '温度是物体冷热程度的量度', answer: '正确', explanation: '温度反映了物体的冷热程度和分子平均动能' },
            ]
        },
        '计算机基础': {
            single: [
                { content: '在计算机中，1 KB 等于多少字节？', options: ['1000', '1024', '1048576', '512'], answer: '1024', explanation: '1 KB = 1024 Bytes (2^10)' },
                { content: 'HTTP 协议默认使用的端口号是？', options: ['21', '80', '443', '8080'], answer: '80', explanation: 'HTTP 默认端口是 80，HTTPS 是 443' },
                { content: 'TCP/IP 模型共有几层？', options: ['3层', '4层', '5层', '7层'], answer: '4层', explanation: 'TCP/IP 模型分为：应用层、传输层、网络层、网络接口层' },
                { content: '下列哪个不是面向对象编程的特性？', options: ['封装', '继承', '多态', '编译'], answer: '编译', explanation: '面向对象三大特性是：封装、继承、多态' },
                { content: '二进制数 1010 转换为十进制是？', options: ['8', '10', '12', '16'], answer: '10', explanation: '1010₂ = 1×2³ + 0×2² + 1×2¹ + 0×2⁰ = 10₁₀' },
                { content: '下列哪种数据结构遵循"先进先出"(FIFO)原则？', options: ['栈', '队列', '树', '图'], answer: '队列', explanation: '队列是先进先出(FIFO)，栈是后进先出(LIFO)' },
                { content: 'SQL 中用于查询数据的关键字是？', options: ['INSERT', 'SELECT', 'UPDATE', 'DELETE'], answer: 'SELECT', explanation: 'SELECT 用于查询数据，INSERT 插入，UPDATE 更新，DELETE 删除' },
            ],
            judge: [
                { content: 'Python 是一种编译型语言', answer: '错误', explanation: 'Python 是解释型语言，不是编译型语言' },
                { content: 'IP 地址由 32 位二进制数组成（IPv4）', answer: '正确', explanation: 'IPv4 地址是 32 位，分为 4 个 8 位段' },
                { content: '递归函数必须有终止条件', answer: '正确', explanation: '没有终止条件的递归会导致栈溢出' },
                { content: 'RAM 是只读存储器', answer: '错误', explanation: 'RAM 是随机存储器(可读写)，ROM 才是只读存储器' },
            ]
        },
        'CET-4': {
            single: [
                { content: '"Abandon" means:', options: ['to keep', 'to give up', 'to find', 'to build'], answer: 'to give up', explanation: 'abandon 意为"放弃"' },
                { content: 'Choose the correct preposition: "She is good ___ math."', options: ['at', 'in', 'on', 'with'], answer: 'at', explanation: 'be good at 表示"擅长于"' },
                { content: '"Consequence" is closest to:', options: ['result', 'beginning', 'process', 'cause'], answer: 'result', explanation: 'consequence 意为"结果，后果"' },
                { content: 'Which sentence is correct?', options: ['I have went there', 'I have gone there', 'I has been there', 'I have been there'], answer: 'I have been there', explanation: 'have been 表示"去过"，have gone 表示"去了"' },
            ],
            judge: [
                { content: '"Affect" and "effect" can be used interchangeably.', answer: '错误', explanation: 'affect 通常是动词，effect 通常是名词' },
                { content: 'The past tense of "read" is pronounced differently from its present tense.', answer: '错误', explanation: 'read 的现在式和过去式拼写相同，发音也相同 [riːd]，但过去分词发音是 [red]' },
            ]
        },
        'CET-6': {
            single: [
                { content: '"Sophisticated" means:', options: ['simple', 'complex and refined', 'old-fashioned', 'cheap'], answer: 'complex and refined', explanation: 'sophisticated 意为"复杂的，精致的"' },
                { content: 'Choose the synonym of "ubiquitous":', options: ['rare', 'omnipresent', 'specific', 'limited'], answer: 'omnipresent', explanation: 'ubiquitous 和 omnipresent 都表示"无处不在的"' },
                { content: '"Paradox" refers to:', options: ['a simple truth', 'a contradictory statement', 'a scientific law', 'a common phrase'], answer: 'a contradictory statement', explanation: 'paradox 意为"悖论，矛盾的说法"' },
            ],
            judge: [
                { content: '"Literally" should only be used for literal meanings, not for emphasis.', answer: '正确', explanation: '虽然口语中常误用，但 literally 应该只用于字面意思' },
                { content: 'Double negatives are acceptable in formal English.', answer: '错误', explanation: '标准英语中应避免双重否定' },
            ]
        },
        '雅思英语': {
            single: [
                { content: 'In IELTS Writing Task 2, the recommended word count is:', options: ['150 words', '200 words', '250 words', '300 words'], answer: '250 words', explanation: 'Task 2 要求至少 250 词' },
                { content: 'Which section comes first in IELTS Listening?', options: ['Section 4', 'Section 3', 'Section 2', 'Section 1'], answer: 'Section 1', explanation: 'IELTS 听力从 Section 1 开始，难度递增' },
                { content: '"Coherence and Cohesion" in IELTS Writing refers to:', options: ['Grammar accuracy', 'Logical flow and linking', 'Vocabulary range', 'Task achievement'], answer: 'Logical flow and linking', explanation: 'Coherence 指连贯性，Cohesion 指衔接性' },
            ],
            judge: [
                { content: 'IELTS Speaking test has 3 parts.', answer: '正确', explanation: 'IELTS 口语分为 3 个部分：Introduction, Long turn, Discussion' },
                { content: 'You can use pencil for IELTS Writing test.', answer: '正确', explanation: 'IELTS 笔试必须用铅笔' },
            ]
        },
        'HSK中文': {
            single: [
                { content: '"你好"的正确拼音是？', options: ['nǐ hǎo', 'ní hào', 'nǐ hào', 'ní hǎo'], answer: 'nǐ hǎo', explanation: '"你"是第三声，"好"也是第三声' },
                { content: '下列哪个词是量词？', options: ['个', '大', '吃', '很'], answer: '个', explanation: '"个"是最常用的量词之一' },
                { content: '"汉语"的意思是？', options: ['Chinese language', 'Chinese people', 'China', 'Chinese food'], answer: 'Chinese language', explanation: '"汉语"指的是中文语言' },
            ],
            judge: [
                { content: '汉语有四个声调', answer: '错误', explanation: '汉语普通话有四个声调加一个轻声，共五种声调' },
                { content: '"的、地、得"的用法完全相同', answer: '错误', explanation: '"的"修饰名词，"地"修饰动词，"得"表示结果' },
            ]
        }
    };
    
    // 根据科目名称选择题库
    let selectedBank = questionBank['通用'] || null;
    for (const [key, value] of Object.entries(questionBank)) {
        if (subjectName.includes(key.split('').filter(c => c !== ' ').join('')) || key.includes(subjectName)) {
            selectedBank = value;
            break;
        }
    }
    
    // 如果没有匹配的题库，生成通用题目
    if (!selectedBank) {
        selectedBank = {
            single: [
                { content: `${subjectName}相关问题：请选择正确答案`, options: ['选项A', '选项B', '选项C', '选项D'], answer: '选项A', explanation: '这是一道示例题目' }
            ],
            judge: [
                { content: `这是一道${subjectName}判断题`, answer: '正确', explanation: '这是判断题解析' }
            ]
        };
    }
    
    // 生成题目
    const questionTypes = ['single', 'judge'];
    if (selectedBank.multiple) questionTypes.push('multiple');
    
    for (let i = 0; i < count; i++) {
        const type = questionTypes[Math.floor(Math.random() * questionTypes.length)];
        let questionData;
        
        if (type === 'single' && selectedBank.single) {
            const template = selectedBank.single[i % selectedBank.single.length];
            questionData = {
                subjectId,
                type: 'single',
                content: template.content,
                options: template.options,
                answer: template.answer,
                difficulty: Math.floor(Math.random() * 3) + 1,
                explanation: template.explanation || '暂无解析'
            };
        } else if (type === 'judge' && selectedBank.judge) {
            const template = selectedBank.judge[i % selectedBank.judge.length];
            questionData = {
                subjectId,
                type: 'judge',
                content: template.content,
                options: ['正确', '错误'],
                answer: template.answer,
                difficulty: Math.floor(Math.random() * 3) + 1,
                explanation: template.explanation || '暂无解析'
            };
        } else if (type === 'multiple' && selectedBank.multiple) {
            const template = selectedBank.multiple[i % selectedBank.multiple.length];
            questionData = {
                subjectId,
                type: 'multiple',
                content: template.content,
                options: template.options,
                answer: template.answer,
                difficulty: Math.floor(Math.random() * 3) + 1,
                explanation: template.explanation || '暂无解析'
            };
        } else {
            // 默认单选题
            questionData = {
                subjectId,
                type: 'single',
                content: `${subjectName}测试题${i + 1}`,
                options: ['选项A', '选项B', '选项C', '选项D'],
                answer: '选项A',
                difficulty: 1,
                explanation: '这是一道测试题'
            };
        }
        
        questions.push(questionData);
    }
    
    return questions;
}

async function openStudyModal() {
    document.getElementById('study-modal').classList.add('visible');
    switchStudyTab('practice');
    loadStudySubjectsSelect();
    loadBanksList();
    loadStudyGoals();
    updateStudyStatsDisplay();
}

function switchStudyTab(tabName) {
    document.querySelectorAll('.study-tab').forEach(t => {
        t.classList.remove('active');
        t.style.borderBottom = 'none';
        t.style.color = '#666';
    });
    const activeTab = document.querySelector(`.study-tab[data-tab="${tabName}"]`);
    if(activeTab) {
        activeTab.classList.add('active');
        activeTab.style.borderBottom = '3px solid #ff6b9d';
        activeTab.style.color = '#ff6b9d';
    }
    
    document.querySelectorAll('.study-panel').forEach(p => {
        p.style.display = 'none';
    });
    const panel = document.getElementById(`study-${tabName}-panel`);
    if(panel) {
        panel.style.display = 'flex';
        panel.style.flexDirection = 'column';
        panel.style.gap = '20px';
    }
    
    if(tabName === 'practice') {
        if(currentStudySession.mode !== 'practice' || currentStudySession.questions.length === 0) {
            document.getElementById('practice-setup-view').style.display = 'block';
            document.getElementById('practice-active-view').style.display = 'none';
        }
    } else if(tabName === 'exam') {
         if(currentStudySession.mode !== 'exam' || currentStudySession.questions.length === 0) {
            document.getElementById('exam-setup-view').style.display = 'block';
            document.getElementById('exam-active-view').style.display = 'none';
            document.getElementById('exam-result-view').style.display = 'none';
             loadStudySubjectsSelect(); // Reload for exam
        }
    }
}

async function loadStudySubjectsSelect() {
    const subjects = await db.studySubjects.toArray();
    const html = subjects.map(s => `<option value="${s.id}">${s.name} (${s.category === 'university' ? '大学' : (s.category === 'exam' ? '考试' : '自定义')})</option>`).join('');
    
    const pSelect = document.getElementById('practice-subject-select');
    if(pSelect) pSelect.innerHTML = html;
    
    const eSelect = document.getElementById('exam-subject-select');
    if(eSelect) eSelect.innerHTML = html;
}

async function startStudySession(mode) {
    const subjectSelectId = mode === 'practice' ? 'practice-subject-select' : 'exam-subject-select';
    const countSelectId = mode === 'practice' ? 'practice-count-select' : 'exam-count-select';
    const customCountInputId = mode === 'practice' ? 'practice-count-custom' : 'exam-count-custom';
    
    const subjectId = parseInt(document.getElementById(subjectSelectId).value);
    const selectCount = parseInt(document.getElementById(countSelectId).value);
    const customInputEl = document.getElementById(customCountInputId);
    const customCountValue = customInputEl ? parseInt(customInputEl.value) : NaN;
    let count = selectCount;
    
    if (!isNaN(customCountValue) && customCountValue > 0) {
        count = Math.min(customCountValue, 999);
    }
    
    if (!subjectId) return alert('请选择科目');
    if (!count || count <= 0) return alert('请输入有效的题目数量');
    
    // 获取通知角色开关状态（根据模式读取对应的开关）
    const notifyCharToggleId = mode === 'practice' ? 'notify-char-study-toggle' : 'notify-char-exam-toggle';
    const notifyCharToggle = document.getElementById(notifyCharToggleId);
    const notifyChar = notifyCharToggle ? notifyCharToggle.checked : false;
    
    const subject = await db.studySubjects.get(subjectId);
    const questions = await getRandomQuestions(subjectId, count);
    
    if (questions.length === 0) {
        return alert('⚠️ 该科目暂无题目！\n\n请点击「题库」标签页，然后点击「刷新题库」按钮加载题目。');
    }
    
    if (questions.length < count) {
        const confirmed = confirm(`⚠️ 题库数量不足！\n\n您选择了 ${count} 题，但当前科目仅有 ${questions.length} 道题目。\n\n建议：点击「题库」标签页的「刷新题库」按钮充实题库！\n\n是否继续以现有 ${questions.length} 题开始？`);
        if (!confirmed) return;
    }
    
    currentStudySession = {
        questions: questions,
        currentIndex: 0,
        answers: new Array(questions.length).fill(null),
        startTime: Date.now(),
        timerInterval: null,
        mode: mode,
        subjectName: subject.name,
        notifyChar: notifyChar  // 保存通知角色状态
    };
    
    if (mode === 'practice') {
        document.getElementById('practice-setup-view').style.display = 'none';
        document.getElementById('practice-active-view').style.display = 'flex';
        document.getElementById('practice-subject-label').textContent = subject.name;
        renderQuestion();
    } else {
        document.getElementById('exam-setup-view').style.display = 'none';
        document.getElementById('exam-active-view').style.display = 'flex';
        document.getElementById('exam-subject-label').textContent = `${subject.name} - 考试中`;
        renderQuestion();
        startTimer();
    }
}

async function getRandomQuestions(subjectId, count) {
    const all = await db.questionBanks.where('subjectId').equals(subjectId).toArray();
    // Simple shuffle
    for (let i = all.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [all[i], all[j]] = [all[j], all[i]];
    }
    return all.slice(0, count);
}

function renderQuestion() {
    if (!currentStudySession.questions || currentStudySession.questions.length === 0) return;
    
    const q = currentStudySession.questions[currentStudySession.currentIndex];
    if (!q) {
        console.error('Question data is missing at index', currentStudySession.currentIndex);
        return;
    }

    const mode = currentStudySession.mode;
    const prefix = mode === 'practice' ? '' : 'exam-';
    
    // Labels
    const progressLabel = document.getElementById(`${prefix}progress-label`);
    if (progressLabel) progressLabel.textContent = `${currentStudySession.currentIndex + 1}/${currentStudySession.questions.length}`;
    
    const textEl = document.getElementById(`${mode === 'practice' ? 'question-text' : 'exam-question-text'}`);
    if (textEl) textEl.textContent = q.content || '（题目内容加载失败）';
    
    // Type Badge (only for practice usually, but ok for exam too)
    if(mode === 'practice') {
        const badge = document.getElementById('question-type-badge');
        if (badge) badge.textContent = getTypeName(q.type);
    }
    
    // Options
    const optionsArea = document.getElementById(`${prefix}options-area`);
    if (optionsArea) {
        optionsArea.innerHTML = '';
        
        const options = Array.isArray(q.options) ? q.options : [];
        
        if (q.type === 'single' || q.type === 'multiple' || q.type === 'judge') {
            options.forEach((opt, idx) => {
                const div = document.createElement('div');
                div.className = 'study-option';
                div.style.cssText = 'padding: 12px; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 8px; cursor: pointer; background: white; transition: all 0.2s;';
                div.textContent = `${String.fromCharCode(65+idx)}. ${opt}`;
                div.dataset.val = opt;
                
                div.onclick = () => {
                    if(mode === 'practice' && document.getElementById('answer-feedback').style.display === 'block') return; // Already answered
                    
                    // Handle selection style
                    if(q.type === 'single' || q.type === 'judge') {
                        optionsArea.querySelectorAll('.study-option').forEach(o => {
                            o.style.background = 'white';
                            o.style.borderColor = '#ddd';
                            o.classList.remove('selected');
                        });
                        div.classList.add('selected');
                        div.style.background = '#e3f2fd';
                        div.style.borderColor = '#2196f3';
                    } else {
                        div.classList.toggle('selected');
                        if(div.classList.contains('selected')) {
                            div.style.background = '#e3f2fd';
                            div.style.borderColor = '#2196f3';
                        } else {
                            div.style.background = 'white';
                            div.style.borderColor = '#ddd';
                        }
                    }
                    
                    // For Exam, save immediately to temp
                    if (mode === 'exam') {
                        saveExamTempAnswer();
                    }
                };
                
                // Restore previous answer if any
                const savedAns = currentStudySession.answers[currentStudySession.currentIndex];
                if (savedAns && savedAns.userAnswer) {
                     if(Array.isArray(savedAns.userAnswer)) {
                         if(savedAns.userAnswer.includes(opt)) {
                             div.classList.add('selected');
                             div.style.background = '#e3f2fd';
                             div.style.borderColor = '#2196f3';
                         }
                     } else {
                         if(savedAns.userAnswer === opt) {
                             div.classList.add('selected');
                             div.style.background = '#e3f2fd';
                             div.style.borderColor = '#2196f3';
                         }
                     }
                }
                
                optionsArea.appendChild(div);
            });
        }
    }
    
    // Canvas
    const canvasArea = document.getElementById(`${prefix}drawing-area`);
    if (canvasArea) {
        if (q.type === 'draw') {
            canvasArea.style.display = 'block';
        } else {
            canvasArea.style.display = 'none';
        }
    }
    
    // Reset buttons for practice
    if (mode === 'practice') {
        const submitBtn = document.getElementById('submit-answer-btn');
        const nextBtn = document.getElementById('next-question-btn');
        const feedback = document.getElementById('answer-feedback');
        
        if(submitBtn) submitBtn.style.display = 'block';
        if(nextBtn) nextBtn.style.display = 'none';
        if(feedback) feedback.style.display = 'none';
        
        // If already answered correctly, show next
        if (currentStudySession.answers[currentStudySession.currentIndex]?.isCorrect) {
             if(submitBtn) submitBtn.style.display = 'none';
             if(nextBtn) nextBtn.style.display = 'block';
             if(feedback) {
                 feedback.style.display = 'block';
                 feedback.textContent = '✅ 回答正确！';
             }
        }
    } else {
        // Exam buttons
        const prevBtn = document.getElementById('exam-prev-btn');
        const nextBtn = document.getElementById('exam-next-btn');
        const submitPaperBtn = document.getElementById('exam-submit-paper-btn');
        
        if(prevBtn) prevBtn.style.display = currentStudySession.currentIndex > 0 ? 'block' : 'none';
        if(nextBtn) nextBtn.style.display = currentStudySession.currentIndex < currentStudySession.questions.length - 1 ? 'block' : 'none';
        if(submitPaperBtn) submitPaperBtn.style.display = currentStudySession.currentIndex === currentStudySession.questions.length - 1 ? 'block' : 'none';
    }
}

function getTypeName(type) {
    const map = { 'single': '单选题', 'multiple': '多选题', 'judge': '判断题', 'draw': '画图题' };
    return map[type] || '未知题型';
}

function checkAnswer() {
    const q = currentStudySession.questions[currentStudySession.currentIndex];
    const optionsArea = document.getElementById('options-area');
    let userAnswer = null;
    
    if (q.type === 'single') {
        const selected = optionsArea.querySelector('.selected');
        if (!selected) return alert('请选择答案');
        userAnswer = selected.dataset.val;
    } else if (q.type === 'multiple') {
        const selected = Array.from(optionsArea.querySelectorAll('.selected')).map(el => el.dataset.val);
        if (selected.length === 0) return alert('请选择至少一个答案');
        userAnswer = selected;
    }
    
    // Check correctness
    let isCorrect = false;
    if (Array.isArray(q.answer)) {
        // Assume multiple choice exact match
        isCorrect = JSON.stringify(userAnswer.sort()) === JSON.stringify(q.answer.sort());
    } else {
        isCorrect = userAnswer === q.answer;
    }
    
    // Save
    currentStudySession.answers[currentStudySession.currentIndex] = {
        questionId: q.id,
        userAnswer: userAnswer,
        isCorrect: isCorrect
    };
    
    // UI Feedback
    const fb = document.getElementById('answer-feedback');
    fb.style.display = 'block';
    if (isCorrect) {
        fb.style.background = '#e8f5e9';
        fb.style.color = '#2e7d32';
        fb.textContent = '✅ 回答正确！';
    } else {
        fb.style.background = '#ffebee';
        fb.style.color = '#c62828';
        fb.textContent = `❌ 回答错误。正确答案是：${Array.isArray(q.answer) ? q.answer.join(', ') : q.answer}`;
    }
    
    document.getElementById('submit-answer-btn').style.display = 'none';
    document.getElementById('next-question-btn').style.display = 'block';
    
    // Update goals progress if correct
    if (isCorrect) updateGoalsProgress(1);
    
    // Save record
    db.studyRecords.add({
        date: new Date().toISOString().split('T')[0],
        subjectId: q.subjectId,
        score: isCorrect ? 1 : 0,
        type: 'practice',
        timestamp: Date.now(),
        notifyChar: currentStudySession.notifyChar || false  // 保存通知角色状态
    });
}

function nextQuestion() {
    if (currentStudySession.currentIndex < currentStudySession.questions.length - 1) {
        currentStudySession.currentIndex++;
        renderQuestion();
    } else {
        if(currentStudySession.mode === 'practice') {
             alert('练习完成！');
             quitStudySession();
        }
    }
}

function prevQuestion() {
    if (currentStudySession.currentIndex > 0) {
        currentStudySession.currentIndex--;
        renderQuestion();
    }
}

function saveExamTempAnswer() {
    const q = currentStudySession.questions[currentStudySession.currentIndex];
    const optionsArea = document.getElementById('exam-options-area');
    let userAnswer = null;
    
    if (q.type === 'single') {
        const selected = optionsArea.querySelector('.selected');
        if (selected) userAnswer = selected.dataset.val;
    } else if (q.type === 'multiple') {
        userAnswer = Array.from(optionsArea.querySelectorAll('.selected')).map(el => el.dataset.val);
    }
    
    currentStudySession.answers[currentStudySession.currentIndex] = {
        questionId: q.id,
        userAnswer: userAnswer
    };
}

async function finishExam() {
    saveExamTempAnswer(); // Save last question
    stopStudyTimer();
    
    let correctCount = 0;
    currentStudySession.answers.forEach((ans, idx) => {
        const q = currentStudySession.questions[idx];
        if (!ans || !ans.userAnswer) return;
        
        let isCorrect = false;
        if (Array.isArray(q.answer)) {
             if(Array.isArray(ans.userAnswer)) {
                 isCorrect = JSON.stringify(ans.userAnswer.sort()) === JSON.stringify(q.answer.sort());
             }
        } else {
            isCorrect = ans.userAnswer === q.answer;
        }
        
        if (isCorrect) correctCount++;
    });
    
    const score = Math.round((correctCount / currentStudySession.questions.length) * 100);
    
    // UI Result
    document.getElementById('exam-active-view').style.display = 'none';
    document.getElementById('exam-result-view').style.display = 'block';
    document.getElementById('exam-score-display').textContent = score;
    document.getElementById('exam-result-detail').textContent = `共 ${currentStudySession.questions.length} 题，答对 ${correctCount} 题`;
    
    // Save Record
    await db.studyRecords.add({
        date: new Date().toISOString().split('T')[0],
        subjectId: currentStudySession.questions[0].subjectId,
        score: score,
        type: 'exam',
        timestamp: Date.now(),
        notifyChar: currentStudySession.notifyChar || false,  // 保存通知角色状态
        details: {
             total: currentStudySession.questions.length,
             correct: correctCount
        }
    });
    
    updateGoalsProgress(correctCount);
    updateStudyStatsDisplay();
}

function quitStudySession() {
    stopStudyTimer();
    // Reset session data to ensure the view switches back to setup
    currentStudySession = {
        questions: [],
        currentIndex: 0,
        answers: [],
        startTime: 0,
        timerInterval: null,
        mode: 'practice',
        subjectName: ''
    };
    switchStudyTab('practice'); // Reset view
}

function startTimer() {
    let seconds = 0;
    const timerEl = document.getElementById('exam-timer');
    const practiceTimerEl = document.getElementById('practice-timer');
    
    clearInterval(currentStudySession.timerInterval);
    currentStudySession.timerInterval = setInterval(() => {
        seconds++;
        const min = Math.floor(seconds / 60).toString().padStart(2, '0');
        const sec = (seconds % 60).toString().padStart(2, '0');
        const str = `${min}:${sec}`;
        
        if(currentStudySession.mode === 'exam') timerEl.textContent = str;
        else practiceTimerEl.textContent = str;
    }, 1000);
}

function stopStudyTimer() {
    clearInterval(currentStudySession.timerInterval);
}

async function askCharForStudyHelp() {
    if (!currentStudySession.questions.length) {
        alert('请先进入练习或考试模式');
        return;
    }
    
    // 检查是否开启了通知角色功能
    if (!currentStudySession.notifyChar) {
        alert('⚠️ 通知角色功能未开启\n\n请在开始练习或考试前，勾选「通知角色」选项。');
        return;
    }
    
    const q = currentStudySession.questions[currentStudySession.currentIndex];
    
    // Close modal
    document.getElementById('study-modal').classList.remove('visible');
    
    // Format White Envelope Message
    // We will trick the system by sending a message that looks like a card
    // Since we can't easily inject HTML as USER message without backend support usually,
    // We will try to format it using the existing message system or assume HTML is allowed.
    // Based on the user request, it should be a "White Envelope".
    
    const envelopeHtml = `
    <div style="max-width: 300px; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); overflow: hidden; font-family: sans-serif;">
        <div style="background: #f8f9fa; padding: 12px 16px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 16px;">📩</span>
            <span style="font-weight: 600; color: #333; font-size: 14px;">学习求助信</span>
        </div>
        <div style="padding: 16px;">
            <div style="font-size: 12px; color: #999; margin-bottom: 4px;">科目：${currentStudySession.subjectName}</div>
            <div style="font-size: 14px; color: #333; line-height: 1.5; margin-bottom: 12px; font-weight: 500;">
                ${q.content}
            </div>
            <div style="font-size: 12px; color: #ff6b9d; text-align: right;">
                点击查看详情 >
            </div>
        </div>
    </div>`;
    
    // We need to send this as the message content.
    // But typically user input is text.
    // We will use a special marker that the system might render, OR just text.
    // "点击求助CHAR会在聊天记录里面发送求助渲染美观信息，是白色信封的"
    
    // Let's try to construct a message object directly if we can access the chat logic.
    // But we can only simulate user input.
    
    const input = document.getElementById('chat-input');
    // We'll put a simplified text for the model to read, but maybe the UI renders HTML?
    // If the chat bubbles support HTML, we can put HTML.
    // If not, we might fail the "White Envelope" visual requirement.
    // Assuming HTML is supported for now or we rely on the system to render it.
    
    // Actually, to ensure the AI understands, we send text, but we want the USER Bubble to look like an envelope.
    // This might require modifying `renderMessage`.
    // For now, I will send a JSON string that might be intercepted or just plain text with instructions.
    
    // Let's just send the text and hope the prompt instruction I added handles the "Context".
    // The user sees the "White Envelope" - this implies client-side rendering change.
    // Since I can't easily change `renderMessage` logic deeply without risking breaking it (it's huge),
    // I will try to just send the text representation.
    
    input.value = `[学习求助] ✉️\n题目：${q.content}\n选项：${q.options.join(', ')}`;
    document.getElementById('send-btn').click();
}

// Canvas Helper
function setupCanvas(canvasId, colorId, clearBtnId) {
    const canvas = document.getElementById(canvasId);
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    
    // Resize
    // canvas.width = canvas.offsetWidth;
    // canvas.height = canvas.offsetHeight;
    
    canvas.addEventListener('mousedown', start);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stop);
    canvas.addEventListener('mouseout', stop);
    
    function start(e) {
        isDrawing = true;
        ctx.beginPath();
        ctx.moveTo(e.offsetX, e.offsetY);
        ctx.strokeStyle = document.getElementById(colorId).value;
        ctx.lineWidth = 2;
    }
    
    function draw(e) {
        if (!isDrawing) return;
        ctx.lineTo(e.offsetX, e.offsetY);
        ctx.stroke();
    }
    
    function stop() {
        isDrawing = false;
        ctx.closePath();
    }
    
    document.getElementById(clearBtnId).addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
}

// 题库导入
function handleBankImport(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (evt) => {
        try {
            const data = JSON.parse(evt.target.result);
            // Expected format: { name: "Subject", questions: [...] }
            if (data.name && Array.isArray(data.questions)) {
                const subjectId = await db.studySubjects.add({
                    name: data.name,
                    category: 'custom',
                    isDefault: 0
                });
                
                for (const q of data.questions) {
                    await db.questionBanks.add({
                        subjectId,
                        ...q
                    });
                }
                alert('导入成功！');
                loadStudySubjectsSelect();
                loadBanksList();
            } else {
                alert('格式错误');
            }
        } catch (err) {
            console.error(err);
            alert('导入失败');
        }
    };
    reader.readAsText(file);
}

async function loadBanksList() {
    const subjects = await db.studySubjects.toArray();
    const container = document.getElementById('banks-list');
    if(!container) return;
    
    container.innerHTML = subjects.map(s => `
        <div style="background: white; padding: 15px; border: 1px solid #eee; border-radius: 10px;">
            <div style="font-weight: bold; margin-bottom: 5px;">${s.name}</div>
            <div style="font-size: 12px; color: #999;">${s.category === 'university' ? '官方题库' : '自定义'}</div>
            <div style="margin-top: 10px; text-align: right;">
                <button style="padding: 4px 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">管理</button>
            </div>
        </div>
    `).join('');
}

// 目标与统计
async function loadStudyGoals() {
    const settings = await db.studySettings.get('default') || {};
    document.getElementById('goal-daily-input').value = settings.dailyGoal || '';
    document.getElementById('goal-weekly-input').value = settings.weeklyGoal || '';
    document.getElementById('goal-monthly-input').value = settings.monthlyGoal || '';
    
    updateGoalsProgressDisplay(settings);
}

async function saveStudyGoals() {
    const daily = parseInt(document.getElementById('goal-daily-input').value) || 0;
    const weekly = parseInt(document.getElementById('goal-weekly-input').value) || 0;
    const monthly = parseInt(document.getElementById('goal-monthly-input').value) || 0;
    
    await db.studySettings.put({
        id: 'default',
        dailyGoal: daily,
        weeklyGoal: weekly,
        monthlyGoal: monthly
    });
    alert('目标已保存');
    loadStudyGoals();
}

async function updateGoalsProgress(count) {
    // Add to stats
    // Logic to update today's record count
}

async function updateGoalsProgressDisplay(settings) {
    // Calculate actual progress from db.studyRecords
    // This is complex to do efficiently in frontend-only DB without aggregates, 
    // but for now let's just show the target.
    const container = document.getElementById('goals-progress-container');
    const summary = document.getElementById('goals-progress-summary');
    if(!container) return;
    
    // Get today's count
    const today = new Date().toISOString().split('T')[0];
    const todayRecords = await db.studyRecords.where('date').equals(today).toArray();
    const todayCount = todayRecords.length;
    
    if(summary) {
        summary.textContent = settings.dailyGoal
            ? `今日 ${todayCount} / ${settings.dailyGoal}`
            : `今日 ${todayCount}`;
    }
    
    container.innerHTML = `
        <div style="margin-bottom: 10px;">
            <div style="display:flex; justify-content:space-between; font-size:13px; margin-bottom:5px;">
                <span>今日目标</span>
                <span>${todayCount} / ${settings.dailyGoal || '-'}</span>
            </div>
            <div style="height: 6px; background: #f0f0f0; border-radius: 3px; overflow: hidden;">
                <div style="height: 100%; width: ${settings.dailyGoal ? Math.min(100, (todayCount/settings.dailyGoal)*100) : 0}%; background: #ff6b9d;"></div>
            </div>
        </div>
    `;
}

async function updateStudyStatsDisplay() {
    const total = await db.studyRecords.count();
    document.getElementById('stat-total-questions').textContent = total;
    
    // Accuracy
    const exams = await db.studyRecords.where('type').equals('exam').toArray();
    if (exams.length > 0) {
        const avg = exams.reduce((acc, cur) => acc + cur.score, 0) / exams.length;
        document.getElementById('stat-accuracy').textContent = Math.round(avg) + '%';
    } else {
         document.getElementById('stat-accuracy').textContent = '-';
    }
}

async function getStudyInfoForChar() {
    const settings = await db.studySettings.get('default');
    const today = new Date().toISOString().split('T')[0];
    const allRecords = await db.studyRecords.where('date').equals(today).toArray();
    const allExams = await db.studyRecords.where('type').equals('exam').reverse().limit(1).toArray();
    
    // 【关键修改】只保留用户允许通知角色的记录（notifyChar === true）
    // 这样关闭通知后，角色完全看不到学习中心内容
    const notifiableRecords = allRecords.filter(r => r.notifyChar === true);
    const notifiableExams = allExams.filter(r => r.notifyChar === true);
    
    if (notifiableRecords.length === 0 && notifiableExams.length === 0) {
        return null;  // 没有可通知角色的记录，返回null，角色完全不知道学习中心
    }
    
    let info = `════════════════════════════\n`;
    info += `📚 【用户的学习情况】\n`;
    info += `今日刷题：${notifiableRecords.length}道\n`;
    if (settings && settings.dailyGoal) info += `今日目标：${settings.dailyGoal}道\n`;
    if (notifiableExams.length > 0) {
        info += `最近考试成绩：${notifiableExams[0].score}分 (${notifiableExams[0].date})\n`;
    }
    info += `════════════════════════════\n`;
    return info;
}

// ▲▲▲ 学习功能结束 ▲▲▲

// ▼▼▼ 消息存放功能开始 ▼▼▼

// 数据结构：存储位列表
let messageStorageSlots = [];
let currentEditingSlotIndex = -1; // 当前正在编辑的存储位索引，-1表示新建

// 从localStorage加载存储位数据
function loadMessageStorageData() {
    const saved = localStorage.getItem('messageStorageSlots');
    if (saved) {
        try {
            messageStorageSlots = JSON.parse(saved);
        } catch (e) {
            console.error('加载消息存储数据失败:', e);
            messageStorageSlots = [];
        }
    }
}

// 保存存储位数据到localStorage
function saveMessageStorageData() {
    try {
        localStorage.setItem('messageStorageSlots', JSON.stringify(messageStorageSlots));
    } catch (e) {
        console.error('保存消息存储数据失败:', e);
    }
}

// 打开消息存放模态框
function openMessageStorageModal() {
    const modal = document.getElementById('message-storage-modal');
    modal.style.display = 'flex';
    renderStorageSlots();
}

// 关闭消息存放模态框
function closeMessageStorageModal() {
    const modal = document.getElementById('message-storage-modal');
    modal.style.display = 'none';
}

// 渲染存储位列表
function renderStorageSlots() {
    const container = document.getElementById('storage-slots-container');
    
    if (messageStorageSlots.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; color: #999; padding: 40px 20px;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" style="margin: 0 auto 15px;">
                    <path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM7 10H17V12H7V10ZM7 13H17V15H7V13ZM7 7H17V9H7V7Z"/>
                </svg>
                <p>暂无存储位</p>
                <p style="font-size: 12px; color: #ccc;">点击上方按钮创建新的消息存储位</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = messageStorageSlots.map((slot, index) => `
        <div class="storage-slot-card" style="background: white; border: 1px solid #e0e0e0; border-radius: 12px; padding: 20px; cursor: pointer; transition: all 0.3s; position: relative;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 8px 0; font-size: 18px; color: #333;">${slot.name || '未命名存储位'}</h3>
                    <div style="font-size: 13px; color: #999;">
                        <span>📝 ${slot.messages.length} 条消息</span>
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="edit-slot-btn" data-index="${index}" style="padding: 6px 12px; background: #e3f2fd; color: #2196f3; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                        编辑
                    </button>
                    <button class="delete-slot-btn" data-index="${index}" style="padding: 6px 12px; background: #ffebee; color: #f44336; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                        删除
                    </button>
                </div>
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px;">
                ${slot.messages.slice(0, 3).map(msg => `
                    <div style="padding: 4px 10px; background: #f5f5f5; border-radius: 4px; font-size: 12px; color: #666; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        ${msg.substring(0, 20)}${msg.length > 20 ? '...' : ''}
                    </div>
                `).join('')}
                ${slot.messages.length > 3 ? `<div style="padding: 4px 10px; background: #f5f5f5; border-radius: 4px; font-size: 12px; color: #999;">+${slot.messages.length - 3}</div>` : ''}
            </div>
            <button class="send-slot-btn" data-index="${index}" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
                发送全部消息
            </button>
        </div>
    `).join('');
    
    // 绑定编辑按钮
    container.querySelectorAll('.edit-slot-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(btn.dataset.index);
            openEditStorageSlotModal(index);
        });
    });
    
    // 绑定删除按钮
    container.querySelectorAll('.delete-slot-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(btn.dataset.index);
            deleteStorageSlot(index);
        });
    });
    
    // 绑定发送按钮
    container.querySelectorAll('.send-slot-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(btn.dataset.index);
            sendStorageSlotMessages(index);
        });
    });
}

// 删除存储位
function deleteStorageSlot(index) {
    if (confirm('确定要删除这个存储位吗？')) {
        messageStorageSlots.splice(index, 1);
        saveMessageStorageData();
        renderStorageSlots();
    }
}

// 发送存储位中的所有消息
async function sendStorageSlotMessages(index) {
    const slot = messageStorageSlots[index];
    if (!slot || slot.messages.length === 0) {
        alert('该存储位没有消息');
        return;
    }
    
    closeMessageStorageModal();
    
    // 依次发送每条消息
    for (let i = 0; i < slot.messages.length; i++) {
        const message = slot.messages[i];
        if (message.trim()) {
            // 设置输入框内容并发送
            const chatInput = document.getElementById('chat-input');
            chatInput.value = message;
            
            // 触发发送
            document.getElementById('send-btn').click();
            
            // 等待一段时间再发送下一条（避免发送太快）
            if (i < slot.messages.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 800));
            }
        }
    }
}

// 打开编辑存储位模态框
function openEditStorageSlotModal(index = -1) {
    currentEditingSlotIndex = index;
    const modal = document.getElementById('edit-storage-slot-modal');
    const titleEl = document.getElementById('edit-storage-slot-title');
    const nameInput = document.getElementById('storage-slot-name-input');
    
    if (index >= 0) {
        // 编辑模式
        const slot = messageStorageSlots[index];
        titleEl.textContent = '编辑存储位';
        nameInput.value = slot.name || '';
        renderMessagesList(slot.messages);
    } else {
        // 新建模式
        titleEl.textContent = '新建存储位';
        nameInput.value = '';
        renderMessagesList([]);
    }
    
    modal.style.display = 'flex';
}

// 关闭编辑存储位模态框
function closeEditStorageSlotModal() {
    const modal = document.getElementById('edit-storage-slot-modal');
    modal.style.display = 'none';
    currentEditingSlotIndex = -1;
}

// 渲染消息列表
function renderMessagesList(messages = []) {
    const container = document.getElementById('messages-list-container');
    
    if (messages.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; color: #999; padding: 20px; background: #f9f9f9; border-radius: 8px; border: 1px dashed #ddd;">
                暂无消息，点击下方"添加消息"按钮开始添加
            </div>
        `;
        return;
    }
    
    container.innerHTML = messages.map((msg, index) => `
        <div class="message-item" style="display: flex; gap: 10px; align-items: flex-start;">
            <div style="flex: 1;">
                <textarea class="message-textarea" data-index="${index}" style="width: 100%; min-height: 60px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px; resize: vertical; font-family: inherit;">${msg}</textarea>
            </div>
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <button class="move-up-btn" data-index="${index}" style="padding: 5px 8px; background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 4px; cursor: pointer; font-size: 12px;" ${index === 0 ? 'disabled' : ''}>↑</button>
                <button class="move-down-btn" data-index="${index}" style="padding: 5px 8px; background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 4px; cursor: pointer; font-size: 12px;" ${index === messages.length - 1 ? 'disabled' : ''}>↓</button>
                <button class="delete-message-btn" data-index="${index}" style="padding: 5px 8px; background: #ffebee; color: #f44336; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×</button>
            </div>
        </div>
    `).join('');
    
    // 绑定删除消息按钮
    container.querySelectorAll('.delete-message-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const index = parseInt(btn.dataset.index);
            messages.splice(index, 1);
            renderMessagesList(messages);
        });
    });
    
    // 绑定上移按钮
    container.querySelectorAll('.move-up-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const index = parseInt(btn.dataset.index);
            if (index > 0) {
                [messages[index], messages[index - 1]] = [messages[index - 1], messages[index]];
                renderMessagesList(messages);
            }
        });
    });
    
    // 绑定下移按钮
    container.querySelectorAll('.move-down-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const index = parseInt(btn.dataset.index);
            if (index < messages.length - 1) {
                [messages[index], messages[index + 1]] = [messages[index + 1], messages[index]];
                renderMessagesList(messages);
            }
        });
    });
}

// 添加新消息
function addNewMessage() {
    const container = document.getElementById('messages-list-container');
    const textareas = container.querySelectorAll('.message-textarea');
    const messages = Array.from(textareas).map(ta => ta.value);
    
    messages.push(''); // 添加一个空消息
    renderMessagesList(messages);
    
    // 聚焦到新添加的textarea
    setTimeout(() => {
        const newTextarea = container.querySelector('.message-textarea:last-child');
        if (newTextarea) newTextarea.focus();
    }, 100);
}

// 保存存储位
function saveStorageSlot() {
    const nameInput = document.getElementById('storage-slot-name-input');
    const name = nameInput.value.trim();
    
    if (!name) {
        alert('请输入存储位名称');
        return;
    }
    
    const container = document.getElementById('messages-list-container');
    const textareas = container.querySelectorAll('.message-textarea');
    const messages = Array.from(textareas).map(ta => ta.value.trim()).filter(msg => msg);
    
    if (messages.length === 0) {
        alert('请至少添加一条消息');
        return;
    }
    
    const slotData = {
        name: name,
        messages: messages,
        createdAt: new Date().toISOString()
    };
    
    if (currentEditingSlotIndex >= 0) {
        // 更新现有存储位
        messageStorageSlots[currentEditingSlotIndex] = slotData;
    } else {
        // 创建新存储位
        messageStorageSlots.push(slotData);
    }
    
    saveMessageStorageData();
    closeEditStorageSlotModal();
    renderStorageSlots();
}

// 初始化消息存放功能
function initMessageStorage() {
    loadMessageStorageData();
    
    // 绑定消息存放按钮
    document.getElementById('message-storage-btn').addEventListener('click', openMessageStorageModal);
    
    // 绑定关闭按钮
    document.getElementById('message-storage-close-btn').addEventListener('click', closeMessageStorageModal);
    
    // 绑定新增存储位按钮
    document.getElementById('add-storage-slot-btn').addEventListener('click', () => {
        openEditStorageSlotModal(-1);
    });
    
    // 绑定编辑模态框的关闭按钮
    document.getElementById('cancel-edit-storage-btn').addEventListener('click', closeEditStorageSlotModal);
    
    // 绑定添加消息按钮
    document.getElementById('add-message-btn').addEventListener('click', addNewMessage);
    
    // 绑定保存按钮
    document.getElementById('save-storage-slot-btn').addEventListener('click', saveStorageSlot);
    
    // 点击模态框外部关闭
    document.getElementById('message-storage-modal').addEventListener('click', (e) => {
        if (e.target.id === 'message-storage-modal') {
            closeMessageStorageModal();
        }
    });
    
    document.getElementById('edit-storage-slot-modal').addEventListener('click', (e) => {
        if (e.target.id === 'edit-storage-slot-modal') {
            closeEditStorageSlotModal();
        }
    });
}

// 在页面加载完成后初始化
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMessageStorage);
} else {
    initMessageStorage();
}

// ▲▲▲ 消息存放功能结束 ▲▲▲

// ▼▼▼ 【全新】宠物功能事件监听器 ▼▼▼

// 1. 绑定输入框上方的宠物图标按钮
document.getElementById('pet-action-btn').addEventListener('click', openPetModal);

// 2. 绑定宠物弹窗内的各种按钮
document.getElementById('pet-modal-cancel-btn').addEventListener('click', () => {
    document.getElementById('pet-modal').classList.remove('visible');
    currentPetData = null; // 取消时也要清理
});
document.getElementById('pet-modal-save-btn').addEventListener('click', savePetSettings);

// 3. 实时更新预览
document.getElementById('pet-type-input').addEventListener('input', updatePetPreview);
document.getElementById('pet-name-input').addEventListener('input', updatePetPreview);
document.getElementById('pet-image-input').addEventListener('input', updatePetPreview);

// 4. “在聊天界面显示”开关的交互
document.getElementById('pet-display-toggle').addEventListener('change', (e) => {
    document.getElementById('pet-position-controls').style.display = e.target.checked ? 'block' : 'none';
});

// 5. 尺寸滑块的交互
const sizeSlider = document.getElementById('pet-size-slider');
sizeSlider.addEventListener('input', () => {
    document.getElementById('pet-size-value').textContent = `${sizeSlider.value}px`;
});

// 6. 绑定更换自定义图片的点击事件
document.getElementById('pet-preview-display').addEventListener('click', () => {
    document.getElementById('pet-custom-image-input').click();
});
document.getElementById('pet-custom-image-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            // 将图片的Base64链接直接填入输入框
            document.getElementById('pet-image-input').value = event.target.result;
            updatePetPreview(); // 并更新预览
        };
        reader.readAsDataURL(file);
    }
});

// 7. 绑定互动按钮 (使用事件委托)
document.getElementById('pet-interaction-area').addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON' && e.target.dataset.action) {
        handlePetInteraction(e.target.dataset.action);
    }
});

// 8. 初始化宠物的拖动功能
initPetDragging();
// ▼▼▼ 【全新】宠物聊天功能事件绑定 ▼▼▼
document.getElementById('send-to-pet-btn').addEventListener('click', handleSendToPet);
document.getElementById('pet-chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-to-pet-btn').click();
    }
});

// 为宠物聊天窗口的“外部”点击添加关闭功能
const petChatModal = document.getElementById('pet-chat-modal');
petChatModal.addEventListener('click', (e) => {
    if (e.target === petChatModal) { // 只有点击灰色遮罩层才关闭
        petChatModal.classList.remove('visible');
    }
});
// ▲▲▲ 新事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
// 【全新】为“放生宠物”按钮绑定事件
document.getElementById('pet-abandon-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;

    const confirmed = await showCustomConfirm(
        '确认放生',
        '确定要关闭宠物系统吗？这将会重置所有宠物数据（数值、聊天记录等），但不会删除你的设置。你可以随时重新领养。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.settings.petAdopted = false; // 关闭领养状态
        delete chat.settings.pet; // 删除宠物数据对象
        
        await db.chats.put(chat);
        
        renderChatPet(); // 从聊天界面移除宠物
        document.getElementById('pet-modal').classList.remove('visible'); // 关闭弹窗
        alert('宠物已放生，江湖再见！');
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 宠物功能事件监听器结束 ▲▲▲


// ▲▲▲ 新增代码粘贴结束 ▲▲▲
// 在 init() 函数的事件监听器区域末尾...

// ▼▼▼ 在这里粘贴下面这几行新代码 ▼▼▼

// 绑定线下模式预设的下拉框和管理按钮
document.getElementById('offline-preset-select').addEventListener('change', handleOfflinePresetSelection);
document.getElementById('manage-offline-presets-btn').addEventListener('click', openOfflinePresetManager);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【已修复】用这段新代码替换旧的 ▼▼▼
document.getElementById('back-from-dm-list').addEventListener('click', () => {
    // 从私信列表返回时，直接显示微博主屏幕
    showScreen('weibo-screen');
    // 并且确保默认显示的是“我的微博”那个页签
    switchToWeiboView('weibo-my-profile-view');
});
// ▲▲▲ 替换结束 ▲▲▲


document.getElementById('back-from-dm-detail').addEventListener('click', () => {
    // 从私信详情返回私信列表
    showScreen('weibo-dm-list-screen');
});

// 绑定“继续生成”按钮
document.getElementById('generate-more-dms-btn').addEventListener('click', handleGenerateMoreDms);

// 使用事件委托处理私信列表的点击
document.getElementById('weibo-dm-list').addEventListener('click', (e) => {
    const item = e.target.closest('.dm-list-item');
    if (item && item.dataset.fanIndex) {
        openDmDetail(parseInt(item.dataset.fanIndex));
    }
});

// 使用事件委托处理私信详情页的删除按钮点击
document.getElementById('weibo-dm-messages').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.dm-message-delete-btn');
    if (deleteBtn) {
        const fanIndex = parseInt(document.querySelector('.dm-list-item.active')?.dataset.fanIndex ?? document.getElementById('weibo-dm-detail-screen').dataset.currentFanIndex);
        const messageIndex = parseInt(deleteBtn.dataset.messageIndex);
        
        const conversation = state.chats[currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id].weiboDms.find(convo => convo.fanName === document.getElementById('weibo-dm-detail-title').textContent);
        const fanIdx = state.chats[currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id].weiboDms.indexOf(conversation);

        if (!isNaN(fanIdx) && !isNaN(messageIndex)) {
            handleDeleteWeiboDm(fanIdx, messageIndex);
        }
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲
document.getElementById('clear-all-dms-btn').addEventListener('click', handleClearAllDms);
// 在 init() 的事件监听器区域
// ▼▼▼ 【全新】聊天总结功能事件绑定 ▼▼▼
document.getElementById('view-summaries-btn').addEventListener('click', openSummaryViewer);
document.getElementById('close-summary-viewer-btn').addEventListener('click', () => {
    document.getElementById('summary-viewer-modal').classList.remove('visible');
    // 关闭后重新打开设置弹窗，回到上一级
    document.getElementById('chat-settings-btn').click();
});

// ▼▼▼ 用这块【功能更全】的代码，替换旧的 summary-list 事件监听器 ▼▼▼
// 使用事件委托处理总结列表中的所有按钮
document.getElementById('summary-list').addEventListener('click', (e) => {
    const editBtn = e.target.closest('.edit-summary-btn');
    if (editBtn) {
        const timestamp = parseInt(editBtn.dataset.timestamp);
        editSummary(timestamp);
        return;
    }
    
    const deleteBtn = e.target.closest('.delete-summary-btn');
    if (deleteBtn) {
        const timestamp = parseInt(deleteBtn.dataset.timestamp);
        deleteSummary(timestamp);
        return;
    }

    // 【核心新增】处理单条精简按钮的点击
    const conciseBtn = e.target.closest('.concise-summary-btn');
    if (conciseBtn) {
        const timestamp = parseInt(conciseBtn.dataset.timestamp);
        handleConciseSummary(timestamp);
        return;
    }
});

// 【全新】为“全部精简”按钮绑定事件
document.getElementById('concise-all-summaries-btn').addEventListener('click', handleConciseAllSummaries);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 第3步：用这块【新代码】替换旧的 manual-summary-btn 事件监听器 ▼▼▼
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manual-summary-btn') {
        // 点击后先关闭设置弹窗
        document.getElementById('chat-settings-modal').classList.remove('visible');
        // 【核心修改】调用我们新创建的选择函数，而不是直接总结
        openManualSummaryOptions();
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】这是角色手机外观设置的事件监听器 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    // 使用事件委托，判断点击的是哪个按钮
    if (e.target.id === 'upload-char-phone-wallpaper-btn') {
        document.getElementById('char-phone-wallpaper-upload-input').click();
    } 
    else if (e.target.id === 'remove-char-phone-wallpaper-btn') {
        handleCharPhoneWallpaperChange(''); // 传入空字符串来移除壁纸
    }
    else {
        const changeIconButton = e.target.closest('.change-icon-btn');
        if (changeIconButton) {
            const iconId = changeIconButton.dataset.iconId;
            handleChangeCharPhoneIcon(iconId);
        }
    }
});

// 监听壁纸文件选择
document.getElementById('char-phone-wallpaper-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise(res => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        handleCharPhoneWallpaperChange(dataUrl);
    }
    event.target.value = null; // 清空，以便下次能选择同一个文件
});
// ▲▲▲ 事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】角色微博主页事件监听器 --- */
// ▼▼▼ 在 init() 的事件监听器区域粘贴这段新代码 ▼▼▼

// 为角色微博主页的“关注”和“粉丝”添加点击编辑功能
document.getElementById('weibo-char-profile-page').addEventListener('click', async (e) => {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 判断点击的是否是“关注”区域
    if (e.target.closest('#weibo-char-following-item')) {
        const newFollowing = await showCustomPrompt("编辑关注数", "请输入新的关注数:", chat.settings.weiboFollowingCount);
        if (newFollowing !== null) {
            chat.settings.weiboFollowingCount = newFollowing.trim() || '0';
            await db.chats.put(chat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
    // 判断点击的是否是“粉丝”区域
    else if (e.target.closest('#weibo-char-fans-item')) {
        const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数 (支持'万'/'亿'):", chat.settings.weiboFansCount);
        if (newFans !== null) {
            chat.settings.weiboFansCount = newFans.trim() || '0';
            await db.chats.put(chat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请用下面这块【已修复】的代码，完整替换掉上面那段旧代码 ▼▼▼
document.getElementById('back-from-char-profile').addEventListener('click', () => {
    // 【核心修改】我们不再显示关注列表弹窗，而是直接返回到微博主屏幕
    showScreen('weibo-screen'); 
});
// ▲▲▲ 替换结束 ▲▲▲


// 2. 绑定新页面右上角的编辑按钮
document.getElementById('edit-char-weibo-profile-btn').addEventListener('click', openCharWeiboEditor);

// 3. 绑定角色资料编辑弹窗的按钮
document.getElementById('cancel-char-weibo-editor-btn').addEventListener('click', () => {
    document.getElementById('char-weibo-editor-modal').classList.remove('visible');
});
document.getElementById('save-char-weibo-editor-btn').addEventListener('click', saveCharWeiboProfile);

// 4. 为角色资料编辑弹窗的图片上传绑定事件
setupFileUpload('char-weibo-editor-avatar-input', (base64) => {
    document.getElementById('char-weibo-editor-avatar-preview').src = base64;
});
setupFileUpload('char-weibo-editor-bg-input', (base64) => {
    document.getElementById('char-weibo-editor-bg-preview').src = base64;
});

// 5. 绑定关注列表的点击事件（事件委托）
document.getElementById('weibo-following-list-container').addEventListener('click', (e) => {
    const viewProfileBtn = e.target.closest('.view-profile-btn');
    if (viewProfileBtn && viewProfileBtn.dataset.charId) {
        openWeiboCharProfile(viewProfileBtn.dataset.charId);
    }
});

/* --- 新事件监听结束 --- */
// ▲▲▲ 新增代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】角色微博资料编辑器事件绑定 --- */

// 1. 使用事件委托，为角色微博编辑弹窗内的所有按钮绑定事件
document.getElementById('char-weibo-editor-modal').addEventListener('click', (e) => {
    // a. 如果点击的是“更换头像框”按钮
    if (e.target.classList.contains('change-frame-btn')) {
        const type = e.target.dataset.type; // 获取按钮类型 'char-weibo'
        const targetId = currentViewingWeiboProfileId; // 获取当前正在查看的角色ID
        
        // 调用头像框选择函数，并传入正确的参数
        openFrameSelectorModal(type, targetId);
    }
    // b. 如果点击的是“取消”按钮
    else if (e.target.id === 'cancel-char-weibo-editor-btn') {
        document.getElementById('char-weibo-editor-modal').classList.remove('visible');
    }
    // c. 如果点击的是“保存”按钮
    else if (e.target.id === 'save-char-weibo-editor-btn') {
        saveCharWeiboProfile();
    }
});

// 2. 为角色手机的图片上传输入框绑定事件（这是之前就有的，确保它在正确的位置）
setupFileUpload('char-weibo-editor-avatar-input', (base64) => {
    document.getElementById('char-weibo-editor-avatar-preview').src = base64;
});
setupFileUpload('char-weibo-editor-bg-input', (base64) => {
    document.getElementById('char-weibo-editor-bg-preview').src = base64;
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
        // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这整块新代码 ▼▼▼

        /* --- 【全新】角色手机小组件上传功能事件绑定 --- */

        // 辅助函数：处理图片上传的通用逻辑
        const handleWidgetUpload = async (widgetKey, inputFileId) => {
            const fileInput = document.getElementById(inputFileId);
            const file = fileInput.files[0];
            if (!file) return;

            const dataUrl = await new Promise(res => {
                const reader = new FileReader();
                reader.onload = () => res(reader.result);
                reader.readAsDataURL(file);
            });
            
            const chat = state.chats[activeCharacterPhoneId];
            if (!chat.characterPhoneData.widgets) {
                chat.characterPhoneData.widgets = {};
            }
            chat.characterPhoneData.widgets[widgetKey] = dataUrl;
            
            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen(); // 刷新设置页预览
            openCharacterPhone(activeCharacterPhoneId); // 刷新手机主屏幕
            alert('小组件图片已更新！');
            fileInput.value = null; // 清空以便下次选择
        };

        // 辅助函数：处理图片移除的通用逻辑
        const handleWidgetRemove = async (widgetKey) => {
             const chat = state.chats[activeCharacterPhoneId];
             if (chat.characterPhoneData.widgets && chat.characterPhoneData.widgets[widgetKey]) {
                delete chat.characterPhoneData.widgets[widgetKey];
                await db.chats.put(chat);
                renderCharPhoneAppearanceScreen();
                openCharacterPhone(activeCharacterPhoneId);
                alert('小组件图片已移除！');
             }
        };

        // 为四个新按钮绑定事件
        document.getElementById('upload-widget-1-btn').addEventListener('click', () => {
            document.getElementById('char-phone-widget-1-upload-input').click();
        });
        document.getElementById('remove-widget-1-btn').addEventListener('click', () => {
            handleWidgetRemove('widget1_url');
        });
        document.getElementById('char-phone-widget-1-upload-input').addEventListener('change', () => {
            handleWidgetUpload('widget1_url', 'char-phone-widget-1-upload-input');
        });

        document.getElementById('upload-widget-2-btn').addEventListener('click', () => {
            document.getElementById('char-phone-widget-2-upload-input').click();
        });
        document.getElementById('remove-widget-2-btn').addEventListener('click', () => {
            handleWidgetRemove('widget2_url');
        });
        document.getElementById('char-phone-widget-2-upload-input').addEventListener('change', () => {
            handleWidgetUpload('widget2_url', 'char-phone-widget-2-upload-input');
        });

        /* --- 小组件事件绑定结束 --- */
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 新增事件监听结束 ▲▲▲
// ▼▼▼ 【全新】角色手机外观预设功能事件绑定 ▼▼▼
document.getElementById('char-phone-preset-selector').addEventListener('change', handleCharPhonePresetSelection);
document.getElementById('apply-char-phone-preset-btn').addEventListener('click', applySelectedCharPhonePreset);
document.getElementById('save-char-phone-preset-btn').addEventListener('click', saveCurrentCharPhonePreset);
document.getElementById('update-char-phone-preset-btn').addEventListener('click', updateSelectedCharPhonePreset);
document.getElementById('rename-char-phone-preset-btn').addEventListener('click', renameSelectedCharPhonePreset);
document.getElementById('delete-char-phone-preset-btn').addEventListener('click', deleteSelectedCharPhonePreset);
document.getElementById('export-char-phone-preset-btn').addEventListener('click', exportCharPhonePreset);
document.getElementById('import-char-phone-preset-btn').addEventListener('click', () => {
    document.getElementById('import-char-phone-preset-input').click();
});
document.getElementById('import-char-phone-preset-input').addEventListener('change', (e) => {
    importCharPhonePreset(e.target.files[0]);
    e.target.value = null; // 清空以便下次能选择同一个文件
});
// ▲▲▲ 事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】角色手机App内壁纸功能事件绑定 ▼▼▼

// 监听“上传”按钮的点击，去触发隐藏的文件选择器
document.getElementById('upload-char-phone-app-wallpaper-btn').addEventListener('click', () => {
    document.getElementById('char-phone-app-wallpaper-upload-input').click();
});

// 监听文件选择器的变化
document.getElementById('char-phone-app-wallpaper-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise((res) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        // 文件读取成功后，立刻调用处理函数来保存和应用
        handleCharPhoneAppWallpaperChange(dataUrl);
    }
    event.target.value = null; // 清空，以便下次能选择同一个文件
});

// 监听“移除”按钮的点击
document.getElementById('remove-char-phone-app-wallpaper-btn').addEventListener('click', () => {
    // 调用处理函数，并传入空字符串表示移除
    handleCharPhoneAppWallpaperChange('');
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲
    // 【全新】心声背景更换功能事件监听
    document.getElementById('change-inner-voice-bg-btn').addEventListener('click', handleInnerVoiceBgChange);

    document.getElementById('inner-voice-bg-input').addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        // 将图片文件转换为Base64，以便保存和显示
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.readAsDataURL(file);
        });
        
        // 调用保存函数
        await saveInnerVoiceBackground(dataUrl);

        // 每次用完后清空，以便下次能选择同一个文件
        event.target.value = null; 
    });

// ▲▲▲ 新增代码结束 ▲▲▲

// 情侣空间取消和解除▼▼▼
document.getElementById('ls-cancel-space-btn').addEventListener('click', handleCancelLoversSpace);
document.getElementById('ls-disconnect-space-btn').addEventListener('click', handleDisconnectLoversSpace);
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 在 init() 函数的事件监听器区域粘贴

/* --- 【全新】User微博私信功能事件监听器 --- */

// 1. 微博主页右上角的“私信”按钮
// 我们需要找到这个按钮并给它一个ID
// (假设你在HTML里已经为它设置了id="weibo-my-dms-btn")
// 注意：这个按钮是你需要手动加到 .header-actions 里的
const userDmBtn = document.getElementById('weibo-my-dms-btn');
if (userDmBtn) {
    userDmBtn.addEventListener('click', openUserDmListScreen);
}

// 2. 私信列表页面的返回按钮
document.getElementById('back-from-user-dm-list').addEventListener('click', () => {
    // 返回到微博主页
    showScreen('weibo-screen');
    switchToWeiboView('weibo-my-profile-view');
});

// 3. 私信列表页面的“生成新私信”和“清空”按钮
document.getElementById('generate-new-user-dms-btn').addEventListener('click', () => generateUserDms(true));
document.getElementById('clear-all-user-dms-btn').addEventListener('click', handleClearAllUserDms);

// 4. 使用事件委托处理私信列表的点击，打开聊天详情
document.getElementById('user-dm-list-container').addEventListener('click', (e) => {
    const item = e.target.closest('.dm-list-item');
    if (item && item.dataset.fanIndex) {
        openUserDmDetail(parseInt(item.dataset.fanIndex));
    }
});

// 5. 私信详情页的返回按钮
document.getElementById('back-from-user-dm-detail').addEventListener('click', () => {
    showScreen('user-dm-list-screen'); // 返回到私信列表
});

// 6. 私信详情页的发送按钮和回车发送
document.getElementById('user-dm-send-btn').addEventListener('click', handleSendUserDm);
document.getElementById('user-dm-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('user-dm-send-btn').click();
    }
});

/* --- User微博私信功能事件监听结束 --- */
// 在 init() 的事件监听区域粘贴

// 7. 【新增】绑定私信详情页输入框的两个新按钮
document.getElementById('user-dm-trigger-ai-btn').addEventListener('click', handleTriggerUserDmAiReply);
document.getElementById('user-dm-reroll-btn').addEventListener('click', handleUserDmReroll);
        // ▼▼▼ 【全新】User私信删除功能事件监听器 ▼▼▼
        
        // --- 1. 单条消息删除的事件委托 ---
        document.getElementById('user-dm-messages-container').addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.user-dm-message-delete-btn');
            if (deleteBtn) {
                // currentUserDmFanIndex 是你已有的全局变量，用于记录当前正在看的粉丝索引
                const messageIndex = parseInt(deleteBtn.dataset.messageIndex);
                if (currentUserDmFanIndex !== null && !isNaN(messageIndex)) {
                    handleDeleteUserDmMessage(currentUserDmFanIndex, messageIndex);
                }
            }
        });

        // --- 2. 整个对话左滑删除的事件 ---
        const userDmListEl = document.getElementById('user-dm-list-container');
        let userDmSwipeState = { isDragging: false, startX: 0, activeContent: null };

        // 关闭所有已滑开的项
        function resetAllUserDmSwipes(exceptThisOne = null) {
            document.querySelectorAll('.user-dm-list-item-content.swiped').forEach(content => {
                if (content !== exceptThisOne) {
                    content.classList.remove('swiped');
                }
            });
        }
        
        // 监听鼠标/触摸开始
        userDmListEl.addEventListener('mousedown', (e) => {
            const content = e.target.closest('.user-dm-list-item-content');
            if (content) {
                resetAllUserDmSwipes(content);
                userDmSwipeState = { isDragging: true, startX: e.pageX, activeContent: content };
                e.preventDefault();
            }
        });
        userDmListEl.addEventListener('touchstart', (e) => {
            const content = e.target.closest('.user-dm-list-item-content');
            if (content) {
                resetAllUserDmSwipes(content);
                userDmSwipeState = { isDragging: true, startX: e.touches[0].pageX, activeContent: content };
            }
        }, { passive: true });

        // 监听鼠标/触摸移动
        document.addEventListener('mousemove', (e) => {
            if (!userDmSwipeState.isDragging || !userDmSwipeState.activeContent) return;
            const diffX = e.pageX - userDmSwipeState.startX;
            if (diffX < 0 && diffX > -90) { // 限制最大滑动距离
                userDmSwipeState.activeContent.style.transition = 'none';
                userDmSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
            }
        });
        document.addEventListener('touchmove', (e) => {
             if (!userDmSwipeState.isDragging || !userDmSwipeState.activeContent) return;
             const diffX = e.touches[0].pageX - userDmSwipeState.startX;
             if (diffX < 0 && diffX > -90) {
                 userDmSwipeState.activeContent.style.transition = 'none';
                 userDmSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
             }
        }, { passive: true });

        // 监听鼠标/触摸结束
        const handleUserDmSwipeEnd = (e) => {
            if (!userDmSwipeState.isDragging || !userDmSwipeState.activeContent) return;
            
            const content = userDmSwipeState.activeContent;
            content.style.transition = 'transform 0.3s ease';
            const transformStyle = window.getComputedStyle(content).transform;
            const currentTranslateX = new DOMMatrix(transformStyle).m41;

            if (currentTranslateX < -40) { // 滑动超过一半就自动滑开
                content.classList.add('swiped');
            } else {
                content.classList.remove('swiped');
            }
            content.style.transform = ''; // 清除内联样式

            userDmSwipeState = { isDragging: false, activeContent: null }; // 重置状态
        };
        document.addEventListener('mouseup', handleUserDmSwipeEnd);
        document.addEventListener('touchend', handleUserDmSwipeEnd);
        
        // --- 3. 监听删除按钮的点击 ---
        userDmListEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('swipe-action-btn') && e.target.classList.contains('delete')) {
                const fanIndex = parseInt(e.target.dataset.fanIndex);
                if (!isNaN(fanIndex)) {
                    handleDeleteUserDmConversation(fanIndex);
                }
            }
        });

        // ▲▲▲ User私信删除功能事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这块新代码 ▼▼▼

// ▼▼▼ 请用这块【功能增强版】的代码，完整替换你旧的 'member-management-list' 事件监听器 ▼▼▼
document.getElementById('member-management-list').addEventListener('click', (e) => {
    const button = e.target.closest('.action-btn');
    if (!button) return;

    const action = button.dataset.action;
    const memberId = button.dataset.memberId;

    if (!action || !memberId) return;

    // --- 处理用户自己的按钮 ---
    if (memberId === 'user') {
        if (action === 'set-nickname') handleSetUserNickname();
        if (action === 'set-title') handleSetUserTitle();
        // ★★★ 【核心新增】用户点击自己的“解禁”按钮 ★★★
        if (action === 'unmute-self') { 
            handleUserUnmute();
        }
        return;
    }

    // --- 处理其他成员的按钮 ---
    switch (action) {
        case 'toggle-admin':
            handleToggleAdmin(memberId);
            break;
        case 'set-title':
            handleSetMemberTitle(memberId);
            break;
        case 'transfer-owner':
            handleTransferOwnership(memberId);
            break;
        case 'remove-member':
            removeMemberFromGroup(memberId);
            break;
        case 'mute-member': // ★★★ 禁言/解禁统一走这里 ★★★
            handleMuteMember(memberId);
            break;
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】群公告功能事件绑定 ▼▼▼
document.getElementById('group-announcement-btn').addEventListener('click', openGroupAnnouncementModal);
// ▲▲▲ 事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听区域添加 ▼▼▼
// 绑定用户表情面板的批量删除按钮
document.getElementById('edit-user-stickers-btn').addEventListener('click', toggleUserStickerSelectionMode);
document.getElementById('done-user-stickers-btn').addEventListener('click', toggleUserStickerSelectionMode);
document.getElementById('delete-selected-user-stickers-btn').addEventListener('click', handleBulkDeleteUserStickers);

// 【重要】关闭面板时，也要退出选择模式
document.getElementById('close-sticker-panel-btn').addEventListener('click', () => {
    exitUserStickerSelectionMode();
    stickerPanel.classList.remove('visible');
});

// 在 init() 函数中
            // ▼▼▼ 请将这整块【全新的、修复后的代码】粘贴到原来的位置 ▼▼▼

            // 辅助函数：处理删除分类按钮的点击
            function onStickerCategoryDelete(deleteButtonElement) {
                const categoryId = parseInt(deleteButtonElement.dataset.categoryId);
                const categoryName = deleteButtonElement.dataset.categoryName;

                // *** 调试关键点 (Debugging Point) ***
                // 请在浏览器中按 F12 打开开发者工具，切换到 "Console" (控制台) 标签页。
                // 点击删除按钮后，在这里查看输出的ID和名称是否是您点击的那一个。
                console.log(`[调试] 准备删除分类: ID=${categoryId}, 名称='${categoryName}'`);

                if (!isNaN(categoryId) && categoryName) {
                    handleDeleteStickerCategory(categoryId, categoryName);
                } else {
                    console.error("[错误] 无法从按钮获取有效的分类ID或名称。", deleteButtonElement.dataset);
                    alert("删除失败：无法获取分类信息，请检查代码或刷新页面。");
                }
            }

            // 辅助函数：处理切换分类按钮的点击
            function onStickerCategorySelect(categoryButtonElement) {
                const categoryIdStr = categoryButtonElement.dataset.categoryId;
                activeStickerCategoryId = (categoryIdStr === 'uncategorized') ? 'uncategorized' : parseInt(categoryIdStr);
                renderStickerPanel(); // 切换分类并重新渲染表情列表
            }





// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听区域添加 ▼▼▼
// 绑定角色表情管理页的批量删除按钮
document.getElementById('edit-char-stickers-btn').addEventListener('click', toggleCharStickerSelectionMode);
document.getElementById('done-char-stickers-btn').addEventListener('click', toggleCharStickerSelectionMode);
document.getElementById('delete-selected-char-stickers-btn').addEventListener('click', handleBulkDeleteCharStickers);

// 【重要】返回聊天设置时，也要退出选择模式
document.getElementById('back-from-sticker-manager').addEventListener('click', () => {
    exitCharStickerSelectionMode();
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 添加结束 ▲▲▲
        // ▼▼▼ 【全新】这是为心声面板编辑按钮新增的事件监听 ▼▼▼
        document.getElementById('inner-voice-modal').addEventListener('click', (e) => {
            if (e.target.closest('#inner-voice-edit-btn')) {
                showInnerVoiceEditOptions();
            }
        });
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】心声样式编辑器事件绑定 ▼▼▼
const ivEditorModal = document.getElementById('inner-voice-editor-modal');
const ivPanel = document.getElementById('inner-voice-main-panel');

// 实时预览功能
ivEditorModal.addEventListener('input', (e) => {
    const targetId = e.target.id;
    const value = e.target.value;

    switch (targetId) {
        case 'iv-color-clothing':
            ivPanel.style.setProperty('--iv-color-clothing', value);
            break;
        case 'iv-color-behavior':
            ivPanel.style.setProperty('--iv-color-behavior', value);
            break;
        case 'iv-color-thoughts':
            ivPanel.style.setProperty('--iv-color-thoughts', value);
            break;
        case 'iv-color-naughty':
            ivPanel.style.setProperty('--iv-color-naughty', value);
            break;
        case 'iv-card-bg-color':
            ivPanel.style.setProperty('--iv-card-bg-rgb', hexToRgb(value));
            break;
        case 'iv-opacity-slider':
            document.getElementById('iv-opacity-value').textContent = `${Math.round(value * 100)}%`;
            ivPanel.style.setProperty('--iv-card-opacity', value);
            break;
                // ★★★ 在这里添加下面的新 case ★★★
        case 'iv-icon-color':
            ivPanel.style.setProperty('--iv-icon-color', value);
            break;
    }
});

// 保存按钮
document.getElementById('iv-editor-save-btn').addEventListener('click', saveInnerVoiceStyles);

// 取消按钮
document.getElementById('iv-editor-cancel-btn').addEventListener('click', () => {
    ivEditorModal.classList.remove('visible');
    // 取消时，重新应用一下保存好的样式，以撤销预览改动
    applySavedInnerVoiceStyles();
});

// ▲▲▲ 新增事件监听器结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域粘贴这段新代码 ▼▼▼

// 【全新】AI生成群成员功能事件绑定
document.getElementById('ai-generate-members-btn').addEventListener('click', openAiGenerateMembersModal);
document.getElementById('cancel-ai-generate-members-btn').addEventListener('click', () => {
    document.getElementById('ai-generate-members-modal').classList.remove('visible');
});
document.getElementById('confirm-ai-generate-members-btn').addEventListener('click', handleGenerateMembers);
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

// ▼▼▼ 在 init() 的事件监听器区域末尾，用这整块新代码替换旧的 ▼▼▼

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】约会大作战功能事件监听器 --- */
document.getElementById('date-a-live-app-icon').addEventListener('click', openDatingApp);
document.getElementById('refresh-dating-scene-btn').addEventListener('click', refreshDatingScenes);
document.getElementById('end-date-btn').addEventListener('click', endDate); // 绑定结束约会按钮

// ▼▼▼ 在 init() 的事件监听器区域，用这块【新代码】替换旧的 'dating-scene-content' 事件监听器 ▼▼▼

// 使用事件委托处理删除和点击
document.getElementById('dating-scene-content').addEventListener('click', (e) => {
    const card = e.target.closest('.dating-scene-card');
    if (!card) return;

    const sceneUid = card.dataset.uid;
    const scene = currentDatingScenes.find(s => s.uid === sceneUid);
    if (!scene) return;
    
    // 如果点击的是删除按钮
    if (e.target.classList.contains('dating-scene-delete-btn')) {
        deleteDatingScene(sceneUid);
    } else {
        // 否则，点击的是卡片本身，打开角色选择器
        openDatingCharacterSelector(scene);
    }
});
// ▲▲▲ 新增/修改事件绑定结束 ▲▲▲


// ▼▼▼ 在 init() 的事件监听器区域，用这块【新代码】替换旧的【文游文本框点击事件】 ▼▼▼

// ▼▼▼ 在 init() 函数中，用这段新代码替换旧的文本框点击事件 ▼▼▼

// 为文游文本框绑定“点击切换下一句”的事件 (已增加保护)
document.querySelector('.dating-game-textbox').addEventListener('click', () => {
    if (
        datingGameState.isActive && 
        !datingGameState.isSwitchingSentence && // 新增：检查是否正在切换中
        datingGameState.currentSentenceIndex < datingGameState.sentences.length - 1
    ) {
        showNextSentence();
    }
});

// ▲▲▲ 替换结束 ▲▲▲



// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新增代码粘贴结束 ▲▲▲



/* --- 事件监听结束 --- */
// ▲▲▲ 替换结束 ▲▲▲


/* --- 事件监听结束 --- */
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】约会大作战-文游模式UI事件绑定 --- */

// 右上角图标
document.getElementById('dating-game-settings-btn').addEventListener('click', openDatingSettingsModal);
document.getElementById('dating-game-reroll-btn').addEventListener('click', handleDatingReroll);

// 设置弹窗内的按钮
document.getElementById('cancel-dating-settings-btn').addEventListener('click', () => {
    document.getElementById('dating-game-settings-modal').classList.remove('visible');
    // 取消时，要恢复到角色已保存的设置，而不是停在临时修改的状态
    const chat = state.chats[datingGameState.characterId];
    currentDatingUISettings = JSON.parse(JSON.stringify(chat.settings.datingUISettings || {}));
    applyDatingUISettings();
});
document.getElementById('save-dating-settings-btn').addEventListener('click', saveDatingSettings);

// 图片上传按钮
document.querySelector('#dating-game-settings-modal .bg-upload-container button').addEventListener('click', () => handleDatingImageUpload('bg'));
document.querySelector('#dating-game-settings-modal .form-group:nth-of-type(5) .bg-upload-container button').addEventListener('click', () => handleDatingImageUpload('sprite'));

// 图片URL输入实时更新
document.getElementById('dating-bg-url-input').addEventListener('input', (e) => {
    currentDatingUISettings.backgroundUrl = e.target.value.trim();
    applyDatingUISettings();
});
// ▼▼▼ 在 init() 的事件监听器区域，粘贴这整块新代码 ▼▼▼

/* --- 【全新】约会立绘功能事件监听器 --- */
document.getElementById('manage-sprite-groups-btn').addEventListener('click', openSpriteGroupManager);
document.getElementById('close-sprite-group-manager-btn').addEventListener('click', () => {
    document.getElementById('sprite-group-manager-modal').classList.remove('visible');
});

document.getElementById('sprite-group-list-container').addEventListener('click', (e) => {
    const target = e.target;
    if (target.tagName === 'BUTTON' && target.dataset.id) {
        const action = target.dataset.action;
        const groupId = parseInt(target.dataset.id);
        if (action === 'edit') {
            openSpriteEditor(groupId);
        } else if (action === 'delete') {
            deleteSpriteGroup(groupId);
        }
    }
});

document.getElementById('create-new-sprite-group-btn').addEventListener('click', () => openSpriteEditor());

document.getElementById('cancel-sprite-editor-btn').addEventListener('click', () => {
    document.getElementById('sprite-editor-modal').classList.remove('visible');
});

document.getElementById('save-sprite-editor-btn').addEventListener('click', saveSpriteGroup);

document.getElementById('add-new-sprite-btn').addEventListener('click', () => {
    document.getElementById('sprite-list-editor').appendChild(createSpriteEditCard());
});
/* --- 约会立绘事件监听器结束 --- */

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// 预设功能按钮
document.getElementById('dating-preset-select').addEventListener('change', handleDatingPresetSelect);
document.getElementById('manage-dating-presets-btn').addEventListener('click', openDatingPresetManager);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】约会结算卡片事件绑定 ▼▼▼

/* --- 约会结算卡片事件绑定 --- */
const summaryCard = document.querySelector('.dating-summary-card');
const summaryCardBackBtn = document.getElementById('summary-flip-back-btn');

// 1. 点击卡片正面或背面的返回按钮，都会触发翻转
summaryCard.addEventListener('click', (e) => {
    // 确保点击的不是分享或关闭按钮
    if (!e.target.closest('button')) {
        summaryCard.classList.toggle('is-flipped');
    }
});
summaryCardBackBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡到父元素
    summaryCard.classList.remove('is-flipped');
});

// 2. 分享按钮
document.getElementById('summary-share-btn').addEventListener('click', shareDatingSummary);

// 3. 关闭按钮 (已修复，支持不同场景)
document.getElementById('summary-close-btn').addEventListener('click', async () => {
    if (datingGameState.isActive) {
        // 如果在约会中，走原来的确认并结束约会的流程
        const confirmed = await showCustomConfirm(
            '确认关闭',
            '确定要关闭结算卡片吗？关闭后约会即告结束。',
            { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) {
            finalizeAndExitDate();
        }
    } else {
        // 如果只是在单聊里查看分享，直接关闭弹窗即可
        document.getElementById('dating-summary-overlay').classList.remove('visible');
        // 同时重置卡片翻转状态，以防下次打开有问题
        const card = document.querySelector('.dating-summary-card');
        if (card) {
            card.classList.remove('is-flipped');
        }
    }
});



// 4. 聊天记录中的卡片点击事件（事件委托）
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const chatCard = e.target.closest('.dating-summary-chat-card');
    // ▼▼▼【核心修复】我们现在检查 data-timestamp ▼▼▼
    if (chatCard && chatCard.dataset.timestamp) {
        try {
            const timestamp = parseInt(chatCard.dataset.timestamp);
            const chat = state.chats[state.activeChatId];
            
            // 用时间戳从聊天记录里找到那条原始消息
            const message = chat.history.find(m => m.timestamp === timestamp);
            
            // 如果找到了，直接用它的 payload
            if (message && message.payload) {
                reopenDatingSummary(message.payload);
            } else {
                // 如果因为某种原因没找到，再给一个提示
                alert("无法找到对应的约会记录数据。");
            }
        } catch (error) {
            // 这个catch现在几乎不会触发了，但保留着以防万一
            console.error("打开分享的约会记录失败:", error);
            alert("打开约会记录时发生未知错误。");
        }
    }
});

// ▼▼▼ 【全新】约会历史记录功能事件绑定 ▼▼▼

// 1. 为“约会大作战”主界面的“历史”图标绑定打开事件
document.getElementById('dating-history-btn').addEventListener('click', openDatingHistory);

// 2. 为“历史约会”页面的返回按钮绑定返回事件
document.getElementById('dating-history-back-btn').addEventListener('click', () => showScreen('date-a-live-screen'));

// 3. 使用事件委托，为历史列表中的所有卡片绑定“翻转”事件
document.getElementById('dating-history-list').addEventListener('click', e => {
    // 找到被点击的卡片
    const card = e.target.closest('.dating-summary-card');
    if (card) {
        // 切换 is-flipped 类即可触发CSS动画
        card.classList.toggle('is-flipped');
    }
});

// ▼▼▼ 【全新】约会大作战-创建场景功能事件绑定 ▼▼▼
document.getElementById('create-dating-scene-btn').addEventListener('click', () => {
    // 打开创建弹窗，并清空输入框
    document.getElementById('scene-name-input').value = '';
    document.getElementById('scene-image-url-input').value = '';
    document.getElementById('scene-cost-input').value = '';
    document.getElementById('create-dating-scene-modal').classList.add('visible');
});

document.getElementById('cancel-create-scene-btn').addEventListener('click', () => {
    document.getElementById('create-dating-scene-modal').classList.remove('visible');
});

document.getElementById('save-custom-scene-btn').addEventListener('click', handleSaveCustomDatingScene);


/* --- 约会结算事件绑定结束 --- */


// --- 表情分类功能事件绑定 ---
document.getElementById('move-selected-stickers-btn').addEventListener('click', openStickerCategoryModal);
document.getElementById('cancel-sticker-category-btn').addEventListener('click', () => {
    document.getElementById('sticker-category-modal').classList.remove('visible');
});
document.getElementById('confirm-sticker-category-btn').addEventListener('click', handleMoveStickers);
// ▼▼▼ 【全新】高级导入/导出功能事件监听器 v2.0 ▼▼▼
document.getElementById('advanced-transfer-btn').addEventListener('click', openAdvancedTransferModal);

document.getElementById('close-advanced-transfer-btn').addEventListener('click', () => {
    document.getElementById('advanced-transfer-modal').classList.remove('visible');
});

document.getElementById('export-selected-data-btn').addEventListener('click', exportChunkedData);

document.getElementById('import-chunked-data-btn').addEventListener('click', () => {
    document.getElementById('import-chunked-data-input').click();
});

document.getElementById('import-chunked-data-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importChunkedData(file);
    }
    e.target.value = null; // 清空以便下次选择
});
document.getElementById('export-for-330-btn').addEventListener('click', exportDataFor330);

// 【全新】为“兼容330格式导入”按钮绑定事件
document.getElementById('import-from-330-btn').addEventListener('click', () => {
    // 点击按钮时，触发隐藏的文件选择器
    document.getElementById('import-from-330-input').click();
});

// 为隐藏的文件选择器绑定change事件
document.getElementById('import-from-330-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        // 当用户选择了文件后，调用我们的核心导入函数
        importFrom330Format(file);
    }
    // 每次用完后清空，这样用户下次还能选择同一个文件
    e.target.value = null;
});

document.getElementById('compress-all-images-btn').addEventListener('click', compressAllImagesInDB);
document.getElementById('export-data-stream-btn').addEventListener('click', exportDataStream);
// 在 init() 函数的事件监听器区域末尾，粘贴下面这行代码
document.getElementById('reset-app-names-btn').addEventListener('click', resetAppNamesToDefault);

// ▼▼▼ 跨设备数据同步功能实现 ▼▼▼
// 同步配置管理
const syncConfig = {
    method: '', // 'webdav' 或 'github'
    webdav: {
        url: '',
        username: '',
        password: ''
    },
    github: {
        token: '',
        gistId: ''
    },
    syncFilename: 'gemini_chat_sync', // 自定义文件名（不包含.json后缀）
    autoSync: false,
    syncInterval: 5, // 分钟
    lastSyncTime: null,
    syncTimerId: null
};

// 从localStorage加载同步配置
function loadSyncConfig() {
    const saved = localStorage.getItem('crossDeviceSyncConfig');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            Object.assign(syncConfig, parsed);
        } catch (e) {
            console.error('加载同步配置失败:', e);
        }
    }
}

// 保存同步配置到localStorage
function saveSyncConfigToStorage() {
    localStorage.setItem('crossDeviceSyncConfig', JSON.stringify(syncConfig));
}

// 更新同步状态显示
function updateSyncStatusDisplay(message, isError = false) {
    const statusEl = document.getElementById('sync-status-display');
    if (statusEl) {
        statusEl.textContent = message;
        statusEl.style.color = isError ? '#ff6b6b' : 'var(--text-secondary)';
    }
}

// 导出所有数据库数据
async function exportAllData() {
    const data = {
        timestamp: Date.now(),
        version: 1,
        tables: {}
    };
    
    // 导出所有表的数据
    const tableNames = db.tables.map(t => t.name);
    for (const tableName of tableNames) {
        try {
            data.tables[tableName] = await db[tableName].toArray();
        } catch (e) {
            console.error(`导出表 ${tableName} 失败:`, e);
        }
    }
    
    return data;
}

// 导入所有数据到数据库
async function importAllData(data) {
    if (!data || !data.tables) {
        throw new Error('无效的数据格式');
    }
    
    // 导入所有表的数据
    for (const [tableName, tableData] of Object.entries(data.tables)) {
        if (db[tableName] && Array.isArray(tableData)) {
            try {
                await db[tableName].clear();
                if (tableData.length > 0) {
                    await db[tableName].bulkPut(tableData);
                }
            } catch (e) {
                console.error(`导入表 ${tableName} 失败:`, e);
            }
        }
    }
}

// WebDAV 同步实现
async function syncViaWebDAV(isUpload) {
    const { url, username, password } = syncConfig.webdav;
    
    if (!url) {
        throw new Error('请配置WebDAV服务器地址');
    }
    
    const fileName = 'gemini_chat_sync.json';
    const fullUrl = url.endsWith('/') ? url + fileName : url + '/' + fileName;
    const auth = 'Basic ' + btoa(username + ':' + password);
    
    if (isUpload) {
        // 上传数据
        const data = await exportAllData();
        const response = await fetch(fullUrl, {
            method: 'PUT',
            headers: {
                'Authorization': auth,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            throw new Error(`上传失败: ${response.status} ${response.statusText}`);
        }
        
        syncConfig.lastSyncTime = Date.now();
        saveSyncConfigToStorage();
        return { success: true, message: '数据已上传到云端' };
    } else {
        // 下载数据
        const response = await fetch(fullUrl, {
            method: 'GET',
            headers: {
                'Authorization': auth
            }
        });
        
        if (response.status === 404) {
            // 文件不存在，执行首次上传
            return await syncViaWebDAV(true);
        }
        
        if (!response.ok) {
            throw new Error(`下载失败: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // 比较时间戳，决定是否需要更新
        const remoteTime = data.timestamp || 0;
        const localTime = syncConfig.lastSyncTime || 0;
        
        if (remoteTime > localTime) {
            await importAllData(data);
            syncConfig.lastSyncTime = remoteTime;
            saveSyncConfigToStorage();
            return { success: true, message: '已从云端同步最新数据' };
        } else if (localTime > remoteTime) {
            // 本地数据更新，上传到云端
            return await syncViaWebDAV(true);
        } else {
            return { success: true, message: '数据已是最新' };
        }
    }
}

// GitHub Gist 同步实现
async function syncViaGitHub(isUpload) {
    const { token, gistId } = syncConfig.github;
    
    if (!token) {
        throw new Error('请配置GitHub Token');
    }
    
    const headers = {
        'Authorization': `token ${token}`,
        'Content-Type': 'application/json',
        'Accept': 'application/vnd.github.v3+json'
    };
    
    if (isUpload || !gistId) {
        // 上传数据或创建新Gist
        const data = await exportAllData();
        const gistData = {
            description: 'Gemini Chat App - Cross-Device Sync Data',
            public: false,
            files: {
                'sync_data.json': {
                    content: JSON.stringify(data)
                }
            }
        };
        
        let response;
        if (gistId) {
            // 更新现有Gist
            response = await fetch(`https://api.github.com/gists/${gistId}`, {
                method: 'PATCH',
                headers: headers,
                body: JSON.stringify(gistData)
            });
        } else {
            // 创建新Gist
            response = await fetch('https://api.github.com/gists', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(gistData)
            });
        }
        
        if (!response.ok) {
            throw new Error(`上传失败: ${response.status} ${response.statusText}`);
        }
        
        const result = await response.json();
        if (!gistId) {
            syncConfig.github.gistId = result.id;
            document.getElementById('github-gist-id-input').value = result.id;
        }
        
        syncConfig.lastSyncTime = Date.now();
        saveSyncConfigToStorage();
        return { success: true, message: '数据已上传到GitHub' };
    } else {
        // 下载数据
        const response = await fetch(`https://api.github.com/gists/${gistId}`, {
            method: 'GET',
            headers: headers
        });
        
        if (!response.ok) {
            throw new Error(`下载失败: ${response.status} ${response.statusText}`);
        }
        
        const gist = await response.json();
        const fileContent = gist.files['sync_data.json']?.content;
        
        if (!fileContent) {
            throw new Error('Gist中未找到同步数据');
        }
        
        const data = JSON.parse(fileContent);
        
        // 比较时间戳
        const remoteTime = data.timestamp || 0;
        const localTime = syncConfig.lastSyncTime || 0;
        
        if (remoteTime > localTime) {
            await importAllData(data);
            syncConfig.lastSyncTime = remoteTime;
            saveSyncConfigToStorage();
            return { success: true, message: '已从GitHub同步最新数据' };
        } else if (localTime > remoteTime) {
            return await syncViaGitHub(true);
        } else {
            return { success: true, message: '数据已是最新' };
        }
    }
}

// 执行同步
async function performSync(showAlert = true) {
    try {
        updateSyncStatusDisplay('正在同步...', false);
        
        let result;
        if (syncConfig.method === 'webdav') {
            result = await syncViaWebDAV(false);
        } else if (syncConfig.method === 'github') {
            result = await syncViaGitHub(false);
        } else {
            throw new Error('未配置同步方式');
        }
        
        const timeStr = new Date().toLocaleTimeString('zh-CN');
        updateSyncStatusDisplay(`同步成功 (${timeStr}): ${result.message}`, false);
        
        if (showAlert) {
            alert('同步成功！\n' + result.message);
        }
    } catch (error) {
        console.error('同步失败:', error);
        updateSyncStatusDisplay(`同步失败: ${error.message}`, true);
        
        if (showAlert) {
            alert('同步失败：\n' + error.message);
        }
    }
}

// 启动自动同步（仅限GitHub方式）
function startAutoSync() {
    stopAutoSync();
    
    if (syncConfig.autoSync && syncConfig.method === 'github') {
        const intervalMs = syncConfig.syncInterval * 60 * 1000;
        syncConfig.syncTimerId = setInterval(() => {
            performSync(false);
        }, intervalMs);
        
        // 立即执行一次同步
        performSync(false);
    }
}

// 停止自动同步
function stopAutoSync() {
    if (syncConfig.syncTimerId) {
        clearInterval(syncConfig.syncTimerId);
        syncConfig.syncTimerId = null;
    }
}

// UI事件监听器
document.getElementById('sync-method-select').addEventListener('change', function() {
    const method = this.value;
    document.getElementById('folder-config').style.display = method === 'folder' ? 'block' : 'none';
    document.getElementById('github-config').style.display = method === 'github' ? 'block' : 'none';
    
    // 云盘文件夹方式不支持自动同步
    const autoSyncContainer = document.querySelector('.setting-item:has(#auto-sync-checkbox)');
    if (autoSyncContainer) {
        autoSyncContainer.style.display = method === 'github' ? 'block' : 'none';
    }
});

document.getElementById('auto-sync-checkbox').addEventListener('change', function() {
    document.getElementById('sync-interval-container').style.display = this.checked ? 'block' : 'none';
});

// 使用说明按钮
document.getElementById('sync-help-btn').addEventListener('click', function() {
    const helpMessage = `
🔄 跨设备数据同步 - 使用说明

━━━━━━━━━━━━━━━━━━━━━━━━
📌 功能介绍
━━━━━━━━━━━━━━━━━━━━━━━━

这个功能可以帮你在多个设备间同步聊天记录、应用配置、提示词等所有数据。支持两种方式：

1️⃣ 云盘文件夹方式（推荐新手）
   ✅ 简单易用，无需额外配置
   ✅ 支持所有主流云盘
   ❌ 需要手动导入导出

2️⃣ GitHub Gist方式（推荐技术用户）
   ✅ 自动同步，无需手动操作
   ✅ 支持定时自动同步
   ❌ 需要GitHub账号和Token

━━━━━━━━━━━━━━━━━━━━━━━━
📁 云盘文件夹方式详细步骤
━━━━━━━━━━━━━━━━━━━━━━━━

【第一步】在设备A上导出数据
1. 选择"云同步文件夹"方式
2. 自定义文件名（可选，默认为gemini_chat_sync）
3. 点击"保存同步配置"
4. 点击"💾 导出同步文件"
5. 将下载的JSON文件保存到云盘同步文件夹
   例如：D:\\百度网盘\\兔K同步\\

【第二步】等待云盘自动同步
云盘客户端会自动将文件同步到其他设备

【第三步】在设备B上导入数据
1. 选择"云同步文件夹"方式
2. 点击"📥 导入同步文件"
3. 选择从云盘同步文件夹中的JSON文件
4. 导入完成！

💡 提示：
• 建议使用相同的文件名，方便识别
• 定期导出可以作为数据备份
• 支持的云盘：百度网盘、OneDrive、Google Drive、Dropbox、坚果云、iCloud Drive等

━━━━━━━━━━━━━━━━━━━━━━━━
🔧 GitHub Gist方式详细步骤
━━━━━━━━━━━━━━━━━━━━━━━━

【准备工作】
1. 注册GitHub账号（如果没有）
2. 创建Personal Access Token：
   • 访问：https://github.com/settings/tokens/new
   • 勾选"gist"权限
   • 生成并复制Token（形如：ghp_xxxxxxxxxxxx）

【配置步骤】
1. 选择"Git仓库 (GitHub Gist)"方式
2. 粘贴你的GitHub Token
3. Gist ID留空（首次使用会自动创建）
4. 勾选"启用自动同步"（可选）
5. 设置同步间隔（建议5-15分钟）
6. 点击"保存同步配置"

【在其他设备上】
1. 使用相同的GitHub Token
2. 填入第一个设备生成的Gist ID
   （可以在GitHub的Gist页面查看）
3. 保存配置即可自动同步

💡 提示：
• Token要妥善保管，不要泄露
• 自动同步需要保持页面打开
• 数据加密存储在你的GitHub账号中

━━━━━━━━━━━━━━━━━━━━━━━━
❓ 常见问题
━━━━━━━━━━━━━━━━━━━━━━━━

Q: 两种方式有什么区别？
A: 云盘方式简单但需手动操作；GitHub方式可以自动同步但需要配置。

Q: 数据安全吗？
A: 云盘方式数据存储在你的云盘；GitHub方式数据存储在你的私有Gist中，都是安全的。

Q: 可以同时使用两种方式吗？
A: 可以，但建议选择一种，避免数据冲突。

Q: 同步会覆盖现有数据吗？
A: 是的，导入时会替换现有数据。建议先备份。

Q: 自定义文件名有什么用？
A: 可以使用有意义的名称，比如"我的兔K数据_2024"，方便识别和管理多个备份文件。

━━━━━━━━━━━━━━━━━━━━━━━━

需要更多帮助？欢迎反馈！
`.trim();
    
    alert(helpMessage);
});

// 云文件夹导出按钮
document.getElementById('folder-export-btn').addEventListener('click', async function() {
    try {
        updateSyncStatusDisplay('正在导出数据...', false);
        
        // 获取自定义文件名
        let filename = document.getElementById('sync-filename-input').value.trim() || 'gemini_chat_sync';
        // 确保文件名合法（移除不合法字符）
        filename = filename.replace(/[\\/:*?"<>|]/g, '_');
        const fullFilename = filename + '.json';
        
        const data = await exportAllData();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fullFilename;
        a.click();
        URL.revokeObjectURL(url);
        updateSyncStatusDisplay('导出成功！请将文件保存到云盘同步文件夹', false);
        alert(`导出成功！\n\n请将 ${fullFilename} 文件保存到你的云盘同步文件夹（如 D:\\百度网盘\\兔K同步\\）\n\n云盘将自动同步到其他设备，然后在其他设备上导入即可。`);
    } catch (err) {
        updateSyncStatusDisplay('导出失败: ' + err.message, true);
        alert('导出失败: ' + err.message);
    }
});

// 云文件夹导入按钮
document.getElementById('folder-import-btn').addEventListener('click', function() {
    document.getElementById('folder-import-input').click();
});

// 云文件夹导入文件选择
document.getElementById('folder-import-input').addEventListener('change', async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
        updateSyncStatusDisplay('正在导入数据...', false);
        const text = await file.text();
        const data = JSON.parse(text);
        await importAllData(data);
        updateSyncStatusDisplay('导入成功！数据已同步', false);
        alert('导入成功！数据已从云盘同步到本地。');
        // 清空文件选择器
        e.target.value = '';
    } catch (err) {
        updateSyncStatusDisplay('导入失败: ' + err.message, true);
        alert('导入失败: ' + err.message);
        e.target.value = '';
    }
});

document.getElementById('save-sync-config-btn').addEventListener('click', function() {
    // 保存配置
    syncConfig.method = document.getElementById('sync-method-select').value;
    syncConfig.github.token = document.getElementById('github-token-input').value.trim();
    syncConfig.github.gistId = document.getElementById('github-gist-id-input').value.trim();
    syncConfig.autoSync = document.getElementById('auto-sync-checkbox').checked;
    syncConfig.syncInterval = parseInt(document.getElementById('sync-interval-input').value) || 5;
    
    // 保存自定义文件名
    let filename = document.getElementById('sync-filename-input').value.trim() || 'gemini_chat_sync';
    filename = filename.replace(/[\\/:*?"<>|]/g, '_'); // 移除不合法字符
    syncConfig.syncFilename = filename;
    document.getElementById('sync-filename-input').value = filename; // 更新显示
    
    saveSyncConfigToStorage();
    
    // 重启自动同步（仅限GitHub方式）
    if (syncConfig.method === 'github' && syncConfig.autoSync) {
        startAutoSync();
    } else {
        stopAutoSync();
    }
    
    updateSyncStatusDisplay('配置已保存', false);
    alert('同步配置已保存！');
});

document.getElementById('manual-sync-btn').addEventListener('click', function() {
    if (!syncConfig.method) {
        alert('请先配置同步方式');
        return;
    }
    performSync(true);
});

// 页面加载时初始化
function initCrossDeviceSync() {
    loadSyncConfig();
    
    // 恢复UI状态
    document.getElementById('sync-method-select').value = syncConfig.method || '';
    document.getElementById('github-token-input').value = syncConfig.github.token || '';
    document.getElementById('github-gist-id-input').value = syncConfig.github.gistId || '';
    document.getElementById('auto-sync-checkbox').checked = syncConfig.autoSync || false;
    document.getElementById('sync-interval-input').value = syncConfig.syncInterval || 5;
    document.getElementById('sync-filename-input').value = syncConfig.syncFilename || 'gemini_chat_sync';
    
    // 显示对应的配置区域
    document.getElementById('folder-config').style.display = syncConfig.method === 'folder' ? 'block' : 'none';
    document.getElementById('github-config').style.display = syncConfig.method === 'github' ? 'block' : 'none';
    document.getElementById('sync-interval-container').style.display = syncConfig.autoSync ? 'block' : 'none';
    
    // 云盘文件夹方式不支持自动同步
    const autoSyncContainer = document.querySelector('.setting-item:has(#auto-sync-checkbox)');
    if (autoSyncContainer) {
        autoSyncContainer.style.display = syncConfig.method === 'github' ? 'block' : 'none';
    }
    
    // 更新状态显示
    if (syncConfig.method) {
        const methodName = syncConfig.method === 'folder' ? '云盘文件夹' : 'GitHub Gist';
        updateSyncStatusDisplay(`已配置: ${methodName} ${syncConfig.autoSync ? '(自动同步已启用)' : ''}`, false);
    } else {
        updateSyncStatusDisplay('同步状态：未配置', false);
    }
    
    // 启动自动同步（仅限GitHub方式）
    if (syncConfig.autoSync && syncConfig.method === 'github') {
        startAutoSync();
    }
}

// 监听数据库变化，触发自动同步（仅限GitHub方式）
let syncDebounceTimer = null;
function triggerAutoSyncOnChange() {
    if (!syncConfig.autoSync || syncConfig.method !== 'github') {
        return;
    }
    
    // 防抖：数据变化后等待3秒，如果3秒内没有新的变化，则触发同步
    if (syncDebounceTimer) {
        clearTimeout(syncDebounceTimer);
    }
    
    syncDebounceTimer = setTimeout(() => {
        console.log('检测到数据变化，触发自动同步...');
        performSync(false);
    }, 3000);
}

// 包装数据库操作，在操作后触发同步
const originalDbPut = {};
const originalDbBulkPut = {};
const originalDbDelete = {};

function wrapDatabaseOperations() {
    db.tables.forEach(table => {
        // 保存原始方法
        if (!originalDbPut[table.name]) {
            originalDbPut[table.name] = table.put.bind(table);
            originalDbBulkPut[table.name] = table.bulkPut.bind(table);
            originalDbDelete[table.name] = table.delete.bind(table);
            
            // 包装 put 方法
            table.put = async function(...args) {
                const result = await originalDbPut[table.name](...args);
                triggerAutoSyncOnChange();
                return result;
            };
            
            // 包装 bulkPut 方法
            table.bulkPut = async function(...args) {
                const result = await originalDbBulkPut[table.name](...args);
                triggerAutoSyncOnChange();
                return result;
            };
            
            // 包装 delete 方法
            table.delete = async function(...args) {
                const result = await originalDbDelete[table.name](...args);
                triggerAutoSyncOnChange();
                return result;
            };
        }
    });
}

// 在页面加载完成后初始化
setTimeout(() => {
    initCrossDeviceSync();
    // 包装数据库操作以支持自动同步
    wrapDatabaseOperations();
}, 1000);
// ▲▲▲ 跨设备数据同步功能实现结束 ▲▲▲

document.addEventListener("DOMContentLoaded", function () {
    const toggleCheckbox = document.getElementById("dark-mode-toggle");
    const storageKey = 'darkModeManualPref'; 
    const darkReaderOptions = {
        brightness: 100,
        contrast: 90,
        sepia: 10
    };
    const manualPref = localStorage.getItem(storageKey);
    if (manualPref === 'true') {
        DarkReader.enable(darkReaderOptions);
        toggleCheckbox.checked = true;
    } else if (manualPref === 'false') {
        DarkReader.disable();
        toggleCheckbox.checked = false;
    } else {
        DarkReader.auto(darkReaderOptions);
        setTimeout(() => {
            toggleCheckbox.checked = DarkReader.isEnabled();
        }, 100); 
    }
    toggleCheckbox.addEventListener("change", function () {  
        if (this.checked) {
            DarkReader.enable(darkReaderOptions);
            localStorage.setItem(storageKey, 'true');
        } else {
            DarkReader.disable();
            localStorage.setItem(storageKey, 'false');
        }
    });
});
// ▼▼▼ 用这块【修复后】的代码替换旧的 sticker-category-tabs 监听器 ▼▼▼
document.getElementById('sticker-category-tabs').addEventListener('click', (event) => {
    const target = event.target;
    
    // --- 委托处理【删除】按钮的点击 ---
    if (target.classList.contains('sticker-category-delete-btn')) {
        event.stopPropagation();
        
        const parentBtn = target.closest('.sticker-category-btn');
        if (parentBtn) {
            const categoryId = parseInt(parentBtn.dataset.categoryId);
            const categoryName = parentBtn.dataset.categoryName;
            
            if (!isNaN(categoryId) && categoryName) {
                handleDeleteStickerCategory(categoryId, categoryName);
            }
        }
        return;
    }

    // --- 委托处理【切换分类】按钮的点击 ---
    const categoryBtn = target.closest('.sticker-category-btn');
    if (categoryBtn) {
        // ★★★ 核心修改：我们已经删除了这里的 "if (isUserStickerSelectionMode) return;" 这行代码 ★★★
        // 现在无论是否在编辑模式，点击分类标签都会切换视图。
        
        const categoryIdStr = categoryBtn.dataset.categoryId;
        activeStickerCategoryId = (categoryIdStr === 'uncategorized') ? 'uncategorized' : parseInt(categoryIdStr);
        renderStickerPanel(); // 切换分类并重新渲染表情列表
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这段新代码 ▼▼▼

// --- 【全新】亲密值面板事件绑定 ---

// 1. 使用事件委托，为整个聊天列表绑定点击事件
document.getElementById('chat-list').addEventListener('click', (e) => {
    // 检查被点击的是否是我们的亲密值按钮
    const intimacyBtn = e.target.closest('.intimacy-btn');
    if (intimacyBtn) {
        const chatId = intimacyBtn.dataset.chatId;
        if (chatId) {
            openIntimacyPanel(chatId);
        }
    }
});

// 2. 为面板的关闭按钮绑定事件
document.getElementById('close-intimacy-panel').addEventListener('click', () => {
    document.getElementById('intimacy-panel').classList.remove('visible');
});

// ▲▲▲ 新事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 函数中，用这行代码替换旧的 open-intimacy-panel-btn 监听器 ▼▼▼
document.getElementById('open-intimacy-panel-btn').addEventListener('click', () => openIntimacyPanel(state.activeChatId));
// ▲▲▲ 替换结束 ▲▲▲
    // 使用事件委托，为动态页面的头部按钮绑定事件
    document.getElementById('qzone-screen').addEventListener('click', (e) => {
        // 检查点击的是否是清空按钮
        const clearBtn = e.target.closest('#clear-qzone-posts-btn');
        if (clearBtn) {
            clearAllQzonePosts(); // 如果是，就调用我们刚刚创建的函数
            return; 
        }
    });

    // ▲▲▲ 新代码粘贴结束 ▲▲▲


initLoversSpace();
initTaobao();




// ===================================================================
// 5. 启动！

// 应用壁纸并更新所有时钟
applyLockscreenWallpaper();
updateLockClock();

// ▼▼▼ 【最终修复版】请用这整块代码，替换掉你 init() 函数中旧的锁屏和状态栏开关逻辑 ▼▼▼

// 1. 读取、应用并监听“启用锁屏”设置
const enableLockScreenToggle = document.getElementById('enable-lock-screen-toggle');
const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
enableLockScreenToggle.checked = lockScreenEnabled;

// 2. 读取、应用并监听“显示状态栏”设置
const showStatusBarToggle = document.getElementById('show-status-bar-toggle');
const statusBar = document.getElementById('status-bar');
// 读取保存的状态，如果没保存过，默认是 true (显示)
const showStatusBar = localStorage.getItem('showStatusBar') !== 'false'; 
// 让开关的状态和保存的状态同步
showStatusBarToggle.checked = showStatusBar; 
// 根据保存的状态，决定一加载进来时是否显示状态栏
if (showStatusBar) {
    statusBar.style.display = 'flex';
} else {
    statusBar.style.display = 'none';
}

// 3. 【关键】给开关添加“变化”监听器，这样你每次点击它都会保存状态
showStatusBarToggle.addEventListener('change', (e) => {
    const isEnabled = e.target.checked;
    // a. 将新的开关状态 (true 或 false) 保存到浏览器的 localStorage 里
    localStorage.setItem('showStatusBar', isEnabled);
    // b. 立刻根据新的状态来显示或隐藏状态栏
    statusBar.style.display = isEnabled ? 'flex' : 'none';
});

// 4. 根据最终的锁屏设置，决定应用启动时第一个显示的屏幕
if (lockScreenEnabled) {
    lockPhone(); // 如果设置是“启用”，就锁定手机
} else {
    showScreen('home-screen'); // 否则，直接进入主屏幕
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 操作4：在 init() 的事件监听器区域，用这三行代码替换旧的两行 ▼▼▼
document.getElementById('edit-font-slots-btn').addEventListener('click', toggleFontSlotSelectionMode);
document.getElementById('add-new-font-preset-btn').addEventListener('click', handleAddNewFontPresetSlot);
document.getElementById('delete-selected-slots-btn').addEventListener('click', handleBulkDeleteFontSlots);
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 操作4：用这块【全新的】代码，替换旧的头像框管理事件监听器 ▼▼▼

/* --- 【全新】自定义头像框管理功能事件绑定 (V2 - 支持选择性导出) --- */

// 打开“管理”弹窗的按钮
document.getElementById('manage-custom-frames-btn').addEventListener('click', () => {
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    openFrameManager();
});

// “管理”弹窗内的按钮
document.getElementById('edit-custom-frames-btn').addEventListener('click', toggleFrameSelectionMode);
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadCustomFrame);
document.getElementById('close-frame-manager-btn').addEventListener('click', () => {
    if (isFrameSelectionMode) {
        toggleFrameSelectionMode(); // 退出编辑模式
    }
    document.getElementById('custom-frame-manager-modal').classList.remove('visible');
    openFrameSelectorModal(currentFrameSelection.type, currentFrameSelection.target);
});

// 底部操作栏的按钮
document.getElementById('frame-select-all-btn').addEventListener('click', async () => {
    const allFrames = await db.customAvatarFrames.toArray();
    allFrames.forEach(frame => selectedFrames.add(frame.id));
    renderFrameManager(); // 重新渲染以显示全部选中
    const exportBtn = document.getElementById('export-selected-frames-btn');
    exportBtn.textContent = `导出已选 (${selectedFrames.size})`;
    exportBtn.disabled = selectedFrames.size === 0;
});
document.getElementById('frame-deselect-all-btn').addEventListener('click', () => {
    selectedFrames.clear();
    renderFrameManager(); // 重新渲染以取消所有选中
    const exportBtn = document.getElementById('export-selected-frames-btn');
    exportBtn.textContent = `导出已选 (0)`;
    exportBtn.disabled = true;
});

document.getElementById('import-custom-frames-btn').addEventListener('click', () => {
    document.getElementById('custom-frame-upload-input').click();
});
document.getElementById('export-selected-frames-btn').addEventListener('click', exportSelectedFrames);

// 文件上传的监听保持不变
document.getElementById('custom-frame-upload-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file && file.name.toLowerCase().endsWith('.json')) {
        importCustomFrames(file);
    } else if(file) {
        // 这是你已有的单张上传逻辑，我们把它包裹起来
        (async () => {
            const name = await showCustomPrompt("为头像框命名", "请输入名称", file.name.replace(/\.[^/.]+$/, ""));
            if (name && name.trim()) {
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                await db.customAvatarFrames.add({ id: 'frame_' + Date.now(), name: name.trim(), url: base64Url });
                renderFrameManager();
            }
        })();
    }
    e.target.value = null;
});
// ▲▲▲ 替换结束 ▲▲▲
}
// ▼▼▼ 操作3：在 init() 函数的事件监听器区域末尾，粘贴这行新代码 ▼▼▼
document.getElementById('clear-local-data-btn').addEventListener('click', handleClearLocalData);
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】PC端主屏幕键盘左右箭头滑动功能 ▼▼▼
document.addEventListener('keydown', (e) => {
    const homeScreen = document.getElementById('home-screen');
    // 确保只在主屏幕激活时才响应按键
    if (!homeScreen.classList.contains('active')) {
        return;
    }

    const slider = homeScreen.querySelector('.home-screen-slider');
    if (!slider || !slider.scrollToPage) return;

    // 获取当前页码
    const currentPage = slider.getCurrentPage ? slider.getCurrentPage() : 0;
    const totalPages = slider.querySelectorAll('.home-page').length;

    // 当用户按下右箭头时
    if (e.key === 'ArrowRight') {
        e.preventDefault(); // 阻止默认行为
        if (currentPage < totalPages - 1) {
            // 只能移动到下一页
            slider.scrollToPage(currentPage + 1);
        }
    } 
    // 当用户按下左箭头时
    else if (e.key === 'ArrowLeft') {
        e.preventDefault(); // 阻止默认行为
        if (currentPage > 0) {
            // 只能移动到上一页
            slider.scrollToPage(currentPage - 1);
        }
    }
});
// ▲▲▲ 新增代码结束 ▲▲▲
        init();

// ▼▼▼ 在这里添加下面这个“全局接口”部分 ▼▼▼

/*
 * ===================================================================
 * === 全局接口 (Public API for other scripts) ===
 * ===================================================================
 * 将主应用的核心功能暴露给其他脚本文件（如 game-hall.js）使用
 */
window.openChat = openChat;
window.triggerAiResponse = triggerAiResponse;
window.openLoversSpaceFromCard = openLoversSpaceFromCard;

// ▲▲▲ 添加结束 ▲▲▲
 // ▼▼▼ 把这【一整块】全新的代码，粘贴到 <script> 标签内的【变量定义区域】的末尾 ▼▼▼

const avatarFrames = [
    { id: 'none', url: '', name: '无' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
    { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
    { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
{ id: 'frame_1', url: 'https://i.postimg.cc/50W2jZGN/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-E4SURh-Uz-J2ZVFv-IQUAc-XVu-Z3o.gif', name: '1' },
{ id: 'frame_2', url: 'https://i.postimg.cc/85gzsq3h/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-I4SURh-WTRLYk-Fv-IQUAc-XVu-Z3o.gif', name: '2' },
{ id: 'frame_3', url: 'https://i.postimg.cc/tTG47LfS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-Jj-SURh-Vmd2ZUFv-IQUAc-XVu-Z3o.gif', name: '3' },
{ id: 'frame_4', url: 'https://i.postimg.cc/sXPDWTd4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-JNSURh-Vj-Iw-ZWdv-IQUAc-XVu-Z3o.gif', name: '4' },
{ id: 'frame_5', url: 'https://i.postimg.cc/SsLN9gFG/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-Jz-SURh-Yj-Ru-Ymdv-IQUAc-XVu-Z3o.gif', name: '5' },
{ id: 'frame_6', url: 'https://i.postimg.cc/SsLN9gb4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mj-NNSURh-Yz-FZYmdv-IQUAc-XVu-Z3o.gif', name: '6' },
{ id: 'frame_7', url: 'https://i.postimg.cc/cJnJxsDg/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjc4RURh-WDl1R3pn-IQUAc-XVu-Z3o.gif', name: '7' },
{ id: 'frame_8', url: 'https://i.postimg.cc/tTG47Lfq/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjdz-RURh-Un-Vm-SERn-IQUAc-XVu-Z3o.gif', name: '8' },
{ id: 'frame_9', url: 'https://i.postimg.cc/DZ3wmtDb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjh-NRURh-UW9VRURn-IQUAc-XVu-Z3o.gif', name: '9' },
{ id: 'frame_10', url: 'https://i.postimg.cc/76rZbpcG/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjhj-RURh-Yml-QRHpn-IQUAc-XVu-Z3o.gif', name: '10' },
{ id: 'frame_11', url: 'https://i.postimg.cc/Pxn5NBcw/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjhz-RURh-WWgq-RHpn-IQUAc-XVu-Z3o.gif', name: '11' },
{ id: 'frame_12', url: 'https://i.postimg.cc/bJ0Nnmc4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mjl-NQURh-YVVm-Rk-Nr-IQUAc-XVu-Z3o.gif', name: '12' },
{ id: 'frame_13', url: 'https://i.postimg.cc/Ghg3vBVL/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-U4RURh-Vmlv-SFNz-IQUAc-XVu-Z3o.gif', name: '13' },
{ id: 'frame_14', url: 'https://i.postimg.cc/YC4rRrBS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-Y4RURh-Zm-Jn-RHlz-IQUAc-XVu-Z3o.gif', name: '14' },
{ id: 'frame_15', url: 'https://i.postimg.cc/SxXSdSbc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-Y4TURh-ZDY3ZGc0IQUAc-XVu-Z3o.gif', name: '15' },
{ id: 'frame_16', url: 'https://i.postimg.cc/rwdVjV2f/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk-ZNRURh-Vl-VNSFNz-IQUAc-XVu-Z3o.gif', name: '16' },
{ id: 'frame_17', url: 'https://i.postimg.cc/MHWZm1zv/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk84VURh-Yk-Fjcnp-BIQUAc-XVu-Z3o.gif', name: '17' },
{ id: 'frame_18', url: 'https://i.postimg.cc/pr2VJKPP/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk9j-VURh-Zkh-Dd-Wp-BIQUAc-XVu-Z3o.gif', name: '18' },
{ id: 'frame_19', url: 'https://i.postimg.cc/C5FMsbwh/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk9NVURh-WW4ud-Wp-BIQUAc-XVu-Z3o.gif', name: '19' },
{ id: 'frame_20', url: 'https://i.postimg.cc/QCXNJcjx/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mk9z-VURh-Wmxncnp-BIQUAc-XVu-Z3o.gif', name: '20' },
{ id: 'frame_21', url: 'https://i.postimg.cc/HnpW9bTb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkc4TURh-YTBv-YVE0IQUAc-XVu-Z3o.gif', name: '21' },
{ id: 'frame_22', url: 'https://i.postimg.cc/HnBYZjLX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkd-NRURh-UXV5RHlz-IQUAc-XVu-Z3o.gif', name: '22' },
{ id: 'frame_23', url: 'https://i.postimg.cc/NFpsJL02/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkd-NTURh-ZW9FZGc0IQUAc-XVu-Z3o.gif', name: '23' },
{ id: 'frame_24', url: 'https://i.postimg.cc/BbMSYtvX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkdj-TURh-VGdn-YWc0IQUAc-XVu-Z3o.gif', name: '24' },
{ id: 'frame_25', url: 'https://i.postimg.cc/nr0FRMLY/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkdz-TURh-ZFBj-YUE0IQUAc-XVu-Z3o.gif', name: '25' },
{ id: 'frame_26', url: 'https://i.postimg.cc/zv0zt3f6/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkh-NTURh-USpm-WFE0IQUAc-XVu-Z3o.gif', name: '26' },
{ id: 'frame_27', url: 'https://i.postimg.cc/2y2kc35H/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkhj-TURh-Vm-ZNWEE0IQUAc-XVu-Z3o.gif', name: '27' },
{ id: 'frame_28', url: 'https://i.postimg.cc/jqXSd3hx/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkhz-TURh-Zlh-JWFE0IQUAc-XVu-Z3o.gif', name: '28' },
{ id: 'frame_29', url: 'https://i.postimg.cc/CMNxLr4b/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mklz-UURh-ZEQ3Tk-I0IQUAc-XVu-Z3o.gif', name: '29' },
{ id: 'frame_30', url: 'https://i.postimg.cc/65p57VHv/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mko4QURh-ZEQ3e-EJ3IQUAc-XVu-Z3o.gif', name: '30' },
{ id: 'frame_31', url: 'https://i.postimg.cc/bNwNG06T/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mko4UURh-ZDl-SS1I0IQUAc-XVu-Z3o.gif', name: '31' },
{ id: 'frame_32', url: 'https://i.postimg.cc/8PzPFdKQ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkpj-UURh-VFl-GS1I0IQUAc-XVu-Z3o.gif', name: '32' },
{ id: 'frame_33', url: 'https://i.postimg.cc/tCvRF1wj/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mkpz-UURh-U1Jq-S1I0IQUAc-XVu-Z3o.gif', name: '33' },
{ id: 'frame_34', url: 'https://i.postimg.cc/Jz91dfR5/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-A4SURh-U0R3a-Hd-FIQUAc-XVu-Z3o.gif', name: '34' },
{ id: 'frame_35', url: 'https://i.postimg.cc/cLVs5pdF/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-A4VURh-Zi5Eb1RBIQUAc-XVu-Z3o.gif', name: '35' },
{ id: 'frame_36', url: 'https://i.postimg.cc/htHS3kKY/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Bj-VURh-Vl-Fxb3p-BIQUAc-XVu-Z3o.gif', name: '36' },
{ id: 'frame_37', url: 'https://i.postimg.cc/YSYpcdSJ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Bz-VURh-WXZPb2p-BIQUAc-XVu-Z3o.gif', name: '37' },
{ id: 'frame_38', url: 'https://i.postimg.cc/5tLxcs0H/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-E4SURh-Wmx-SYmd-FIQUAc-XVu-Z3o.gif', name: '38' },
{ id: 'frame_39', url: 'https://i.postimg.cc/1zw9xvt4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-E4VURh-Vj-Y0b-VRBIQUAc-XVu-Z3o.gif', name: '39' },
{ id: 'frame_40', url: 'https://i.postimg.cc/R0KMrgFc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Fj-SURh-VG9v-ZWd-FIQUAc-XVu-Z3o.gif', name: '40' },
{ id: 'frame_41', url: 'https://i.postimg.cc/PxHdd1pP/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Fj-VURh-VWh-Sb-Gp-BIQUAc-XVu-Z3o.gif', name: '41' },
{ id: 'frame_42', url: 'https://i.postimg.cc/sXz335Q4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-FNSURh-Vm-Nx-ZXd-FIQUAc-XVu-Z3o.gif', name: '42' },
{ id: 'frame_43', url: 'https://i.postimg.cc/764qqSGc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-FNVURh-VE1ub-Gp-BIQUAc-XVu-Z3o.gif', name: '43' },
{ id: 'frame_44', url: 'https://i.postimg.cc/bJRprdkW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Fz-SURh-UVB2ZVFFIQUAc-XVu-Z3o.gif', name: '44' },
{ id: 'frame_45', url: 'https://i.postimg.cc/LXV25hjF/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-I4RURh-Vkw3Nl-Mw-IQUAc-XVu-Z3o.gif', name: '45' },
{ id: 'frame_46', url: 'https://i.postimg.cc/ZRL4n06R/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-I4TURh-WDVFKnh-BIQUAc-XVu-Z3o.gif', name: '46' },
{ id: 'frame_47', url: 'https://i.postimg.cc/Gthryrj1/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-I4VURh-Zm1u-Z1RBIQUAc-XVu-Z3o.gif', name: '47' },
{ id: 'frame_48', url: 'https://i.postimg.cc/4yNZ9Z14/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-RURh-UWx1OWkw-IQUAc-XVu-Z3o.gif', name: '48' },
{ id: 'frame_49', url: 'https://i.postimg.cc/zvX5g5kX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-SURh-Ynd-WYmd-FIQUAc-XVu-Z3o.gif', name: '49' },
{ id: 'frame_50', url: 'https://i.postimg.cc/2y8mZmxv/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-TURh-U3JSKmh-BIQUAc-XVu-Z3o.gif', name: '50' },
{ id: 'frame_51', url: 'https://i.postimg.cc/J04mkmQj/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jj-VURh-ZS5sa-FRBIQUAc-XVu-Z3o.gif', name: '51' },
{ id: 'frame_52', url: 'https://i.postimg.cc/vTqy7jP9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNRURh-VVVs-OWkw-IQUAc-XVu-Z3o.gif', name: '52' },
{ id: 'frame_53', url: 'https://i.postimg.cc/sx6zP8n9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNSURh-ZFc1Yl-FFIQUAc-XVu-Z3o.gif', name: '53' },
{ id: 'frame_54', url: 'https://i.postimg.cc/VvGw9T7D/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNTURh-VEd-QQ1JFIQUAc-XVu-Z3o.gif', name: '54' },
{ id: 'frame_55', url: 'https://i.postimg.cc/yxQKh5fb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-JNVURh-UTl2a-Wp-BIQUAc-XVu-Z3o.gif', name: '55' },
{ id: 'frame_56', url: 'https://i.postimg.cc/J7PRWD1z/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Jz-VURh-YXdta-Xp-BIQUAc-XVu-Z3o.gif', name: '56' },
{ id: 'frame_57', url: 'https://i.postimg.cc/J7PRWD1z/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-M4VURh-ZTZx-ZERBIQUAc-XVu-Z3o.gif', name: '57' },
{ id: 'frame_58', url: 'https://i.postimg.cc/SQDmp2yn/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Nj-TURh-YWNVOHh-BIQUAc-XVu-Z3o.gif', name: '58' },
{ id: 'frame_59', url: 'https://i.postimg.cc/h4pKqzS8/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-NNRURh-WWJ1Nl-Mw-IQUAc-XVu-Z3o.gif', name: '59' },
{ id: 'frame_60', url: 'https://i.postimg.cc/vHTb8YBt/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-NNVURh-Zko2Z0RBIQUAc-XVu-Z3o.gif', name: '60' },
{ id: 'frame_61', url: 'https://i.postimg.cc/4Nys4fdF/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Nz-TURh-ZXo4OFJBIQUAc-XVu-Z3o.gif', name: '61' },
{ id: 'frame_62', url: 'https://i.postimg.cc/CL5SMh5M/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Nz-VURh-Zld-DZGp-BIQUAc-XVu-Z3o.gif', name: '62' },
{ id: 'frame_63', url: 'https://i.postimg.cc/SNPqJBYS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Q4VURh-Y2Fa-WFRBIQUAc-XVu-Z3o.gif', name: '63' },
{ id: 'frame_64', url: 'https://i.postimg.cc/DyNF894W/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-U4VURh-Uk8y-VURBIQUAc-XVu-Z3o.gif', name: '64' },
{ id: 'frame_65', url: 'https://i.postimg.cc/JzB8JpjD/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Vj-VURh-YS5NWERBIQUAc-XVu-Z3o.gif', name: '65' },
{ id: 'frame_66', url: 'https://i.postimg.cc/dVTFd5GC/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-VNVURh-Wl-Bi-WERBIQUAc-XVu-Z3o.gif', name: '66' },
{ id: 'frame_67', url: 'https://i.postimg.cc/t4VbPBFS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Y4VURh-ZWdl-Ul-RBIQUAc-XVu-Z3o.gif', name: '67' },
{ id: 'frame_68', url: 'https://i.postimg.cc/k53myWyT/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-ZNVURh-Wjg3VURBIQUAc-XVu-Z3o.gif', name: '68' },
{ id: 'frame_69', url: 'https://i.postimg.cc/zfZrkTk2/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Ml-Zz-VURh-Zm5GUk-RBIQUAc-XVu-Z3o.gif', name: '69' },
{ id: 'frame_70', url: 'https://i.postimg.cc/xdM0r6Cn/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mlc4QURh-Vm-ZCNFI4IQUAc-XVu-Z3o.gif', name: '70' },
{ id: 'frame_71', url: 'https://i.postimg.cc/9fZW3LMW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mldz-QURh-VDUq-NGg4IQUAc-XVu-Z3o.gif', name: '71' },
{ id: 'frame_72', url: 'https://i.postimg.cc/3wXHfWSw/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-I4SURh-Y09JSWd-RIQUAc-XVu-Z3o.gif', name: '72' },
{ id: 'frame_73', url: 'https://i.postimg.cc/LstMQhC5/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Jj-SURh-VU9VSXd-RIQUAc-XVu-Z3o.gif', name: '73' },
{ id: 'frame_74', url: 'https://i.postimg.cc/7L3ytbs5/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-JNSURh-Y2Fu-TFFRIQUAc-XVu-Z3o.gif', name: '74' },
{ id: 'frame_75', url: 'https://i.postimg.cc/8CRVXsKr/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Jz-SURh-YWVi-SWd-RIQUAc-XVu-Z3o.gif', name: '75' },
{ id: 'frame_76', url: 'https://i.postimg.cc/63Bxkwgr/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Nj-SURh-U2h-XRmd-RIQUAc-XVu-Z3o.gif', name: '76' },
{ id: 'frame_77', url: 'https://i.postimg.cc/C1wp3YX4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm-Nz-SURh-VGYy-Rmd-RIQUAc-XVu-Z3o.gif', name: '77' },
{ id: 'frame_78', url: 'https://i.postimg.cc/MG2SY1D2/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm04UURh-VVht-Vk-NZIQUAc-XVu-Z3o.gif', name: '78' },
{ id: 'frame_79', url: 'https://i.postimg.cc/Bv90C2Cy/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm1NUURh-WHI1WUNZIQUAc-XVu-Z3o.gif', name: '79' },
{ id: 'frame_80', url: 'https://i.postimg.cc/k53myWyL/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm1z-UURh-VWI1V0NZIQUAc-XVu-Z3o.gif', name: '80' },
{ id: 'frame_81', url: 'https://i.postimg.cc/CKTg4bNV/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm5j-UURh-YXBl-VGl-ZIQUAc-XVu-Z3o.gif', name: '81' },
{ id: 'frame_82', url: 'https://i.postimg.cc/QMG3qcb8/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm5NUURh-VDd-FVUNZIQUAc-XVu-Z3o.gif', name: '82' },
{ id: 'frame_83', url: 'https://i.postimg.cc/JhVLQjqn/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm5z-UURh-VUpz-Uml-ZIQUAc-XVu-Z3o.gif', name: '83' },
{ id: 'frame_84', url: 'https://i.postimg.cc/JhNWYt68/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm84UURh-Vm1XTFNZIQUAc-XVu-Z3o.gif', name: '84' },
{ id: 'frame_85', url: 'https://i.postimg.cc/GpwCjvQ9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm9j-UURh-Um-JJT0NZIQUAc-XVu-Z3o.gif', name: '85' },
{ id: 'frame_86', url: 'https://i.postimg.cc/zfC123tr/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mm9z-UURh-Ylh0Tl-NZIQUAc-XVu-Z3o.gif', name: '86' },
{ id: 'frame_87', url: 'https://i.postimg.cc/HLwCvjZp/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmg4TURh-Y2s1NUJRIQUAc-XVu-Z3o.gif', name: '87' },
{ id: 'frame_88', url: 'https://i.postimg.cc/R07zpqsc/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmk4TURh-VENz-Ml-JRIQUAc-XVu-Z3o.gif', name: '88' },
{ id: 'frame_89', url: 'https://i.postimg.cc/jjHr3Cgh/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mml-NTURh-Wk-Q0NGh-RIQUAc-XVu-Z3o.gif', name: '89' },
{ id: 'frame_90', url: 'https://i.postimg.cc/q7sdDgbX/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmlj-TURh-Zjh-MMl-JRIQUAc-XVu-Z3o.gif', name: '90' },
{ id: 'frame_91', url: 'https://i.postimg.cc/1ty1kP2D/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmlz-RURh-VFhzd3p-JIQUAc-XVu-Z3o.gif', name: '91' },
{ id: 'frame_92', url: 'https://i.postimg.cc/wv9YCHZ4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmo4UURh-WVVya0NZIQUAc-XVu-Z3o.gif', name: '92' },
{ id: 'frame_93', url: 'https://i.postimg.cc/C1wp3Y9V/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmp-NRURh-Ulkud-Gp-JIQUAc-XVu-Z3o.gif', name: '93' },
{ id: 'frame_94', url: 'https://i.postimg.cc/xC9VwYh4/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpj-RURh-Y3Fpdnp-JIQUAc-XVu-Z3o.gif', name: '94' },
{ id: 'frame_95', url: 'https://i.postimg.cc/4dXRDZjC/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpj-UURh-WVZJbl-NZIQUAc-XVu-Z3o.gif', name: '95' },
{ id: 'frame_96', url: 'https://i.postimg.cc/LXvFRwFb/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpz-RURh-WTZ6c3p-JIQUAc-XVu-Z3o.gif', name: '96' },
{ id: 'frame_97', url: 'https://i.postimg.cc/MTtJxNJN/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmpz-UURh-Uyoqb-Wl-ZIQUAc-XVu-Z3o.gif', name: '97' },
{ id: 'frame_98', url: 'https://i.postimg.cc/MTtJxN88/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mms4RURh-WGl-FYnp-RIQUAc-XVu-Z3o.gif', name: '98' },
{ id: 'frame_99', url: 'https://i.postimg.cc/V64P1pcz/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mms4UURh-ZGFYZ3l-ZIQUAc-XVu-Z3o.gif', name: '99' },
{ id: 'frame_100', url: 'https://i.postimg.cc/fL5QZpht/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmt-NUURh-Uzkyanl-ZIQUAc-XVu-Z3o.gif', name: '100' },
{ id: 'frame_101', url: 'https://i.postimg.cc/9M1HVKjW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmtj-RURh-Wn-Nab-Xp-JIQUAc-XVu-Z3o.gif', name: '101' },
{ id: 'frame_102', url: 'https://i.postimg.cc/Y98BkZw9/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmtj-UURh-V21oak-NZIQUAc-XVu-Z3o.gif', name: '102' },
{ id: 'frame_103', url: 'https://i.postimg.cc/G2znrV1s/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmw4UURh-U1da-ZENZIQUAc-XVu-Z3o.gif', name: '103' },
{ id: 'frame_104', url: 'https://i.postimg.cc/tJTQgkXs/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmx-NUURh-Vj-NBZ0NZIQUAc-XVu-Z3o.gif', name: '104' },
{ id: 'frame_105', url: 'https://i.postimg.cc/MHT2G5WT/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmxj-UURh-Zl-NYZFNZIQUAc-XVu-Z3o.gif', name: '105' },
{ id: 'frame_106', url: 'https://i.postimg.cc/RhF50dMJ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mmxz-UURh-Zk-NIZFNZIQUAc-XVu-Z3o.gif', name: '106' },
{ id: 'frame_107', url: 'https://i.postimg.cc/2y6R5GzZ/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-A4UURh-U3JYTml-ZIQUAc-XVu-Z3o.gif', name: '107' },
{ id: 'frame_108', url: 'https://i.postimg.cc/SRsFKdyC/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Bj-UURh-VDcq-S1NZIQUAc-XVu-Z3o.gif', name: '108' },
{ id: 'frame_109', url: 'https://i.postimg.cc/D0Zkz62q/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Bz-UURh-Ynha-SVNZIQUAc-XVu-Z3o.gif', name: '109' },
{ id: 'frame_110', url: 'https://i.postimg.cc/5y0dtgxp/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Fj-UURh-Um-FBSHl-ZIQUAc-XVu-Z3o.gif', name: '110' },
{ id: 'frame_111', url: 'https://i.postimg.cc/yxd4NjVf/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-FNUURh-ZEV5SUNZIQUAc-XVu-Z3o.gif', name: '111' },
{ id: 'frame_112', url: 'https://i.postimg.cc/zvBZf7J2/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Fz-UURh-Ym-Zq-RXl-ZIQUAc-XVu-Z3o.gif', name: '112' },
{ id: 'frame_113', url: 'https://i.postimg.cc/rsP6R4mS/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-I4SURh-WXNMSGdn-IQUAc-XVu-Z3o.gif', name: '113' },
{ id: 'frame_114', url: 'https://i.postimg.cc/x84rNmC3/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Jj-SURh-ZWps-UHdn-IQUAc-XVu-Z3o.gif', name: '114' },
{ id: 'frame_115', url: 'https://i.postimg.cc/1XjxVFtj/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-JNSURh-ZVU3U3dn-IQUAc-XVu-Z3o.gif', name: '115' },
{ id: 'frame_116', url: 'https://i.postimg.cc/nrP89mzW/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-JNUURh-WElp-RXl-ZIQUAc-XVu-Z3o.gif', name: '116' },
{ id: 'frame_117', url: 'https://i.postimg.cc/5tCt4xPt/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-M4SURh-VUt-UM3dr-IQUAc-XVu-Z3o.gif', name: '117' },
{ id: 'frame_118', url: 'https://i.postimg.cc/6QvQW9H7/NR8AVj-Vi-Q2d-Be-E1EVTBPVEE1Tk-Rn-Mn-Nj-SURh-ZTZPTk-Fn-IQUAc-XVu-Z3o.gif', name: '118' },
];

// ▲▲▲ 粘贴结束 ▲▲▲       
    });

// ▼▼▼ 第十四部分：三次点击下载NAI图片功能（完整代码） ▼▼▼
// ========================================
// 🖼️ NAI图片三击下载功能（非入侵式）
// ========================================
// 功能：为所有NAI图片（realimag-image、naiimag-image）添加三击下载功能
// 适用场景：群聊、私聊、动态、测试弹窗等所有显示NAI图片的地方
// 实现方式：事件委托，不修改任何现有代码
// 触发方式：在图片上快速点击三次
// ========================================

(function() {
    'use strict';
    
    // 下载图片的核心函数
    function downloadImage(imageSrc, filename) {
        try {
            // 创建一个隐藏的下载链接
            const link = document.createElement('a');
            link.href = imageSrc;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();  // 触发下载
            
            // 短暂延迟后移除链接
            setTimeout(() => {
                document.body.removeChild(link);
            }, 100);
            
            console.log('✅ [NAI下载] 开始下载图片:', filename);
            
            // 显示下载提示
            showDownloadToast();
        } catch (error) {
            console.error('❌ [NAI下载] 下载失败:', error);
            showDownloadToast('下载失败，请重试', 'error');
        }
    }
    
    // 显示下载提示（临时Toast）
    function showDownloadToast(message = '📥 图片下载中...', type = 'success') {
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: ${type === 'success' ? '#4CAF50' : '#f44336'};
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        `;
        
        document.body.appendChild(toast);
        
        // 动画进入
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateY(0)';
        }, 10);
        
        // 2秒后淡出并移除
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateY(-20px)';
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 2000);
    }
    
    // 生成智能文件名
    function generateFilename(imgElement) {
        // 尝试从title属性获取prompt（用于文件名）
        const title = imgElement.getAttribute('title') || imgElement.getAttribute('alt') || '';
        
        // 清理title，提取前30个有效字符
        let cleanTitle = title
            .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')  // 保留中英文字母数字和空格
            .replace(/\s+/g, '_')  // 空格转下划线
            .substring(0, 30);
        
        if (!cleanTitle) {
            cleanTitle = 'NAI_Image';
        }
        
        // 添加时间戳（精确到秒）
        const timestamp = new Date().toISOString()
            .replace(/[-:]/g, '')
            .replace('T', '_')
            .split('.')[0];  // 格式：20250124_123045
        
        // 生成文件名
        return `${cleanTitle}_${timestamp}.png`;
    }
    
    // 为图片添加双击时的视觉反馈
    function addVisualFeedback(imgElement) {
        const originalTransform = imgElement.style.transform || '';
        const originalTransition = imgElement.style.transition || '';
        
        // 添加缩放动画
        imgElement.style.transition = 'transform 0.15s ease';
        imgElement.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            imgElement.style.transform = originalTransform;
            setTimeout(() => {
                imgElement.style.transition = originalTransition;
            }, 150);
        }, 150);
    }
    
    // 三击检测相关变量
    let clickCount = 0;
    let clickTimer = null;
    let lastClickedElement = null;
    
    // 全局事件监听器（事件委托 - 三击触发）
    document.addEventListener('click', function(e) {
        const target = e.target;
        
        // 检查是否是NAI图片（realimag-image 或 naiimag-image）
        if (target.tagName === 'IMG' && 
            (target.classList.contains('realimag-image') || 
             target.classList.contains('naiimag-image'))) {
            
            // 如果点击的是同一个元素，增加计数
            if (target === lastClickedElement) {
                clickCount++;
            } else {
                // 点击了不同的元素，重置计数
                clickCount = 1;
                lastClickedElement = target;
            }
            
            // 清除之前的定时器
            if (clickTimer) {
                clearTimeout(clickTimer);
            }
            
            // 如果达到三击
            if (clickCount === 3) {
                // 重置计数
                clickCount = 0;
                lastClickedElement = null;
                
                // 阻止默认行为和事件冒泡
                e.preventDefault();
                e.stopPropagation();
                
                console.log('🖼️ [NAI下载] 检测到三击NAI图片');
                
                // 添加视觉反馈
                addVisualFeedback(target);
                
                // 获取图片源（可能是base64或URL）
                const imageSrc = target.src;
                
                if (!imageSrc || imageSrc === 'about:blank') {
                    console.warn('⚠️ [NAI下载] 图片源为空，无法下载');
                    showDownloadToast('图片加载中，请稍后重试', 'error');
                    return;
                }
                
                // 生成文件名
                const filename = generateFilename(target);
                
                // 触发下载
                downloadImage(imageSrc, filename);
            } else {
                // 设置定时器，500ms后重置计数（如果用户停止点击）
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                    lastClickedElement = null;
                }, 500);
            }
        }
    }, true);  // 使用捕获阶段，确保优先处理
    
    console.log('✅ [NAI下载] 三击下载功能已初始化');
    console.log('💡 [NAI下载] 提示：三击任意NAI图片即可下载');
})();
// ▲▲▲ 第十四部分结束 ▲▲▲

// ▼▼▼ 页面动态效果功能 ▼▼▼
(function() {
    'use strict';
    
    console.log('🎨 [页面动态效果] 初始化中...');
    
    // 全局变量
    let currentEffectInterval = null;
    let currentEffectTimeout = null;
    
    // 从localStorage加载效果预设
    function loadEffectPresets() {
        const presets = localStorage.getItem('pageEffectPresets');
        return presets ? JSON.parse(presets) : {};
    }
    
    // 保存效果预设到localStorage
    function saveEffectPresets(presets) {
        localStorage.setItem('pageEffectPresets', JSON.stringify(presets));
    }
    
    // 加载当前聊天的动态效果设置
    function loadChatEffectSettings() {
        if (!state.activeChatId) return null;
        const chat = state.chats[state.activeChatId];
        return chat?.effectSettings || null;
    }
    
    // 保存当前聊天的动态效果设置
    function saveChatEffectSettings(settings) {
        if (!state.activeChatId) return;
        const chat = state.chats[state.activeChatId];
        if (chat) {
            chat.effectSettings = settings;
            db.chats.put(chat).catch(err => console.error('保存聊天效果设置失败:', err));
        }
    }
    
    // 创建下雪效果
    function createSnowEffect(color = '#ffffff', speed = 3) {
        const container = document.getElementById('page-effect-container');
        if (!container) return;
        
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';
        snowflake.textContent = '❄';
        
        // 随机位置和大小
        snowflake.style.left = Math.random() * 100 + '%';
        snowflake.style.fontSize = (Math.random() * 1 + 0.5) + 'em';
        snowflake.style.opacity = Math.random() * 0.6 + 0.4;
        
        // 设置雪花颜色
        snowflake.style.color = color;
        
        // 使用速度参数，添加随机变化（±30%）
        const randomFactor = 0.7 + Math.random() * 0.6; // 0.7 到 1.3
        const duration = speed * randomFactor;
        snowflake.style.animationDuration = duration + 's';
        
        container.appendChild(snowflake);
        
        // 动画结束后移除
        setTimeout(() => {
            snowflake.remove();
        }, duration * 1000);
    }
    
    // 启动下雪效果
    function startSnowEffect(duration, color = '#ffffff', speed = 3) {
        stopAllEffects();
        
        console.log(`❄️ [页面动态效果] 启动下雪效果，时长: ${duration}秒，颜色: ${color}，速度: ${speed}秒`);
        
        // 每100ms创建一个雪花
        currentEffectInterval = setInterval(() => createSnowEffect(color, speed), 100);
        
        // 设置持续时间
        if (duration > 0) {
            currentEffectTimeout = setTimeout(() => {
                stopAllEffects();
                console.log('❄️ [页面动态效果] 下雪效果已停止');
            }, duration * 1000);
        }
    }
    
    // 执行自定义效果
    function executeCustomEffect(code, duration) {
        stopAllEffects();
        
        console.log(`✨ [页面动态效果] 执行自定义效果，时长: ${duration}秒`);
        
        try {
            // 创建一个安全的执行环境
            const container = document.getElementById('page-effect-container');
            const effectFunction = new Function('container', 'duration', code);
            effectFunction(container, duration);
            
            // 设置持续时间
            if (duration > 0) {
                currentEffectTimeout = setTimeout(() => {
                    stopAllEffects();
                    console.log('✨ [页面动态效果] 自定义效果已停止');
                }, duration * 1000);
            }
        } catch (error) {
            console.error('❌ [页面动态效果] 自定义效果执行失败:', error);
            alert('自定义效果执行失败: ' + error.message);
        }
    }
    
    // 停止所有效果
    function stopAllEffects() {
        if (currentEffectInterval) {
            clearInterval(currentEffectInterval);
            currentEffectInterval = null;
        }
        if (currentEffectTimeout) {
            clearTimeout(currentEffectTimeout);
            currentEffectTimeout = null;
        }
        
        // 清空效果容器
        const container = document.getElementById('page-effect-container');
        if (container) {
            container.innerHTML = '';
        }
    }
    
    // 更新预设下拉框
    function updatePresetSelect() {
        const select = document.getElementById('effect-preset-select');
        const presets = loadEffectPresets();
        
        select.innerHTML = '<option value="">选择预设...</option>';
        
        for (const [name, data] of Object.entries(presets)) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
        }
    }
    
    // 加载设置到UI
    function loadSettingsToUI() {
        const settings = loadChatEffectSettings();
        
        if (settings) {
            // 下雪效果设置
            document.getElementById('snow-effect-toggle').checked = settings.snowEnabled || false;
            document.getElementById('snow-auto-trigger-toggle').checked = settings.snowAutoTrigger || false;
            document.getElementById('snow-duration-input').value = settings.snowDuration || 30;
            document.getElementById('snow-color-picker').value = settings.snowColor || '#ffffff';
            document.getElementById('snow-color-input').value = settings.snowColor || '#ffffff';
            document.getElementById('snow-speed-input').value = settings.snowSpeed || 3;
            
            // 自定义效果设置
            document.getElementById('custom-effect-input').value = settings.customCode || '';
            document.getElementById('custom-auto-trigger-toggle').checked = settings.customAutoTrigger || false;
            document.getElementById('custom-duration-input').value = settings.customDuration || 30;
            document.getElementById('custom-speed-input').value = settings.customSpeed || 3;
            
            // 显示/隐藏下雪效果设置
            document.getElementById('snow-effect-settings').style.display = 
                settings.snowEnabled ? 'block' : 'none';
            
            // 高亮匹配的颜色预设
            highlightColorPreset(settings.snowColor || '#ffffff');
        } else {
            // 默认值
            document.getElementById('snow-effect-toggle').checked = false;
            document.getElementById('snow-auto-trigger-toggle').checked = false;
            document.getElementById('snow-duration-input').value = 30;
            document.getElementById('snow-color-picker').value = '#ffffff';
            document.getElementById('snow-color-input').value = '#ffffff';
            document.getElementById('snow-speed-input').value = 3;
            document.getElementById('custom-effect-input').value = '';
            document.getElementById('custom-auto-trigger-toggle').checked = false;
            document.getElementById('custom-duration-input').value = 30;
            document.getElementById('custom-speed-input').value = 3;
            document.getElementById('snow-effect-settings').style.display = 'none';
            
            // 高亮默认颜色
            highlightColorPreset('#ffffff');
        }
        
        updatePresetSelect();
    }
    
    // 高亮匹配的颜色预设
    function highlightColorPreset(color) {
        document.querySelectorAll('.snow-color-preset').forEach(preset => {
            const presetColor = preset.getAttribute('data-color');
            if (presetColor === color) {
                preset.classList.add('selected');
                preset.style.transform = 'scale(1.1)';
                preset.style.boxShadow = '0 0 0 3px var(--accent-color)';
            } else {
                preset.classList.remove('selected');
                preset.style.transform = 'scale(1)';
                preset.style.boxShadow = 'none';
            }
        });
    }
    
    // 从UI获取设置
    function getSettingsFromUI() {
        return {
            snowEnabled: document.getElementById('snow-effect-toggle').checked,
            snowAutoTrigger: document.getElementById('snow-auto-trigger-toggle').checked,
            snowDuration: parseInt(document.getElementById('snow-duration-input').value) || 30,
            snowColor: document.getElementById('snow-color-input').value || '#ffffff',
            snowSpeed: parseFloat(document.getElementById('snow-speed-input').value) || 3,
            customCode: document.getElementById('custom-effect-input').value,
            customAutoTrigger: document.getElementById('custom-auto-trigger-toggle').checked,
            customDuration: parseInt(document.getElementById('custom-duration-input').value) || 30,
            customSpeed: parseFloat(document.getElementById('custom-speed-input').value) || 3
        };
    }
    
    // 事件监听器
    
    // 下雪效果开关
    document.getElementById('snow-effect-toggle').addEventListener('change', function(e) {
        document.getElementById('snow-effect-settings').style.display = 
            e.target.checked ? 'block' : 'none';
    });
    
    // 颜色选择器同步
    document.getElementById('snow-color-picker').addEventListener('input', function() {
        document.getElementById('snow-color-input').value = this.value;
        highlightColorPreset(this.value);
    });
    
    document.getElementById('snow-color-input').addEventListener('input', function() {
        document.getElementById('snow-color-picker').value = this.value;
        highlightColorPreset(this.value);
    });
    
    // 预设颜色点击事件
    document.querySelectorAll('.snow-color-preset').forEach(preset => {
        preset.addEventListener('click', function() {
            const color = this.getAttribute('data-color');
            document.getElementById('snow-color-picker').value = color;
            document.getElementById('snow-color-input').value = color;
            
            // 视觉反馈 - 使用CSS类
            document.querySelectorAll('.snow-color-preset').forEach(p => {
                p.classList.remove('selected');
                p.style.transform = 'scale(1)';
                p.style.boxShadow = 'none';
            });
            this.classList.add('selected');
            this.style.transform = 'scale(1.1)';
            this.style.boxShadow = '0 0 0 3px var(--accent-color)';
        });
        
        // 悬停效果
        preset.addEventListener('mouseenter', function() {
            if (!this.classList.contains('selected')) {
                this.style.transform = 'scale(1.05)';
            }
        });
        
        preset.addEventListener('mouseleave', function() {
            if (!this.classList.contains('selected')) {
                this.style.transform = 'scale(1)';
            }
        });
    });
    
    // 保存预设按钮
    document.getElementById('save-effect-preset-btn').addEventListener('click', function() {
        const name = prompt('请输入预设名称:');
        if (!name) return;
        
        const settings = getSettingsFromUI();
        const presets = loadEffectPresets();
        presets[name] = settings;
        saveEffectPresets(presets);
        
        updatePresetSelect();
        alert('预设已保存: ' + name);
    });
    
    // 删除预设按钮
    document.getElementById('delete-effect-preset-btn').addEventListener('click', function() {
        const presets = loadEffectPresets();
        const presetNames = Object.keys(presets);
        
        if (presetNames.length === 0) {
            alert('没有可删除的预设');
            return;
        }
        
        // 显示删除模式
        const deleteMode = document.getElementById('delete-preset-mode');
        const deleteList = document.getElementById('preset-delete-list');
        
        deleteList.innerHTML = '';
        presetNames.forEach(name => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.padding = '5px';
            label.style.cursor = 'pointer';
            label.innerHTML = `
                <input type="checkbox" class="preset-delete-checkbox" value="${name}" style="width: auto; margin-right: 8px;">
                <span>${name}</span>
            `;
            deleteList.appendChild(label);
        });
        
        deleteMode.style.display = 'block';
    });
    
    // 全选复选框
    document.getElementById('select-all-presets-checkbox').addEventListener('change', function(e) {
        const checkboxes = document.querySelectorAll('.preset-delete-checkbox');
        checkboxes.forEach(cb => cb.checked = e.target.checked);
    });
    
    // 确认删除
    document.getElementById('confirm-delete-presets-btn').addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('.preset-delete-checkbox:checked');
        if (checkboxes.length === 0) {
            alert('请选择要删除的预设');
            return;
        }
        
        if (!confirm(`确定要删除 ${checkboxes.length} 个预设吗？`)) return;
        
        const presets = loadEffectPresets();
        checkboxes.forEach(cb => {
            delete presets[cb.value];
        });
        saveEffectPresets(presets);
        
        updatePresetSelect();
        document.getElementById('delete-preset-mode').style.display = 'none';
        document.getElementById('select-all-presets-checkbox').checked = false;
        
        alert('预设已删除');
    });
    
    // 取消删除
    document.getElementById('cancel-delete-presets-btn').addEventListener('click', function() {
        document.getElementById('delete-preset-mode').style.display = 'none';
        document.getElementById('select-all-presets-checkbox').checked = false;
    });
    
    // 预设选择
    document.getElementById('effect-preset-select').addEventListener('change', function(e) {
        const name = e.target.value;
        if (!name) return;
        
        const presets = loadEffectPresets();
        const preset = presets[name];
        
        if (preset) {
            // 加载预设到UI
            document.getElementById('snow-effect-toggle').checked = preset.snowEnabled || false;
            document.getElementById('snow-auto-trigger-toggle').checked = preset.snowAutoTrigger || false;
            document.getElementById('snow-duration-input').value = preset.snowDuration || 30;
            document.getElementById('snow-color-picker').value = preset.snowColor || '#ffffff';
            document.getElementById('snow-color-input').value = preset.snowColor || '#ffffff';
            document.getElementById('snow-speed-input').value = preset.snowSpeed || 3;
            document.getElementById('custom-effect-input').value = preset.customCode || '';
            document.getElementById('custom-auto-trigger-toggle').checked = preset.customAutoTrigger || false;
            document.getElementById('custom-duration-input').value = preset.customDuration || 30;
            document.getElementById('custom-speed-input').value = preset.customSpeed || 3;
            
            document.getElementById('snow-effect-settings').style.display = 
                preset.snowEnabled ? 'block' : 'none';
        }
    });
    
    // 应用按钮
    document.getElementById('apply-page-effect-btn').addEventListener('click', function() {
        const settings = getSettingsFromUI();
        saveChatEffectSettings(settings);
        
        stopAllEffects();
        
        // 应用效果
        if (settings.snowEnabled) {
            startSnowEffect(settings.snowDuration, settings.snowColor, settings.snowSpeed);
        } else if (settings.customCode) {
            executeCustomEffect(settings.customCode, settings.customDuration);
        }
        
        alert('页面动态效果已应用');
    });
    
    // 重置按钮
    document.getElementById('reset-page-effect-btn').addEventListener('click', function() {
        if (!confirm('确定要重置所有设置吗？')) return;
        
        stopAllEffects();
        saveChatEffectSettings(null);
        loadSettingsToUI();
        
        alert('设置已重置');
    });
    
    // 预览按钮
    document.getElementById('preview-page-effect-btn').addEventListener('click', function() {
        const settings = getSettingsFromUI();
        
        stopAllEffects();
        
        if (settings.snowEnabled) {
            startSnowEffect(10, settings.snowColor); // 预览10秒
        } else if (settings.customCode) {
            executeCustomEffect(settings.customCode, 10); // 预览10秒
        } else {
            alert('请先启用一个效果');
        }
    });
    
    // 监听聊天设置弹窗打开
    document.getElementById('chat-settings-btn').addEventListener('click', function() {
        setTimeout(() => {
            loadSettingsToUI();
        }, 100);
    });
    
    // 监听聊天切换，自动触发效果
    function checkAutoTrigger() {
        const settings = loadChatEffectSettings();
        if (!settings) return;
        
        stopAllEffects();
        
        if (settings.snowEnabled && settings.snowAutoTrigger) {
            startSnowEffect(settings.snowDuration, settings.snowColor, settings.snowSpeed);
        } else if (settings.customCode && settings.customAutoTrigger) {
            executeCustomEffect(settings.customCode, settings.customDuration);
        }
    }
    
    // 监听聊天切换
    const originalOpenChat = window.openChat;
    if (originalOpenChat) {
        window.openChat = function(...args) {
            const result = originalOpenChat.apply(this, args);
            setTimeout(checkAutoTrigger, 500);
            return result;
        };
    }
    
    // 页面加载完成后，检查并应用已保存的自动触发效果
    setTimeout(() => {
        if (state.activeChatId) {
            checkAutoTrigger();
            console.log('🎨 [页面动态效果] 已检查自动触发设置');
        }
    }, 1000);
    
    console.log('✅ [页面动态效果] 初始化完成');
})();
// ▲▲▲ 页面动态效果功能结束 ▲▲▲

// ▼▼▼ 记忆库功能 ▼▼▼
(function() {
    'use strict';
    
    // 记忆库数据存储key
    const MEMORY_BANK_KEY = 'ephone-memory-bank';
    
    // 初始化记忆库
    function initMemoryBank() {
        loadMemoryBankUI();
        bindMemoryBankEvents();
    }
    
    // 获取所有记忆
    function getMemories() {
        const data = localStorage.getItem(MEMORY_BANK_KEY);
        return data ? JSON.parse(data) : [];
    }
    
    // 保存记忆列表
    function saveMemories(memories) {
        localStorage.setItem(MEMORY_BANK_KEY, JSON.stringify(memories));
    }
    
    // 保存当前状态为记忆
    async function saveCurrentMemory() {
        if (!state.activeChatId) {
            await showCustomAlert('无法保存', '请先打开一个聊天对话');
            return;
        }
        
        const chat = state.chats[state.activeChatId];
        if (!chat) {
            await showCustomAlert('无法保存', '未找到当前聊天');
            return;
        }
        
        // 生成默认名称
        const defaultName = `${chat.name}的记忆 - ${new Date().toLocaleString('zh-CN')}`;
        
        // 弹出输入框让用户自定义名称（可留空使用默认名称）
        const customName = await showCustomPrompt(
            '保存记忆',
            '请输入记忆名称（留空使用默认名称）',
            defaultName
        );
        
        // 如果用户点击取消，则不保存
        if (customName === null) {
            return;
        }
        
        // 使用用户输入的名称，如果为空则使用默认名称
        const memoryName = customName.trim() || defaultName;
        
        // 创建记忆对象，保存所有相关数据
        const memory = {
            id: Date.now().toString(),
            name: memoryName,
            timestamp: Date.now(),
            chatData: {
                id: chat.id,
                name: chat.name,
                avatar: chat.avatar,
                persona: chat.persona,
                history: chat.history,
                settings: chat.settings,
                relationship: chat.relationship,
                members: chat.members,
                isGroup: chat.isGroup,
                // 保存美化设置
                customCSS: chat.settings?.customCSS || '',
                background: chat.settings?.background || '',
                messageStyle: chat.settings?.messageStyle || {},
                avatarShape: chat.settings?.avatarShape || {},
                effectSettings: chat.effectSettings || {},
            },
            globalSettings: {
                theme: localStorage.getItem('ephone-theme') || 'light',
                customPlaceholder: localStorage.getItem('custom-chat-placeholder') || '',
                showStatusBar: localStorage.getItem('showStatusBar') || 'true',
            },
            messageCount: chat.history ? chat.history.length : 0,
        };
        
        const memories = getMemories();
        memories.unshift(memory); // 添加到列表开头
        saveMemories(memories);
        
        await showCustomAlert('保存成功', `已保存当前状态到记忆库\n包含 ${memory.messageCount} 条聊天记录`);
        loadMemoryBankUI();
    }
    
    // 删除选中的记忆
    async function deleteSelectedMemories() {
        const memories = getMemories();
        const checkboxes = document.querySelectorAll('.memory-card-checkbox:checked');
        
        if (checkboxes.length === 0) {
            await showCustomAlert('提示', '请先选择要删除的记忆');
            return;
        }
        
        const confirmed = await showCustomConfirm(
            '确认删除',
            `确定要删除选中的 ${checkboxes.length} 个记忆吗？此操作不可恢复。`
        );
        
        if (!confirmed) return;
        
        const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.memoryId);
        const filteredMemories = memories.filter(m => !selectedIds.includes(m.id));
        
        saveMemories(filteredMemories);
        await showCustomAlert('删除成功', `已删除 ${checkboxes.length} 个记忆`);
        loadMemoryBankUI();
    }
    
    // 恢复记忆
    async function restoreMemory(memoryId) {
        const memories = getMemories();
        const memory = memories.find(m => m.id === memoryId);
        
        if (!memory) {
            await showCustomAlert('错误', '未找到该记忆');
            return;
        }
        
        const confirmed = await showCustomConfirm(
            '确认恢复',
            `确定要恢复记忆"${memory.name}"吗？\n\n这将：\n• 恢复所有聊天记录（${memory.messageCount}条）\n• 恢复人设和头像\n• 恢复美化设置\n\n当前对话内容不会丢失，会被保存在原有的聊天中。`
        );
        
        if (!confirmed) return;
        
        try {
            const chatData = memory.chatData;
            
            // 创建或更新聊天
            let chat = state.chats[chatData.id];
            if (!chat) {
                // 如果聊天不存在，创建新的
                chat = {
                    id: chatData.id || Date.now().toString(),
                    name: chatData.name,
                    avatar: chatData.avatar,
                    persona: chatData.persona,
                    history: [],
                    settings: {},
                    isGroup: chatData.isGroup || false,
                    members: chatData.members || [],
                    relationship: chatData.relationship || { status: 'normal' },
                };
                state.chats[chat.id] = chat;
            }
            
            // 恢复所有数据
            chat.name = chatData.name;
            chat.avatar = chatData.avatar;
            chat.persona = chatData.persona;
            chat.history = [...chatData.history]; // 复制历史记录
            chat.settings = { ...chatData.settings };
            chat.members = chatData.members ? [...chatData.members] : [];
            chat.relationship = chatData.relationship || { status: 'normal' };
            chat.effectSettings = chatData.effectSettings || {};
            
            // 保存到数据库
            await db.chats.put(chat);
            
            // 恢复全局设置
            if (memory.globalSettings) {
                if (memory.globalSettings.theme) {
                    localStorage.setItem('ephone-theme', memory.globalSettings.theme);
                    // 直接操作DOM切换主题
                    const phoneScreen = document.getElementById('phone-screen');
                    const toggleSwitch = document.getElementById('theme-toggle-switch');
                    const isDark = memory.globalSettings.theme === 'dark';
                    if (phoneScreen) {
                        phoneScreen.classList.toggle('dark-mode', isDark);
                    }
                    if (toggleSwitch) {
                        toggleSwitch.checked = isDark;
                    }
                }
                if (memory.globalSettings.customPlaceholder) {
                    localStorage.setItem('custom-chat-placeholder', memory.globalSettings.customPlaceholder);
                    const chatInput = document.getElementById('chat-input');
                    if (chatInput) {
                        chatInput.placeholder = memory.globalSettings.customPlaceholder;
                    }
                }
                if (memory.globalSettings.showStatusBar) {
                    localStorage.setItem('showStatusBar', memory.globalSettings.showStatusBar);
                    const statusBar = document.getElementById('status-bar');
                    if (statusBar) {
                        statusBar.style.display = memory.globalSettings.showStatusBar === 'true' ? 'flex' : 'none';
                    }
                }
            }
            
            // 关闭设置弹窗并打开恢复的聊天
            document.getElementById('chat-settings-modal').classList.remove('visible');
            showScreen('chat-interface-screen');
            openChat(chat.id);
            
            await showCustomAlert('恢复成功', `已恢复记忆"${memory.name}"\n共恢复 ${memory.messageCount} 条聊天记录`);
        } catch (error) {
            console.error('恢复记忆失败:', error);
            await showCustomAlert('恢复失败', `发生错误: ${error.message}`);
        }
    }
    
    // 重命名记忆
    function renameMemory(memoryId, newName) {
        if (!newName || !newName.trim()) return;
        
        const memories = getMemories();
        const memory = memories.find(m => m.id === memoryId);
        if (memory) {
            memory.name = newName.trim();
            saveMemories(memories);
        }
    }
    
    // 加载记忆库UI
    function loadMemoryBankUI() {
        const listContainer = document.getElementById('memory-bank-list');
        if (!listContainer) return;
        
        const memories = getMemories();
        
        if (memories.length === 0) {
            listContainer.innerHTML = `
                <div class="memory-bank-empty">
                    <p>暂无保存的记忆</p>
                    <p style="font-size: 12px; color: #999; margin-top: 5px;">点击"保存当前状态"来保存当前对话的所有内容</p>
                </div>
            `;
            return;
        }
        
        listContainer.innerHTML = memories.map(memory => {
            const date = new Date(memory.timestamp).toLocaleString('zh-CN');
            
            return `
                <div class="memory-card" data-memory-id="${memory.id}">
                    <input type="checkbox" class="memory-card-checkbox" data-memory-id="${memory.id}">
                    <div class="memory-card-header">
                        <div class="memory-card-info">
                            <div class="memory-card-name">
                                <input type="text" value="${memory.name}" data-memory-id="${memory.id}" class="memory-name-input" readonly>
                                <button class="memory-card-edit-btn" data-memory-id="${memory.id}">编辑</button>
                            </div>
                            <div class="memory-card-date">${date}</div>
                        </div>
                    </div>
                    <div class="memory-card-details">
                        <span class="memory-card-detail-item">${memory.messageCount} 条消息</span>
                        <span class="memory-card-detail-item">${memory.chatData.isGroup ? '群聊' : '单聊'}</span>
                        ${memory.chatData.settings?.background ? '<span class="memory-card-detail-item">含背景</span>' : ''}
                    </div>
                </div>
            `;
        }).join('');
    }
    
    // 绑定事件
    function bindMemoryBankEvents() {
        // 保存按钮
        const saveBtn = document.getElementById('save-memory-btn');
        if (saveBtn) {
            saveBtn.addEventListener('click', saveCurrentMemory);
        }
        
        // 删除按钮
        const deleteBtn = document.getElementById('delete-memory-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', deleteSelectedMemories);
        }
        
        // 记忆列表事件委托
        const listContainer = document.getElementById('memory-bank-list');
        if (listContainer) {
            listContainer.addEventListener('click', async function(e) {
                const memoryCard = e.target.closest('.memory-card');
                const checkbox = e.target.closest('.memory-card-checkbox');
                const editBtn = e.target.closest('.memory-card-edit-btn');
                
                if (checkbox) {
                    // 点击复选框，切换选中状态
                    memoryCard.classList.toggle('selected', checkbox.checked);
                    return;
                }
                
                if (editBtn) {
                    // 编辑按钮
                    const memoryId = editBtn.dataset.memoryId;
                    const input = memoryCard.querySelector('.memory-name-input');
                    
                    if (input.readOnly) {
                        input.readOnly = false;
                        input.focus();
                        input.select();
                        editBtn.textContent = '保存';
                    } else {
                        input.readOnly = true;
                        editBtn.textContent = '编辑';
                        renameMemory(memoryId, input.value);
                    }
                    return;
                }
                
                if (memoryCard && !checkbox && !editBtn) {
                    // 点击卡片其他区域，恢复记忆
                    const memoryId = memoryCard.dataset.memoryId;
                    await restoreMemory(memoryId);
                }
            });
        }
        
        // 监听聊天设置弹窗打开时加载记忆库
        const chatSettingsBtn = document.getElementById('chat-settings-btn');
        if (chatSettingsBtn) {
            chatSettingsBtn.addEventListener('click', function() {
                setTimeout(loadMemoryBankUI, 100);
            });
        }
    }
    
    // 自定义确认对话框
    async function showCustomConfirm(title, message) {
        return new Promise((resolve) => {
            const confirmed = confirm(`${title}\n\n${message}`);
            resolve(confirmed);
        });
    }
    
    // 页面加载完成后初始化
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initMemoryBank);
    } else {
        initMemoryBank();
    }
    
    console.log('✅ [记忆库] 初始化完成');
})();
// ▲▲▲ 记忆库功能结束 ▲▲▲

</script>
<!-- ▼▼▼ 这是我们新加的隐藏文件选择器 ▼▼▼ -->
<input type="file" id="character-card-input" accept=".png, .json" style="display: none;">
<!-- ▲▲▲ 文件选择器结束 ▲▲▲ -->
<input type="file" id="world-book-import-input" accept=".json, .jsonl" style="display: none;">
<input type="file" id="ludo-qbank-import-input" accept=".json" hidden>
<input type="file" id="inner-voice-bg-input" accept="image/*" hidden>

<!-- ▼▼▼ 清空数据选项弹窗 ▼▼▼ -->
<div id="clear-data-options-modal" class="modal">
    <div class="modal-content" style="width: 360px; height: auto; max-height: 70%;">
        <div class="modal-header">
            <span>清空数据选项</span>
        </div>
        <div class="modal-body" style="padding: 20px;">
            <p style="margin-bottom: 20px; color: #666; font-size: 14px;">确定要清空此聊天的【消息和心声】吗？<br>（聊天总结将被保留）</p>
            
            <div style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
                <p style="margin-bottom: 15px; font-size: 14px; font-weight: 600; color: #333;">是否同时清空以下数据？</p>
                
                <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer; padding: 10px; border-radius: 8px; background: #f9f9f9;">
                    <input type="checkbox" id="clear-accounting-checkbox" style="width: 18px; height: 18px; margin-right: 12px; cursor: pointer;">
                    <span style="font-size: 14px; color: #333;">📊 记账数据（所有收支记录、分类、目标）</span>
                </label>
                
                <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer; padding: 10px; border-radius: 8px; background: #f9f9f9;">
                    <input type="checkbox" id="clear-period-checkbox" style="width: 18px; height: 18px; margin-right: 12px; cursor: pointer;">
                    <span style="font-size: 14px; color: #333;">🌸 月经数据（经期设置和手动标记）</span>
                </label>
                
                <label style="display: flex; align-items: center; margin-bottom: 0; cursor: pointer; padding: 10px; border-radius: 8px; background: #f9f9f9;">
                    <input type="checkbox" id="clear-study-checkbox" style="width: 18px; height: 18px; margin-right: 12px; cursor: pointer;">
                    <span style="font-size: 14px; color: #333;">📚 学习数据（科目、题库、学习记录）</span>
                </label>
            </div>
            
            <p style="margin-top: 15px; font-size: 12px; color: #999; line-height: 1.5;">💡 提示：默认不清除这些数据，只清除聊天记录。如需清除，请勾选对应选项。</p>
        </div>
        <div class="modal-footer" style="display: flex; gap: 10px;">
            <button class="cancel" id="cancel-clear-data-btn" style="flex: 1; margin: 0;">取消</button>
            <button class="save" id="confirm-clear-data-btn" style="flex: 1; margin: 0; background: #ff3b30; border-color: #ff3b30;">确认清空</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 清空数据选项弹窗结束 ▲▲▲ -->

</body>
</html>
</html>
